[Problem: 1458. 两个子序列的最大点积](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/description/)

### 方法：DFS & DP & 空间优化

子序列：从原数组中删除一些元素（不删除）后得到的序列，且相对顺序保持不变。

说白了，每个数组中的元素都是「选」或「不选」两种可能 —— **递归**。

**定义** $dfs(i, j)$ 表示从 $nums1$ 的索引 $i$ 和 $nums2$ 的索引 $j$ 开始，能得到的最大点积。

在每一对位置 $(i, j)$ 处，有三种选择策略：

- 选中当前的一对数字 `(nums1[i], nums2[j])` 进行配对：
  - 这一对的点积是 $nums1[i]\times nums2[j]$
  - 配对后，继续处理剩下的部分。如果 $dfs(i+1, j+1)$ 的结果是 **负数**，那不如不选剩下的部分，也就是在此结束序列，后续结果是 $0$。
- 不选 $nums1[i]$，跳过它：
  - 用 $nums1$ 的下一个数字去匹配 $nums2[j]$ 及之后的数字
- 不选 $nums2[j]$，跳过它：
  - 用 $nums1[i]$ 去匹配 $nums2$ 的下一个数字及之后的数字

得出 **状态转移方程**：

$$
dfs(i, j)=\max\{nums1[i] \times nums2[j] + \max(0, dfs(i+1, j+1)), dfs(i+1, j), dfs(i, j+1)\}
$$

在第一种情况中，一定要加上 $max(0,\dots)$。后面两个 $dfs$ 是其余两种情况。

**边界判断**：任意序列到达数组末尾，返回 $-\infty$，表示无法继续选择元素进行配对。

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有两个，所以记忆化数组需要两维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        
        # 索引分别从 i,j 开始，能得到的最大点积
        @lru_cache(None)
        def dfs(i, j):
            # 任意一个数组遍历结束
            if i == n or j == m:
                # 无效状态
                return -float('inf')
            
            # 选中 nums1[i] 和 nums2[j]，注意不要负数
            pick = nums1[i] * nums2[j] + max(0, dfs(i + 1, j + 1))
            # 不选 nums1[i]
            skip_i = dfs(i + 1, j)
            # 不选 nums2[j]
            skip_j = dfs(i, j + 1)
            # 取最大值
            return max(pick, skip_i, skip_j)
        
        return dfs(0, 0)
```

```java
// java
class Solution {
    private int[] nums1;
    private int[] nums2;
    private int n;
    private int m;
    // 记忆化数组
    private Integer[][] memo;

    public int maxDotProduct(int[] nums1, int[] nums2) {
        this.nums1 = nums1;
        this.nums2 = nums2;
        this.n = nums1.length;
        this.m = nums2.length;
        this.memo = new Integer[n][m];
        
        return dfs(0, 0);
    }

    private int dfs(int i, int j) {
        // 任意一个数组遍历结束
        if (i == n || j == m) {
            return Integer.MIN_VALUE;
        }
        
        // 之前计算过，直接返回
        if (memo[i][j] != null) {
            return memo[i][j];
        }
        
        // 选中 nums1[i] 和 nums2[j]，注意不要负数
        int subRes = dfs(i + 1, j + 1);
        int pick = nums1[i] * nums2[j] + Math.max(0, subRes);
        
        // 不选 nums1[i]，尝试 nums1 的下一个位置
        int skip_i = dfs(i + 1, j);
        // 不选 nums2[j]，尝试 nums2 的下一个位置
        int skip_j = dfs(i, j + 1);
        
        // 取三种情况的最大值
        int res = Math.max(pick, Math.max(skip_i, skip_j));
        // 存入记忆化数组并返回
        memo[i][j] = res;
        return res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(n\times m)$，单个状态的计算时间为 $O(1)$，所以总时间为 $O(n\times m)$。

- 时间复杂度： $O(n \times m)$，其中 $n,m$ 分别为数组 $nums1,nums2$ 的长度
- 空间复杂度： $O(n \times m)$，保存多少状态，就需要多少空间

---

### $DP$

将递归 $1:1$ 转化为递推。

定义 $dp[i][j]$ 表示使用 $nums1$ 的前 $i$ 个元素和 $nums2$ 的前 $j$ 个元素得到的最大点积。

同理，得出 **状态转移方程**：

$$
dp[i][j] = \max \begin{cases}
nums1[i-1] \times nums2[j-1] + \max(0, dp[i-1][j-1]) \\
dp[i-1][j] \\
dp[i][j-1]
\end{cases}
$$

点积可能为负数，所以将 $dp[i][j]$ 初始化为 $-\infty$，对应 $dfs$ 的边界。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        # 使用 nums1 的前 i 个和 nums2 的前 j 个元素得到的最大点积
        dp = [[-float('inf')] * (m + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                curr_prod = nums1[i-1] * nums2[j-1]
                
                # 使用当前这一对数字
                term1 = curr_prod + max(0, dp[i-1][j-1])
                
                # 跳过 nums1[i-1] 或 nums2[j-1]
                term2 = dp[i-1][j]
                term3 = dp[i][j-1]
                
                # 取最大值
                dp[i][j] = max(term1, term2, term3)
        
        # 全局最大值
        return dp[n][m]
```

```java
// java
class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;
        // 使用 nums1 的前 i 个和 nums2 的前 j 个元素得到的最大点积
        int[][] dp = new int[n + 1][m + 1];
        
        // 初始化为负无穷
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MIN_VALUE);
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int currProd = nums1[i - 1] * nums2[j - 1];
                
                // 使用当前这一对数字
                int term1 = currProd + Math.max(0, dp[i - 1][j - 1]);
                
                // 跳过 nums1[i-1] 或 nums2[j-1]
                int term2 = dp[i - 1][j];
                int term3 = dp[i][j - 1];
                
                // 取最大值
                dp[i][j] = Math.max(term1, Math.max(term2, term3));
            }
        }
        
        // 全局最大值
        return dp[n][m];
    }
}
```

如果不好理解，换成下面这种稍微冗余一点的写法：

```Python
# python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        # nums1从前i个数挑，nums2从前j个数挑得到的最大点积
        n = len(nums1)
        m = len(nums2)
        dp = [[-inf] * (m + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                curr_prod = nums1[i - 1] * nums2[j - 1]
                # 重新开始选，重置
                dp[i][j] = curr_prod
                # 都选，拼接在之前的末尾
                dp[i][j] = max(dp[i][j], curr_prod + dp[i - 1][j - 1])
                # 选1不选2
                dp[i][j] = max(dp[i][j], dp[i][j - 1])
                # 选2不选1
                dp[i][j] = max(dp[i][j], dp[i - 1][j])
                # 两者都不选，没必要加这一行
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1])
        
        return dp[n][m]
```

```java
// java
class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        // nums1从前i个数挑，nums2从前j个数挑得到的最大点积
        int n = nums1.length;
        int m = nums2.length;
        int[][] dp = new int[n + 1][m + 1];
        
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MIN_VALUE / 2);
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int curr_prod = nums1[i - 1] * nums2[j - 1];
                // 重新开始选，重置
                dp[i][j] = curr_prod;
                // 都选，拼接在之前的末尾
                dp[i][j] = Math.max(dp[i][j], curr_prod + dp[i - 1][j - 1]);
                // 选1不选2
                dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);
                // 选2不选1
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
                // 两者都不选，没必要加这一行
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);
            }
        }
        
        return dp[n][m];
    }
}
```

- 时间复杂度： $O(n \times m)$，两重循环
- 空间复杂度： $O(n \times m)$，表示 $dp$ 数组的大小

---

### 空间优化

注意到计算 $dp[i][j]$ 时只依赖于 $dp[i-1][j-1]$、$dp[i-1][j]$ 和 $dp[i][j-1]$，因此可以使用一维数组来优化空间。

**关键技巧**：使用 $prevDiag$ 变量暂存 $dp[i-1][j-1]$ 的值，因为在更新 $dp[j]$ 之前需要保存它，以便在下次循环中使用。

**状态转移方程**：

$$
dp[j] = \max\{nums1[i-1] \times nums2[j-1] + \max(0, prevDiag), dp[j], dp[j-1]\}
$$

其中 $prevDiag$ 表示更新前的 $dp[j]$，它在更新后会成为下一次循环中的 $dp[j-1]$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        # dp 数组只保留上一行的结果
        dp = [-float('inf')] * (m + 1)
        
        for i in range(1, n + 1):
            # 暂存 dp[i-1][j-1] 的值
            prev_diag = dp[0]
            
            for j in range(1, m + 1):
                # 记录更新前的 dp[j]，它将在下一次循环中成为 dp[j-1]
                temp = dp[j]
                curr_prod = nums1[i-1] * nums2[j-1]
                dp[j] = max(
                    curr_prod + max(0, prev_diag), # 选当前对
                    dp[j],                         # 跳过 nums1[i]
                    dp[j-1]                        # 跳过 nums2[j]
                )
                
                # 更新 prev_diag
                prev_diag = temp
                
        return dp[m]
```

```java
// java
class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;
        // dp 数组只保留上一行的结果
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MIN_VALUE);
        
        for (int i = 1; i <= n; i++) {
            // 暂存 dp[i-1][j-1] 的值
            int prevDiag = dp[0];
            
            for (int j = 1; j <= m; j++) {
                // 记录更新前的 dp[j]，它将在下一次循环中成为 dp[j-1]
                int temp = dp[j];
                int currProd = nums1[i - 1] * nums2[j - 1];
                dp[j] = Math.max(
                    currProd + Math.max(0, prevDiag), // 选当前对
                    Math.max(dp[j],                   // 跳过 nums1[i]
                             dp[j - 1])               // 跳过 nums2[j]
                );
                
                // 更新 prevDiag
                prevDiag = temp;
            }
        }
        
        return dp[m];
    }
}
```

- 时间复杂度： $O(n \times m)$
- 空间复杂度： $O(m)$，优化了空间

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solutions/3875499/si-jie-ji-yi-hua-dfs-er-yi-wei-dprong-yi-1rv8/)
