[Problem: 3234. 统计 1 显著的字符串的数量](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/description/)

### 方法：根号枚举 & 前缀和

“1 显著”：字符串中 $1$ 的数量（记为 $c1$）大于或等于 $0$ 的数量（记为 $c0$）的平方，即 $c1 >= c0 * c0$。二进制串中仅含 $0,1$，如何寻找符合要求的子串？

一个 **朴素** 的想法：遍历所有可能的子字符串，然后对每一个子字符串进行检查。

长度为 $n$ 的串 $s$ 的子字符串大约有 $n*n/2$ 个。线性检查的话，总时间复杂度到达 $O(n^3)$，使用前缀和优化一下，可以做到 $O(n^2)$。题目限制 $n\leq 4\times 10^4$，会超时。

我们仔细观察，条件是 $c1 >= c0 * c0$，而子字符串的长度 $L = c1 + c0$。带入可得 $L\geq c0 * c0 + c0$。又因为子字符串的长度 $L$ 不可能超过 $n$，因此 $n \geq c0 * c0+c0$。这意味着，任何一个 “1 显著” 的子字符串，其包含的 $0$ 的数量 $c0$ 不会超过 $\sqrt{n}$。

也即，在一个满足条件的子字符串中，**0 的数量** 是相对较少的。这启发我们，不用去遍历所有子字符串，而是围绕数量较少的 $0$ 来构建算法。

为了方便处理，首先 **预处理** 字符串 $s$，得到所有 $0$ 的位置索引，存入列表 $zeros$。

枚举子字符串 **起始位置** $left$，对于每一个固定的起始位置 $left$，我们计算从它开始的、满足条件的子字符串有多少个。根据 $c0$ 来分类讨论：

- **不包含 $0$ 的子字符串**：子串完全由 $1$ 组成。根据 $zeros$ 列表，得出当前 $left$ 右侧第一个 $0$ 的位置 $zeros[t]$，则 $(left,zeros[t])$ 内全都是 $1$。
- **包含 $c0$ 个 $0$ 的子字符串**：从 $t$ 位置向后枚举 $zeros$ 列表，对应 $c0$ 从 $1$ 开始增大。同理，假设当前包含 $c0$ 个 $0$，对应索引是 $zeros[j]$。这意味着，在 $(zeros[j],zeros[j+1])$ 内不包含 $0$，且 $(left,zeros[j+1])$ 恰好包含 $c0$ 个 $0$。此时，根据 $c1 >= c0 * c0$ 这个条件，继续约束这个区间。

可以发现，子串的 $left$ 指针一直在递增，因此我们可以动态维护 $t$ 指针，让它始终指向 $left$ 右侧第一个 $0$ 的位置。

**总结**：枚举子串的起点，内部枚举子串中包含 $0$ 的数量，通过 $zeros$ 快速求解。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        # 记录所有 '0' 的索引
        zeros = [i for i, char in enumerate(s) if char == '0']
        # 在末尾添加 n 作为哨兵，处理边界
        zeros.append(n)
        m = len(zeros)

        ans = 0
        # 在 zeros 列表中的索引，指向 left 右侧的第一个 '0' 
        zero_idx = 0

        # 枚举子串起始位置
        for left in range(n):
            # 子字符串不包含 '0'
            ans += zeros[zero_idx] - left

            # 子字符串包含 '0'，枚举可能的 '0' 的数量 c0
            # j 是 zeros 列表的索引
            for j in range(zero_idx, m - 1):
                # 子字符串中 '0' 的数量
                c0 = j - zero_idx + 1

                # 如果 c0*c0 > n, 那么 c1 必然小于 c0*c0
                if c0 * c0 > n:
                    break

                # 最后一个 '0' 的位置
                end_zeros_pos = zeros[j]
                # 下一个 '0' 的位置
                next_zero_pos = zeros[j + 1]
                
                # 合法的右端点 right 需要满足三个条件:
                # 1. right >= end_zeros_pos (必须包含这 c0 个 '0')
                # 2. right < next_zero_pos (不能包含第 c0+1 个 '0')
                # 3. right >= left + c0*c0 + c0 - 1 (满足 "1显著" 条件)
                
                # 起始
                start_r = max(end_zeros_pos, left + c0 * c0 + c0 - 1)
                # 结束
                end_r = next_zero_pos - 1
                # 存在合法的右端点
                if start_r <= end_r:
                    ans += (end_r - start_r + 1)

            # 当前位置变为 '0'，更新
            if zero_idx < m and zeros[zero_idx] == left:
                zero_idx += 1
                
        return ans
```

```Java
// java
class Solution {
    public int numberOfSubstrings(String s) {
        int n = s.length();
        // 记录所有 '0' 的索引
        List<Integer> zeros = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') {
                zeros.add(i);
            }
        }
        // 在末尾添加 n 作为哨兵，处理边界
        zeros.add(n);
        int m = zeros.size();

        int ans = 0;
        // 在 zeros 列表中的索引，指向 left 右侧的第一个 '0'
        int zero_idx = 0;

        // 枚举子串起始位置
        for (int left = 0; left < n; left++) {
            // 子字符串不包含 '0'
            ans += zeros.get(zero_idx) - left;

            // 子字符串包含 '0'，枚举可能的 '0' 的数量 c0
            // j 是 zeros 列表的索引
            for (int j = zero_idx; j < m - 1; j++) {
                // 子字符串中 '0' 的数量
                int c0 = j - zero_idx + 1;

                // 如果 c0*c0 > n, 那么 c1 必然小于 c0*c0
                if (c0 * c0 > n) {
                    break;
                }

                // 最后一个 '0' 的位置
                int end_zeros_pos = zeros.get(j);
                // 下一个 '0' 的位置
                int next_zero_pos = zeros.get(j + 1);

                // 合法的右端点 right 需要满足三个条件:
                // 1. right >= end_zeros_pos (必须包含这 c0 个 '0')
                // 2. right < next_zero_pos (不能包含第 c0+1 个 '0')
                // 3. right >= left + c0*c0 + c0 - 1 (满足 "1显著" 条件)
                
                // 起始
                int start_r = Math.max(end_zeros_pos, left + c0 * c0 + c0 - 1);
                // 结束
                int end_r = next_zero_pos - 1;
                // 存在合法的右端点
                if (start_r <= end_r) {
                    ans += (end_r - start_r + 1);
                }
            }

            // 当前位置变为 '0'，更新
            if (zero_idx < m && zeros.get(zero_idx) == left) {
                zero_idx++;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^{1.5})$，其中 $n$ 是字符串 $s$ 的长度
- 空间复杂度： $O(n)$，表示列表 $zeros$ 的大小

---

### 前缀和

我们可以用一种更动态、基于前缀和的思想来优化。

> $ps$：前缀和的具体原理/做法，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

在主流程中，换成枚举子串的右端点 $i$，然后寻找左边界。对于结束位置 $i$ 来说，计算所有以 $i$ 结尾的 “1显著” 子字符串 $s[j...i]$ 的数量。

定义 $left[z]$ 和 $right[z]$ 记录前缀 $0$ 的数量等于 $z$ 的 **首次** 和 **末次** 出现的索引。使用前缀和 $prefix$ 数组，统计从字符串开头到当前位置 $i$ 的 $0$ 的数量。

对于一个子字符串 $s[j...i]$，它包含的 $0$ 的数量是 $prefix[i] - prefix[j-1]$。如果想让这个子串恰好有 $z$ 个 $0$，那就需要寻找一个左边界 $j$，使得 $z = prefix[i] - prefix[j-1]$。

固定的右端点 $i$ 和 $0$ 的数量 $z$ 后，想让左端点 $j$ 合法，必须同时满足两个条件：

- **0的数量**：根据上面 $left[z]$ 和 $right[z]$ 的定义，由于 $s[j...i]$ 必须包含 $z$ 个 $0$。这意味着 $j-1$ 必须在 $[left[prefix[i] - z], right[prefix[i] - z]]$ 的索引范围内。
- **“1显著”条件**：由于 $c1\geq z*z$，子串长度是 $i - j + 1$，所以 $c1 = i - j + 1 - z$。代入条件，整理后可的新约束： $j \leq i - z - z^2 + 1$。

同时满足上述两个条件的 $j$ 的数量，就是当前 $i$ 对应的左端点数，也即合法子串数。

如何计算 $left$ 和 $right$ 数组？它们用来存储左侧 $0$ 首次/最新的索引，由于主流程是从前往后枚举，所以我们在循环末尾时更新这两者就行。

此外，上面流程中是寻找 $j$，所以用不到 $prefix[j]$，仅仅只用到 $prefix[i]$ 的值，所以只需要一个变量 $ones$ 替换，而省略这个 $prefix$ 数组。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        ans = 0
        # s[0...i] 前缀中'0'的数量
        prefix_zeros = 0

        # left[k] 存储前缀'0'数量首次达到k时的索引
        # right[k] 存储前缀'0'数量等于k的最新索引
        left = [-2] * (n + 1)
        right = [-2] * (n + 1)
        
        # 初始化
        left[0] = -1
        right[0] = -1

        # 枚举子串结束位置
        for i, char in enumerate(s):
            if char == '0':
                prefix_zeros += 1
            
            # 枚举可能的 '0' 的数量 c0
            zero_start = 1 if char == '0' else 0
            for c0 in range(zero_start, int(n**0.5) + 2):
                # 子串最小长度 > 当前前缀长度，不可能满足
                if c0 * c0 + c0 > i + 1:
                    break
                
                # 目标前缀'0'数
                target_zeros = prefix_zeros - c0
                # 从未出现过
                if target_zeros < 0 or left[target_zeros] == -2:
                    continue
                
                # 起始
                start_l = left[target_zeros]
                # 结束
                end_l = min(right[target_zeros], i - c0 * c0 - c0)
                
                # 存在合法的左端点
                if start_l <= end_l:
                    ans += (end_l - start_l + 1)

            # 第一次出现这个数量的前缀'0'
            if left[prefix_zeros] == -2:
                left[prefix_zeros] = i
            # 每次都更新right
            right[prefix_zeros] = i
        
        return ans
```

```Java
// java
class Solution {
    public int numberOfSubstrings(String s) {
        int n = s.length();
        int ans = 0;
        // s[0...i] 前缀中'0'的数量
        int prefix_zeros = 0;

        // left[k] 存储前缀'0'数量首次达到k时的索引
        // right[k] 存储前缀'0'数量等于k的最新索引
        int[] left = new int[n + 1];
        int[] right = new int[n + 1];
        Arrays.fill(left, -2);
        Arrays.fill(right, -2);
        
        // 初始化
        left[0] = -1;
        right[0] = -1;

        // 枚举子串结束位置
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') {
                prefix_zeros++;
            }
            
            // 枚举可能的 '0' 的数量 c0
            int zero_start = (s.charAt(i) == '0') ? 1 : 0;
            for (int c0 = zero_start; c0 * c0 <= n; c0++) {
                // 子串最小长度 > 当前前缀长度，不可能满足
                if (c0 * c0 + c0 > i + 1) {
                    break;
                }
                
                // 目标前缀'0'数
                int target_zeros = prefix_zeros - c0;
                // 从未出现过
                if (target_zeros < 0 || left[target_zeros] == -2) {
                    continue;
                }
                
                // 起始
                int start_l = left[target_zeros];
                // 结束
                int end_l = Math.min(right[target_zeros], i - c0 * c0 - c0);
                
                // 存在合法的左端点
                if (start_l <= end_l) {
                    ans += (end_l - start_l + 1);
                }
            }

            // 第一次出现这个数量的前缀'0'
            if (left[prefix_zeros] == -2) {
                left[prefix_zeros] = i;
            }
            // 每次都更新right
            right[prefix_zeros] = i;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^{1.5})$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/solutions/3832142/shuang-jie-cong-ling-tui-dao-si-lu-you-l-9buo/)
