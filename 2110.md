[Problem: 2110. 股票平滑下跌阶段的数目](https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/description/)

### 方法：分段 & 数学

必须是子数组，且相邻元素的差值是 $1$。

按照 **子数组** 拼接的思路：

- 数组 $[3]$ 只有一个子数组 $[3]$；
- 数组 $[3,2]$ 在前者基础上拼接一个 $[2]$，新增子数组 $[2],[3,2]$；
- 数组 $[3,2,1]$ 继续拼接一个 $[1]$，新增子数组 $[1],[2,1],[3,2,1]$。

也就是说，当前连续段长度为 $L$，就意味着以 **当前位置结尾** 的有效子数组 **新增** $L$ 个。

我们只需要一次遍历，定义变量 $len$ 表示当前连续下降段的长度。

- 当前 $nums[i]$ 是 $nums[i-1]-1$，则延续递减，长度 $len+1$，增加子数组 $len$ 个；
- 否则，说明递减中断，计数器重置为 $1$，子数组仅有一个 $[nums[i]]$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        ans = 1
        # 当前连续下降片段的长度
        length = 1
        
        for i in range(1, len(prices)):
            # 检查
            if prices[i] == prices[i-1] - 1:
                length += 1  # 延续
            else:
                length = 1   # 趋势中断
            
            # 以当前元素结尾的有效片段
            ans += length
        
        return ans
```

```Java
// java
class Solution {
    public long getDescentPeriods(int[] prices) {
        long ans = 1;
        // 当前连续下降片段的长度
        int length = 1;
        
        for (int i = 1; i < prices.length; i++) {
            // 检查
            if (prices[i] == prices[i-1] - 1) {
                length += 1;  // 延续
            } else {
                length = 1;   // 趋势中断
            }
            
            // 以当前元素结尾的有效片段
            ans += length;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $prices$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 数学

上面的做法是拆分到 **每一步统计**，而实际上我们可以 **一次性统计**。也就是说，在递减结束时，直接计算出这个段包含的子数组数量。

本质上来看，就是将 $1+2+\dots+t$ 的累加过程换成一步 $t\times(t+1)/2$。

最好采用 **变量标记** 前一天股价，而不是使用 **双指针** 探查连续段。前者是正规的一次遍历，后者会让相邻元素的比较次数 $\ge 1$，速度更慢。

不过切记，如果最后一段一直递减，可能会忽略计数。要么将 $prices$ 扩展，要么增加一次末尾判断。经实测 $Python$ 代码耗时 $43ms$，超过 $99\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        # 所有长度为1的子数组
        ans = len(prices)
        # 连续下降的次数
        cnt = 0
        # 前一天的股价
        prev = 0
        
        for price in prices:
            if price == prev - 1:
                # 下降
                cnt += 1
            else:
                # 趋势中断，等差数列求和
                ans += (cnt + 1) * cnt // 2
                # 重置计数器
                cnt = 0
            
            # 更新
            prev = price
            
        # 最后一段可能也下降
        return ans + (cnt + 1) * cnt // 2
```

```Java
// java
class Solution {
    public long getDescentPeriods(int[] prices) {
        // 所有长度为1的子数组
        long ans = prices.length;
        // 连续下降的次数
        long cnt = 0;
        // 前一天的股价
        int prev = 0;
        
        for (int price : prices) {
            if (price == prev - 1) {
                // 下降
                cnt += 1;
            } else {
                // 趋势中断，等差数列求和
                ans += (cnt + 1) * cnt / 2;
                // 重置计数器
                cnt = 0;
            }
            
            // 更新
            prev = price;
        }
        
        // 最后一段可能也下降
        return ans + (cnt + 1) * cnt / 2;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/solutions/3857221/shuang-jie-fen-duan-ji-shu-shu-xue-you-h-7xjo/)
