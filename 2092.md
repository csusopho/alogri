[Problem: 2092. 找出知晓秘密的所有专家](https://leetcode.cn/problems/find-all-people-with-secret/description/)

### 方法：并查集/BFS/DFS

看示例 $2$，在时间 $t=3$ 时，第一场与第三场会议同时进行，则参加会议的人 $0,1,3$ 可以相互传递秘密。当然，如果会议中的每个人都不知道秘密，就无法传递。

**核心**：传递基于时间，且在同一时间内瞬时发生，应该按 **时间先后** 的顺序处理。

将 $meetings$ 数组按第三维时间 $time_i$ 从小到大排序。

对于同一时间发生的所有会议，秘密可以在这些专家之间瞬间传递。

- 将在这一时刻的所有会议，看作一个子图。
- 这时，如果某个连通分量中 **至少有一个人** 已经知道秘密，那么该连通分量中的 **所有人** 都会在这一刻知道秘密。

因此，可以使用 **并查集** 或者 $DFS/BFS$ 处理连通性。并查集的推导，看这篇 [题解](https://leetcode.cn/problems/redundant-connection/solutions/2966966/bing-cha-ji-bao-li-mei-ju-zhao-huan-you-k08ct/)。

初始时，专家 $0$ 和 $firstPerson$ 在 $t=0$ 时互相传递，用 $union$ 连接两者。

**关键点**：

- 在处理完某一时刻 $t$ 的所有会议后，我们需要检查参加了这些会议的人。
- 如果某个人所在的连通分量的根节点，不是专家 $0$，即他们无法通过这一时刻或之前的会议联系到秘密源 $0$，我们需要 **重置** 他们的并查集状态，将 $parent[i]$ 设回 $i$。
- 如果不重置，这些本该不知道秘密的人会在逻辑上保持连接，干扰下一时刻的判断。

比如示例 $2$，为什么答案没有专家 $2$？因为即使第二场会议 $[1,2]$ 连接，但是他们都不知道秘密，所以无法传递。注意，一定要断开 $1,2$ 的连通块连接，不然全连在一起，出现错误。

因此，我们使用 $pool$ **集合**，记录这一时刻的会议的所有专家。在秘密传完后，如果他们最终没能连接到 $0$，就强制断开连接，避免 “时空穿梭”。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        # 初始化
        parent = list(range(n))
        
        def find(i):
            if parent[i] == i:
                return i
            parent[i] = find(parent[i])  # 路径压缩
            return parent[i]
        
        def union(i, j):
            root_i = find(i)
            root_j = find(j)
            if root_i != root_j:
                # 让小的编号作为根
                if root_i < root_j:
                    parent[root_j] = root_i
                else:
                    parent[root_i] = root_j

        # 0 和 firstPerson 共享秘密
        union(0, firstPerson)
        # 按时间排序
        meetings.sort(key=lambda x: x[2])
        m = len(meetings)
        i = 0

        while i < m:
            curTime = meetings[i][2]
            pool = set()
            j = i
            
            # 找到当前时间点的所有会议
            while j < m and meetings[j][2] == curTime:
                u, v, t = meetings[j]
                union(u, v)
                pool.add(u)
                pool.add(v)
                j += 1
            
            # 检查当前时间段参与会议的人，是否和 0 连通
            for expert in pool:
                if find(expert) != 0:
                    parent[expert] = expert  # 重置状态
            
            i = j  # 移动到下一个时间点
            
        # 所有与 0 相关的人都是知晓者
        ans = []
        target = find(0)
        for i in range(n):
            if find(i) == target:
                ans.append(i)
        return ans
```

```Java
// java
class Solution {
    int[] parent;

    private int find(int i) {
        if (parent[i] == i) {
            return i;
        }
        parent[i] = find(parent[i]);  // 路径压缩
        return parent[i];
    }

    private void union(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            // 让小的编号作为根
            if (root_i < root_j) {
                parent[root_j] = root_i;
            } else {
                parent[root_i] = root_j;
            }
        }
    }

    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        // 初始化
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;

        // 0 和 firstPerson 共享秘密
        union(0, firstPerson);
        // 按时间排序
        Arrays.sort(meetings, (a, b) -> Integer.compare(a[2], b[2]));
        
        int m = meetings.length;
        int i = 0;

        while (i < m) {
            int curTime = meetings[i][2];
            Set<Integer> pool = new HashSet<>();
            int j = i;

            // 找到当前时间点的所有会议
            while (j < m && meetings[j][2] == curTime) {
                int u = meetings[j][0];
                int v = meetings[j][1];
                union(u, v);
                pool.add(u);
                pool.add(v);
                j++;
            }

            // 检查当前时间段参与会议的人，是否和 0 连通
            for (int expert : pool) {
                if (find(expert) != 0) {
                    parent[expert] = expert;  // 重置状态
                }
            }

            i = j;  // 移动到下一个时间点
        }

        // 所有与 0 相关的人都是知晓者
        List<Integer> ans = new ArrayList<>();
        int target = find(0);
        for (int k = 0; k < n; k++) {
            if (find(k) == target) {
                ans.add(k);
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(mlogm+m\alpha(n))$，其中 $m$ 是数组 $meetings$ 的长度，且 $\alpha$ 是阿克曼反函数，增长速度极慢
- 空间复杂度： $O(n+m)$，表示数组 $parent$ 以及集合 $pool$ 的大小

---

### $BFS$

同理，将 **相同时间** 发生的会议看作一个独立的图，在这个局部图中，从已经获知秘密的人出发进行搜索，扩散给与他们有会议接触的人。

也就是说，我们 **局部建图**，建立一个临时的无向图，表示哪些专家在这一刻互开了会。

使用一个 **全局数组**，表示每个专家是否知道秘密。一旦某人在 $BFS$ 中被标记为 “知晓”，他就永远处于知晓状态。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        # knows[i] 表示专家 i 是否知道秘密
        knows = [False] * n
        knows[0] = True
        knows[firstPerson] = True
        
        # 按时间排序
        meetings.sort(key=lambda x: x[2])
        m = len(meetings)
        i = 0

        while i < m:
            curr_time = meetings[i][2]
            
            # 找出当前时间点的所有会议并构图
            adj = defaultdict(list)
            # 记录当前时刻参加会议的所有专家
            pool = set()
            
            j = i
            while j < m and meetings[j][2] == curr_time:
                u, v, t = meetings[j]
                adj[u].append(v)
                adj[v].append(u)
                pool.add(u)
                pool.add(v)
                j += 1
            
            # 从当前会议中已知秘密的人出发
            queue = deque()
            for expert in pool:
                if knows[expert]:
                    queue.append(expert)
            
            while queue:
                u = queue.popleft()
                for v in adj[u]:
                    if not knows[v]:
                        knows[v] = True
                        queue.append(v)
            
            # 移动指针到下一个时间点
            i = j
            
        # 收集所有结果
        return [i for i, k in enumerate(knows) if k]
```

```Java
// java
class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        // knows[i] 表示专家 i 是否知道秘密
        boolean[] knows = new boolean[n];
        knows[0] = true;
        knows[firstPerson] = true;

        // 按时间排序
        Arrays.sort(meetings, (a, b) -> Integer.compare(a[2], b[2]));
        int m = meetings.length;
        int i = 0;

        while (i < m) {
            int curr_time = meetings[i][2];

            // 找出当前时间点的所有会议并构图
            Map<Integer, List<Integer>> adj = new HashMap<>();
            // 记录当前时刻参加会议的所有专家
            Set<Integer> pool = new HashSet<>();

            int j = i;
            while (j < m && meetings[j][2] == curr_time) {
                int u = meetings[j][0];
                int v = meetings[j][1];
                adj.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
                adj.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
                pool.add(u);
                pool.add(v);
                j++;
            }

            // 从当前会议中已知秘密的人出发
            Queue<Integer> queue = new LinkedList<>();
            for (int expert : pool) {
                if (knows[expert]) {
                    queue.offer(expert);
                }
            }

            while (!queue.isEmpty()) {
                int u = queue.poll();
                if (adj.containsKey(u)) {
                    for (int v : adj.get(u)) {
                        if (!knows[v]) {
                            knows[v] = true;
                            queue.offer(v);
                        }
                    }
                }
            }

            // 移动指针到下一个时间点
            i = j;
        }

        // 收集所有结果
        List<Integer> result = new ArrayList<>();
        for (int k = 0; k < n; k++) {
            if (knows[k]) {
                result.add(k);
            }
        }
        return result;
    }
}
```

- 时间复杂度： $O(mlogm+m)$
- 空间复杂度： $O(n+m)$

---

### $DFS$

“递归” 与 “递推” 同理，只不过是写法不同。

定义 $dfs(u,adj)$ 表示从专家 $u$ 开始，在当前时刻的邻接表 $adj$ 中扩散秘密。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        # knows[i] 记录专家 i 是否已知秘密
        knows = [False] * n
        knows[0] = knows[firstPerson] = True
        
        # 按时间升序排序
        meetings.sort(key=lambda x: x[2])
        
        # 从专家 u 开始，在当前时刻的邻接表 adj 中扩散秘密
        def dfs(u, adj):
            for v in adj[u]:
                if not knows[v]:
                    knows[v] = True
                    dfs(v, adj)

        m = len(meetings)
        i = 0
        while i < m:
            curr_time = meetings[i][2]
            
            # 构建当前时刻的局部邻接表
            adj = defaultdict(list)
            # 记录当前时刻参加会议的所有人
            participants = set()
            
            j = i
            while j < m and meetings[j][2] == curr_time:
                u, v, _ = meetings[j]
                adj[u].append(v)
                adj[v].append(u)
                participants.add(u)
                participants.add(v)
                j += 1
            
            # 如果某人参加了会议且已知秘密，则开始扩散
            for p in participants:
                if knows[p]:
                    dfs(p, adj)
            
            i = j  # 移动到下一组时间
        
        # 收集
        return [i for i, k in enumerate(knows) if k]
```

```Java
// java
class Solution {
    boolean[] knows;

    // 从专家 u 开始，在当前时刻的邻接表 adj 中扩散秘密
    private void dfs(int u, Map<Integer, List<Integer>> adj) {
        if (adj.containsKey(u)) {
            for (int v : adj.get(u)) {
                if (!knows[v]) {
                    knows[v] = true;
                    dfs(v, adj);
                }
            }
        }
    }

    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        // knows[i] 记录专家 i 是否已知秘密
        knows = new boolean[n];
        knows[0] = true;
        knows[firstPerson] = true;

        // 按时间升序排序
        Arrays.sort(meetings, (a, b) -> Integer.compare(a[2], b[2]));

        int m = meetings.length;
        int i = 0;
        while (i < m) {
            int curr_time = meetings[i][2];

            // 构建当前时刻的局部邻接表
            Map<Integer, List<Integer>> adj = new HashMap<>();
            // 记录当前时刻参加会议的所有人
            Set<Integer> participants = new HashSet<>();

            int j = i;
            while (j < m && meetings[j][2] == curr_time) {
                int u = meetings[j][0];
                int v = meetings[j][1];
                adj.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
                adj.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
                participants.add(u);
                participants.add(v);
                j++;
            }

            // 如果某人参加了会议且已知秘密，则开始扩散
            for (int p : participants) {
                if (knows[p]) {
                    dfs(p, adj);
                }
            }

            i = j;  // 移动到下一组时间
        }

        // 收集
        List<Integer> result = new ArrayList<>();
        for (int k = 0; k < n; k++) {
            if (knows[k]) {
                result.add(k);
            }
        }
        return result;
    }
}
```

- 时间复杂度： $O(mlogm+m)$
- 空间复杂度： $O(n+m)$

经实测，三种方法的 $Python$ 用时分别为 $375ms,445ms,327ms$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-all-people-with-secret/solutions/3860905/san-jie-bing-cha-ji-bfs-dfspai-xu-kuai-n-0zpd/)
