[Problem: 3027. 人员站位的方案数 II](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/description/)

### 方法：排序 & 优化

如果你没做过前一题 [方案 I](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/description/)，强烈建议先做一遍。本题与它一模一样，仅仅只是数据量扩大，~~题干包含大量废话~~。题解为 [传送门](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/solutions/3769982/tu-jie-bao-li-pai-xu-xiang-xi-tui-dao-sh-7a01/)，解法一致。

长度为 $n$ 的数组中，一共有 $n\times(n-1)/2$ 个点对。假设点对为 $(a,b)$，必须确保点 $a$ 在坐标系中处于点 $b$ 的左上角。

下面看一个正确示例：

```Java
↑
|
|    x(2,7)
|
|
|        x(4,4)
|
|
|
O — — — — — — — — — — — —→
```

如果点 $a$ 的坐标为 $(x1,y1)$，点 $b$ 的坐标为 $(x2,y2)$。处于左上角，则有

$$
x1\leq x2,y1\geq y2
$$

同时，我们还要确保中间不能有其他点，下面看一个错误示例：

```Java
↑
|
|    a(2,7)
|
|
|        c(4,4)
|
|
|            b(6,1)
O — — — — — — — — — — — —→
```

那么，如果中间夹杂一个其余的点 $c(x3,y3)$，则有

$$
x1\leq x3\leq x2,y1\geq y3\geq y2
$$

> $ps$：暴力代码会超时，这里不展示，如果想看请移步至前一题，链接在上。

这些点没有顺序，所以需要检查所有 **三元组**。有什么办法，只检查 **两元组** 呢？联想到 **排序**，强制让这些点具有顺序。规则是：

$\textbf{让第一维 x 坐标递增，且第二维 y 坐标递减。}$

如此一来，双 $for$ 遍历就能确保点 $a$ 一定在点 $b$ 的左上角。那么，如何不让点 $c$ 进来骚扰呢？

由于我们是从前往后遍历，且排过序，所以新的点一定比旧的点 *横坐标* $x$ 更大。看看前面的示例，在 $x$ 值已经更大的情况下，如果不想包裹其他点，必须让点 $b$ 的纵坐标比点 $c$ 的 **更大**！也即

```Java
↑
|
|    a(2,7)
|
|
|            c(6,4)
|
|
|        b(4,1)
O — — — — — — — — — — — —→
```

此时，才能保证 $a,b$ 中间不包含其他点。具体来说，就是让新的点 $b$ 的总坐标 $y2$ 永远大于之前遍历过的 $maxY2$。

**注意**：本题的纵坐标可以为负！所以，不能直接套用前一题的代码，记得将 $maxY2$ 的初始值设置为 $-\infty$，不然就会卡在 $348/550$ 样例，别问我怎么知道的。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        # 按照 x 升序排序，若 x 相同则按照 y 降序排序
        points.sort(key=lambda p: (p[0], -p[1]))

        n = len(points)
        ans = 0  # 结果统计

        for i in range(n):
            x1, y1 = points[i]
            max_y2 = -inf  # 用于记录当前能配对的最大 y2

            for j in range(i + 1, n):
                x2, y2 = points[j]

                # 条件：y1 >= y2，同时 y2 必须比之前记录的 max_y2 大
                if y1 >= y2 > max_y2:
                    ans += 1
                    max_y2 = y2  # 更新最大 y2，避免后续重复

        return ans
```

```Java
// java
class Solution {
    public int numberOfPairs(int[][] points) {
        // 按照 x 升序排序，若 x 相同则按照 y 降序排序
        Arrays.sort(points, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1]; // x 相同，按 y 降序
            }
            return a[0] - b[0]; // 按 x 升序
        });

        int n = points.length;
        int ans = 0;  // 结果统计

        for (int i = 0; i < n; i++) {
            int x1 = points[i][0], y1 = points[i][1];
            int maxY2 = -1;  // 用于记录当前能配对的最大 y2

            for (int j = i + 1; j < n; j++) {
                int x2 = points[j][0], y2 = points[j][1];

                // 条件：y1 >= y2，同时 y2 必须比之前记录的 maxY2 大
                if (y1 >= y2 && y2 > maxY2) {
                    ans++;
                    maxY2 = y2;  // 更新最大 y2，避免后续重复
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2+nlogn)$，其中 $n$ 为数组 $points$ 的长度，快排
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

---

### 剪枝

如果点 $a$ 与点 $b$ 的纵坐标相同，那就只用计数一次！因为后续点 $c$ 的纵坐标一定比点 $b$ 的更小或相等，所以一定会将点 $b$ 夹在其中，不符合要求！

同时，将 $y2$ 与 $y1,maxY$ 的判断进行拆分，会小幅度提升代码速度。经实测，使用这两个优化后， $Python$ 语言耗时从 $1154ms$ 变为 $795ms$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        # 按照 x 升序排序，若 x 相同则按照 y 降序排序
        points.sort(key=lambda p: (p[0], -p[1]))
        ans = 0
        
        for i, (x1, y1) in enumerate(points):
            max_y = float('-inf')  # 记录当前遇到的最大y值
            
            for j in range(i + 1, len(points)):
                x2, y2 = points[j]
                
                # Bob必须在Alice下方
                if y2 > y1:
                    continue
                
                # 如果y坐标相同，直接计数并跳出内层循环
                if y2 == y1:
                    ans += 1
                    break
                
                # 如果当前点的y值大于之前记录的最大y值，说明没有其他点阻挡
                if y2 > max_y:
                    max_y = y2
                    ans += 1
        
        return ans
```

```Java
// java
class Solution {
    public int numberOfPairs(int[][] points) {
        // 按照 x 升序排序，若 x 相同则按照 y 降序排序
        Arrays.sort(points, (a, b) -> {
            if (a[0] == b[0]) {
                return Integer.compare(b[1], a[1]); // y 降序
            }
            return Integer.compare(a[0], b[0]); // x 升序
        });

        int ans = 0;

        for (int i = 0; i < points.length; i++) {
            int x1 = points[i][0];
            int y1 = points[i][1];
            int maxY = Integer.MIN_VALUE;  // 记录当前遇到的最大 y 值

            for (int j = i + 1; j < points.length; j++) {
                int x2 = points[j][0];
                int y2 = points[j][1];

                // Bob 必须在 Alice 下方
                if (y2 > y1) {
                    continue;
                }

                // 如果 y 坐标相同，直接计数并跳出内层循环
                if (y2 == y1) {
                    ans++;
                    break;
                }

                // 如果当前点的 y 值大于之前记录的最大 y 值，说明没有其他点阻挡
                if (y2 > maxY) {
                    maxY = y2;
                    ans++;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2+nlogn)$，同理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/solutions/3770888/tu-jie-shuo-ming-pai-xu-qu-zui-zhi-yuan-mhrqz/)
