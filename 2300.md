[Problem: 2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)

### 方法：二分 & 双指针

题目有点绕，直接看示例即可，就是让 $spell\times potion \geq sucess$。

一个数学小知识：如果 $2\times 5\geq x$ 成立，那么 $2\times 6\geq x$ 也一定成立。题目给定的 $potions$ 数组固定，如果 $potions[j]$ 越大，则越有可能满足上面不等式。

因此，我们想到 **排序**，让 $potions$ 升序排列。对于当前的 $spell$ 来说，如果 $potions[j]$ 满足条件，则 $potions[j+1...m-1]$ 一定都满足条件！

由于 $potions$ 具有 **单调性**，所以能够使用 **二分**。固定 $spell$，如果我们找到 **第一个** 使得上面不等式成立的 $potions[j]$，则满足的 $potion$ 一共有 $m-j$ 个！

**总结**：枚举 $spells$，对于每个 $spells[i]$，使用二分找到数组 $potions$ 中，最小满足条件的 $potions[j]$，然后累加答案。

二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~

切记使用 $long$ 避免溢出，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        n = len(spells)
        m = len(potions)
        res = [0] * n
        # 升序排列
        potions.sort()

        for i in range(n):
            spell = spells[i]
            
            # 我们的目标是找到第一个（最左边的）索引 j
            # 使得 potions[j] * spell >= success
            left, right = 0, m - 1
            
            while left < right:
                mid = (left + right) >> 1
                
                # 避免浮点数除法的精度问题，改为乘法
                if potions[mid] * spell >= success:
                    # 如果中间的药水强度足够，说明目标可能在 mid 或其左侧
                    right = mid
                else:
                    # 如果中间的药水强度不够，说明目标一定在 mid 的右侧
                    left = mid + 1
            
            # 循环结束后，left 指向了第一个可能满足条件的药水
            # 最后的检查，确认该位置的药水是否真的能成功
            if potions[left] * spell >= success:
                res[i] = m - left
        
        return res
```

```Java
// java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int n = spells.length, m = potions.length;
        int[] res = new int[n];
        // 升序排列
        Arrays.sort(potions);

        for(int i = 0; i < n; i++){
            // 避免浮点数除法的精度问题，改为乘法
            double cur = success * 1.0 / spells[i];
            // 我们的目标是找到第一个（最左边的）索引 j
            // 使得 potions[j] * spell >= success
            int left = 0, right = m - 1;
            
            while(left < right){
                int mid = (left + right) >>> 1;
                // 如果中间的药水强度足够，说明目标可能在 mid 或其左侧
                if(potions[mid] >= cur)
                    right = mid;
                else  // 如果中间的药水强度不够，说明目标一定在 mid 的右侧
                    left = mid + 1;
            }

            // 循环结束后，left 指向了第一个可能满足条件的药水
            // 最后的检查，确认该位置的药水是否真的能成功
            if(potions[right] * 1L * spells[i] >= success)
                res[i] = m - right;
        }
        
        return res;
    }
}
```

- 时间复杂度： $O((n+m)\times logm)$，其中 $n,m$ 分别为数组 $spells,potions$ 的长度，使用的是快排，对数组 $potions$ 二分
- 空间复杂度： $O(logm)$，表示排序时的栈开销，返回值 $res$ 一般不计入复杂度

---

### 双指针

对 $potions$ 排序，就能优化暴力！那如果再对 $spells$ 排序，不就是又一次优化！

同样的数学知识，如果 $3\times 5\geq x$ 成立，那么 $(3+1)\times (5+2)\geq x$ 也一定成立。

因此，我们使用 **双指针**。如果当前的 $spells[i]\times potions[j]$ 满足条件，则 $potions[j,m-1]$ 一定都满足，当前的 $spell$ 对应了 $m-j-1$ 个药水。

此时，我们扩大为 $spells[i+1]$，则原来的 $potions[j,m-1]$ 一定都满足，**甚至** 会导致 $potions[j-1]$ 也满足条件！因此，我们可以尝试缩小 $j$ 指针！

**总结**：在 $spells$ 上的指针从小到大不断移动，而 $potions$ 上的指针从大到小移动。

有一个问题：答案必须保留原始的 $spells$ 元素顺序，排序后会打乱，怎么办？

- 通用方法：将 `(索引，值)` 进行打包排序。
- 进阶方法：使用索引数组，将 $spells$ 的下标进行记录，对索引数组 $indices$ 进行排序（根据 $spells$），则 $indices[0]$ 是最小元素的下标，不改变原数组！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        n = len(spells)
        m = len(potions)
        
        # 索引数组，其内容为 [0, 1, 2, ..., n-1]
        indices = list(range(n))
        # 根据 spells 数组的值对索引数组进行排序
        # 排序后，indices[0] 将是 spells 中最小元素的原始索引
        indices.sort(key=lambda i: spells[i])

        # 升序排列
        potions.sort()
        res = [0] * n
        j = m - 1  # 右指针
        
        for idx in indices:
            # 获取当前咒语的强度
            spell_val = spells[idx]
            
            # 移动指针 j，寻找第一个不满足条件的药水位置
            while j >= 0 and spell_val * potions[j] >= success:
                j -= 1
            
            count = m - 1 - j
            # 存放到原始索引位置
            res[idx] = count
            
        return res
```

```Java
// java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int n = spells.length, m = potions.length;

        // 索引数组，其内容为 [0, 1, 2, ..., n-1]
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++)
            indices[i] = i;
        // 根据 spells 数组的值对索引数组进行排序
        // 排序后，indices[0] 将是 spells 中最小元素的原始索引
        Arrays.sort(indices, Comparator.comparingInt(i -> spells[i]));

        // 升序排列
        Arrays.sort(potions);
        int[] res = new int[n];
        
        for (int i = 0, j = m - 1; i < n; i++) {
            // 当前药水下限
            long t = (success - 1) / spells[indices[i]] + 1;
            // 移动指针 j，寻找第一个不满足条件的药水位置
            while (j >= 0 && potions[j] >= t)
                j--;
            // 存放到原始索引位置
            res[indices[i]] = m - j - 1;
        }

        return res;
    }
}
```

- 时间复杂度： $O(nlogn+mlogm)$，两个指针最多各自移动一趟数组，时间大头在于排序
- 空间复杂度： $O(n)$，表示索引数组 $indices$ 的长度

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solutions/3800368/shuang-jie-pai-xu-er-fen-shuang-zhi-zhen-1ggl/)
