[Problem: 1200. 最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference/description/)

### 数学

题意很清晰，暴力做法就是计算所有可能的元素对的差值。不过时间为 $O(n^2)$，会超时。

假设我们在数轴上画出这些点。考虑三个数 $A, B, C$，且 $A < B < C$。易知：

$(C - A) = (C - B) + (B - A)$

因为数组元素都 **不相同**，所以 $(C - B) > 0$ 且 $(B - A) > 0$。这意味着：

$(C - A) > (C - B), (C - A) > (B - A)$

**结论：** 任意两个非相邻数字的差值（例如 $C-A$），一定 **大于** 它们之间相邻数字的差值（例如 $C-B$ 或 $B-A$）。

因此，最小绝对差一定出现在排序后 **相邻** 的两个元素之间。

---

**命题**：在一个升序排列的数组 $S = [x_1, x_2, \dots, x_n]$ 中，任意两个元素 $x_i, x_j (i < j)$ 的最小绝对差 $\min(x_j - x_i)$ 一定等于某个相邻元素对 $x_{k+1} - x_k$ 的差。

**反证法**：假设最小绝对差出现在两个 **非相邻** 的元素 $x_i$ 和 $x_j$ 之间（即 $j > i + 1$）。

那么，根据索引，必定存在至少一个中间元素 $x_{i+1}$ 使得 $i < i+1 < j$。由于数组是有序的，且元素互不相同，则有 $x_i < x_{i+1} < \dots < x_j$。

此时 $x_j - x_i$ 可以拆解为 $x_j - x_i = (x_j - x_{i+1}) + (x_{i+1} - x_i)$。因为所有元素不同，所以 $(x_j - x_{i+1}) > 0$。因此：

$$
x_j - x_i > x_{i+1} - x_i
$$

这意味着 $x_i$ 和 $x_{i+1}$ 这一对 **相邻** 元素的差值，比 $x_i$ 和 $x_j$ 的差值更小。这与 “最小绝对差出现在非相邻元素之间” 的假设矛盾。

**得证**：最小绝对差只能出现在相邻元素之间。

---

总的来看，我们首先将数组 $arr$ 进行升序排序，维护一个最小差值 $minDiff$，然后一次遍历：

- 计算当前相邻元素 $arr[i+1] - arr[i]$ 的差值。
- 如果这个新的差值比 $minDiff$ 小，说明之前收集的答案都作废了，清空答案列表，更新 $minDiff$，并将当前对加入列表。
- 如果新的差值等于 $minDiff$，则将当前对加入答案列表。
- 如果差值大于 $minDiff$，则忽略。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:
        # 排序
        arr.sort()
        
        min_diff = 1000_001
        res = []
        
        # 遍历相邻元素
        for i in range(len(arr) - 1):
            curr_diff = arr[i+1] - arr[i]
            # 发现更小的差值
            if curr_diff < min_diff:
                min_diff = curr_diff
                # 清空旧结果，开始新列表
                res = [[arr[i], arr[i+1]]]
            # 等于当前最小差值的对
            elif curr_diff == min_diff:
                res.append([arr[i], arr[i+1]])
            # 大于，不做处理
        
        return res
```

```Java
// java
class Solution {
    public List<List<Integer>> minimumAbsDifference(int[] arr) {
        // 排序
        Arrays.sort(arr);
        
        int min_diff = Integer.MAX_VALUE;
        List<List<Integer>> res = new ArrayList<>();
        
        // 遍历相邻元素
        for (int i = 0; i < arr.length - 1; i++) {
            int curr_diff = arr[i+1] - arr[i];
            // 发现更小的差值
            if (curr_diff < min_diff) {
                min_diff = curr_diff;
                // 清空旧结果，开始新列表
                res.clear();
                res.add(Arrays.asList(arr[i], arr[i+1]));
            }
            // 等于当前最小差值的对
            else if (curr_diff == min_diff) {
                res.add(Arrays.asList(arr[i], arr[i+1]));
            }
            // 大于，不做处理
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $arr$ 的长度，快速排序
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-absolute-difference/solutions/3889078/shu-xue-pai-xu-bi-jiao-xiang-lin-yuan-su-0tyo/)
