[Problem: 11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)

### 方法：双指针&优化

注意，本题的垂线没有宽度，不是 “接雨水” 中的墙体。面积 = 宽 $\times$ 高，直接计算即可，无需考虑中间的垂线。

**暴力** 想法：枚举左右两端垂线 $(i,j)$，下标差 $j-i$ 就是容器宽度，高度则是较短的线高 `min(height[i], height[j])`，两者相乘就是答案。

假设数组 $height$ 的长度为 $n$，题目限制 $n\leq 10^5$，该解法的复杂度为 $O(n^2)$，会超时。

如何优化？这个问题的目标是找到 `(j - i) * min(height[i], height[j])` 的最大值。也就是说，我们希望宽度和高度都尽可能大。

**贪心**：如果将宽度设置为 $0$ ~ $n$，则宽度最大。此时，容器的容量由短板决定。为了使答案最大，我们必须在宽度缩小的同时，尽可能地增加容器的高度。

因此，我们想到 **双指针**。从两端开始，向内缩减，宽度由大变小。

- 假设 `height[left] < height[right]`，此时的短板是 `left`。如果我们移动较高的 `right` 指针，新的宽度必然减小，而新的高度最多也只能是 `height[left]`，因此容量不可能增大。
- 反之，如果我们移动较短的 `left` 指针，虽然宽度减小了，但新的 `height[left+1]` 有可能比原来的 `height[left]` 更高，这就为找到更大的容量提供了可能性。

**核心**：每次都移动短板指针，用宽度上的损失去博取高度上可能获得的收益，这是唯一可能找到更优解的策略。

> 这种逐步排除不可能成为最优解的区域、缩小问题规模的方式，正是双指针算法的精髓所在。

**初始化**：设置两个指针，`left` 指向数组的起始位置（最左边的线），`right` 指向数组的末尾（最右边的线）。

**计算与移动**：此时，`left` 和 `right` 指针之间的距离是最大的。容器的容量受限于较短的那条线。计算当前 `left` 和 `right` 指针所构成的容器容量 `(right - left) * min(height[left], height[right])`，并用它来更新记录的最大容量。

接下来是关键一步：**移动哪个指针？** 答案是移动指向较短线段的那个指针。

**终止条件**：当 `left` 和 `right` 指针相遇时，意味着已经考虑了所有可能的有效组合，循环终止。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        ans = 0
        # 分别指向数组的开头和结尾
        left, right = 0, len(height) - 1

        while left < right:
            # 宽度是 right - left，高度由较短的木板决定
            area = (right - left) * min(height[left], height[right])
            # 更新
            ans = max(ans, area)
            
            # 核心思想：移动指向较短木板的指针
            if height[left] < height[right]:
                left += 1  # 左边是短板，左指针向右移动
            else:
                right -= 1 # 右边是短板或一样高，右指针向左移动
                
        return ans
```

```Java
// java
class Solution {
    public int maxArea(int[] height) {
        int ans = 0;
        // 分别指向数组的开头和结尾
        int left = 0, right = height.length - 1;

        while (left < right) {
            // 宽度是 right - left，高度由较短的木板决定
            int area = (right - left) * Math.min(height[left], height[right]);
            // 更新
            ans = Math.max(ans, area);

            // 核心思想：移动指向较短木板的指针
            if (height[left] < height[right]) {
                left += 1;  // 左边是短板，左指针向右移动
            } else {
                right -= 1; // 右边是短板或一样高，右指针向左移动
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $height$ 的长度，每个指针最多各自移动一趟
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

面积 = 宽 $\times$ 高。双指针移动时，宽度必定缩小，如果想让答案增大，必须让高度增大！因此，我们可以优化上述流程：

**移动短板指针，直到高度增大。**

上面是一次移动一步，这里直接跨越多步，从而减少大量无意义的 “计算面积、比较” 等过程，实际运行时间能从 $264ms$ 飞跃至 $19ms$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 优化
        l, r = 0, len(height) - 1
        ans = 0

        # 宽度缩小，所以高度必须增大才能让面积更大
        while l < r:
            # 当前容器高度取决于短板
            minH = min(height[l], height[r])
            # 面积 = 宽度 * 高度
            area = (r - l) * minH
            ans = max(ans, area)
            # 移动短板指针，尝试寻找更高的木板
            while height[l] <= minH and l < r:
                l += 1
            while height[r] <= minH and l < r:
                r -= 1
        
        return ans
```

```Java
// java
class Solution {
    public int maxArea(int[] height) {
        // 优化
        int l = 0, r = height.length - 1;
        int ans = 0;

        // 宽度缩小，所以高度必须增大才能让面积更大
        while (l < r) {
            // 当前容器高度取决于短板
            int minH = Math.min(height[l], height[r]);
            // 面积 = 宽度 * 高度
            int area = (r - l) * minH;
            ans = Math.max(ans, area);

            // 移动短板指针，尝试寻找更高的木板
            while (l < r && height[l] <= minH) {
                l++;
            }
            while (l < r && height[r] <= minH) {
                r--;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，同理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/container-with-most-water/solutions/3797886/tan-xin-zen-yao-xiang-dao-shuang-zhi-zhe-w8cn/)
