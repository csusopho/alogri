[Problem: 1351. 统计有序矩阵中的负数](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/description/)

### 方法：二分 & 线性

查找矩阵中的负数个数。如果暴力遍历，花费 $O(n\times m)$ 时间。虽然可行，但是没有利用 **每行/列递减** 的特性，不算最优解。

仅从 **行或列** 递减的角度来看，一行中的前半部分是正数和 $0$，后半部分是负数。

因此，对每一行(列)进行二分，查找那个分割点 $idx$，那么一行中的负数有 $n-idx$ 个。对所有行进行二分，累加总和得到答案。

使用容易理解的 **闭区间** 二分，代码如下，已附加注释：

```Python
# python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        res = 0
        n = len(grid[0])
        
        # 遍历每一行
        for row in grid:
            # 在当前行找到第一个小于0的数的索引
            left, right = 0, n - 1
            
            while left <= right:
                mid = left + (right - left) // 2
                # 说明负数在右边
                if row[mid] >= 0:
                    left = mid + 1
                else:
                    # 第一个负数可能在左侧
                    right = mid - 1
            
            # left 指向第一个负数的索引
            res += (n - left)
        
        return res
```

```Java
// java
class Solution {
    public int countNegatives(int[][] grid) {
        int res = 0;
        int n = grid[0].length;
        
        // 遍历每一行
        for (int[] row : grid) {
            // 在当前行找到第一个小于0的数的索引
            int left = 0, right = n - 1;
            
            while (left <= right) {
                int mid = left + (right - left) / 2;
                // 说明负数在右边
                if (row[mid] >= 0) {
                    left = mid + 1;
                } else {
                    // 第一个负数可能在左侧
                    right = mid - 1;
                }
            }
            
            // left 指向第一个负数的索引
            res += (n - left);
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(mlogn)$，其中 $m,n$ 为矩阵 $grid$ 的行数和列数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 线性

我们应该充分利用 **行和列** 都递减的特性。

从左到右递减，从上到下递减。也就是说，负数都 **集中在右下角**！如果我们沿着副对角线（右上到左下）**阶梯型** 划分，则右下区域全是负数。

因此，使用一个 **记号笔**，从右上角开始，在正数与负数的交界处划线，

- 如果当前元素为负数，则当前列下面的所有元素为负数，笔迹向左移动一列；
- 反之为正数，笔迹向下移动一行，确保正数不被划分为右下角；

代码如下，已附加注释：

```Python
# python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        res = 0
        row, col = 0, len(grid[0]) - 1  # 右上角

        # 从右上角开始遍历，换成左下角也行
        while row < len(grid) and col >= 0:
            if grid[row][col] < 0:
                # 如果当前元素为负数，则当前列下面的所有元素都是负数
                res += len(grid) - row
                col -= 1  # 向左移动一列
            else:
                row += 1  # 向下移动一行

        return res
```

```Java
// java
class Solution {
    public int countNegatives(int[][] grid) {
        int res = 0;
        int row = 0, col = grid[0].length - 1;  // 右上角

        // 从右上角开始遍历，换成左下角也行
        while (row < grid.length && col >= 0) {
            if (grid[row][col] < 0) {
                // 如果当前元素为负数，则当前列下面的所有元素都是负数
                res += grid.length - row;
                col--;  // 向左移动一列
            } else {
                row++;  // 向下移动一行
            }
        }

        return res;
    }
}
```

- 时间复杂度： $O(m+n)$，向下距离最大为 $m$，向左距离最大为 $n$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/solutions/3867522/shuang-jie-bi-qu-jian-er-fen-xian-xing-h-xqjw/)
