[Problem: 2654. 使数组所有元素变成 1 的最少操作次数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/)

### 方法：数学+Logtrick

什么是最大公约数 $GCD$？具体的原理/模版/推导，可以看这篇 [题解](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/solutions/3783419/shu-xue-san-chong-gcdmo-ban-zhan-mo-ni-j-ffav/)。

数字 $2,4$ 的最大公约数是 $2$，而数字 $3,5$ 的最大公约数是 $1$。根据数学知识可知， $gcd(x, 1)$ 的结果总是 $1$。于是，原问题 “最少操作使得所有数字变为 $1$” 转化为

**通过最少的操作次数在数组中创造出一个 $1$**。

一旦数组中出现了 $1$，我们就可以利用这个 $1$ 和任何与它相邻的数 $x$ 进行操作，这样就可以将 $1$ “传播” 到整个数组。

分情况讨论：

1）最简单的情况，数组中 **已经存在** $1$：

如果数组中已经有 $k$ 个 $1$，则还有 $n - k$ 个非 $1$ 的元素需要转换。利用这个 $1$，通过 $n-k$ 次操作，将所有其他元素都变成 $1$。

例如，对于数组 $[2,1,3]$，可以将 $2$ 变为 $gcd(2, 1) = 1$，再将 $3$ 变为 $gcd(1, 3) = 1$。那么，最少操作次数就是 $n - cnts1$，其中 $cnts1$ 是 $1$ 的数量。

2）一般情况，数组中 **没有** $1$：

- 我们的首要目标是必须先创造出一个 $1$。
- 创造 $1$ 的唯一方法是找到一个 **连续的子数组**，其所有元素的 $GCD$ 为 $1$。

假设有一个长度为 $L$ 的子数组 $[nums[i], ..., nums[i+L-1]]$，其 $GCD$ 为 $1$。那么，我们需要 $L-1$ 次操作才能将这个子数组中的 **某个** 元素变为 $1$。

例如，对于数组 $[4,6,3]$，先计算 $gcd(4,6) = 2$，数组变为 $[4,2,3]$，再计算 $gcd(2,3) = 1$。通过 $2$ 次操作，计算出整个子数组的 $GCD$，且这个值为 $1$。

为了使创造 $1$ 的步骤最少，我们必须寻找 **最短的**、且其 $GCD$ 为 $1$ 的子数组。

简单的 **暴力** 想法：枚举出所有可能的连续子数组，计算每个子数组的 $GCD$，并找到满足 $GCD=1$ 的最短子数组长度，记为 $minLen$。

一旦花费了 $minLen - 1$ 次操作创造出了第一个 $1$，我们就回到了情况 $1$。此时数组中有一个 $1$ 和 $n-1$ 个其他元素。还需要 $n-1$ 次操作将这 $n-1$ 个元素变为 $1$。因此，总操作次数为 $(minLen - 1) + (n - 1)$。

3）特殊情况，**无法完成**：

遍历完所有子数组后，都无法找到一个 $GCD$ 为 $1$ 的子数组，那我们永远无法创造出 $1$。这意味着，整个数组所有元素的最大公约数 $>1$，应返回 $-1$。

实现上述的 **贪心** 流程，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)

        # 计算最大公约数 GCD
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        # 检查数组中是否已存在 1
        cnts = nums.count(1)
        if cnts > 0:
            return n - cnts

        # 寻找最短的、GCD为1的子数组
        ans = 1000

        # 枚举
        for i in range(n):
            cur_gcd = nums[i]
            for j in range(i + 1, n):
                # 计算当前子数组 [i...j] 的最大公约数
                cur_gcd = gcd(cur_gcd, nums[j])
                # 找到
                if cur_gcd == 1:
                    length = j - i + 1
                    # 更新
                    ans = min(ans, length)
                    # 找到从i开始的最短子数组
                    break
        
        # 没有找到任何GCD为1的子数组
        if ans == 1000:
            return -1
        
        # 创造第一个1 + 将1传播到整个数组
        return (ans - 1) + (n - 1)
```

```Java
// java
class Solution {
    // 计算最大公约数 GCD
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    public int minOperations(int[] nums) {
        int n = nums.length;

        // 检查数组中是否已存在 1
        int cnts = 0;
        for (int x : nums) {
            if (x == 1) {
                cnts++;
            }
        }
        if (cnts > 0) {
            return n - cnts;
        }

        // 寻找最短的、GCD为1的子数组
        int ans = 1000;

        // 枚举
        for (int i = 0; i < n; i++) {
            int cur_gcd = nums[i];
            for (int j = i + 1; j < n; j++) {
                // 计算当前子数组 [i...j] 的最大公约数
                cur_gcd = gcd(cur_gcd, nums[j]);
                // 找到
                if (cur_gcd == 1) {
                    int length = j - i + 1;
                    // 更新
                    ans = Math.min(ans, length);
                    // 找到从i开始的最短子数组
                    break;
                }
            }
        }

        // 没有找到任何GCD为1的子数组
        if (ans == 1000) {
            return -1;
        }
        
        // 创造第一个1 + 将1传播到整个数组
        return (ans - 1) + (n - 1);
    }
}
```

“没有子数组的 $GCD$ 为 $1$” 可以 **提前** 到最前方的第一步，判断完成后再开始整个操作流程，这样子速度更快，变为 $0ms$，代码如下：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if gcd(*nums) > 1:
            return -1

        n = len(nums)
        # 数组中已经存在1
        cnts1 = nums.count(1)
        if cnts1 > 0:
            return n - cnts1

        # 创造第一个1所需的最少操作数
        ans = 1000

        # 枚举
        for i in range(n):
            cur_gcd = nums[i]
            for j in range(i + 1, n):
                cur_gcd = gcd(cur_gcd, nums[j])
                # 子数组[i...j]的GCD为1
                if cur_gcd == 1:
                    # 操作次数为 长度 - 1
                    ans = min(ans, j - i)
                    break
        
        # 创造第一个1的操作数 + 将1传播到全数组的操作数
        return ans + n - 1
```

```Java
// java
class Solution {
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }
    
    public int minOperations(int[] nums) {
        int n = nums.length;
        int overallGcd = nums[0];
        for (int i = 1; i < n; i++) {
            overallGcd = gcd(overallGcd, nums[i]);
        }
        // 没有找到任何GCD为1的子数组
        if (overallGcd > 1) {
            return -1;
        }

        // 数组中已经存在1
        int cnts1 = 0;
        for (int x : nums) {
            if (x == 1) {
                cnts1++;
            }
        }
        if (cnts1 > 0) {
            return n - cnts1;
        }

        // 创造第一个1所需的最少操作数
        int ans = 1000;

        // 枚举
        for (int i = 0; i < n; i++) {
            int cur_gcd = nums[i];
            for (int j = i + 1; j < n; j++) {
                cur_gcd = gcd(cur_gcd, nums[j]);
                // 子数组[i...j]的GCD为1
                if (cur_gcd == 1) {
                    // 操作次数为 长度 - 1
                    ans = Math.min(ans, j - i);
                    break;
                }
            }
        }
        
        // 创造第一个1的操作数 + 将1传播到全数组的操作数
        return ans + n - 1;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### $LogTrick$

下面推导的本质是数学，明确求解 $GCD$ 的过程满足 **交换律**。

对于一个固定的起点 $i$，当我们向右移动 $j$ 时，$totalGcd = gcd(nums[i], ..., nums[j])$ 的值是 **非递增** 的。不仅如此，这个值 **变化得非常缓慢**。

例如，对于子数组 $[a, b, c, d, ...]$， $GCD$ 序列是：

- $g1 = a$
- $g2 = gcd(g1, b)$
- $g3 = gcd(g2, c)$
- $\dots$

因为 $gcd(x, y) <= x$，所以 $g1 >= g2 >= g3 >= ...$。每次 $g$ 发生变化，它至少要除以一个大于 $1$ 的整数。一个数 $x$ 最多只能被除以 $log_2x$ 次就会变成 $1$。因此，对于一个固定的起点 $i$，随着 $j$ 的增加，上述 $gcd(nums[i...j])$ 的 **不同值的数量** 是非常少的，将数组 $nums$ 中最大值记为 $M$，则其数量级为 $O(logM)$。

上述算法之所以慢，是因为它为每个 $i$ 都重新计算了大量的、重复的 $GCD$ 值。我们可以利用上述性质，在遍历数组的同时，维护一个 *当前所有* 可能子数组 **后缀** 的 $GCD$ 值的集合。这个集合的大小受限于 $log(M)$。

整体类似 **动态规划** 的思路，但我们维护的不是一个数组，而是一个哈希表 $gcdMap$，其中 $gcdMap[g] = k$ 的含义是：在所有以 **上一个元素** $nums[i-1]$ 结尾的子数组中， $GCD$ 值为 $g$ 的 **最短** 子数组的长度是 $k$。

从左到右遍历数组 $nums$，假设当前元素为 $num$：

- 创建一个新的、临时的字典 $newMap$。
- 对于 $num$ 本身，它构成了一个长度为 $1$ 的子数组，则 `newMap[num] = 1`。
- 遍历上一轮的 $gcdMap$ 中的每一个 $(g, length)$ 对，计算 $newGcd = gcd(g, num)$。这意味着我们将 $num$ 接到了那个长度为 $length$ 的子数组末尾，形成了一个长度为 $length + 1$ 的新子数组，且 $GCD$ 为 $newGcd$。那么就有 `newMap[newGcd] = length + 1`。如果 $newGcd$ 已存在，则不需要更新，因为我们是从上一轮最短的子数组扩展而来的，所以新形成的也一定是最短的。
- 用 $newMap$ 替换旧的 $gcdMap$，进入下一个元素的计算。
- 在每一步更新完 $gcdMap$ 后，检查 $1$ 是否作为键存在。如果 $gcdMap[1]$ 存在，说明我们找到了一个以当前元素结尾、且 $GCD$ 为 1 的子数组，其长度为 $gcdMap[1]$。

用一个变量 $mn$ 来记录所有这些长度中的最小值。那么，创造第一个 $1$ 需要 $mn - 1$ 次操作，将这个 $1$ 传播到整个数组需要 $n - 1$ 次操作。总次数为 $(mn - 1) + (n - 1)$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if gcd(*nums) > 1:
            return -1

        n = len(nums)
        # 数组中已经存在1
        cnts1 = nums.count(1)
        if cnts1 > 0:
            return n - cnts1

        # 寻找最短的、GCD为1的子数组长度
        mn_len = 1000
        
        # gcd_len[g] = k
        # 在所有以上一个元素结尾的子数组中，GCD为g的最短子数组长度为k
        gcd_len = {}

        # 遍历数组中的每个数
        for num in nums:
            # 存储以当前 num 结尾的子数组的GCD情况
            new_map = {}
            
            # num 自身构成一个长度为1的子数组
            if num not in new_map:
                new_map[num] = 1

            # 将 num 与之前所有后缀子数组的GCD进行计算
            for g, length in gcd_len.items():
                new_g = gcd(g, num)
                # 总是从上一轮最短的 length 扩展
                if new_g not in new_map:
                    new_map[new_g] = length + 1
            
            # 更新 gcd_map 以供下一轮使用
            gcd_len = new_map

            # 检查是否在本轮找到了GCD为1的子数组
            if 1 in gcd_len:
                mn_len = min(mn_len, gcd_len[1])

        return (mn_len - 1) + (n - 1)
```

```Java
// java
class Solution {
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }
    
    public int minOperations(int[] nums) {
        int n = nums.length;
        int overallGcd = nums[0];
        for (int i = 1; i < n; i++) {
            overallGcd = gcd(overallGcd, nums[i]);
        }
        if (overallGcd > 1) {
            return -1;
        }

        // 数组中已经存在1
        int cnts1 = 0;
        for (int x : nums) {
            if (x == 1) {
                cnts1++;
            }
        }
        if (cnts1 > 0) {
            return n - cnts1;
        }

        // 寻找最短的、GCD为1的子数组长度
        int mn_len = Integer.MAX_VALUE;
        
        // gcd_len[g] = k
        // 在所有以上一个元素结尾的子数组中，GCD为g的最短子数组长度为k
        Map<Integer, Integer> gcd_len = new HashMap<>();

        // 遍历数组中的每个数
        for (int num : nums) {
            // 存储以当前 num 结尾的子数组的GCD情况
            Map<Integer, Integer> new_map = new HashMap<>();
            
            // num 自身构成一个长度为1的子数组
            new_map.put(num, 1);

            // 将 num 与之前所有后缀子数组的GCD进行计算
            for (Map.Entry<Integer, Integer> entry : gcd_len.entrySet()) {
                int g = entry.getKey();
                int length = entry.getValue();
                int new_g = gcd(g, num);
                int new_len = length + 1;
                
                // 如果新路径更短，则更新；如果键不存在，则添加
                if (!new_map.containsKey(new_g) || new_len < new_map.get(new_g)) {
                    new_map.put(new_g, new_len);
                }
            }
            
            // 更新 gcd_map 以供下一轮使用
            gcd_len = new_map;

            // 检查是否在本轮找到了GCD为1的子数组
            if (gcd_len.containsKey(1)) {
                mn_len = Math.min(mn_len, gcd_len.get(1));
            }
        }

        return (mn_len - 1) + (n - 1);
    }
}
```

- 时间复杂度： $O(n\times logM)$，其中 $M$ 是数组 $nums$ 中的最大值
- 空间复杂度： $O(logM)$，表示哈希表 $gcdMap$ 的大小

---

### 原地

核心相同："对于固定的起点，后缀 $GCD$ 的不同值的数量是 $O(logM)$"。

在内层循环中，当我们处理到 $nums[i]$ 时，我们从 $j = i-1$ 开始 **向左** 遍历。这里的 $nums[j]$ 不再是 $nums$ 中的初始值，而是用作一个 “状态” 存储。

- 在处理 $nums[i]$ **之前**， $nums[j]$ (对于 $j < i$) 存储的是 **原始数组** 中子数组 $[nums[j], ..., nums[i-1]]$ 的最大公约数。
- 内层循环，在 $j$ 位置执行 $nums[j] = gcd(nums[j], nums[i])$ 时，它实际上是在计算 $gcd( gcd(nums[j...i-1]), nums[i] )$，这等价于 $gcd(nums[j...i])$。
- 所以，在内层循环结束后，$nums$ 数组的前 $i$ 个元素 $[nums[0], ..., nums[i-1]]$ 已经被更新为以 $nums[i]$ 结尾的各个后缀子数组的 $GCD$。
  - $nums[i-1]$ 存储 $gcd(nums[i-1], nums[i])$
  - $nums[i-2]$ 存储 $gcd(nums[i-2], nums[i-1], nums[i])$
  - $\dots$

**剪枝优化**：如果 $gcd(nums[j], nums[i])$ 就是 $nums[j]$，说明 $nums[i]$ 是 $nums[j]$ 的倍数。因为 $nums[j]$ 代表了 $gcd(nums[j...i-1])$，那么对于任何 $k < j$， $nums[k]$ 也必然是 $nums[j]$ 的倍数。此时，用 $nums[i]$ 去更新 $nums[k]$ 不会改变 $nums[k]$ 的值。这意味着 $GCD$ 的值向左传播时已经 “稳定”了，再往左计算也是徒劳，所以可以安全地退出内层循环。这就是 $LogTrick$ 加速的体现。

当 $nums[j]$ 被更新为 $1$ 时，意味着我们找到了一个子数组 $nums[j...i]$，其 $GCD$ 为 $1$。将这个子数组中的一个元素变为 $1$ 所需的操作次数是 $长度 - 1$，即 $i - j$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if gcd(*nums) > 1:
            return -1

        n = len(nums)
        # 数组中已经存在1
        cnts1 = nums.count(1)
        if cnts1 > 0:
            return n - cnts1

        # 创造第一个1所需的最少操作数
        mn_ops = 1000

        # 更新 nums[i] 左边的所有后缀GCD
        for i in range(n):
            # 向左更新
            for j in range(i - 1, -1, -1):
                # 计算新的GCD
                new_gcd = gcd(nums[j], nums[i])

                # 如果GCD值没有变小，说明nums[i]是nums[j]的倍数
                # 那么它也一定是更左边所有后缀GCD的倍数，无需再向左传播
                if new_gcd == nums[j]:
                    break
                
                # 原地更新：nums[j] 现在存储 gcd(nums[j...i])
                nums[j] = new_gcd

                # 子数组 [j...i] 符合
                if nums[j] == 1:
                    # 操作数为 长度 - 1
                    mn_ops = min(mn_ops, i - j)
                    break
        
        # 创造第一个1的操作数 + 将1传播到全数组的操作数
        return mn_ops + n - 1
```

```Java
// java
class Solution {
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int overallGcd = nums[0];
        for (int i = 1; i < n; i++) {
            overallGcd = gcd(overallGcd, nums[i]);
        }
        if (overallGcd > 1) {
            return -1;
        }

        // 数组中已经存在1
        int cnts1 = 0;
        for (int x : nums) {
            if (x == 1) {
                cnts1++;
            }
        }
        if (cnts1 > 0) {
            return n - cnts1;
        }

        // 创造第一个1所需的最少操作数
        int mn_ops = 1000;

        // 更新 nums[i] 左边的所有后缀GCD
        for (int i = 0; i < n; i++) {
            // 向左更新
            for (int j = i - 1; j >= 0; j--) {
                // 计算新的GCD
                int new_gcd = gcd(nums[j], nums[i]);

                // 如果GCD值没有变小，说明nums[i]是nums[j]的倍数
                // 那么它也一定是更左边所有后缀GCD的倍数，无需再向左传播
                if (new_gcd == nums[j]) {
                    break;
                }
                
                // 原地更新：nums[j] 现在存储 gcd(nums[j...i])
                nums[j] = new_gcd;

                // 子数组 [j...i] 符合
                if (nums[j] == 1) {
                    // 操作数为 长度 - 1
                    mn_ops = Math.min(mn_ops, i - j);
                    break;
                }
            }
        }
        
        // 创造第一个1的操作数 + 将1传播到全数组的操作数
        return mn_ops + n - 1;
    }
}
```

- 时间复杂度： $O(n\times logM)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3829750/shu-xue-ben-zhi-shi-zhao-zui-duan-zi-shu-7jdl/)
