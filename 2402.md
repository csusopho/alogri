[Problem: 2402. 会议室 III](https://leetcode.cn/problems/meeting-rooms-iii/description/)

### 方法：暴力 & 双堆

题意：如果会议室无空闲，则让会议进行排队。开始早的会议先预约排队，等待会议室空闲。多个会议室空闲，优先安排 $id$ 最小的房间。

初始时，所有会议室空闲，所以最早开始的会议优先得到会议室。且后续过程中， 开始时间更早的会议先用会议室。

一个自然的 **想法**：对 $meetings$ 按照 *开始时间* 排序。

**模拟** 分配流程，顺序遍历排序后的 $meetings$，对于每个会议：

- 如果有会议室空闲，就使用 $id$ 最小的会议室；
- 如果没有可用的会议室，会议需要延期，等待某个最早空闲的会议室。

安排当前 $meeting$ 到第 $x$ 个会议室后，累加 $x$ 的安排次数。

会议室被占用后，它的空闲时间会被延后到 $end$，所以使用数组 $freeTime$ 记录最早空闲时间。以及数组 $count$，记录会议室的安排次数。

代码如下，已附加注释：

```Python
# python
class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        # 按开始时间排序
        meetings.sort()
        # 每个会议室空闲的时间
        free_time = [0] * n
        # 每个会议室举办的会议次数
        count = [0] * n
        
        for start, end in meetings:
            duration = end - start
            
            # 从前往后，查找可用的会议室
            found = False
            for i in range(n):
                if free_time[i] <= start:
                    free_time[i] = start + duration
                    count[i] += 1
                    found = True
                    break
            
            if not found:
                # 找到最早空闲且编号最小的会议室
                min_free_time = min(free_time)
                for i in range(n):
                    if free_time[i] == min_free_time:
                        free_time[i] = min_free_time + duration
                        count[i] += 1
                        break
        
        # 最大次数&最小编号
        return count.index(max(count))
```

```Java
// java
class Solution {
    public int mostBooked(int n, int[][] meetings) {
        // 按开始时间排序
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);
        
        // 每个会议室空闲的时间
        long[] freeTime = new long[n];
        // 每个会议室举办的会议次数
        int[] count = new int[n];
        
        for (int[] meeting : meetings) {
            int start = meeting[0];
            int end = meeting[1];
            long duration = end - start;
            
            // 从前往后，查找可用的会议室
            boolean found = false;
            for (int i = 0; i < n; i++) {
                if (freeTime[i] <= start) {
                    freeTime[i] = start + duration;
                    count[i]++;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                // 找到最早空闲且编号最小的会议室
                long minFreeTime = Long.MAX_VALUE;
                for (int i = 0; i < n; i++) {
                    if (freeTime[i] < minFreeTime) {
                        minFreeTime = freeTime[i];
                    }
                }
                for (int i = 0; i < n; i++) {
                    if (freeTime[i] == minFreeTime) {
                        freeTime[i] = minFreeTime + duration;
                        count[i]++;
                        break;
                    }
                }
            }
        }
        
        // 最大次数&最小编号
        int maxCount = 0;
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (count[i] > maxCount) {
                maxCount = count[i];
                result = i;
            }
        }
        return result;
    }
}
```

- 时间复杂度： $O(mlogm+mn)$，其中 $m$ 为数组 $meetings$ 的长度
- 空间复杂度： $O(n)$，表示数组 $freeTime,count$ 的大小

---

### 最小堆

离散事件模拟，可以使用 **优先队列/堆** 来管理会议室的状态。

- **空闲** 会议室 $available$：存储当前未被占用的会议室编号，堆顶是最小编号；
- **使用中** 会议室 $busy$：存储当前正在开会的会议室，格式为 `(结束时间, 房间编号)`。

遍历排序后的会议，模拟过程：

- **释放资源**：处理前，检查 $busy$ 队列。如果堆顶会议室的结束时间 $\le$ 当前会议的开始时间，说明该房间已变为空闲，将其从 $busy$ 移回 $available$。
- **分配房间**：
  - 如果有空闲房间。从 $available$ 堆中取出编号最小的房间，更新其结束时间，加入 $busy$。
  - 无空闲房间。必须延期，取出 $busy$ 堆顶的房间。该会议的新开始时间，即为这个房间的结束时间。计算新的结束时间后，重新压入 $busy$。注意，不需要将房间放回 $available$ 再取出来，直接更新时间即可，因为它是无缝衔接下一场会议的。

模拟整个流程，最后找出 $count$ 最大值对应的最小编号 $id$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        # 记录会议室使用次数
        count = [0] * n
        # 按照会议开始时间升序排列
        meetings.sort(key=lambda x: x[0])
        # 存储空闲的房间编号
        available = [i for i in range(n)]
        heapq.heapify(available)
        # 存储正在使用的房间，格式为 (结束时间, 房间编号)
        busy = []
        
        # 遍历每一场会议
        for start, end in meetings:
            # 释放已结束的会议室
            while busy and busy[0][0] <= start:
                _, room_idx = heapq.heappop(busy)
                heapq.heappush(available, room_idx)
                
            # 分配会议室
            if available:
                # 有空闲房间，选编号最小的
                room_idx = heapq.heappop(available)
                # 记录该房间结束时间
                heapq.heappush(busy, (end, room_idx))
            else:
                # 没有空闲房间，等待最早结束的房间释放
                finish_time, room_idx = heapq.heappop(busy)
                # 计算延期后的新结束时间
                new_end = finish_time + (end - start)
                # 房间直接进入下一场会议
                heapq.heappush(busy, (new_end, room_idx))
                
            # 计数
            count[room_idx] += 1
        
        mx = 0
        res = 0
        for i in range(n):
            if count[i] > mx:
                mx = count[i]
                res = i
                
        return res
```

```Java
// java
class Solution {
    public int mostBooked(int n, int[][] meetings) {
        // 记录会议室使用次数
        int[] count = new int[n];
        // 按照会议开始时间升序排列
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);
        
        // 存储空闲的房间编号（最小堆）
        PriorityQueue<Integer> available = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            available.offer(i);
        }
        
        // 存储正在使用的房间，格式为 (结束时间, 房间编号)（按结束时间最小堆）
        PriorityQueue<long[]> busy = new PriorityQueue<>((a, b) -> {
                if (a[0] == b[0]) {
                    return Long.compare(a[1], b[1]);
                }
                return Long.compare(a[0], b[0]);
            }
        );
        
        // 遍历每一场会议
        for (int[] meeting : meetings) {
            int start = meeting[0];
            int end = meeting[1];
            
            // 释放已结束的会议室
            while (!busy.isEmpty() && busy.peek()[0] <= start) {
                long[] room = busy.poll();
                available.offer((int) room[1]);
            }
            
            int roomIdx;
            if (!available.isEmpty()) {
                // 有空闲房间，选编号最小的
                roomIdx = available.poll();
                // 记录该房间结束时间
                busy.offer(new long[]{end, roomIdx});
            } else {
                // 没有空闲房间，等待最早结束的房间释放
                long[] room = busy.poll();
                long finishTime = room[0];
                roomIdx = (int) room[1];
                // 计算延期后的新结束时间
                long newEnd = finishTime + (end - start);
                // 房间直接进入下一场会议
                busy.offer(new long[]{newEnd, roomIdx});
            }
            
            // 计数
            count[roomIdx]++;
        }
        
        // 找出使用次数最多的最小编号房间
        int maxCount = 0;
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (count[i] > maxCount) {
                maxCount = count[i];
                result = i;
            }
        }
        return result;
    }
}
```

- 时间复杂度： $O(mlogm+mlogn)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/meeting-rooms-iii/solutions/3866951/shuang-jie-bao-li-mo-ni-shuang-dui-you-h-edi0/)
