[Problem: 37. 解数独](https://leetcode.cn/problems/sudoku-solver/description/)

### 方法：DFS & 优化

解决本题前，建议先做完前一道 $36$ 题，题解为 [传送门](https://leetcode.cn/problems/valid-sudoku/solutions/3767374/shuang-jie-shu-zu-biao-ji-wei-yun-suan-j-3g3c/)。如果你之前没做过回溯的题，建议先去练一练经典例题 [N皇后](https://leetcode.cn/problems/n-queens/description/)，[题解链接](https://leetcode.cn/problems/n-queens/solutions/3006469/hui-su-po-su-jie-fa-yi-wei-you-hua-dfstu-gdhu/)。

**暴力**：每一个空格子都尝试 $1$ ~ $9$ 的可能，拓展出无数个棋盘，检查方案是否可行。每一次的填入，都会让空方格变少，从父问题变为子问题 —— **递归**。

**定义** $dfs(grid)$ 表示准备填充 $grid$ 矩阵，选择一个空方格填入数字，会得到一个新的矩阵 $newGrid$，返回值表示是否找到合法方案。状态转移为：

$$
dfs(grid)=\bigvee dfs(newGrid)
$$

选择任意一个方格，填入任意一个数字，具体的过程就是：

```Java
for(int i = 0; i < 9; i++) {  // 遍历行
    for(int j = 0; j < 9; j++) {  // 遍历列
        if(board[i][j] != '.')  // 必须是空格
            continue;
        for(char k = '1'; k <= '9'; k++) {  // 填入数字
            //
            // 尝试放置并继续递归
            //
        }
        //
    }
}
```

**递归边界**：只有确定某一种方案可行或者不可行，才需要返回结果。

- 当 $9$ 种数字都尝试完成后，没有数字就表示不填，肯定不合法，返回 $False$；
- 如果子问题找到合法方案，那就没必要搜索，直接返回 $True$；
- 如果方格遍历完成，也就是三 $for$ 全结束，说明都填满了，返回 $True$。

那一个数字填入后，怎么知道是否合法呢？也就是前一道题，题解链接在上方。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        self.dfs(board)

    def dfs(self, board):
        # 遍历每一个格子
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    continue
                for k in range(1, 10):
                    x = str(k)
                    if self.check(board, i, j, x):
                        board[i][j] = x
                        if self.dfs(board):
                            return True
                        board[i][j] = '.'
                return False  # 当前格子填不进去，回溯
        return True  # 全部填好

    def check(self, board, row, col, val):
        # 检查行
        for i in range(9):
            if board[row][i] == val:
                return False
        # 检查列
        for j in range(9):
            if board[j][col] == val:
                return False
        # 检查 3x3 宫格
        startRow = (row // 3) * 3
        startCol = (col // 3) * 3
        for i in range(startRow, startRow + 3):
            for j in range(startCol, startCol + 3):
                if board[i][j] == val:
                    return False
        return True
```

```Java
// java
class Solution {
    public void solveSudoku(char[][] board) {
        // 回溯大法，检查9宫格、整行、整列
        dfs(board);
    }

    // 使用boolean可以提前返回快速剪枝，同时让答案能够收集
    private boolean dfs(char[][] board) {
        // 尽可能填充，每一种可能都去尝试，true表示成功
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.')
                    continue;
                for(int k = 1; k <= 9; k++) {
                    char x = (char)('0' + k);
                    if(check(board, i, j, x)) {
                        board[i][j] = x;
                        if(dfs(board))
                            return true;
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }

    private boolean check(char[][] board, int row, int col, char val) {
        for(int i = 0; i < 9; i++)  // 检查这一行
            if(board[row][i] == val)
                return false;
        for(int j = 0; j < 9; j++)  // 检查这一列
            if(board[j][col] == val)
                return false;
        int startRow = (row / 3) * 3;  // 转化为这一块的开头一行
        int startCol = (col / 3) * 3;  // 转为这一块的开头一列
        for(int i = startRow; i < startRow + 3; i++)  // 遍历这一块
            for(int j = startCol; j < startCol + 3; j++)
                if(board[i][j] == val)
                    return false;
        return true;  // 走到这说明前面都检查没问题
    }
}
```

单层填入九种数字，搜索树的分支数为 $9$。在最坏情况下，棋盘几乎全是空格，深度最大为 $81$。由于中途会进行合法性检查，所以实际复杂度小于 $O(9^{81})$。

在 $2024$ 年四月上述代码能过，但增加了一个样例，所以 $2025$ 年八月不能通过。

---

### 空格标记

只需要填充空格，棋盘中原有的数字根本无需理会！

因此，我们 **提前** 将所有空格的位置收集到列表 $list$ 中。那么，没必要使用三重 $for$ 循环遍历棋盘，仅需单 $for$ 遍历此列表！

同时，增加前一题的 **技巧**：行/列/宫标记法，从而缩减 $check$ 检查时间。

代码如下，已附加注释：

```Python
# python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        self.board = board
        # 标志某行、列、九宫格是否填了对应数字
        self.rows = [[False] * 9 for _ in range(9)]
        self.cols = [[False] * 9 for _ in range(9)]
        self.block = [[[False] * 9 for _ in range(3)] for _ in range(3)]
        self.spaces = []
        self.isValid = False

        # 初始化
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    self.spaces.append((i, j))
                else:
                    index = int(board[i][j]) - 1
                    self.rows[i][index] = True
                    self.cols[j][index] = True
                    self.block[i // 3][j // 3][index] = True

        # 从第0个空格开始回溯
        self.dfs(0)

    def dfs(self, pos):
        # 所有空格填完
        if pos == len(self.spaces):
            self.isValid = True
            return

        r, c = self.spaces[pos]
        for digit in range(1, 10):
            index = digit - 1
            if not self.rows[r][index] and not self.cols[c][index] and not self.block[r // 3][c // 3][index]:
                # 标记
                self.rows[r][index] = self.cols[c][index] = self.block[r // 3][c // 3][index] = True
                self.board[r][c] = str(digit)
                # 递归
                self.dfs(pos + 1)
                if self.isValid:
                    return
                # 撤销标记
                self.rows[r][index] = self.cols[c][index] = self.block[r // 3][c // 3][index] = False
```

```Java
// java
class Solution {
    private char[][] board;
    // 标志某行、列、九宫格是否填了对应数字
    private boolean[][] rows = new boolean[9][9];
    private boolean[][] cols = new boolean[9][9];
    private boolean[][][] block = new boolean[3][3][9];
    // 存放空格位置
    private List<int[]> spaces = new ArrayList<>();
    // 全局有效标志
    private boolean isValid = false;

    public void solveSudoku(char[][] board) {
        this.board = board;
        
        // 初始化空格位置和已出现的数字
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    spaces.add(new int[]{i, j});
                } else {
                    int index = board[i][j] - '1'; // 转为0-8索引
                    rows[i][index] = true;
                    cols[j][index] = true;
                    block[i / 3][j / 3][index] = true;
                }
            }
        }

        // 从第0个空格开始回溯
        dfs(0);
    }

    private void dfs(int pos) {
        // 所有空格填完
        if (pos == spaces.size()) {
            isValid = true;
            return;
        }

        int r = spaces.get(pos)[0];
        int c = spaces.get(pos)[1];

        // 尝试1~9的数字
        for (int digit = 1; digit <= 9; digit++) {
            int index = digit - 1;
            if (!rows[r][index] && !cols[c][index] && !block[r / 3][c / 3][index]) {
                // 标记已使用
                rows[r][index] = cols[c][index] = block[r / 3][c / 3][index] = true;
                board[r][c] = (char) (digit + '0');

                // 递归填下一个空格
                dfs(pos + 1);
                if (isValid) return; // 已找到解，直接返回

                // 回溯：撤销标记
                rows[r][index] = cols[c][index] = block[r / 3][c / 3][index] = false;
            }
        }
    }
}
```

假设空格有 $m$ 个，那么递归的深度就变为 $O(m)$。

- 时间复杂度：远小于 $O(9^m)$，其中 $m\leq 81$
- 空间复杂度： $O(m)$，表示列表 $spaces$ 、辅助数组、递归栈开销的大小

---

### 位运算

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 对应的二进制数为 $10011$。

应用到数组中，数 $5=101$ 可以代表数组中的第 $0$ 个和第 $2$ 个元素存在，其余元素都不存在。数组 $rows$ 的第二维表示数字填充情况，长度为 $9$，能进行状态压缩。

**使用技巧**：

- 使用 `|` 或运算将数字放到掩码中，以及 `&` 与运算判断数字是否存在；
- 我们需要取出具体数字，因此使用 `~` 取反运算，它的规则是 `~(100)=011`；
- 回溯撤销选择，所以使用 `^` 异或运算。比如 `1001 | 10 = 1011` 表示添加数字 $2$，对这个结果异或原数字 $2$，得到 `1011 ^ 10 = 1001` 表示回归原状态；
- `-` 符号是按位取反再 $+1$，它和 `&` 与运算结合，能取出最低位的 $1$。比如 `-(000101)=111011`，则 `101 & -(101) = 001`，只剩下一个 $1$。
- 去除最低位的 $1$，就是使用 `n & (n - 1)`，比如 `101 & 100 = 100`。
- 取出最低位 $1$，去除最低位 $1$，两个过程结合，能取出所有 $1$，也就是存在的数字。

上述流程是常用的位运算方法，建议尽早掌握。

代码如下，已附加注释：

```Python
# python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        # 二进制中1表示对应位置已经填值
        rows, cols = [0] * 9, [0] * 9
        blocks = [[0] * 3 for _ in range(3)]
        spaces = []

        # 初始化
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    spaces.append((i, j))
                else:
                    n = int(board[i][j]) - 1
                    mask = 1 << n
                    rows[i] |= mask
                    cols[j] |= mask
                    blocks[i // 3][j // 3] |= mask

        def dfs(pos):
            if pos == len(spaces):  # 所有空格填完
                return True

            x, y = spaces[pos]
            # 计算当前位置可用数字：取反后 & 低9位
            mask = ~(rows[x] | cols[y] | blocks[x // 3][y // 3]) & 0x1FF
            while mask:  # 遍历所有候选位
                lowbit = mask & -mask       # 取最低位 1
                n = (lowbit.bit_length() - 1)  # 转成数字索引 0~8
                # 填入
                rows[x] |= lowbit
                cols[y] |= lowbit
                blocks[x // 3][y // 3] |= lowbit
                board[x][y] = str(n + 1)
                if dfs(pos + 1): return True
                # 撤销
                rows[x] ^= lowbit
                cols[y] ^= lowbit
                blocks[x // 3][y // 3] ^= lowbit
                mask &= mask - 1  # 去掉最低位 1
            return False

        dfs(0)
```

```Java
// java
class Solution {
    public void solveSudoku(char[][] board) {
        // 二进制中1表示对应位置已经填值
        int[] rows = new int[9];
        int[] cols = new int[9];
        int[][] blocks = new int[3][3];
        List<int[]> spaces = new ArrayList<>();

        // 初始化
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') {
                    spaces.add(new int[]{i, j});
                } else {
                    int n = c - '1';
                    int mask = 1 << n;
                    rows[i] |= mask;
                    cols[j] |= mask;
                    blocks[i / 3][j / 3] |= mask;
                }
            }
        }

        dfs(0, board, spaces, rows, cols, blocks);
    }

    private boolean dfs(int pos, char[][] board, List<int[]> spaces,
                        int[] rows, int[] cols, int[][] blocks) {
        if (pos == spaces.size()) return true; // 所有空格填完

        int x = spaces.get(pos)[0];
        int y = spaces.get(pos)[1];

        // 当前位置可用数字掩码：取反后 & 低9位
        int mask = ~(rows[x] | cols[y] | blocks[x / 3][y / 3]) & 0x1FF;

        while (mask != 0) {
            int lowbit = mask & -mask;      // 取最低位1
            int n = Integer.numberOfTrailingZeros(lowbit); // 转为数字索引0~8

            // 填入
            rows[x] |= lowbit;
            cols[y] |= lowbit;
            blocks[x / 3][y / 3] |= lowbit;
            board[x][y] = (char) (n + 1 + '0');

            if (dfs(pos + 1, board, spaces, rows, cols, blocks)) return true;

            // 撤销
            rows[x] ^= lowbit;
            cols[y] ^= lowbit;
            blocks[x / 3][y / 3] ^= lowbit;

            mask &= mask - 1; // 去掉最低位1
        }

        return false;
    }
}
```

- 时间复杂度：远小于 $O(9^m)$，其中 $m$ 是空格数
- 空间复杂度： $O(m)$，同理

---

### 优先队列

某个空格 $(r, c)$ 能填的数字，并不是 $1$ ~ $9$ 全部，而是要 **排除** 该行、该列、该宫格中 **已经用过** 的数字。比如这一行左边有 $2$，当前这一格不可能填 $2$。

定义 $candidates$ 列表，它存储这个格子当前所有可能填的数字（候选）。比如，若某格只可能填 $\{2, 7\}$，那么 $candidates$ 的长度就是 $2$。

数字越少，说明这个格子越 “紧迫”，**自由度** 越低。如果我们 **优先** 填候选数最少的位置，就能大大减少回溯次数：

- 如果某格只有 $1$ 个合法数字，直接填上即可；
- 如果某格有 $7$ 个候选数，那就要试 $7$ 次分支，搜索量大。

这种策略叫 $MRV$ `(Minimum Remaining Values)` 启发式，是典型的约束满足问题 $CSP$ 的优化思路。

队列 $heap$ 中每个元素是一个三元组：`(candidates.size(), r, c, b)`。分别表示：该位置的候选数字个数、行索引、列索引、宫索引。

结合上面的位运算技巧，得到下面的代码，已附加注释：

```Python
# python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        full_mask = (1 << 9) - 1  # 9位全1，表示1-9都可用
        
        # 行、列、宫格的掩码
        rows = [full_mask] * 9
        cols = [full_mask] * 9
        blocks = [full_mask] * 9  # 0~8 表示 9 个 3x3 宫格

        spaces = []  # 空格位置列表
        
        # 初始化掩码
        for i in range(9):
            for j in range(9):
                c = board[i][j]
                if c == '.':
                    spaces.append((i, j))
                else:
                    n = int(c) - 1
                    bit = 1 << n
                    rows[i] ^= bit
                    cols[j] ^= bit
                    blocks[(i // 3) * 3 + (j // 3)] ^= bit

        # 构建最小堆 (候选数个数, 行, 列, 宫格索引)
        # 按可能的数字数量排序
        heap = []
        for i, j in spaces:
            b = (i // 3) * 3 + (j // 3)
            # 二进制中1的个数，即可用数字数量
            mask = rows[i] & cols[j] & blocks[b]
            heapq.heappush(heap, (bin(mask).count("1"), i, j, b))

        def dfs():
            if not heap:
                return True  # 填完

            # 取出可能性最少的单元格
            _, i, j, b = heapq.heappop(heap)
            mask = rows[i] & cols[j] & blocks[b]
            count = 0

            # 尝试所有可能的数字
            while mask:
                # 提取最低位的1
                lowbit = mask & -mask
                # 尝试该数字，标记为已使用
                mask ^= lowbit
                rows[i] ^= lowbit
                cols[j] ^= lowbit
                blocks[b] ^= lowbit

                digit = lowbit.bit_length()  # 转换为 1-9
                board[i][j] = str(digit)

                # 递归
                if dfs():
                    return True

                # 回溯：恢复掩码和单元格状态
                rows[i] |= lowbit
                cols[j] |= lowbit
                blocks[b] |= lowbit
                count += 1

            # 将单元格放回队列
            heapq.heappush(heap, (count, i, j, b))
            return False

        dfs()
```

```Java
// java
class Solution {
    public void solveSudoku(char[][] board) {
        int fullMask = (1 << 9) - 1; // 9位全1，表示1-9都可用

        // 行、列、宫格的掩码
        int[] rows = new int[9];
        int[] cols = new int[9];
        int[] blocks = new int[9];
        Arrays.fill(rows, fullMask);
        Arrays.fill(cols, fullMask);
        Arrays.fill(blocks, fullMask);

        List<int[]> spaces = new ArrayList<>(); // 空格位置列表

        // 初始化掩码
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') {
                    spaces.add(new int[]{i, j});
                } else {
                    int n = c - '1';
                    int bit = 1 << n;
                    rows[i] ^= bit;
                    cols[j] ^= bit;
                    blocks[(i / 3) * 3 + (j / 3)] ^= bit;
                }
            }
        }

        // 构建最小堆 (候选数个数, 行, 列, 宫格索引)
        PriorityQueue<int[]> heap = new PriorityQueue<>(
            (a, b) -> Integer.compare(a[0], b[0])
        );

        for (int[] pos : spaces) {
            int i = pos[0], j = pos[1];
            int b = (i / 3) * 3 + (j / 3);
            int mask = rows[i] & cols[j] & blocks[b];
            int count = Integer.bitCount(mask); // 二进制中1的个数，即可用数字数量
            heap.offer(new int[]{count, i, j, b});
        }

        dfs(board, rows, cols, blocks, heap);
    }

    private boolean dfs(char[][] board, int[] rows, int[] cols, int[] blocks, PriorityQueue<int[]> heap) {
        if (heap.isEmpty()) return true; // 填完

        // 取出可能性最少的单元格
        int[] cur = heap.poll();
        int i = cur[1], j = cur[2], b = cur[3];
        int mask = rows[i] & cols[j] & blocks[b];
        int count = 0;

        // 尝试所有可能的数字
        while (mask != 0) {
            int lowbit = mask & -mask; // 提取最低位的1
            mask ^= lowbit;

            // 尝试该数字，标记为已使用
            rows[i] ^= lowbit;
            cols[j] ^= lowbit;
            blocks[b] ^= lowbit;

            int digit = Integer.numberOfTrailingZeros(lowbit) + 1; // 转换为 1-9
            board[i][j] = (char) (digit + '0');

            // 递归
            if (dfs(board, rows, cols, blocks, heap)) return true;

            // 回溯：恢复掩码和单元格状态
            rows[i] |= lowbit;
            cols[j] |= lowbit;
            blocks[b] |= lowbit;
            count++;
        }

        // 将单元格放回队列
        heap.offer(new int[]{count, i, j, b});
        return false;
    }
}
```

- 时间复杂度：远小于 $O(9^m)$，实际能超越 $97\%$
- 空间复杂度： $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/sudoku-solver/solutions/3768152/yi-bu-bu-tui-dao-hui-su-jian-zhi-wei-yun-lsw2/)
