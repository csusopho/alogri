[Problem: 85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

### 暴力 & 单调栈 & DP

暴力解法会超时，可以将问题分解为两个步骤：

1. 计算每个位置向左延伸的连续 $1$ 的宽度
2. 枚举每个位置作为矩形的右下角，向上扩展计算最大矩形

前缀和的具体原理/推导，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

对于每一行，我们需要知道从当前位置向左有多少个连续的 $1$。**定义** $width[r][c]$ 表示位置 $(r, c)$ 向左延伸的连续 $1$ 的个数。

- 如果 $matrix[r][c] == '1'$：
  - 若 $c == 0$（第一列），则 $width[r][c] = 1$
  - 否则，$width[r][c] = width[r][c-1] + 1$（累加前缀）
- 如果 $matrix[r][c] = '0'$，则 $width[r][c] = 0$（重置）

对于每个位置 $(r, c)$，它可以尝试作为矩形的 **右下角**：

- 如果 $matrix[r][c] = '0'$，无法连续 $1$，跳过
- 否则，向上遍历每一行 $k$：
  - 维护当前最小宽度 $curr\_width = \min(curr\_width, width[k][c])$
  - 如果 $curr\_width == 0$，说明向上延伸时遇到 $0$，无法继续，退出循环
  - 计算当前矩形高度 $curr\_height = r - k + 1$
  - 更新最大面积 $ans = \max(ans, curr\_width \times curr\_height)$

**总结**：当我们固定右下角 $(r, c)$ 并向上扩展时，矩形的高度在增加，但宽度受到所有行的最小宽度限制。假设我们向上扩展到第 $k$ 行，那么：

- 矩形高度为 $r - k + 1$
- 矩形宽度为从第 $k$ 行到第 $r$ 行在列 $c$ 处的最小宽度

因此，枚举所有可能的右下角位置，就能找到最大矩形。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        rows = len(matrix)
        cols = len(matrix[0])
        ans = 0
        # 前缀和，记录每一行连续的 1 的数量
        width = [[0] * cols for _ in range(rows)]
        
        # 第一步：构建宽度前缀和数组
        for r in range(rows):
            for c in range(cols):
                if matrix[r][c] == '1':
                    # 如果是第一列，宽度为1；否则为前一列宽度+1
                    if c == 0:
                        width[r][c] = 1
                    else:
                        width[r][c] = width[r][c-1] + 1
                else:
                    width[r][c] = 0
        
        # 第二步：遍历每一个点作为矩形的右下角
        for r in range(rows):
            for c in range(cols):
                # 无法构成矩形右下角
                if matrix[r][c] == '0':
                    continue
                # 初始化当前最小宽度
                curr_width = width[r][c]
                
                # 向上遍历行 k，从 r 到 0
                for k in range(r, -1, -1):
                    # 获取这一列向上延伸过程中的最小宽度
                    curr_width = min(curr_width, width[k][c])
                    # 宽度变为0，说明断开了，无法继续向上扩展
                    if curr_width == 0:
                        break
                    
                    # 计算当前矩形的高度和面积
                    curr_height = r - k + 1
                    ans = max(ans, curr_width * curr_height)
               
        return ans
```

```Java
// java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int ans = 0;
        // 前缀和，记录每一行连续的 1 的数量
        int[][] width = new int[rows][cols];
        
        // 第一步：构建宽度前缀和数组
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (matrix[r][c] == '1') {
                    // 如果是第一列，宽度为1；否则为前一列宽度+1
                    if (c == 0) {
                        width[r][c] = 1;
                    } else {
                        width[r][c] = width[r][c - 1] + 1;
                    }
                } else {
                    width[r][c] = 0;
                }
            }
        }
        
        // 第二步：遍历每一个点作为矩形的右下角
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                // 无法构成矩形右下角
                if (matrix[r][c] == '0') {
                    continue;
                }
                // 初始化当前最小宽度
                int currWidth = width[r][c];
                
                // 向上遍历行 k，从 r 到 0
                for (int k = r; k >= 0; k--) {
                    // 获取这一列向上延伸过程中的最小宽度
                    currWidth = Math.min(currWidth, width[k][c]);
                    // 宽度变为0，说明断开了，无法继续向上扩展
                    if (currWidth == 0) {
                        break;
                    }
                    
                    // 计算当前矩形的高度和面积
                    int currHeight = r - k + 1;
                    ans = Math.max(ans, currWidth * currHeight);
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(m^2 \times n)$，其中 $m, n$ 分别为矩阵的行数和列数
- 空间复杂度： $O(m \times n)$，表示前缀和数组 $width$ 的大小

---

### 单调栈

如果将 $1$ 看作实物 $'-'$，而 $0$ 看作空气，那么本题就能视作

```Java
    -       -       -   -
- - -   -   - -     -   - -
  - - - -   - -       - -
```

柱状图，在里面找出最大矩形（三个 $'-'$ 表示高度为 $3$，类比其他，画的有点丑）。

**核心思路**：将二维矩阵问题转化为一系列一维柱状图最大矩形问题，参考前一题 [84](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)。

对于每一行，维护一个高度数组 $heights$，其中 $heights[j]$ 表示从当前行向上延伸，第 $j$ 列连续 $1$ 的高度。

- 如果当前元素为 $'1'$，则高度累加：$heights[j] += 1$
- 如果当前元素为 $'0'$，则高度重置：$heights[j] = 0$

这样，每一行对应的 $heights$ 数组就是一个柱状图，问题转化为在柱状图中找最大矩形。

对于柱状图问题，使用 **单调栈** 可以高效求解。

**核心思路**：对于每个柱子，找到它左右两边第一个比它矮的柱子，这两个位置之间的矩形就是以当前柱子高度为高的最大矩形。

1. 使用单调 **递增** 栈，栈中存储索引
2. 在高度数组末尾添加 $0$ 作为哨兵，确保所有元素最后都能被弹出计算
3. 栈底添加 $-1$ 作为哨兵，防止栈空
4. 遍历高度数组：
   - 当前高度 $h$ 小于栈顶高度，说明栈顶元素的右边界确定了，弹出栈顶计算面积
   - 高度为栈顶元素的高度，宽度为当前索引 $i$ 到栈中下一个元素的距离 $-1$

假设栈顶元素索引为 $top$，弹出后的新栈顶为 $stack[-1]$，当前索引为 $i$，则：

- 高度为 $heights[top]$
- 宽度为 $i - stack[-1] - 1$
- 面积为 $heights[top] \times (i - stack[-1] - 1)$

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        # 计算柱状图中的最大矩形面积（第84题）
        def calc(heights):
            # 哨兵，防止栈空
            stack = [-1]
            max_area = 0
            # 添加一个 0 在末尾，确保所有元素最后都能被弹出计算
            ex_heights = heights + [0]
            
            for i, h in enumerate(ex_heights):
                # 当前高度小于栈顶高度，说明栈顶元素的右边界确定了
                while stack[-1] != -1 and ex_heights[stack[-1]] >= h:
                    # 弹出栈顶元素并计算面积
                    height = ex_heights[stack.pop()]
                    # 宽度 = 右边界 - 左边界
                    width = i - stack[-1] - 1
                    max_area = max(max_area, height * width)
                # 当前索引入栈
                stack.append(i)
            
            return max_area
        
        rows = len(matrix)
        cols = len(matrix[0])
        # 存储每行的高度（每列向上延伸的连续1的个数）
        heights = [0] * cols
        ans = 0
        
        # 遍历每一行，将问题转化为柱状图问题
        for row in range(rows):
            for col in range(cols):
                # 如果是'1'则累加，如果是'0'则重置
                if matrix[row][col] == '1':
                    heights[col] += 1
                else:
                    heights[col] = 0
            # 计算当前行对应的柱状图的最大矩形面积
            current_area = calc(heights)
            ans = max(ans, current_area)
        
        return ans
```

```Java
// java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        // 存储每行的高度（每列向上延伸的连续1的个数）
        int[] heights = new int[cols];
        int ans = 0;
        
        // 遍历每一行，将问题转化为柱状图问题
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                // 如果是'1'则累加，如果是'0'则重置
                if (matrix[row][col] == '1') {
                    heights[col] += 1;
                } else {
                    heights[col] = 0;
                }
            }
            // 计算当前行对应的柱状图的最大矩形面积
            int currentArea = calc(heights);
            ans = Math.max(ans, currentArea);
        }
        
        return ans;
    }
    
    // 计算柱状图中的最大矩形面积（第84题）
    private int calc(int[] heights) {
        // 哨兵，防止栈空
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxArea = 0;
        
        // 添加一个 0 在末尾，确保所有元素最后都能被弹出计算
        int[] exHeights = new int[heights.length + 1];
        System.arraycopy(heights, 0, exHeights, 0, heights.length);
        exHeights[heights.length] = 0;
        
        for (int i = 0; i < exHeights.length; i++) {
            // 当前高度小于栈顶高度，说明栈顶元素的右边界确定了
            while (stack.peek() != -1 && exHeights[stack.peek()] >= exHeights[i]) {
                // 弹出栈顶元素并计算面积
                int height = exHeights[stack.pop()];
                // 宽度 = 右边界 - 左边界
                int width = i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            // 当前索引入栈
            stack.push(i);
        }
        
        return maxArea;
    }
}
```

- 时间复杂度： $O(m \times n)$，每个元素最多入栈出栈一次
- 空间复杂度： $O(n)$，用于存储高度数组和单调栈

---

### 优化 $DP$

可以这样定义矩阵中任意一点 $(i, j)$ 的状态：想求出以 $(i, j)$ 为底、高度为 $height[j]$ 的最大矩形，则需要知道这个矩形的 **高度、左边界和右边界**。

对于当前行 $i$，定义三个数组：

- $height[j]$：从第 $0$ 行到第 $i$ 行，第 $j$ 列向上延伸的连续 $1$ 的高度
- $left[j]$：在当前行，高度为 $height[j]$ 的矩形能延伸到的最左边的下标
- $right[j]$：在当前行，高度为 $height[j]$ 的矩形能延伸到的最右边的下标

对于位置 $(i, j)$ 来说，如果 $matrix[i][j] = '1'$，那么以 $(i, j)$ 为底部的矩形：

- 高度为 $height[j]$（从下往上连续 $1$ 的个数）
- 左边界为 $left[j]$（能延伸到的最左边）
- 右边界为 $right[j]$（能延伸到的最右边）
- 面积 = $height[j] \times (right[j] - left[j])$

问题的重点就在于 **状态转移**：

**更新** $height$ 数组：

- 如果 $matrix[i][j] = '1'$：$height[j] += 1$，累加
- 如果 $matrix[i][j] = '0'$：$height[j] = 0$，重置

从左向右遍历，**更新** $left$ 数组：

- 如果 $matrix[i][j] = '1'$：当前行的左边界 $cur\_left$ 是遇到 $0$ 后的下一个位置，所以 $left[j] = \max(left[j], cur\_left)$
- 如果 $matrix[i][j] = '0'$，那么重置 $left[j] = 0$，并更新当前行左边界到下一列，即 $cur\_left = j + 1$

从右向左遍历，**更新** $right$ 数组：

- 如果 $matrix[i][j] = '1'$，当前行的右边界 $cur\_right$ 是遇到 $0$ 的前一个位置，所以 $right[j] = \min(right[j], cur\_right)$
- 如果 $matrix[i][j] == '0'$，那么重置 $right[j] = cols$，并更新当前行右边界到当前列，即 $cur\_right = j$（）

**为什么这样更新？**

- $left[j]$ 取最大值：矩形的高度是累加的，左边界必须满足所有行都能延伸到，所以取最严格的限制（最大值）
- $right[j]$ 取最小值：同理，右边界也必须满足所有行都能延伸到，所以取最严格的限制（最小值）

对于每一行，遍历每一列，计算出面积：

$$
area = height[j] \times (right[j] - left[j])
$$

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        rows = len(matrix)
        cols = len(matrix[0])
        # left[j] 表示在当前行，高度为 height[j] 的矩形能延伸到的最左边的下标
        # right[j] 表示在当前行，高度为 height[j] 的矩形能延伸到的最右边的下标
        left = [0] * cols
        right = [cols] * cols
        height = [0] * cols
        ans = 0
        
        for i in range(rows):
            # 当前行的左边界和右边界
            cur_left = 0
            cur_right = cols
            
            # 更新 height 数组
            for j in range(cols):
                if matrix[i][j] == '1':
                    height[j] += 1
                else:
                    height[j] = 0
            
            # 更新 left 数组（从左向右遍历）
            for j in range(cols):
                if matrix[i][j] == '1':
                    # 左边界取历史 left 和当前行 cur_left 的最大值
                    left[j] = max(left[j], cur_left)
                else:
                    # 重置为 0，移到下一格
                    left[j] = 0 
                    cur_left = j + 1
            
            # 更新 right 数组（从右向左遍历）
            for j in range(cols - 1, -1, -1):
                if matrix[i][j] == '1':
                    # 右边界取历史 right 和当前行 cur_right 的最小值
                    right[j] = min(right[j], cur_right)
                else:
                    # 重置为 cols
                    right[j] = cols
                    cur_right = j
            
            # 计算当前行所有位置的最大面积
            for j in range(cols):
                curr_area = height[j] * (right[j] - left[j])
                ans = max(ans, curr_area)
            
        return ans
```

```Java
// java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        // left[j] 表示在当前行，高度为 height[j] 的矩形能延伸到的最左边的下标
        // right[j] 表示在当前行，高度为 height[j] 的矩形能延伸到的最右边的下标
        int[] left = new int[cols];
        int[] right = new int[cols];
        int[] height = new int[cols];
        Arrays.fill(right, cols);  // 初始化为 cols
        int ans = 0;
        
        for (int i = 0; i < rows; i++) {
            // 当前行的左边界和右边界
            int curLeft = 0;
            int curRight = cols;
            
            // 更新 height 数组
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == '1') {
                    height[j] += 1;
                } else {
                    height[j] = 0;
                }
            }
            
            // 更新 left 数组（从左向右遍历）
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == '1') {
                    // 左边界取历史 left 和当前行 curLeft 的最大值
                    left[j] = Math.max(left[j], curLeft);
                } else {
                    // 重置为 0，移到下一格
                    left[j] = 0;
                    curLeft = j + 1;
                }
            }
            
            // 更新 right 数组（从右向左遍历）
            for (int j = cols - 1; j >= 0; j--) {
                if (matrix[i][j] == '1') {
                    // 右边界取历史 right 和当前行 curRight 的最小值
                    right[j] = Math.min(right[j], curRight);
                } else {
                    // 重置为 cols
                    right[j] = cols;
                    curRight = j;
                }
            }
            
            // 计算当前行所有位置的最大面积
            for (int j = 0; j < cols; j++) {
                int currArea = height[j] * (right[j] - left[j]);
                ans = Math.max(ans, currArea);
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(m \times n)$，每行需要遍历列数组三次
- 空间复杂度： $O(n)$，表示三个长度为 $n$ 的数组

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximal-rectangle/solutions/3877666/san-jie-qian-zhui-he-bao-li-wen-ti-zhuan-6s68/)
