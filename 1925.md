[Problem: 1925. 统计平方和三元组的数目](https://leetcode.cn/problems/count-square-sum-triples/description/)

### 方法：暴力 & 预处理 & 双指针 & 打表

题意很清晰，就是找 $n$ 以内的数字，凑成勾股定理。

最直观的 **暴力** 解法：使用两个 $for$ 循环遍历 $a$ 和 $b$，计算出 $c$，然后判断 $c$ 是否符合条件。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countTriples(self, n: int) -> int:
        ans = 0
    
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                target = a * a + b * b
                # 剪枝
                if target > n * n:
                    break
                
                # 开方计算 c
                c = math.isqrt(target)
                # 判断
                if c * c == target and c <= n:
                    ans += 1
            
        return ans
```

```Java
// java
class Solution {
    public int countTriples(int n) {
        int ans = 0;

        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                int target = a * a + b * b;
                // 剪枝
                if (target > n * n) {
                    break;
                }

                // 开方计算 c
                int c = (int) Math.sqrt(target);
                // 判断
                if (c * c == target && c <= n) {
                    ans += 1;
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(1)$

---

### 哈希

我们可以使用一个容器，**提前存储** 所有的平方数。这样一来，无需平方根，直接在集合中 $O(1)$ 判断即可。

同时，由于 $(a,b,c)$ 与 $(b,a,c)$ 是不同组合，但计算的结果相同，所以只需要枚举 $a<b$ 的情况，最后答案再 $\times 2$ 就行，节省一半的枚举时间。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countTriples(self, n: int) -> int:
        # 使用集合预存 1 到 n 的平方值
        squares = {i * i for i in range(1, n + 1)}
        
        ans = 0
        # 枚举 a 和 b，限定 a < b
        for a in range(1, n):
            for b in range(a + 1, n):
                target = a * a + b * b
                
                # 说明存在 c
                if target in squares:
                    ans += 1
        
        # (a, b, c) 和 (b, a, c) 为不同解
        return ans * 2
```

```Java
// java
class Solution {
    public int countTriples(int n) {
        // 使用集合预存 1 到 n 的平方值
        Set<Integer> squares = new HashSet<>();
        for (int i = 1; i <= n; i++) {
            squares.add(i * i);
        }

        int ans = 0;
        // 枚举 a 和 b，限定 a < b
        for (int a = 1; a < n; a++) {
            for (int b = a + 1; b < n; b++) {
                int target = a * a + b * b;

                // 说明存在 c
                if (squares.contains(target)) {
                    ans += 1;
                }
            }
        }

        // (a, b, c) 和 (b, a, c) 为不同解
        return ans * 2;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$

---

### 双指针

仿照力扣的经典第一题 “两数之和”。

在那一道题中，寻找 `num[i] + num[j] = target`。在本题中，方程是 `a² + b² = c²`。如果我们 **固定 c**，那么 $c^2$ 就变成了 $target$，问题就转化为：

**在 $1$ 到 $c-1$ 这个天然有序的区间内，寻找两个数 $a$ 和 $b$，使得它们的平方和等于 $target$。**

怎么想到的？与其同时找三个数，不如先枚举 **最大** 的那个数 $c$。整数序列 $1, 2, 3, ..., c-1$ 是严格单调递增的，它们的 “平方和” 也是单调递增的，符合 **双指针** 的使用条件。

- $left$ 指针指向最小的 $1$。
- $right$ 指针指向最大的 $c-1$。
- 令 $square = left^2 + right^2$，
  - 如果 $square = target$：找到一对解！因为题目区分 $(a,b)$ 和 $(b,a)$，所以计数器 $+2$。然后 **同时** 移动指针，即 $left$ 右移 $right$ 左移，继续找下一对。
  - 如果 $square < target$：和太小了，需要变大 -> $left$ 往右移。
  - 如果 $square > target$：和太大了，需要变小 -> $right$ 往左移。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countTriples(self, n: int) -> int:
        ans = 0
        
        # 固定 c，将其作为 target
        for c in range(1, n + 1):
            target = c * c
            # 双指针初始化
            left = 1
            right = c - 1

            while left < right:
                # 当前平方和
                square = left * left + right * right
                
                if square == target:
                    # 找到
                    ans += 2
                    # 继续寻找
                    left += 1
                    right -= 1
                elif square < target:
                    # 和太小，让小的数变大
                    left += 1
                else:
                    # 和太大，让大的数变小
                    right -= 1
               
        return ans
```

```Java
// java
class Solution {
    public int countTriples(int n) {
        int ans = 0;

        // 固定 c，将其作为 target
        for (int c = 1; c <= n; c++) {
            int target = c * c;
            // 双指针初始化
            int left = 1;
            int right = c - 1;

            while (left < right) {
                // 当前平方和
                int square = left * left + right * right;

                if (square == target) {
                    // 找到
                    ans += 2;
                    // 继续寻找
                    left += 1;
                    right -= 1;
                } else if (square < target) {
                    // 和太小，让小的数变大
                    left += 1;
                } else {
                    // 和太大，让大的数变小
                    right -= 1;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(1)$

---

### 打表

有两种打表解法，

1. 存储不同 $n$ 下面的答案总数
2. 根据勾股定理，存储所有正整数 $c$，如果 $n$ 能被 $c$ 整除，说明这个 $c$ 符合。举个例子，从小到大的 $c$ 包含 $5,10,15\dots$

使用最容易理解的第一种，代码如下：

```Python
# python
class Solution:
    RESULT = [
        0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 4, 4, 6, 6, 8, 8, 10, 10, 10,
        12, 12, 12, 12, 12, 16, 18, 18, 18, 20, 22, 22, 22, 22, 24, 26, 26, 28, 28, 30,
        32, 34, 34, 34, 34, 36, 36, 36, 36, 36, 40, 42, 44, 46, 46, 48, 48, 48, 50, 50,
        52, 54, 54, 54, 54, 62, 62, 62, 64, 64, 66, 66, 66, 68, 70, 74, 74, 74, 76, 76,
        78, 78, 80, 80, 80, 88, 88, 90, 90, 92, 94, 96, 96, 96, 96, 98, 98, 100, 100, 100,
        104, 106, 108, 108, 110, 112, 114, 114, 114, 116, 118, 120, 120, 122, 122, 124, 126, 128, 128, 130,
        132, 132, 134, 136, 136, 142, 142, 142, 142, 142, 150, 150, 150, 150, 150, 152, 154, 156, 156, 156,
        158, 158, 158, 160, 160, 168, 170, 170, 172, 174, 178, 178, 178, 180, 180, 182, 184, 186, 186, 188,
        190, 190, 190, 190, 192, 194, 194, 194, 194, 198, 206, 206, 206, 208, 210, 214, 214, 214, 216, 216,
        218, 220, 222, 224, 224, 232, 232, 234, 234, 234, 236, 236, 236, 238, 240, 248, 248, 250, 250, 250,
        254, 254, 256, 258, 260, 268, 268, 268, 270, 270, 272, 272, 274, 274, 274, 276, 276, 276, 278, 280,
        282, 290, 292, 292, 292, 296, 298, 298, 298, 300, 302, 302, 304, 306, 308, 310, 310, 310, 312, 312,
        314, 316, 316, 316, 318, 320, 322, 324, 324, 324, 330
    ]

    def countTriples(self, n: int) -> int:
        return self.RESULT[n]
```

```Java
// java
class Solution {
    private static final int[] RESULT = {
        0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 4, 4, 6, 6, 8, 8, 10, 10, 10,
        12, 12, 12, 12, 12, 16, 18, 18, 18, 20, 22, 22, 22, 22, 24, 26, 26, 28, 28, 30,
        32, 34, 34, 34, 34, 36, 36, 36, 36, 36, 40, 42, 44, 46, 46, 48, 48, 48, 50, 50,
        52, 54, 54, 54, 54, 62, 62, 62, 64, 64, 66, 66, 66, 68, 70, 74, 74, 74, 76, 76,
        78, 78, 80, 80, 80, 88, 88, 90, 90, 92, 94, 96, 96, 96, 96, 98, 98, 100, 100, 100,
        104, 106, 108, 108, 110, 112, 114, 114, 114, 116, 118, 120, 120, 122, 122, 124, 126, 128, 128, 130,
        132, 132, 134, 136, 136, 142, 142, 142, 142, 142, 150, 150, 150, 150, 150, 152, 154, 156, 156, 156,
        158, 158, 158, 160, 160, 168, 170, 170, 172, 174, 178, 178, 178, 180, 180, 182, 184, 186, 186, 188,
        190, 190, 190, 190, 192, 194, 194, 194, 194, 198, 206, 206, 206, 208, 210, 214, 214, 214, 216, 216,
        218, 220, 222, 224, 224, 232, 232, 234, 234, 234, 236, 236, 236, 238, 240, 248, 248, 250, 250, 250,
        254, 254, 256, 258, 260, 268, 268, 268, 270, 270, 272, 272, 274, 274, 274, 276, 276, 276, 278, 280,
        282, 290, 292, 292, 292, 296, 298, 298, 298, 300, 302, 302, 304, 306, 308, 310, 310, 310, 312, 312,
        314, 316, 316, 316, 318, 320, 322, 324, 324, 324, 330
    };

    public int countTriples(int n) {
        return RESULT[n];
    }
}
```

- 时间复杂度： $O(1)$，时间与空间被所有样例均摊
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-square-sum-triples/solutions/3851616/si-jie-bao-li-ha-xi-yu-chu-li-shuang-zhi-w3yu/)
