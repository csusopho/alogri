[Problem: 679. 24 点游戏](https://leetcode.cn/problems/24-game/description/)

### 方法：回溯 & 递推

根据示例可知，这些数字 **没有顺序** 要求，可以随意组合。**本质**：从 $4$ 张牌中任选两张进行某一种运算，放回牌堆，重复该过程直至剩余一张。

假设牌堆中剩余 $n$ 张，每次抽牌时，都是从 $n$ 张纸牌中选择两个。每次的操作相同，父问题能拆解为子问题，所以联想到 **递归**。

**定义** $dfs(nums)$ 表示从牌堆 $nums$ 中抽取并放回，最终能否凑成 $24$ 点。

递归入口： $dfs(cards)$，表示初始拥有 $cards$ 里面的牌。

**递归边界**：如果 $len(nums)=1$，则说明抽到只剩一张，判断它与 $24$ 的关系。

**转移过程**：假设一共有 $[a,b,c]$ 三张牌，抽出 $a,b$ 后，四种运算得出不同结果，每种新结果与之前剩余的牌组合，形成新的 $[x,c]$ 牌堆，判断是否有一种可行：

$$
dfs(nums) = \bigcup_{k=1}^{6} dfs(newNums_k)
$$

一共 $+-*/$ 四种运算，只要分母不为 $0$，就能得出 $6$ 种计算结果。

如何使用 $[3,3,8,8]$ 凑出 $24$ 点？正确方案是 `8 / (3 - 8 / 3)`。直接计算会出现小数，我们需要注意 **精度** 问题！根据测试，误差控制在 $10^{-4}$ 以内即可。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        def dfs(nums):
            # 递归终止条件
            if len(nums) == 1:
                return abs(nums[0] - 24) < 1e-4
            
            # 从数组中选择两个数
            n = len(nums)
            for i in range(n):
                for j in range(i+1, n):
                    # 剩余的数字
                    rest = [nums[k] for k in range(n) if k != i and k != j]
                    
                    # 所有可能的运算结果
                    a, b = nums[i], nums[j]
                    candidates = [a + b, a - b, b - a, a * b]
                    if b != 0: 
                        candidates.append(a / b)
                    if a != 0: 
                        candidates.append(b / a)
                    
                    # 递归
                    for c in candidates:
                        if dfs(rest + [c]):
                            return True
            return False

        # 变为浮点数，开始递归
        return dfs([float(x) for x in cards])
```

注意，直接转化为 $java$ 会报错 `java.lang.StackOverflowError`。因为这段代码会生成大量临时数组，所以优化写法放在下面。

假设牌数为 $n$，每次从中抽选 $2$ 张，是组合数学；数学结果有 $6$ 种，递归层数依次减小，则总复杂度接近：

$$
T(n) \le \prod_{k=2}^{n} \Big( 6 \cdot \binom{k}{2} \Big) = \prod_{k=2}^{n} 3 \, k \, (k-1)
$$

- 时间复杂度： $O((n!)^2\times 3^n)$，其中 $n=4$
- 空间复杂度： $O(n^2)$，递归栈深度为 $O(n)$，每层临时数组空间为 $O(n)$

---

### 原地

取消上面 $nums$ 这个参数的设定，在 $nums$ 上原地修改。

具体来说，假设计算的两个数字是 $nums[i],nums[j]$，剩余两个数字没有参与。则将新的计算结果放在 $nums[i]$ 位置，总长度会变为 $n-1$，所以将最后的有效元素 $nums[n-1]$ 放在 $nums[j]$ 位置，防止它被丢失。

注意，我们是原地修改，无论这一次选择 $(i,j)$ 或者 $(i,k)$，两者都不能互相影响，所以使用 **回溯**。将计算的两个数字暂存，之后进行恢复。具体原理，可以看这篇 [题解](https://leetcode.cn/problems/n-queens/solutions/3006469/hui-su-po-su-jie-fa-yi-wei-you-hua-dfstu-gdhu/)。

其他细节与上述递归相同，代码如下：

```Python
# python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        nums = [float(x) for x in cards]

        def dfs(n):
            if n == 1:
                return abs(nums[0] - 24) < 1e-4

            for i in range(n):
                for j in range(i + 1, n):
                    a, b = nums[i], nums[j]

                    # 把最后一个有效元素移到 j 的位置
                    nums[j] = nums[n - 1]

                    # 收集候选结果
                    candidates = [a + b, a - b, b - a, a * b]
                    if b != 0:
                        candidates.append(a / b)
                    if a != 0:
                        candidates.append(b / a)

                    # 尝试所有结果
                    for val in candidates:
                        # nums[i] 存放新计算的结果 val
                        nums[i] = val
                        if dfs(n - 1):
                            return True

                    # 回溯，取消这次计算
                    nums[i], nums[j] = a, b
            return False

        return dfs(4)
```

```Java
// java
public class Solution {
    public boolean judgePoint24(int[] cards) {
        // 将整数数组转为浮点数数组
        double[] nums = new double[cards.length];
        for (int i = 0; i < cards.length; i++) {
            nums[i] = (double) cards[i];
        }
        return dfs(nums, 4);
    }

    private boolean dfs(double[] nums, int n) {
        // 递归终止条件
        if (n == 1) {
            return Math.abs(nums[0] - 24) < 1e-4;
        }

        // 从数组中选择两个数
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                double a = nums[i], b = nums[j];

                // 把最后一个有效元素移到 j 的位置
                nums[j] = nums[n - 1];

                // 收集候选结果
                List<Double> candidates = new ArrayList<>();
                candidates.add(a + b);
                candidates.add(a - b);
                candidates.add(b - a);
                candidates.add(a * b);
                if (b != 0) candidates.add(a / b);
                if (a != 0) candidates.add(b / a);

                // 尝试所有结果
                for (double val : candidates) {
                    nums[i] = val;
                    if (dfs(nums, n - 1)) {
                        return true;
                    }
                }

                // 回溯，取消这次计算
                nums[i] = a;
                nums[j] = b;
            }
        }
        return false;
    }
}
```

- 时间复杂度： $O(1)$，当 $n=4$ 时递归总次数不超过 $3888$
- 空间复杂度： $O(1)$，递归栈深度为 $O(n)$

---

### 递推

将递归改为递推，使用 **队列** 的形式存储每种组合方案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        EPS = 1e-4

        def compute(a, b):
            res = [a + b, a - b, b - a, a * b]
            if b != 0: res.append(a / b)
            if a != 0: res.append(b / a)
            return res

        nums = [float(x) for x in cards]
        queue = deque()
        queue.append(nums)  # 初始状态

        while queue:
            curr = queue.popleft()
            if len(curr) == 1:
                if abs(curr[0] - 24) < EPS:
                    return True
                continue

            n = len(curr)
            # 选择任意两个数字组合
            for i in range(n):
                for j in range(i + 1, n):
                    a, b = curr[i], curr[j]
                    rest = [curr[k] for k in range(n) if k != i and k != j]
                    for val in compute(a, b):
                        queue.append(rest + [val])

        return False
```

```Java
// java
public class Solution {
    private static final double EPS = 1e-4;

    // 计算 a 和 b 的所有可能结果
    private List<Double> compute(double a, double b) {
        List<Double> res = new ArrayList<>();
        res.add(a + b);
        res.add(a - b);
        res.add(b - a);
        res.add(a * b);
        if (b != 0) res.add(a / b);
        if (a != 0) res.add(b / a);
        return res;
    }

    public boolean judgePoint24(int[] cards) {
        // 初始状态，将整数数组转为浮点数列表
        List<Double> nums = new ArrayList<>();
        for (int x : cards) {
            nums.add((double) x);
        }

        Queue<List<Double>> queue = new LinkedList<>();
        queue.offer(nums); // 初始状态入队

        while (!queue.isEmpty()) {
            List<Double> curr = queue.poll();
            int n = curr.size();

            // 递归终止条件：数组只剩一个元素
            if (n == 1) {
                if (Math.abs(curr.get(0) - 24) < EPS) {
                    return true;
                }
                continue;
            }

            // 选择任意两个数字组合
            for (int i = 0; i < n; i++) {
                for (int j = i + 1; j < n; j++) {
                    double a = curr.get(i), b = curr.get(j);

                    // 收集剩余数字
                    List<Double> rest = new ArrayList<>();
                    for (int k = 0; k < n; k++) {
                        if (k != i && k != j) {
                            rest.add(curr.get(k));
                        }
                    }

                    // 尝试所有运算结果，并入队
                    for (double val : compute(a, b)) {
                        List<Double> next = new ArrayList<>(rest);
                        next.add(val);
                        queue.offer(next);
                    }
                }
            }
        }

        return false;
    }
}
```

可以直接枚举所有组合的方式。假设总共 $[a,b,c,d]$ 四张牌，枚举前两张组合，然后让计算结果与剩余两张牌组合，分别组成不同方案。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        EPS = 1e-4

        def compute(a, b):
            res = [a + b, a - b, b - a, a * b]
            if b != 0: res.append(a / b)
            if a != 0: res.append(b / a)
            return res

        # 遍历所有两张卡牌组合
        for i in range(3):
            for j in range(i + 1, 4):
                # 剩下的两张卡牌
                rest = [cards[k] for k in range(4) if k != i and k != j]

                # i,j 两张牌的所有运算结果
                first = compute(cards[i], cards[j])
                # 剩余两张牌所有可能的运算结果
                second = compute(rest[0], rest[1])

                # 遍历两组结果的笛卡尔积，检查是否能得到 24
                for x, y in product(first, second):
                    for val in compute(x, y):
                        if abs(val - 24) < EPS:
                            return True

                # 尝试不同的运算顺序
                for p in first:
                    # 先和剩余第一张牌运算，再和第二张牌
                    for q in compute(p, rest[0]):
                        for ans in compute(q, rest[1]):
                            if abs(ans - 24) < EPS:
                                return True

                    # 先和剩余第二张牌运算，再和第一张牌
                    if rest[0] != rest[1]:
                        for q in compute(p, rest[1]):
                            for ans in compute(q, rest[0]):
                                if abs(ans - 24) < EPS:
                                    return True

        return False
```

```Java
// java
public class Solution {
    private static final double EPS = 1e-4;

    // 计算 a 和 b 的所有可能结果
    private List<Double> compute(double a, double b) {
        List<Double> res = new ArrayList<>();
        res.add(a + b);
        res.add(a - b);
        res.add(b - a);
        res.add(a * b);
        if (b != 0) res.add(a / b);
        if (a != 0) res.add(b / a);
        return res;
    }

    public boolean judgePoint24(int[] cards) {
        // 遍历所有两张卡牌组合
        for (int i = 0; i < 3; i++) {
            for (int j = i + 1; j < 4; j++) {
                // 剩下的两张卡牌
                List<Double> rest = new ArrayList<>();
                for (int k = 0; k < 4; k++) {
                    if (k != i && k != j) {
                        rest.add((double) cards[k]);
                    }
                }

                // i,j 两张牌的所有运算结果
                List<Double> first = compute(cards[i], cards[j]);
                // 剩余两张牌的所有运算结果
                List<Double> second = compute(rest.get(0), rest.get(1));

                // 遍历两组结果的笛卡尔积，检查是否能得到 24
                for (double x : first) {
                    for (double y : second) {
                        for (double val : compute(x, y)) {
                            if (Math.abs(val - 24) < EPS) {
                                return true;
                            }
                        }
                    }
                }

                // 尝试不同的运算顺序
                for (double p : first) {
                    // 先和剩余第一张牌运算，再和第二张牌
                    for (double q : compute(p, rest.get(0))) {
                        for (double ans : compute(q, rest.get(1))) {
                            if (Math.abs(ans - 24) < EPS) {
                                return true;
                            }
                        }
                    }

                    // 先和剩余第二张牌运算，再和第一张牌
                    if (!rest.get(0).equals(rest.get(1))) {
                        for (double q : compute(p, rest.get(1))) {
                            for (double ans : compute(q, rest.get(0))) {
                                if (Math.abs(ans - 24) < EPS) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
}
```

- 时间复杂度： $O(1)$，同理
- 空间复杂度： $O(1)$，仅使用常数个额外变量

不想考虑精度问题的话，那就需要计算分数的加减，太过麻烦，不推荐；速度最快的代码是打表，不算正统解法，这里不展示。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/24-game/solutions/3756239/si-jie-di-gui-yuan-di-hui-su-bfs-di-tui-rdkwr/)
