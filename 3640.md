[Problem: 3640. 三段式数组 II](https://leetcode.cn/problems/trionic-array-ii/description/)

### 预处理 & 状态机DP

题意很清晰，就是找 "N" 字形子数组的最大和。

如果我们暴力枚举 $l, p, q, r$ 的时间复杂度是 $O(n^4)$，哪怕优化后枚举 $p, q$ 也是 $O(n^2)$。题目指定 $n\leq 10^5$，所以枚举会超时，需要优化。

仔细想想，上升下降的关键在于转折点 —— 山峰/山谷。如何判断当前索引 $i$ 是山峰？左侧 $nums[i-1]$ 小于 $nums[i]$，且 $nums[i]$ 大于右侧 $nums[i+1]$。

如何得知左侧递增段的和？向左遍历当然可行，不过更妙的方法是 **预处理**。

定义 $leftInc[i]$ 表示以索引 $i$ **结尾** 的最长严格递增子数组的和（下面会重新定义）。

- 如果 $nums[i] > nums[i-1]$，则 $leftInc[i] = leftInc[i-1] + nums[i]$。
- 否则，递增中断，重置 $leftInc[i] = nums[i]$。

同理，定义 $rightInc[i]$ 表示以索引 $i$ **开始** 的最长严格递增子数组的和。

- 如果 $nums[i] < nums[i+1]$，则 $rightInc[i] = rightInc[i+1] + nums[i]$。
- 否则，重置 $rightInc[i] = nums[i]$。

那中间的下降段怎么办？如何合并三段？

先来看看子数组 $nums[l\dots r]$ 的总和为：

$$
\text{Sum}(l...p) + \text{Sum}(p...q) + \text{Sum}(q...r) - nums[p] - nums[q]
$$

利用上面得出的预处理数组，这等价于：

$$
leftInc[p] + \text{Sum}(p...q) + rightInc[q] - nums[p] - nums[q]
$$

如何计算子数组 $nums[p\dots q]$ 的累加和？想到 **前缀和**，具体原理可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

定义 $prefix[i]$ 表示子数组 $[0\dots i-1]$ 的累加和，则上式可以继续转化为：

$$
leftInc[p] + (prefix[q+1] - prefix[p]) + rightInc[q] - nums[p] - nums[q]
$$

整理公式，将其拆分为只与 $p$ 相关和只与 $q$ 相关的部分：

$$
(leftInc[p] - nums[p] - prefix[p]) + (rightInc[q] - nums[q] + prefix[q+1])
$$

将前半部分记作 $Val(p)$，后半部分记作 $Val(q)$。

也就是说，我们需要在满足 $nums[p...q]$ 严格递减的条件下，最大化 $Val(p) + Val(q)$。那么，遍历数组寻找 **连续的下降段**。对于每一个下降段：

1. 记录在这个下降段之前的上升段的 $Val(p)$。
2. 当我们遍历到某个点 $i$ 时，将其视为 $q$。如果 $nums[i] < nums[i+1]$，说明 $i$ 是一个合法的谷底，则尝试用 $Val(p)$ 加上当前的 $Val(q)$ 来更新全局最大值。
3. 如果 $nums[i]\geq nums[i-1]$，则下降关系中断，则重置 $Val(p)$，因为 $p$ 和 $q$ 必须通过连续的下降路径连接。

上面这套逻辑没问题，但是会卡在用例 $486$，即 $[2,993,-791,-635,-569]$。不能 **简单地** 计算以 $p/q$ 开始的最长上升子数组的和，这里 $-635<-569$ 也是递增，但是累加的总和会变小！

上面的 $leftInc$ 以及 $rightInc$ 需要修改定义，不再是最长xxx，而是xxx的最大和。然后，利用已经计算出的 $prefix$ 结合 $max$ 运算辅助计算出最大和。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        
        # 前缀和 prefix[i] 表示 nums[0...i-1] 的和
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        # 以 i 结尾的严格递增子数组的最大和
        left_inc = [float('-inf')] * n
        # 维护当前上升段中遇到的最小前缀和
        start = 0
        min_prev_p = prefix[0] 
        
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                # 当前在上升段中
                # 这是新的一段上升刚开始
                if i == 1 or nums[i-1] <= nums[i-2]:
                    min_prev_p = prefix[i-1]
                else:
                    min_prev_p = min(min_prev_p, prefix[i-1])
                # 累加
                left_inc[i] = prefix[i+1] - min_prev_p
            else:
                # 上升中断
                pass

        # 以 i 开始的严格递增子数组的最大和
        right_inc = [float('-inf')] * n
        # 维护当前上升段中遇到的最大前缀和
        max_next_q = float('-inf')
        
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i+1]:
                # 连贯的上升段
                # 新的一段
                if i == n - 2 or nums[i+1] >= nums[i+2]:
                    max_next_q = prefix[i+2]
                else:
                    max_next_q = max(max_next_q, prefix[i+2])
                # 累加
                right_inc[i] = max_next_q - prefix[i]
            else:
                pass
        
        ans = float('-inf')
        val_p = float('-inf')
        
        # 遍历寻找中间的下降段
        for i in range(1, n - 1):
            # 处于下降段中
            if nums[i-1] > nums[i]:
                # 检查 i-1 是否可以作为合法的峰值 p
                if i >= 2 and nums[i-1] > nums[i-2]:
                    # 计算该点作为 p 的贡献值
                    val_p = left_inc[i-1] - nums[i-1] - prefix[i-1]
                
                # 检查 i 是否可以作为合法的谷底 q
                if nums[i] < nums[i+1]:
                    if val_p != float('-inf'):
                        # 计算该点作为 q 的贡献值
                        val_q = right_inc[i] - nums[i] + prefix[i+1]
                        # 两段结合
                        ans = max(ans, val_p + val_q)
            else:
                # 下降段中断
                val_p = float('-inf')
        
        return ans if ans != float('-inf') else 0
```

```Java
// java
class Solution {
    public long maxSumTrionic(int[] nums) {
        int n = nums.length;
        
        // 前缀和 prefix[i] 表示 nums[0...i-1] 的和
        long[] prefix = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i+1] = prefix[i] + nums[i];
        }
        
        // 以 i 结尾的严格递增子数组的最大和
        long[] left_inc = new long[n];
        Arrays.fill(left_inc, Long.MIN_VALUE);
        // 维护当前上升段中遇到的最小前缀和
        long min_prev_p = prefix[0]; 
        
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) {
                // 当前在上升段中
                // 这是新的一段上升刚开始
                if (i == 1 || nums[i-1] <= nums[i-2]) {
                    min_prev_p = prefix[i-1];
                } else {
                    min_prev_p = Math.min(min_prev_p, prefix[i-1]);
                }
                // 累加
                left_inc[i] = prefix[i+1] - min_prev_p;
            } else {
                // 上升中断
                // pass
            }
        }

        // 以 i 开始的严格递增子数组的最大和
        long[] right_inc = new long[n];
        Arrays.fill(right_inc, Long.MIN_VALUE);
        // 维护当前上升段中遇到的最大前缀和
        long max_next_q = Long.MIN_VALUE;
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) {
                // 连贯的上升段
                // 新的一段
                if (i == n - 2 || nums[i+1] >= nums[i+2]) {
                    max_next_q = prefix[i+2];
                } else {
                    max_next_q = Math.max(max_next_q, prefix[i+2]);
                }
                // 累加
                right_inc[i] = max_next_q - prefix[i];
            } else {
                // pass
            }
        }
        
        long ans = Long.MIN_VALUE;
        long val_p = Long.MIN_VALUE;
        
        // 遍历寻找中间的下降段
        for (int i = 1; i < n - 1; i++) {
            // 处于下降段中
            if (nums[i-1] > nums[i]) {
                // 检查 i-1 是否可以作为合法的峰值 p
                if (i >= 2 && nums[i-1] > nums[i-2]) {
                    // 确保 left_inc[i-1] 有效
                    if (left_inc[i-1] != Long.MIN_VALUE) {
                        // 计算该点作为 p 的贡献值
                        val_p = left_inc[i-1] - nums[i-1] - prefix[i-1];
                    }
                }
                
                // 检查 i 是否可以作为合法的谷底 q
                if (nums[i] < nums[i+1]) {
                    if (val_p != Long.MIN_VALUE && right_inc[i] != Long.MIN_VALUE) {
                        // 计算该点作为 q 的贡献值
                        long val_q = right_inc[i] - nums[i] + prefix[i+1];
                        // 两段结合
                        ans = Math.max(ans, val_p + val_q);
                    }
                }
            } else {
                // 下降段中断
                val_p = Long.MIN_VALUE;
            }
        }
        
        return ans == Long.MIN_VALUE ? 0 : ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，线性遍历
- 空间复杂度： $O(n)$，表示前缀和 $prefix$ 以及两个递增数组的大小

---

### 状态机DP

实际上，这个流程就是状态机的转化过程，定义 $dp[i][k]$ 表示以索引 $i$ 结尾，且当前处于第 $k$ 个阶段的最大子数组和。

- $k=0$，左侧上升段: 子数组形状为 `/`，要求 $nums[i] > nums[i-1]$
- $k=1$，中间下降段: 子数组形状为 `/ \`，要求 $nums[i] < nums[i-1]$
- $k=2$，右侧上升段: 子数组形状为 `/ \ /`，要求 $nums[i] > nums[i-1]$

状态转移：比较 $nums[i]$ 和 $nums[i-1]$ 的关系，分为三种情况。

**情况 A**：如果 $nums[i] > nums[i-1]$，处于上升趋势。在这种情况下，只能更新阶段 $0$ 和阶段 $2$。

第一段上升，更新 $dp[i][0]$：

- 要么延续，接在 $dp[i-1][0]$ 后面。
- 要么新开，之前不连贯，从 $i-1$ 开始新的一段上升。
- 所以有 $dp[i][0] = max(dp[i-1][0], nums[i-1]) + nums[i]$。

第三段上升，更新 $dp[i][2]$：

- 要么延续，接在 $dp[i-1][2]$ 后面。
- 要么转折，接在 $dp[i-1][1]$ 后面。
- 所以有 $dp[i][2] = max(dp[i-1][2], dp[i-1][1]) + nums[i]$。

阶段 $1$ 是下降，与情况 $A$ 冲突，无法在上升趋势中存在，重置为 $-\infty$。

**情况 B**：如果 $nums[i] < nums[i-1]$，处于下降趋势。在这种情况下，只能更新阶段 $1$。

第二段下降，更新 $dp[i][1]$：

- 要么延续，接在 $dp[i-1][1]$ 后面。
- 要么转折，接在 $dp[i-1][0]$ 后面。
- 所以有 $dp[i][1] = max(dp[i-1][1], dp[i-1][0]) + nums[i]$。

同理，阶段 $0$ 和 $2$ 是上升，与情况 $B$ 冲突，无法在下降趋势中存在，重置为 $-\infty$。

**情况 C**：如果 $nums[i] = nums[i-1]$，那么所有连续性中断，所有状态重置为 $-\infty$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        ans = float('-inf')

        #  dp[i][k] 表示以索引 i 结尾，且当前处于第 k 个阶段的最大子数组和
        dp = [[float('-inf')] * 3 for _ in range(n)]
        
        for i in range(1, n):
            cur = nums[i]
            prev = nums[i-1]

            # 上升趋势
            if cur > prev:
                # 计算阶段 0
                # 要么延续之前的上升段，要么从 prev 开始新的一段
                dp[i][0] = max(dp[i-1][0], prev) + cur
                
                # 计算阶段 2
                # 要么延续之前的阶段2，要么从阶段1转折过来
                dp[i][2] = max(dp[i-1][2], dp[i-1][1]) + cur
            
            # 下降趋势
            elif cur < prev:
                # 计算阶段 1
                # 要么延续之前的下降段，要么从阶段0转折过来
                dp[i][1] = max(dp[i-1][1], dp[i-1][0]) + cur
                
            # 尝试用当前的阶段 3 更新全局答案
            if dp[i][2] > ans:
                ans = dp[i][2]
        
        return ans if ans != float('-inf') else 0
```

```Java
// java
class Solution {
    public long maxSumTrionic(int[] nums) {
        int n = nums.length;
        long ans = Long.MIN_VALUE;

        // dp[i][k] 表示以索引 i 结尾，且当前处于第 k 个阶段的最大子数组和
        long[][] dp = new long[n][3];
        for (long[] row : dp) {
            Arrays.fill(row, Long.MIN_VALUE);
        }
        
        for (int i = 1; i < n; i++) {
            long cur = nums[i];
            long prev = nums[i-1];

            // 上升趋势
            if (cur > prev) {
                // 计算阶段 0
                // 要么延续之前的上升段，要么从 prev 开始新的一段
                dp[i][0] = Math.max(dp[i-1][0], prev) + cur;
                
                // 计算阶段 2
                // 要么延续之前的阶段2，要么从阶段1转折过来
                long maxPrevStage = Math.max(dp[i-1][2], dp[i-1][1]);
                if (maxPrevStage != Long.MIN_VALUE) {
                    dp[i][2] = maxPrevStage + cur;
                }
            }
            
            // 下降趋势
            else if (cur < prev) {
                // 计算阶段 1
                // 要么延续之前的下降段，要么从阶段0转折过来
                long maxPrevStage = Math.max(dp[i-1][1], dp[i-1][0]);
                if (maxPrevStage != Long.MIN_VALUE) {
                    dp[i][1] = maxPrevStage + cur;
                }
            }
            
            // 尝试用当前的阶段 3 更新全局答案
            if (dp[i][2] > ans) {
                ans = dp[i][2];
            }
        }
        
        return ans == Long.MIN_VALUE ? 0 : ans;
    }
}
```

- 时间复杂度： $O(n)$，同理
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/trionic-array-ii/solutions/3895880/shuang-jie-yu-chu-li-qian-zhui-he-fen-du-6mbs/)
