[Problem: 3606. 优惠券校验器](https://leetcode.cn/problems/coupon-code-validator/description/)

### 方法：模拟 & 正则

阅读理解题，从上往下仔细读一遍就行。

一个优惠券想满足要求，必须 “标识符” 不为空且满足字符组成，“业务类别” 是四种之一，仍然有效。三个条件缺一不可。

直接 **模拟**，从前往后遍历，将满足的 `(业务类别, 标识符)` 都存入列表，然后对列表排序即可。因为四个业务类别是 $e,g,p,r$ 开头，也符合字典序，所以按照默认排序可行。

代码如下，已附加注释：

```Python
# python
class Solution:
    def validateCoupons(self, code: List[str], businessLine: List[str], isActive: List[bool]) -> List[str]:
        # 检查标识符
        def is_valid_code(s):
            for char in s:
                if not (char.isalnum() or char == '_'):
                    return False
            return True
        
        n = len(code)
        valid_coupons = []
        
        for i in range(n):
            # 跳过空标识符
            if not code[i]:
                continue
            
            # 检查标识符，是否有效，业务类别
            if (is_valid_code(code[i]) and 
                isActive[i] and 
                businessLine[i] in {"electronics", "grocery", "pharmacy", "restaurant"}):
                valid_coupons.append((businessLine[i], code[i]))
        
        # 先按业务类别，再按标识符
        valid_coupons.sort()
        # 提取标识符
        res = [coupon[1] for coupon in valid_coupons]
        return res
```

```Java
// java
class Solution {
    public List<String> validateCoupons(String[] code, String[] businessLine, boolean[] isActive) {
        int n = code.length;
        // 存储 [业务类别, 标识符]
        List<String[]> validCoupons = new ArrayList<>();
        Set<String> validBusinesses = new HashSet<>(Arrays.asList("electronics", "grocery", "pharmacy", "restaurant"));
        
        for (int i = 0; i < n; i++) {
            // 跳过空标识符
            if (code[i] == null || code[i].length() == 0) {
                continue;
            }
            
            // 检查标识符
            boolean isCodeValid = true;
            for (char c : code[i].toCharArray()) {
                if (!(Character.isLetterOrDigit(c) || c == '_')) {
                    isCodeValid = false;
                    break;
                }
            }
            
            // 检查标识符，是否有效，业务类别
            if (isCodeValid && 
                isActive[i] && 
                validBusinesses.contains(businessLine[i])) {
                validCoupons.add(new String[]{businessLine[i], code[i]});
            }
        }
        
        // 先按业务类别，再按标识符
        validCoupons.sort((a, b) -> {
            int cmp = a[0].compareTo(b[0]);
            return cmp != 0 ? cmp : a[1].compareTo(b[1]);
        });
        
        // 提取标识符
        List<String> res = new ArrayList<>();
        for (String[] pair : validCoupons) {
            res.add(pair[1]);
        }
        return res;
    }
}
```

- 时间复杂度： $O(nLlogn)$，其中 $n$ 是数组 $code$ 的长度，而 $L$ 是字符串平均长度，快排
- 空间复杂度： $O(n)$，表示列表 $validCoupons$ 的大小，返回值 $res$ 一般不计入复杂度

---

### 简化

我们可以将四个 “业务类别” 分别定义优先级为 $0,1,2,3$。如此一来，对数字排序，比对字符串排序的速度要快很多。（真实业务不作为返回值）

同时，定义正则化表达式，字母+数字+下划线，用 `[a-zA-Z0-9_]+` 或者 `^\w+` 都可以。

代码如下，已附加注释：

```Python
# python
import re

class Solution:
    def validateCoupons(self, code: List[str], businessLine: List[str], isActive: List[bool]) -> List[str]:
        # 定义业务类别优先级
        priority_map = {
            "electronics": 0,
            "grocery": 1,
            "pharmacy": 2,
            "restaurant": 3
        }
        
        # 预编译正则
        pattern = re.compile(r"^\w+$")
        # 存储 (优先级, 标识符)
        valid_coupons = []
        
        # 同时遍历
        for cd, business, active in zip(code, businessLine, isActive):
            # 有效，业务类别是四种之一，标识符符合正则
            if active and business in priority_map and pattern.match(cd):
                priority = priority_map[business]
                valid_coupons.append((priority, cd))
        
        valid_coupons.sort()
        return [cd for _, cd in valid_coupons]
```

```Java
// java
import java.util.regex.*;

class Solution {
    public List<String> validateCoupons(String[] code, String[] businessLine, boolean[] isActive) {
        // 定义业务类别优先级
        Map<String, Integer> priorityMap = new HashMap<>();
        priorityMap.put("electronics", 0);
        priorityMap.put("grocery", 1);
        priorityMap.put("pharmacy", 2);
        priorityMap.put("restaurant", 3);
        
        // 预编译正则
        Pattern pattern = Pattern.compile("^\\w+$");
        // 存储 (优先级, 标识符)，利用 Object[] 存放混合类型
        List<Object[]> validCoupons = new ArrayList<>();
        
        // 同时遍历
        for (int i = 0; i < code.length; i++) {
            String cd = code[i];
            String business = businessLine[i];
            boolean active = isActive[i];
            
            // 有效，业务类别是四种之一，标识符符合正则
            if (active && priorityMap.containsKey(business) && pattern.matcher(cd).matches()) {
                int priority = priorityMap.get(business);
                validCoupons.add(new Object[]{priority, cd});
            }
        }
        
        validCoupons.sort((a, b) -> {
            // 先比优先级 (索引0是Integer)
            int p1 = (Integer) a[0];
            int p2 = (Integer) b[0];
            if (p1 != p2) return p1 - p2;
            // 再比标识符 (索引1是String)
            return ((String) a[1]).compareTo((String) b[1]);
        });
        
        List<String> res = new ArrayList<>();
        for (Object[] item : validCoupons) {
            res.add((String) item[1]);
        }
        return res;
    }
}
```

- 时间复杂度： $O(nLlogn)$，同理
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/coupon-code-validator/solutions/3855936/shuang-jie-yue-du-li-jie-mo-ni-zheng-ze-bwg24/)
