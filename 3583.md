[Problem: 3583. 统计特殊三元组](https://leetcode.cn/problems/count-special-triplets/description/)

### 方法：前后缀 & 优化

直接暴力枚举 $i, j, k$，复杂度是 $O(n^3)$，会超时。怎么优化？枚举三维超时，枚举一维不就行了？枚举中间，或者枚举两边都行，先介绍 “枚举中间” 这种容易理解的解法。

**枚举中间元素 $j$**，假设 $nums[j]$ 的值为 $x$：

- 我们需要在 $j$ 的 **左边** $[0,j-1]$ 中找到数值为 $2x$ 的元素个数，记为 $leftCnt$。
- 同理，在 $j$ 的 **右边** $[j+1,n-1]$ 中找到数值为 $2x$ 的元素个数，记为 $rightCnt$。
- 对于当前的 $j$，能构成的特殊三元组数量就是 $leftCnt * rightCnt$。

从左到右枚举 $j$，将不同 $j$ 计算出的结果累加即为答案。

如何快速获取左右两侧特定数值的计数？使用两个 **哈希表**：其中 $rightMap$ 存储 $j$ 右侧的元素频率分布，且 $leftMap$ 存储 $j$ 左侧的元素频率分布。

由于 $j$ 是从 $0$ 开始向右枚举，所以初始化 $rightMap$ 为 $nums$ 中所有元素的频率统计，且 $leftMap$ 为空。

**流程**：对于每一个中间元素 $nums[j]=x$ 来说，它不再属于右侧部分，所以从 $rightMap$ 中减去当前 $x$，此时的目标值 $target = x * 2$。我们查找 $leftMap[target]$ 和 $rightMap[target]$，每个 $x$ 都可以和左右两侧元素进行组合，根据乘法原理可知

$$
ans += leftMap[target]\times rightMap[target]
$$

在计算完成后，对于下一个 $j+1$ 来说，当前 $j$ 是左侧元素，将当前 $x$ 加入 $leftMap$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7

        # 存储当前元素左/右侧的数值频率
        left_cnt = defaultdict(int)
        right_cnt = defaultdict(int)
        ans = 0

        # 预处理
        for x in nums:
            right_cnt[x] += 1

        # 枚举中间元素
        for x in nums:
            # 从右侧计数中移除
            right_cnt[x] -= 1
            target = x * 2
            
            # 左/右侧满足条件的数量
            count_l = left_cnt[target]
            count_r = right_cnt[target]
            
            # 根据乘法原理累加组合数
            if count_l > 0 and count_r > 0:
                ans = (ans + count_l * count_r) % MOD
            
            # 变为下一轮的“左侧”元素
            left_cnt[x] += 1
        
        return ans
```

```Java
// java
class Solution {
    public int specialTriplets(int[] nums) {
        int MOD = 1_000_000_007;

        // 存储当前元素左/右侧的数值频率
        Map<Integer, Integer> leftCnt = new HashMap<>();
        Map<Integer, Integer> rightCnt = new HashMap<>();
        long ans = 0;

        // 预处理
        for (int x : nums) {
            rightCnt.put(x, rightCnt.getOrDefault(x, 0) + 1);
        }

        // 枚举中间元素
        for (int x : nums) {
            // 从右侧计数中移除
            rightCnt.put(x, rightCnt.get(x) - 1);
            int target = x * 2;

            // 左/右侧满足条件的数量
            int countL = leftCnt.getOrDefault(target, 0);
            int countR = rightCnt.getOrDefault(target, 0);

            // 根据乘法原理累加组合数
            if (countL > 0 && countR > 0) {
                ans = (ans + (long) countL * countR) % MOD;
            }

            // 变为下一轮的“左侧”元素
            leftCnt.put(x, leftCnt.getOrDefault(x, 0) + 1);
        }

        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$，两次遍历
- 空间复杂度： $O(n)$，表示两个哈希表的大小

---

### 优化

经实测，将哈希 $Map$ 换为数组形式，并没有加快速度。因为最大值 $max(nums)$ 在 $O(10^5)$ 量级，初始化数组的时间较长，修改代码后 $Python$ 反而运行 $1731ms$。

如果将数组放到类外，也就是静态代码块，速度会有显著提升。但是切记，每次计算完一个样例后，要清空两个哈希数组。这是运行速度最快的代码，非本人思路，所以放在评论区。

另外一种 **优化手段**：右侧数量 = 总数量 - 左侧数量。因此，我们完全没必要更新两个哈希，只更新一个哈希即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        # 全局所有元素的频率
        total_cnt = {}
        # 左侧元素频率
        prefix_cnt = {}
        ans = 0

        for x in nums:
            total_cnt[x] = total_cnt.get(x, 0) + 1
        
        # 枚举中间元素
        for x in nums:
            target = x * 2
            
            # 获取左侧数量
            left_count = prefix_cnt.get(target, 0)
            # 更新计数
            prefix_cnt[x] = prefix_cnt.get(x, 0) + 1
            # 计算右侧数量
            right_count = total_cnt.get(target, 0) - prefix_cnt.get(target, 0)
            
            # 累加合法组合数
            if left_count > 0 and right_count > 0:
                ans = (ans + left_count * right_count) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int specialTriplets(int[] nums) {
        int MOD = 1_000_000_007;

        // 全局所有元素的频率
        Map<Integer, Integer> totalCnt = new HashMap<>();
        // 左侧元素频率
        Map<Integer, Integer> prefixCnt = new HashMap<>();
        long ans = 0;

        for (int x : nums) {
            totalCnt.put(x, totalCnt.getOrDefault(x, 0) + 1);
        }

        // 枚举中间元素
        for (int x : nums) {
            int target = x * 2;

            // 获取左侧数量
            int leftCount = prefixCnt.getOrDefault(target, 0);
            // 更新计数
            prefixCnt.put(x, prefixCnt.getOrDefault(x, 0) + 1);
            // 计算右侧数量
            int rightCount = totalCnt.getOrDefault(target, 0) - prefixCnt.getOrDefault(target, 0);

            // 累加合法组合数
            if (leftCount > 0 && rightCount > 0) {
                ans = (ans + (long) leftCount * rightCount) % MOD;
            }
        }

        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

实测 $Python$ 运行时间为 $533ms$，超过 $98.78\%$，算是最快的一种。

---

### 枚举右侧

我们可以参考力扣的经典题目 “三数之和”。

**核心逻辑**：对于当前元素 $x = nums[k]$ 来说，看它能和左边已经存在的多少对 $(i, j)$ 组合完整的三元组。

因此，需要维护两个哈希表：

- **前缀频数表** $iCnt$：记录左侧 $nums[i]$ 的频率。
- **前缀数对表** $ijCnt$：记录左边已经形成的 $(i, j)$ 数对数量。其中 $ijCnt[v]=t$ 表示中间元素是 $v=nums[j]$，它对应的合法数对 $(i, j)$ 有 $t$ 个。

从左到右遍历时，必须严格按照 $k \rightarrow j \rightarrow i$ 的顺序处理，以保证下标满足 $i < j < k$。假设当前遍历到的元素是 $val$：

1. 首先，将当前元素视作 $nums[k]$。检查 $ijCnt$ 中是否存在以 $val/2$ 为中间值的数对。如果有，说明找到了 $(i, j)$ 组合，再加上当前的 $k$，累加答案。
2. 然后，将当前元素视作 $nums[j]$。检查 $iCnt$ 中是否存在 $val\times 2$。如果有，说明之前的那些 $i$ 可以和当前的 $val$ 组成新的 $(i, j)$ 数对，更新 $ijCnt$。
3. 最后，将当前元素视作 $nums[i]$。把 $val$ 计入 $iCnt$，供后续元素匹配。

元素顺序不能混淆！先后更新，确保组合数的正确累加。

代码如下，已附加注释：

```Python
# python
class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        # 左侧 nums[i] 的频率
        i_cnt = defaultdict(int)
        # 左侧合法 (i, j) 数对数量，也即 (中间元素nums[j], 对数)
        ij_cnt = defaultdict(int)
        ans = 0

        for x in nums:
            # 作为第三者 nums[k]
            if x % 2 == 0:
                mid = x // 2
                # 左边已经有以 mid 为中间项的 (i, j) 数对
                if ij_cnt[mid] > 0:
                    ans = (ans + ij_cnt[mid]) % MOD
            
            # 更新数对，当前 x 作为 nums[j]
            target_i = x * 2
            if i_cnt[target_i] > 0:
                ij_cnt[x] += i_cnt[target_i]
            
            # 更新开头，当前 x 作为 nums[i]
            i_cnt[x] += 1
        
        return ans
```

```Java
// java
class Solution {
    public int specialTriplets(int[] nums) {
        int MOD = 1_000_000_007;

        // 左侧 nums[i] 的频率
        Map<Integer, Integer> iCnt = new HashMap<>();
        // 左侧合法 (i, j) 数对数量，也即 (中间元素nums[j], 对数)
        Map<Integer, Integer> ijCnt = new HashMap<>();
        long ans = 0;

        for (int x : nums) {
            // 作为第三者 nums[k]
            if (x % 2 == 0) {
                int mid = x / 2;
                // 左边已经有以 mid 为中间项的 (i, j) 数对
                if (ijCnt.containsKey(mid)) {
                    ans = (ans + ijCnt.get(mid)) % MOD;
                }
            }

            // 更新数对，当前 x 作为 nums[j]
            int targetI = x * 2;
            if (iCnt.containsKey(targetI)) {
                int count = iCnt.get(targetI);
                ijCnt.put(x, ijCnt.getOrDefault(x, 0) + count);
            }

            // 更新开头，当前 x 作为 nums[i]
            iCnt.put(x, iCnt.getOrDefault(x, 0) + 1);
        }

        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-special-triplets/solutions/3852533/san-jie-mei-ju-zhong-jian-you-hua-or-mei-y1oc/)
