[Problem: 3347. 执行操作后元素的最高频率 II](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/)

### 方法：二分 & 双指针 & 前缀和

温馨提示，前置题目为 [3346](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/)，题解为 [传送门](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/solutions/3811913/si-jie-bao-li-mei-ju-er-fen-bian-jie-you-45sh/)。建议先通关前一题，再来攻克本题。因为两者一致，本题只是数据量增大而已，解读思路几乎相同。

为了方便表述，将 $numOperations$ 简记为 $op$。

本题可以理解为 **至多** 操作 $op$ 次，毕竟 $+0$ 相当于没有操作。题意比较清晰，就是将某些数字，全都变为一个数字 $x$。求 $x$ 的最大出现次数。

注意，变形后的 $x$ 不一定属于 $nums$！比如样例 $583$，数组 $nums=[88,53]$，而 $k=27$，最后变成的数字是 $88-27=61$，且 $53+8=61$，所以答案是 $2$。

小数字往大变形，大数字往小变形，最后的变形结果 $x$ 肯定 $\leq max(nums)$。

**暴力** 想法：枚举 $x$，然后判断在 $op$ 的条件下，数组 $nums$ 中有多少数字能变为它。也即，寻找 $nums$ 中有多少数在 $[x-k,x+k]$ 的范围内。

查找数字？很容易联想到 **二分**，而前提是 “有序”，因此对数组 $nums$ **升序** 排列。

记得使用一个 **哈希 $Map$**，其中 $cnts[x]=m$ 表示数组中的 $x$ 重复了 $m$ 次。

假设数组中 $> x+k$ 的数字有 $l$ 个，且 $\geq x-k$ 的数字有 $r$ 个，则在 $[x-k,x+k]$ 范围内的数字一共有 $r-l$ 个。

- 假设 $op$ 无限大，能将范围内所有数字都变形为 $x$，则最终次数为 $r-l$；
- 反之，若 $op$ 不够大，不能全部转为 $x$，则至多转化 $op$ 个数字，加上 $x$ 自身无需变形，则最终次数为 $op+cnts[x]$。

因此，最终结果就是上述两者取 **较小值** $min$。

如果不好理解，就拆分为三步，先计算可以用来转化的数量 $r-l-cnts[x]$，再将它与 $op$ 对比取较小者，最后加上 $cnts[x]$ 得到总次数。

二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~ 下面使用最容易理解的 **闭区间** 二分。

注意，不能使用昨天的 $[mn,mx]$ 枚举，会超时，卡在 $583/633$ 样例！

上面是正常的思维：范围里的每个值都尝试。而实际上，根据昨天滑窗的思维来看，只要 $[x-k,x+k]$ 区间固定，那么 $l,r$ 的边界就随之确定。只要目标 $target$ 在这个数值范围内，滑窗就不会移动。也即，只需要考虑 $x-k,x,x+k$ 这 **三个数字** 即可！

**差分** 优化：不再是枚举 $[mn,mx]$ 的所有数，而是枚举所有的 `nums[i]-k, nums[i], nums[i]+k`。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        cnt = Counter(nums)
        ans = 0
        
        # 最优的目标值 i 可能在 x, x-k, x+k 这三个位置上
        candidates = set()
        for x in nums:
            candidates.add(x)
            candidates.add(x - k)
            candidates.add(x + k)
            
        # 遍历所有候选目标值，不是暴力！
        for i in candidates:
            # 候选值 i 肯定在 [mn,mx] 范围内
            if nums[0] <= i <= nums[-1]:
                # 区间内总数
                l = bisect_left(nums, i - k)
                r = bisect_right(nums, i + k)
                
                # 能够变成 i 的数字数量
                current_freq = min(r - l, numOperations + cnt.get(i, 0))
                ans = max(ans, current_freq)
                
        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        Arrays.sort(nums);
        // 使用 HashMap 统计
        Map<Integer, Integer> counts = new HashMap<>();
        for (int num : nums) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }

        // 最优的目标值 i 可能在 x, x-k, x+k 这三个位置上
        Set<Integer> candidates = new HashSet<>();
        for (int x : nums) {
            candidates.add(x);
            candidates.add(x - k);
            candidates.add(x + k);
        }
        
        int ans = 0;
        // 遍历所有候选目标值，这不是暴力！
        for (int x : candidates) {
            int l = search(nums, x - k);
            int r = search(nums, x + k + 1);

            int currentMaxFreq = Math.min(r - l, numOperations + counts.getOrDefault(x, 0));
            ans = Math.max(ans, currentMaxFreq);
        }
        
        return ans;
    }

    // 查找第一个 >= target 的元素索引
    private int search(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int idx = arr.length;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= target) {
                idx = mid;
                right = mid - 1;
            } else {
                // 当前数小于 target，需要往右边找
                left = mid + 1;
            }
        }
        return idx;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示哈希 $cnt$ 以及 $candidates$ 的大小

---

### 双指针

这题的 **本质**，就是用一个 $[x-k,x+k]$ 范围的 “精灵球”，在 $nums$ 这片大陆上，尽可能抓住最多数量的 “宠物”。

将其抽象为一个 **滑窗**，初始时能覆盖 $[l,r]$ 范围内的元素。滑窗的总长度为 $2k$，从下标 $0$ 开始覆盖，不断递增 $x$，看看每次能覆盖几个下标。

也即，在枚举 $x$ 的过程中，左右指针都是不断向右移动，确保 $nums[i]$ 在范围内。

同理使用差分优化，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        cnt = Counter(nums)
        ans = 0
        
        # 最优的目标值 i 可能在 x, x-k, x+k 这三个位置上
        candidates = set()
        for x in nums:
            candidates.add(x)
            candidates.add(x - k)
            candidates.add(x + k)

        # 需要对候选值排序
        sorted_candidates = sorted(list(candidates))
            
        left = 0
        right = 0
        ans = 0
        
        # 遍历候选目标！
        for target in sorted_candidates:
            # 无法转换成 target 的数从窗口左侧移出
            while left < len(nums) and nums[left] < target - k:
                left += 1
            
            # 可以转换成 target 的数都包含进窗口右侧
            while right < len(nums) and nums[right] <= target + k:
                right += 1
            
            # 能够变成 i 的数字数量
            current_freq = min(right - left, numOperations + cnt.get(target, 0))
            ans = max(ans, current_freq)

        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 别忘了排序！
        Arrays.sort(nums);
        // 使用 HashMap 统计
        Map<Integer, Integer> cnts = new HashMap<>();
        for (int num : nums) {
            cnts.put(num, cnts.getOrDefault(num, 0) + 1);
        }

        // 最优的目标值 i 可能在 x, x-k, x+k 这三个位置上
        Set<Integer> candidates = new HashSet<>();
        for (int x : nums) {
            candidates.add(x);
            candidates.add(x - k);
            candidates.add(x + k);
        }

        // 需要对候选值排序，以保证滑动窗口指针单向移动
        List<Integer> sortedCandidates = new ArrayList<>(candidates);
        Collections.sort(sortedCandidates);
            
        int left = 0;   // 指向可转换区间的左边界
        int right = 0;  // 右边界
        int ans = 0;
        
        // 遍历候选目标！
        for (int target : sortedCandidates) {
            // 无法转换成 target 的数从窗口左侧移出
            while (left < nums.length && nums[left] < target - k) {
                left++;
            }
            
            // 可以转换成 target 的数都包含进窗口右侧
            while (right < nums.length && nums[right] <= target + k) {
                right++;
            }
            
            // 能够变成 target 的数字数量
            // 区间 [left, right) 内的元素总数
            int totalConvertible = right - left;
            // target 的初始数量加上可用的操作数
            int operationsLimit = numOperations + cnts.getOrDefault(target, 0);

            int currentFreq = Math.min(totalConvertible, operationsLimit);
            ans = Math.max(ans, currentFreq);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(nlogn)$，两个指针最多各自移动一趟 $nums$ 数组
- 空间复杂度： $O(n)$，表示哈希 $Map$ 以及列表 $List$ 的大小

---

### 前缀和

“前缀和” 的原理及推导，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。在本题中，定义 $prefix[x]$ 表示数值在 $[0,x]$ 范围内的元素个数。

总体的逻辑不变，还是枚举变形后的 $x$，只不过换成 “前缀和” 来寻找答案次数。

注意，不能直接使用昨天的 “数组哈希”，因为本题的 $nums[i]\leq 10^9$，会超出空间。怎么办？使用 **离散化**，只保留有用的点 `x+-k`，其他没用到的点都忽略。也即，使用 **哈希** 进行存储，而不是数组形式。

这样产生一个问题，比 $x$ 小的数量有几个？原本的数组，值对应下标；现在的哈希，值无法对应 $nums$ 下标，所以得通过 **二分** 寻找。

> $ps$：这种方法速度很慢，不推荐硬解，不如直接换成 “差分” 做法。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        cnts = Counter(nums)
        # 离散化坐标轴
        unique_nums = sorted(cnts.keys())

        # 前缀和数组
        prefix = [0] * len(unique_nums)
        prefix[0] = cnts[unique_nums[0]]
        for i in range(1, len(unique_nums)):
            prefix[i] = prefix[i - 1] + cnts[unique_nums[i]]

        # 生成候选的目标值
        candidate_targets = set()
        for num in unique_nums:
            candidate_targets.add(num)
            candidate_targets.add(num - k)
            candidate_targets.add(num + k)
        
        ans = 0
        # 遍历所有候选目标值
        for target in sorted(list(candidate_targets)):
            # 获取目标值本身的初始频率
            initial_freq = cnts.get(target, 0)

            # 定义可以转换成 target 的数值范围
            lower_bound = target - k
            upper_bound = target + k

            # 区间查询
            start_idx = bisect_left(unique_nums, lower_bound)
            end_idx = bisect_right(unique_nums, upper_bound) - 1

            # 区间无效
            if start_idx > end_idx:
                total = 0
            else:
                # 计算区间内元素总数
                sum_end = prefix[end_idx]
                sum_start = prefix[start_idx - 1] if start_idx > 0 else 0
                total = sum_end - sum_start
            
            # 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            convert = total - initial_freq
            # 实际能转换的数量受限于操作次数
            op_use = min(convert, numOperations)

            # 可以达到的总频率 = 初始频率 + 新转换过来的数量
            total_freq = initial_freq + op_use
            ans = max(ans, total_freq)
        
        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 使用 HashMap 统计频率
        Map<Integer, Integer> cnts = new HashMap<>();
        for (int num : nums) {
            cnts.put(num, cnts.getOrDefault(num, 0) + 1);
        }

        // 离散化坐标轴
        List<Integer> uniqueNums = new ArrayList<>(cnts.keySet());
        Collections.sort(uniqueNums);

        // 前缀和数组
        int[] prefix = new int[uniqueNums.size()];
        prefix[0] = cnts.get(uniqueNums.get(0));
        for (int i = 1; i < uniqueNums.size(); i++) {
            prefix[i] = prefix[i - 1] + cnts.get(uniqueNums.get(i));
        }

        // 生成候选的目标值
        Set<Integer> candidateTargets = new HashSet<>();
        for (int num : uniqueNums) {
            candidateTargets.add(num);
            candidateTargets.add(num - k);
            candidateTargets.add(num + k);
        }
        
        // 为了有序遍历，转为列表并排序
        List<Integer> sortedCandidates = new ArrayList<>(candidateTargets);
        Collections.sort(sortedCandidates);
        
        int ans = 0;
        // 遍历所有候选目标值
        for (int target : sortedCandidates) {
            // 获取目标值本身的初始频率
            int initialFreq = cnts.getOrDefault(target, 0);

            // 定义可以转换成 target 的数值范围
            int lowerBound = target - k;
            int upperBound = target + k;

            // 区间查询: 在离散坐标轴上找到范围边界
            int startIdx = search(uniqueNums, lowerBound);
            int endIdx = search(uniqueNums, upperBound + 1) - 1;

            int total = 0;
            // 如果区间无效
            if (startIdx > endIdx) {
                total = 0;
            } else {
                // 计算区间内元素总数
                int sumEnd = prefix[endIdx];
                int sumStart = (startIdx > 0) ? prefix[startIdx - 1] : 0;
                total = sumEnd - sumStart;
            }
            
            // 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            int convert = total - initialFreq;
            // 实际能转换的数量受限于操作次数
            int opUse = Math.min(convert, numOperations);

            // 可以达到的总频率 = 初始频率 + 新转换过来的数量
            int totalFreq = initialFreq + opUse;
            ans = Math.max(ans, totalFreq);
        }
        
        return ans;
    }

    // 查找第一个 >= target 的元素索引
    private int search(List<Integer> arr, int target) {
        int low = 0, high = arr.size();
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr.get(mid) >= target) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

- 时间复杂度： $O(nlogn)$
- 空间复杂度： $O(n)$

---

### 差分

实际上，不如直接使用差分，将 $x-k,x,x+k$ 转化为在数轴上的增减事件，然后一次性扫描计算出每个点的覆盖数，从而避免区间内的搜索。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        cnt = Counter(nums)
        diff_map = defaultdict(int)
        
        for num in nums:
            # 在区间的起点将覆盖数 +1
            start = num - k
            diff_map[start] += 1
            
            # 在区间终点的后一个位置将覆盖数 -1
            end = num + k + 1
            diff_map[end] -= 1
            
            # 确保原始数字 num 成为字典的一个键
            diff_map[num] += 0


        ans = 0
        # 当前点的区间覆盖总数
        coverage = 0
        
        # 从左到右扫描数轴
        for target in sorted(diff_map.keys()):
            # 总共有 coverage 个数字可以被转换
            coverage += diff_map[target]
            
            # 初始数量
            initial_freq = cnt.get(target, 0)
            
            # 实际能转换的数量受限于操作次数
            possible_freq = min(coverage, initial_freq + numOperations)
            ans = max(ans, possible_freq)
            
        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int num : nums) {
            cnt.put(num, cnt.getOrDefault(num, 0) + 1);
        }

        // 使用 TreeMap 作为差分字典，自动按键排序
        Map<Integer, Integer> diffMap = new TreeMap<>();
        
        for (int num : nums) {
            // 在区间的起点将覆盖数 +1
            int start = num - k;
            diffMap.put(start, diffMap.getOrDefault(start, 0) + 1);
            
            // 在区间终点的后一个位置将覆盖数 -1
            int end = num + k + 1;
            diffMap.put(end, diffMap.getOrDefault(end, 0) - 1);
            
            // 确保原始数字 num 成为字典的一个键
            diffMap.putIfAbsent(num, 0);
        }

        int ans = 0;
        // 当前点的区间覆盖总数
        int coverage = 0;
        
        // 从左到右扫描数轴
        for (int target : diffMap.keySet()) {
            // 共有 coverage 个数可以被转换成 target
            coverage += diffMap.get(target);
            
            // 初始数量
            int initial_freq = cnt.getOrDefault(target, 0);
            
            // 实际能达到的频率受限于总覆盖数和操作数
            int possible_freq = Math.min(coverage, initial_freq + numOperations);
            ans = Math.max(ans, possible_freq);
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(nlogn)$，键值需要排序
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/3812948/wu-jie-you-hua-er-fen-hua-chuang-qian-zh-8nu4/)
