[Problem: 3047. 求交集区域内的最大正方形面积](https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/description/)

### 暴力 & 剪枝

核心逻辑：任何两个矩形的 **交集**（如果存在）本身一定也是一个矩形。

如果交集矩形的宽度为 $w$，高度为 $h$，那么能放入该交集区域内的最大正方形的边长为 $s = \min(w, h)$，且对应的面积为 $s^2$。

因此，我们只需要 **暴力** 解决本题：

1. 遍历所有可能的矩形对 $(i, j)$。
2. 计算这两个矩形的交集区域。
3. 如果存在交集，计算该交集矩形的最小边长。
4. 维护一个全局的最大边长，最后返回其平方。

如何计算 **两个矩形的交集？** 假设矩形 $A$ 的 $x$ 范围是 $[ax1, ax2]$，且 $y$ 范围是 $[ay1, ay2]$。矩形 $B$ 的 $x$ 范围是 $[bx1, bx2]$，且 $y$ 范围是 $[by1, by2]$。

已知一维坐标系下，两个区间 $[L1, R1]$ 和 $[L2, R2]$ 的重叠部分是 $[\max(L1, L2), \min(R1, R2)]$。那么，二维的交集矩形的坐标范围为：

- **左下角 x**： $ix\_min = \max(ax1, bx1)$
- **左下角 y**： $iy\_min = \max(ay1, by1)$
- **右上角 x**： $ix\_max = \min(ax2, bx2)$
- **右上角 y**： $iy\_max = \min(ay2, by2)$

**有效性判断：** 只有当 $ix\_min < ix\_max$ 且 $iy\_min < iy\_max$ 时，交集才存在且面积大于 $0$。此时，正方形边长为 “两个 $x$ 坐标差” 与 “两个 $y$ 坐标差” 中的较小者。

代码如下，已附加注释：

```Python
# python
class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        n = len(bottomLeft)
        max_side = 0
        
        # 遍历所有可能的矩形对 (i, j)
        for i in range(n):
            # 获取矩形 i 的坐标
            ax1, ay1 = bottomLeft[i]
            ax2, ay2 = topRight[i]
            
            for j in range(i + 1, n):
                # 获取矩形 j 的坐标
                bx1, by1 = bottomLeft[j]
                bx2, by2 = topRight[j]
                
                # 计算交集区域的边界
                ix_min = max(ax1, bx1)
                iy_min = max(ay1, by1)
                ix_max = min(ax2, bx2)
                iy_max = min(ay2, by2)
                
                # 检查是否交集
                if ix_min < ix_max and iy_min < iy_max:
                    # 计算交集的宽和高
                    width = ix_max - ix_min
                    height = iy_max - iy_min
                    
                    # 受限于宽和高中的较小值
                    current_side = min(width, height)
                    
                    # 更新全局最大边长
                    if current_side > max_side:
                        max_side = current_side
            
        # 返回面积
        return max_side * max_side
```

```Java
// java
class Solution {
    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {
        int n = bottomLeft.length;
        long maxSide = 0;
        
        // 遍历所有可能的矩形对 (i, j)
        for (int i = 0; i < n; i++) {
            // 获取矩形 i 的坐标
            int ax1 = bottomLeft[i][0];
            int ay1 = bottomLeft[i][1];
            int ax2 = topRight[i][0];
            int ay2 = topRight[i][1];
            
            for (int j = i + 1; j < n; j++) {
                // 获取矩形 j 的坐标
                int bx1 = bottomLeft[j][0];
                int by1 = bottomLeft[j][1];
                int bx2 = topRight[j][0];
                int by2 = topRight[j][1];
                
                // 计算交集区域的边界
                int ixMin = Math.max(ax1, bx1);
                int iyMin = Math.max(ay1, by1);
                int ixMax = Math.min(ax2, bx2);
                int iyMax = Math.min(ay2, by2);
                
                // 检查是否交集
                if (ixMin < ixMax && iyMin < iyMax) {
                    // 计算交集的宽和高
                    int width = ixMax - ixMin;
                    int height = iyMax - iyMin;
                    
                    // 受限于宽和高中的较小值
                    int currentSide = Math.min(width, height);
                    
                    // 更新全局最大边长
                    if (currentSide > maxSide) {
                        maxSide = currentSide;
                    }
                }
            }
        }
        // 返回面积
        return maxSide * maxSide;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是数组 $bottomLeft$ 的长度，两两配对检查
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 剪枝

任何两个矩形的 **交集**，其面积一定 **小于或等于** 其中任意一个原矩形的面积。也即，交集内能放入的最大正方形边长，绝不可能超过原矩形自身的最小边长。

所以，如果矩形 $A$ 的边长不超过之前的最大边长 $mxSide$，那就没必要进行第二次 $for$ 查找。

经实测，上述 $Python$ 代码耗时 $2077ms$，而下面的仅耗时 $39ms$，超过 $95\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        max_side = 0
        n = len(bottomLeft)
        
        for i in range(n):
            # 获取矩形 A 的坐标
            ax1, ay1 = bottomLeft[i]
            ax2, ay2 = topRight[i]
            
            # 剪枝：矩形 A 自身的边长都无法超过当前最大边长
            if min(ax2 - ax1, ay2 - ay1) <= max_side:
                continue
            
            # 遍历之前的矩形 B
            for j in range(i):
                bx1, by1 = bottomLeft[j]
                bx2, by2 = topRight[j]
                
                # 计算交集区域的宽高
                width = min(ax2, bx2) - max(ax1, bx1)
                height = min(ay2, by2) - max(ay1, by1)
                
                # 最大正方形边长受限于宽和高的最小值
                cur_side = min(width, height)
                # 手动 if 判断
                if cur_side > max_side:
                    max_side = cur_side
                    
        return max_side * max_side
```

```Java
// java
class Solution {
    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {
        long maxSide = 0;
        int n = bottomLeft.length;
        
        for (int i = 0; i < n; i++) {
            // 获取矩形 A 的坐标
            int ax1 = bottomLeft[i][0];
            int ay1 = bottomLeft[i][1];
            int ax2 = topRight[i][0];
            int ay2 = topRight[i][1];
            
            // 剪枝：矩形 A 自身的边长都无法超过当前最大边长
            if (Math.min(ax2 - ax1, ay2 - ay1) <= maxSide) {
                continue;
            }
            
            // 遍历之前的矩形 B
            for (int j = 0; j < i; j++) {
                int bx1 = bottomLeft[j][0];
                int by1 = bottomLeft[j][1];
                int bx2 = topRight[j][0];
                int by2 = topRight[j][1];
                
                // 计算交集区域的宽高
                int width = Math.min(ax2, bx2) - Math.max(ax1, bx1);
                int height = Math.min(ay2, by2) - Math.max(ay1, by1);
                
                // 最大正方形边长受限于宽和高的最小值
                int curSide = Math.min(width, height);
                // 手动 if 判断
                if (curSide > maxSide) {
                    maxSide = curSide;
                }
            }
        }
        return maxSide * maxSide;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/solutions/3882601/shuang-jie-ji-suan-xiang-jiao-zuo-biao-b-ynxf/)
