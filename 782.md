[Problem: 782. 变为棋盘](https://leetcode.cn/problems/transform-to-chessboard/description/)

### 方法：数学

题意很清晰，就是求交换行列的最小次数。我们先来看看，如果一个矩阵能交换成棋盘，它满足什么条件。

### 分析特点

棋盘上的棋子是 $0-1$ 交替，并且相邻行与相邻列都不相同。如果棋盘的边长大于 $1$，可以发现，总共只有 **两种** 行和列，即 $101\dots$ 或 $010\dots$。

**逆向** 思维，将这个棋盘打乱成矩阵，得到矩阵需要满足的特点。

如果交换任意两行 $i$ 和 $j$，即 $grid[i][col]$ 与 $grid[j][col]$ 发生交换，可以发现，行的规律没有变，依旧只有两种行；对应地，所有列均受到影响，任意的第 $col$ 列的这两个数值产生顺序的变化。不过，依旧只有两种列。

举个例子，最开始是 $1010,0101$ 这两种列，交换第一行和第二行，它们变为 $1100,0011$。**本质上**，就是两个相同的列在 *交换行* 后依旧是相同的列。

同理，任意交换两列 $i$ 和 $j$，即 $grid[row][i]$ 与 $grid[row][j]$ 发生交换。可以发现，列的规律没有变，依旧只有两种列；对应地，所有行均受到影响，但依旧只有两种行。

还有一个 **特点**：交换行并不影响列中 $0,1$ 的数量，交换列也不改变行中 $0,1$ 的数量。那么，为了得到 $0-1$ 交替的行和列，以上的这两种行和列都必须保证 $0$ 与 $1$ 的数值相等，或者某一种的 $1$ 更多，而另一种的 $0$ 更多。

**同时**，这两种行列的数量必须最多只相差 $1$。假如有四种 $010\dots$ 和一种 $101\dots$，不管怎么交换，肯定得不到棋盘。

总结，如果想让矩阵变为棋盘，必须满足 **三个条件**：

1. 只有两种行和两种列，对应位置完全相反
2. 每一个行列中 $0,1$ 的数量最多只相差 $1$，取决于棋盘边长的奇偶性
3. 两种行列的数量最多只相差 $1$，取决于棋盘边长的奇偶性

### 预处理

已知上面的这三个限制条件，如果矩阵不满足它们，就没必要进行交换。所以，先判断这三个条件，然后再去计算。

行和列的特点相同，这里只展示行的做法，列的做法同理，以 **行** 为例，将第一行作为参照物，它是其中一种行。

先处理 **第一个** 条件，如何得知只有两种行？

对于任意第 $i$ 行来说，它要么与第一行相同，要么完全相反，所以只需要用 **双指针** 进行一次遍历。

先比较 $grid[i][0]$ 与 $grid[0][0]$，如果相同就说明是相同行，如果不同就是不同行。然后遍历剩余的 $n-1$ 个位置，必须对应相同或相反。

具体来说，可以使用 *异或* $XOR$ 运算。规则：相同为 $0$，相异为 $1$。

- 得到 $diff = grid[i][0]$ ^ $grid[0][0]$，判断两者是否相同；
- 循环，比较 $grid[i][j]$ ^ $grid[0][j]$ 是否等于 $diff$ 即可。

正常结束循环，没有提前退出，说明第 $i$ 行符合。以此类推所有行。

再来处理 **第二个** 条件，如何判断数量差值？

其实，只需要统计第一行（第一列）中的 $0-1$ 的数量即可。因为只有两种行，完全相同行的 $0-1$ 数量相同，完全相反行的 $0-1$ 数量相反。

也即，只要第一行符合要求，那么所有的行都符合要求。定义数组 $rowCnt$，其中 $rowCnt[0]$ 表示第一行中 $0$ 的数量，且 $rowCnt[1]$ 表示第一行中 $1$ 的数量。

遍历第一行 $grid[0]$，填充 $rowCnt$ 数组，然后比较差值。

最后来处理 **第三个** 条件，如何判断行的数量差？

可以放在第一个条件的循环比较中，也就是一边比较，一边统计这种类型的行的数量。不过，其实无需判断 —— 它已经 *隐含* 在第二个判断中。

**原因**：只有两种列，第一行某个位置是 $0$ 就说明是一种列，某个位置是 $1$ 就说明是另一种列。在第二个条件中，计算了 $0-1$ 的差值，也意味着计算了两种列的差值。

如果两种列的差值不超过 $1$，就说明符合条件。那么，这个条件就无需特判，只进行上面一种就够了。

### 计算交换次数

现在，我们已经得到了符合要求的矩阵，该考虑如何将它变为棋盘，也即计算最小交换次数。

先来看一个例子，原始串 $x=000111$，想让它变成 $y=010101$。可以发现，只有两个位置不同，所以只需要交换一次。

**结论**：如果两个串 $x$ 和 $y$ 有 $t$ 处不同（串长为偶数），那么只需要交换 $t/2$ 次。

**证明**：

记 $t$ 表示 $x[i] \neq y[i]$ 的总次数，它可以被分成两种类型的错误：

- 类型 $A$： $x[i] = 0$ 且 $y[i] = 1$
- 类型 $B$： $x[i] = 1$ 且 $y[i] = 0$

设类型 $A$ 的错误有 $a$ 次，类型 $B$ 的错误有 $b$ 次，由于 $x$ 和 $y$ 是由相同字符集合构成的，因此 $a = b$，即 $t = 2a$。

每次交换可以选择一个 $A$ 类型错误和一个 $B$ 类型错误修复，这样 $a$ 对错误可以在 $a$ 次交换内完全修复。

因此，所需的最小交换次数为 $a = \frac{t}{2}$。

但是，需要考虑变换成不同样式的目标，即不止变成 $010\dots$ 类型，也有可能变成 $101\dots$ 类型。也即， $y$ 要发生变化。

在这种情况下，根据 **对称性** 可知，总的 $x[i]\neq y'[i]$ 的次数就变为 $n-t$，其中 $n$ 是串长。那么，最小次数就是 $\frac{n-t}{2}$。

同时，在串长为奇数时，很容易发现 $t=n-t$，两者都是偶数。

**总结**：

- 当串长 $n$ 为偶数时，最小交换次数为 $\min \left(t,(n-t)\right)/2$
- 当串长 $n$ 为奇数时，最小交换次数为 $t/2$

**有个问题**，交换行不会影响交换列的答案吗？

在上面的推导中，我们已经发现，交换的本质只是顺序的变更，相同行在交换后仍然是相同行。也即，行与列之间的变换实际是 **相互独立** 的，二者互不影响，列变换不会影响相邻两行的异同关系，行变换不会不会影响相邻两列的异同关系。

那么，我们只需要计算第一行的最小交换次数，表示交换完成所有列；再计算第一列的最小交换次数，表示交换完成所有行。

实现上面的过程，代码如下，已附加注释：

```Python
# python
class Solution:
    def movesToChessboard(self, board):
        # 计算最小交换次数
        def min_swap(arr, cnt):
            n = len(arr)
            more = 1 if cnt[1] > cnt[0] else 0  # 第一个数选择1或0
            diff = sum(i % 2 ^ more ^ arr[i] for i in range(n))
            return diff // 2 if n % 2 else min(diff, n - diff) // 2
        
        n = len(board)
        first_row = board[0]
        first_col = [board[i][0] for i in range(n)]
        row_cnt = [0, 0]
        col_cnt = [0, 0]

        for i in range(n):  # 统计 0 和 1 的个数
            row_cnt[first_row[i]] += 1
            col_cnt[first_col[i]] += 1

        # 第一行和第一列的 0,1 的个数之差不能超过 1
        if abs(row_cnt[0] - row_cnt[1]) > 1 or abs(col_cnt[0] - col_cnt[1]) > 1:
            return -1

        # 每一行和第一行比较，只能所有位置相同，或所有位置不同
        for row in board:
            diff = row[0] ^ first_row[0]
            for i in range(1, n):
                if (row[i] ^ first_row[i]) != diff:
                    return -1
        
        # 第一行和第一列都需要交换，相互独立
        return min_swap(first_row, row_cnt) + min_swap(first_col, col_cnt)
```

```Java
// java
class Solution {
    public int movesToChessboard(int[][] board) {
        int n = board.length;
        int[] firstRow = board[0];
        int[] firstCol = new int[n];
        int[] rowCnt = new int[2];
        int[] colCnt = new int[2];

        for (int i = 0; i < n; i++) {  // 统计 0 和 1 的个数
            rowCnt[firstRow[i]]++;
            firstCol[i] = board[i][0];
            colCnt[firstCol[i]]++;
        }

        // 第一行和第一列的 0,1 的个数之差不能超过 1
        if (Math.abs(rowCnt[0] - rowCnt[1]) > 1 || Math.abs(colCnt[0] - colCnt[1]) > 1) {
            return -1;
        }

        // 每一行和第一行比较，只能所有位置相同，或所有位置不同
        for (int[] row : board) {
            int diff = row[0] ^ firstRow[0];
            for (int i = 1; i < n; i++) {
                if ((row[i] ^ firstRow[i]) != diff) {
                    return -1;
                }
            }
        }

        // 第一行和第一列都需要交换，相互独立
        return minSwap(firstRow, rowCnt) + minSwap(firstCol, colCnt);
    }

    // 计算最小交换次数
    private int minSwap(int[] arr, int[] cnt) {
        int n = arr.length;
        int more = cnt[1] > cnt[0] ? 1 : 0; // 第一个数选择1或0
        int diff = 0;
        for (int i = 0; i < n; i++) {
            diff += i % 2 ^ more ^ arr[i];
        }
        return n % 2 > 0 ? diff / 2 : Math.min(diff, n - diff) / 2;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为矩阵 $board$ 的边长，循环比较所有行的所有位置
- 空间复杂度： $O(n)$，表示辅助数组 $firstCol$ 的长度

在比较两行的差异时，这里使用的是简单的 $for$ 循环比较。因为 $n\leq 30$，可以使用位运算，也即一个掩码 $mask$ 表示某行的状态，感兴趣的小伙伴可以自行尝试。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/transform-to-chessboard/solutions/3013958/shu-xue-zhao-gui-lu-bi-jiao-bu-tong-lei-q3zx9/)
