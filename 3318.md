[Problem: 3318. 计算子数组的 x-sum I](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/description/)

### 方法：模拟 & 滑窗

什么是 $x-sum$？

- 统计数组中每个元素出现的次数；
- 按出现次数降序，如果出现次数相同，则数值大的排在前面；
- 将前面这些次数多/数值大的 $x$ 个数字进行累加。

比如数组 $[1,3,1,2]$，则排序后为 $[1,1,3,2]$，前面 $x=3$ 个数字的和为 $5$。特别地，如果数组长度不足 $x$，则是全部元素的总和。比如上述 $x=5$ 时总和为 $7$。

**题意**：找出所有长度为 $k$ 的子数组，每个子数组求 $x-sum$，将它们记录下来。

**暴力** 思路：模拟操作流程，定义 $cal$ 函数去计算 $x-sum$。从头到尾遍历这个 $nums$ 数组，提取出长度为 $k$ 的子数组，然后调用方法计算并保存。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        # 计算单个子数组的 x-sum
        def calculate_x_sum(subarray):
            # 统计子数组中元素的出现次数
            counts = Counter(subarray)

            # 不同元素的数量少于 x
            if len(counts) < x:
                return sum(subarray)

            # 降序，先按照次数，后按照数值
            sorted_elements = sorted(counts.items(), key=lambda item: (item[1], item[0]), reverse=True)

            # 提取出现次数最多的前 x 个元素
            top_x_elements = set()
            for i in range(x):
                top_x_elements.add(sorted_elements[i][0])
            
            # 只累加属于 top_x_elements 的元素
            cur_sum = 0
            for num in subarray:
                if num in top_x_elements:
                    cur_sum += num
            
            return cur_sum

        n = len(nums)

        res = []
        # 遍历所有长度为 k 的子数组
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            # 计算
            res.append(calculate_x_sum(subarray))
        
        return res
```

```Java
// java
class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] res = new int[n - k + 1];

        // 遍历所有长度为 k 的子数组
        for (int i = 0; i <= n - k; i++) {
            int[] subarray = Arrays.copyOfRange(nums, i, i + k);
            // 计算
            res[i] = calculateXSum(subarray, x);
        }
        
        return res;
    }

    // 计算单个子数组的 x-sum
    private int calculateXSum(int[] subarray, int x) {
        // 统计子数组中元素的出现次数
        Map<Integer, Integer> counts = new HashMap<>();
        for (int num : subarray) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }

        // 不同元素的数量少于 x
        if (counts.size() < x) {
            return Arrays.stream(subarray).sum();
        }

        // 将 map 条目转为 list 以便排序
        List<Map.Entry<Integer, Integer>> sortedElements = new ArrayList<>(counts.entrySet());

        // 降序，先按照次数，后按照数值
        sortedElements.sort((a, b) -> {
            if (!a.getValue().equals(b.getValue())) {
                return b.getValue().compareTo(a.getValue()); // 按频率降序
            } else {
                return b.getKey().compareTo(a.getKey());   // 按数值降序
            }
        });

        // 提取出现次数最多的前 x 个元素
        Set<Integer> topXElements = new HashSet<>();
        for (int i = 0; i < x; i++) {
            topXElements.add(sortedElements.get(i).getKey());
        }
        
        // 只累加属于 top_x_elements 的元素
        int currentSum = 0;
        for (int num : subarray) {
            if (topXElements.contains(num)) {
                currentSum += num;
            }
        }
        
        return currentSum;
    }
}
```

外层循环，一共有 $n-k+1$ 个长度为 $k$ 的子数组；内层循环中，对这个子数组进行复制、哈希统计、快排、遍历求和，时间为 $O(k\times logk)$，瓶颈在于排序。

- 时间复杂度： $O((n-k)\times klogk)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(k)$，表示哈希表 $counts$ 以及辅助列表的开销

---

### 滑动窗口

仔细观察，第一个长为 $k$ 的子数组，和第二个长为 $k$ 的子数组有什么 **联系**？比如数组 $[1,2,3,4]$，且 $k=3$ 时，第一个子数组是 $[1,2,3]$，第二个子数组是 $[2,3,4]$。

发现规律：两个相邻的子数组之前，只相差 **首尾** 两个元素。

因此，我们想到使用 **滑窗**：固定一个长度为 $k$ 的窗口。从前一个窗口，只需要更改两个元素，即可滑动到下一个窗口。

这样做有什么好处？我们完全可以只使用 **一个** 哈希表。

上面的代码中，每次都是对子数组进行哈希计数，然后排序，非常浪费时间。现在，我们只需要略微修改，就可快速得到新窗口的哈希，从而节省时间。

**修改点**：在 $cal$ 函数中，不用定义新哈希；计算总和时，换成 “值*次数” 的方式，代替效率低下的加法；在主流程中，增加滑窗进行滚动更新。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        # 存储当前窗口内元素的频率
        counts = {}
        res = []

        # 初始化第一个窗口
        for i in range(k):
            value = nums[i]
            counts[value] = counts.get(value, 0) + 1

        # 计算当前窗口的 x-sum
        def cal_x_sum():
            # 降序
            sorted_items = sorted(counts.items(), key=lambda item: (-item[1], -item[0]))
            # 处理唯一元素少于 x 的情况
            l = len(sorted_items)
            limit = x if x < l else l
            
            total_sum = 0
            # 累加前 limit 个元素的和
            for j in range(limit):
                value, count = sorted_items[j]
                total_sum += value * count
            return total_sum

        # 第一个窗口
        res.append(cal_x_sum())

        # 遍历所有长度为 k 的子数组
        for i in range(n - k):
            # 确定移出和移入窗口的元素值
            out_value = nums[i]
            in_value = nums[i + k]

            # 移除最左侧的元素
            count = counts.get(out_value, 0)
            if count <= 1:
                if out_value in counts:
                    del counts[out_value]
            else:
                counts[out_value] -= 1

            # 将新元素添加到窗口
            counts[in_value] = counts.get(in_value, 0) + 1
            # 计算新窗口的 x-sum
            res.append(cal_x_sum())

        return res
```

```Java
// java
class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        // 存储当前窗口内元素的频率
        Map<Integer, Integer> counts = new HashMap<>();
        int[] res = new int[n - k + 1];
        // 初始化第一个窗口
        for (int i = 0; i < k; i++) {
            int value = nums[i];
            counts.put(value, counts.getOrDefault(value, 0) + 1);
        }
        
        // 第一个窗口
        res[0] = calculateCurrentXSum(counts, x);

        // 遍历所有长度为 k 的子数组
        for (int i = 0; i < n - k; i++) {
            // 确定移出和移入窗口的元素值
            int outValue = nums[i];
            int inValue = nums[i + k];

            // 移除最左侧的元素
            int currentCount = counts.getOrDefault(outValue, 0);
            if (currentCount <= 1) {
                counts.remove(outValue);
            } else {
                counts.put(outValue, currentCount - 1);
            }

            // 将新元素添加到窗口
            counts.put(inValue, counts.getOrDefault(inValue, 0) + 1);
            
            // 计算新窗口的 x-sum
            res[i + 1] = calculateCurrentXSum(counts, x);
        }

        return res;
    }

    // 计算单个子数组的 x-sum
    private int calculateCurrentXSum(Map<Integer, Integer> counts, int x) {
        List<Map.Entry<Integer, Integer>> sortedItems = new ArrayList<>(counts.entrySet());

        // 降序
        sortedItems.sort((a, b) -> {
            if (!a.getValue().equals(b.getValue())) {
                return b.getValue().compareTo(a.getValue());
            } else {
                return b.getKey().compareTo(a.getKey());
            }
        });

        // 处理唯一元素少于 x 的情况
        int l = sortedItems.size();
        int limit = x < l ? x : l;
        
        int totalSum = 0;
        // 累加前 limit 个元素的和
        for (int j = 0; j < limit; j++) {
            Map.Entry<Integer, Integer> entry = sortedItems.get(j);
            int value = entry.getKey();
            int count = entry.getValue();
            totalSum += value * count;
        }
        return totalSum;
    }
}
```

- 时间复杂度： $O((n-k)\times klogk)$，同理
- 空间复杂度： $O(k)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/solutions/3823263/shuang-jie-bao-li-mo-ni-hua-chuang-you-h-2p9p/)
