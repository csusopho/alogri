[Problem: 1461. 检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)

### 方法：滑窗 & 位运算

长度为 $k$ 的所有二进制串，总共有 $2^k$ 个。

固定一个宽度为 $k$ 的 “窗口”，从左到右扫描 $s$。每移动一步，窗口内的字符就组成了一个子串。我们将这个子串扔进一个 $set$ “篮子” 里。

**暴力**：遍历字符串 $s$，把所有长度为 $k$ 的子串截取出来放入 $set$ 集合中去重，最后判断集合的大小是否等于 $2^k$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        # 边界
        if len(s) < k:
            return False
        
        seen = set()
        # 截取所有 s[i : i+k]
        for i in range(len(s) - k + 1):
            sub_str = s[i : i + k]
            # 自动去重
            seen.add(sub_str)
            
        # 判断
        return len(seen) == (1 << k)
```

```Java
// java
class Solution {
    public boolean hasAllCodes(String s, int k) {
        // 边界
        if (s.length() < k) {
            return false;
        }
        
        Set<String> seen = new HashSet<>();
        // 截取所有 s[i : i+k]
        for (int i = 0; i < s.length() - k + 1; i++) {
            String sub_str = s.substring(i, i + k);
            // 自动去重
            seen.add(sub_str);
        }
            
        // 判断
        return seen.size() == (1 << k);
    }
}
```

- 时间复杂度： $O(n\times k)$，其中 $n$ 为字符串 $s$ 的长度，截取子串时间为 $O(k)$
- 空间复杂度： $O(2^k\times k)$，每个串都要存储在 $set$ 集合中

---

### 位运算

截取/存储字符串比较慢，而整数非常快。长度为 $k$ 的二进制串本质上就是 $0$ 到 $2^k - 1$ 之间的整数。比如 $101$ 对应十进制的 $5$。

那窗口内的数值怎么算？

假设当前窗口是 $101$，下一个字符是 $0$。滑动后变成 $010$。**位运算操作**：

1. 旧数值左移一位： $101$ -> $1010$。
2. 加上新进来的位： $1010$ + $0$ = $1010$。
3. 去掉最左边溢出的一位：需要用一个掩码 $mask$ 把高位截断。
4. 此时 $1010$ 截断最高位后变成 $010$。

掩码如何构建？如果 $k=2$，我们需要保留最后两位，掩码是二进制 $11$；如果 $k=3$，掩码是 $111$。也即，通项公式为 $2^k-1$。

位运算中的 `&` **“与运算”**：有 $0$ 就是 $0$，全 $1$ 才是 $1$。那么，在上面的例子中，我们构造 $111$ 这样的掩码。低位全是 $1$ 保留它们，高位是 $0$ 表示去除。比如溢出的 $1010$ 和 $111$ 相与后，高位“与” $0$，低位“与” $1$，自然剩下 $010$。

因此，我们 **维护** 一个整数 $val$，表示当前窗口的值。每次滑动后，用上述位运算快速更新 $val$ 为新窗口的值，把它加入集合，最后判断集合大小。

---

为了在算法和底层性能之间取得平衡，彻底舍弃动态扩容的 $set$，转而使用 **固定大小** 的布尔数组。整数范围严格固定在 $0$ 到 $2^k - 1$ 之间，用数值直接做索引映射，省去了 “动态扩容” 和 “哈希冲突” 的开销，这在算法设计上叫做 **直接寻址表**。

开辟一个长度为 $2^k$ 的数组，整数 $val$ 直接作为数组下标。检查是否存在，只需判断 $seen[val]$。没有任何哈希计算，纯正的物理内存偏移，速度极快。

要收集 $2^k$ 个不同的子串，**最短** 需要多长的字符串？第一个子串消耗 $k$ 个字符，想要再增加 $1$ 个新子串，最少需要往后看 $1$ 个字符。所以要得到 $2^k$ 个子串，最少需要的字符总数为： $k + (2^k - 1)$。提前剪枝！

注意，在 $Python$ 中，布尔值 $True$ 和 $False$ 在参与位运算时等价于 $1$ 和 $0$。使用 $s[i] == '1'$ 比调用内置函数 $int(s[i])$ 省去了函数调用的栈开销，速度更快。

同时，维护一个 **计数器** $count$，每次遇到一个没见过的 $val$，就把该位置为 $True$，且 $count+1$。一旦 $count$ 变为 $2^k$，意味着我们集齐了所有目标，直接提前返回！

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        # 理论最短长度剪枝
        target = 1 << k
        if len(s) < target + k - 1:
            return False

        # 固定大小的布尔数组
        seen = [False] * target
        # 已经找到的子串数
        count = 0
        mask = target - 1
        
        # 初始化第一个窗口
        val = 0
        for i in range(k - 1):
            val = (val << 1) | (s[i] == '1')
            
        # 开始滑动
        for i in range(k - 1, len(s)):
            # 移位并加入新字符，利用 mask 截断保留低位
            val = ((val << 1) & mask) | (s[i] == '1')
            
            # 数组寻址判断
            if not seen[val]:
                seen[val] = True
                count += 1
                # 提前退出
                if count == target:
                    return True
                    
        return False
```

```Java
// java
class Solution {
    public boolean hasAllCodes(String s, int k) {
        // 理论最短长度剪枝
        int target = 1 << k;
        if (s.length() < target + k - 1) {
            return false;
        }

        // 固定大小的布尔数组
        boolean[] seen = new boolean[target];
        // 已经找到的子串数
        int count = 0;
        int mask = target - 1;
        
        // 初始化第一个窗口
        int val = 0;
        for (int i = 0; i < k - 1; i++) {
            val = (val << 1) | (s.charAt(i) - '0');
        }
            
        // 开始滑动
        for (int i = k - 1; i < s.length(); i++) {
            // 移位并加入新字符，利用 mask 截断保留低位
            val = ((val << 1) & mask) | (s.charAt(i) - '0');
            
            // 数组寻址判断
            if (!seen[val]) {
                seen[val] = true;
                count += 1;
                // 提前退出
                if (count == target) {
                    return true;
                }
            }
        }
                
        return false;
    }
}
```

- 时间复杂度： $O(n)$，位运算的时间为 $O(1)$
- 空间复杂度： $O(2^k)$，表示数组 $seen$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solutions/3906732/shuang-jie-bao-li-hua-chuang-wei-yun-sua-69dt/)
