[Problem: 2211. 统计道路上的碰撞次数](https://leetcode.cn/problems/count-collisions-on-a-road/description/)

### 方法：脑筋急转弯

题意很简单，注意碰撞发生后，车辆会停在原地不动（~~物理学动量不存在~~）。

公路一维无限长，本质上，车辆只有 “停止” 或者 “一直移动” 两种可能。

**排除绝对安全的车**：

- **左边的 'L'**：如果一辆车在最左边且向左开 $L$，它左边没有任何车，它会无限向左行驶，永远不会发生碰撞。
- **右边的 'R'**：如果一辆车在最右边且向右开 $R$，它右边没有任何车，它会无限向右行驶，永远不会发生碰撞。

**中间的碰撞区**：

- 去掉上述两种 “安全车” 后，剩下的字符串片段，从第一个非 $L$ 到最后一个非 $R$，就是 “碰撞区” 。在这个区域内，所有的移动车辆最终都会 **停下来**。
- 任何向右开 $R$ 的车，最终都会撞上 $S$，或者是被迫停止的另一辆车。
- 任何向左开 $L$ 的车，最终也都会撞上。

该如何计分？可以将规则进行转化：

- $R$ 撞 $L$： $+2$ 分，相当于 $R$ 贡献 $1$ 分，且 $L$ 贡献 $1$ 分。
- $R$ 撞 $S$： $+1$ 分，也即 $R$ 贡献 $1$ 分。
- $S$ 撞 $L$： $+1$ 分，也即 $L$ 贡献 $1$ 分。

**结论**：在去掉了两端安全的车之后，剩余字符串中，每一个 **'L'** 和每一个 **'R'** 都会贡献 $1$ 次碰撞计数。

因此，我们采取两步走：第一步使用双指针，首先排除左右两侧永不碰撞的车辆，然后统计中间段里非 $S$ 的字符总数。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countCollisions(self, directions: str) -> int:
        left = 0
        right = len(directions) - 1

        # 跳过左边所有的 'L'
        while left <= right and directions[left] == 'L':
            left += 1

        # 跳过右边所有的 'R'
        while left <= right and directions[right] == 'R':
            right -= 1

        # 统计中间段非 'S' 的字符个数
        ans = 0
        for i in range(left, right + 1):
            if directions[i] != 'S':
                ans += 1

        return ans
```

```Java
// java
class Solution {
    public int countCollisions(String directions) {
        int left = 0;
        int right = directions.length() - 1;

        // 跳过左边所有的 'L'
        while (left <= right && directions.charAt(left) == 'L') {
            left++;
        }

        // 跳过右边所有的 'R'
        while (left <= right && directions.charAt(right) == 'R') {
            right--;
        }

        // 统计中间段非 'S' 的字符个数
        int ans = 0;
        for (int i = left; i <= right; i++) {
            if (directions.charAt(i) != 'S') {
                ans++;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是串 $directions$ 的长度，每个字符遍历一次
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 调库

从字符串的角度考虑，将左侧的 $L$ 删除，右侧的 $R$ 删除，然后统计串中 $S$ 的数量。这三步都可以调库实现，实测速度比上面的一次遍历速度更快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countCollisions(self, directions: str) -> int:
        # 去掉最左边所有向左开的车
        temp = directions.lstrip('L')
        # 去掉最右边所有向右开的车
        temp = temp.rstrip('R')
        # 碰撞总数 = 剩下的总长度 - 静止车('S')的数量
        return len(temp) - temp.count('S')
```

```Java
// java
class Solution {
    public int countCollisions(String directions) {
        // 去掉最左边所有向左开的车
        String temp = directions.replaceFirst("^L+", "");
        // 去掉最右边所有向右开的车
        temp = temp.replaceFirst("R+$", "");
        // 碰撞总数 = 剩下的总长度 - 静止车('S')的数量
        int sCount = temp.length() - temp.replace("S", "").length();
        return temp.length() - sCount;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$，表示串 $temp$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-collisions-on-a-road/solutions/3848813/shuang-jie-zuo-zuo-you-you-yong-bu-zhuan-s5k4/)
