[Problem: 2154. 将找到的值乘以 2](https://leetcode.cn/problems/keep-multiplying-found-values-by-two/description/)

### 方法：模拟 & 位运算

让 $original$ 不断乘 $2$，直至 $nums$ 中找不到这个数。

使用一个 $set$ **集合** 提前存储 $nums$ 中所有数，这样能 $O(1)$ 时间判断数字是否存在。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        # 转为集合，方便查找
        nums_set = set(nums)
        # 循环检查
        while original in nums_set:
            original *= 2
        return original
```

```Java
// java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        // 转为集合，方便查找
        Set<Integer> numsSet = new HashSet<>();
        for (int num : nums) {
            numsSet.add(num);
        }

        // 循环检查
        while (numsSet.contains(original)) {
            original *= 2;
        }
        
        return original;
    }
}
```

将 $nums$ 所有数字放入集合，消耗时间为 $O(n)$。不断让数字 $\times 2$，最大上限为数组中的最大值 $M$，也即时间为 $O(min(n,log_2{M}))$，一般远小于 $n$，下面不放入复杂度。

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示集合 $set$ 的大小

---

### 位运算

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 对应的二进制数为 $10011$。

通过 **移位** 的方式，可以快速判断某个数是否在集合中或者添加某个数到集合中。第 $nums[i]$ 位为 $1$ 就表示 $nums[i]$ 在集合中，增加一个数就代表将第 $nums[i]$ 位置 $1$。

举个例子，状态 $0010$ 表示包含数字 $1$，而 $0010|(1<<2) = 0110$ 就表示在此基础上，增加一个 $2$。而 $(0110>>2)$ & $1=1$ 就说明集合中包含 $2$，反之等于 $0$ 就说明没包含。

使用 `|` 运算将数字放到掩码中，以及 `&` 运算判断数字是否存在。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        bit_map = 0
        # 构建位图
        for num in nums:
            bit_map |= 1 << num

        # 循环检查
        while (1 << original) & bit_map:
            # 如果找到，将 original 乘以 2
            original <<= 1
        
        return original
```

```Java
// java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        // 创建一个大小为1001的布尔数组来模拟位图
        boolean[] seen = new boolean[1001];
        
        // 构建"位图"
        for (int num : nums) {
            seen[num] = true;
        }

        // 循环检查
        while (seen[original]) {
            // 如果找到，将 original 乘以 2
            original <<= 1;
        }
        
        return original;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/keep-multiplying-found-values-by-two/solutions/3836198/shuang-jie-setmo-ni-wei-yun-suan-xie-fa-fme3b/)
