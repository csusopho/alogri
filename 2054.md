[Problem: 2054. 两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/description/)

### 方法：二分 & 最小堆 & 双指针

题意比较清晰，注意 **最多选两个**，不能选两个以上。

首先，我们应该将数组 $events$ 进行 **排序**，按照 “开始/结束时间” 均可。确保遍历到第 $i$ 个活动时，所有可能作为 “第一个活动” 的候选者都在它的左侧。

暴力想法就是双 $for$，枚举第二个活动，并向前寻找第一个活动。满足 “第一个结束时间” < “第二个开始时间”，两者无重叠，然后记录最大和。

时间复杂度为 $O(n^2)$，题目限制 $n\leq 10^5$，所以会超时。

一种简单的 **想法**：第二个 $for$ 循环本质是找最大价值的 “第一个活动”，因此如果提前得到 “某个时间点之前结束的所有活动中的最大价值”，那就能快速得出答案。

维护一个 **前缀最大** 数组 $preMax$，其中 $preMax[i]$ 表示前 $i$ 个活动（即 $events[0...i]$）中，单个活动能提供的最大价值。

这里，我们对 $events$ 按照 “结束时间” 排序，并使用一个列表 $ends$ 存储排好序的结束时间。

那么，对于当前 “第二个活动” $events[i]$，假设其开始时间为 $s$。目标是在列表 $ends$ 中，找到 **最后一个** 满足 $endTime < s$ 的活动索引 $j$。

- 如果找到了这样的 $j$，那么最大价值就是 $events[i].value + preMax[j]$。
- 由于结束时间升序，可以使用二分查找在 $ends$ 内找到 $j$。

总结：先排序，预处理 $ends,preMax$ 数组；枚举第二个活动，二分查找 $ends$ 数组，找到最晚结束索引，并利用 $preMax$ 求出最大和。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        # 按结束时间排序
        events.sort(key=lambda x: x[1])
        n = len(events)
        # 提取排序后的结束时间
        ends = [e[1] for e in events]
        
        # pre_max[i] 表示前 i 个活动中的最大价值
        pre_max = [0] * n
        pre_max[0] = events[0][2]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i-1], events[i][2])
            
        ans = 0
        
        # 第二个活动
        for i in range(n):
            s, e, v = events[i]
            # 只参加当前这一个活动
            ans = max(ans, v)
            
            # 找到最后一个结束时间 < 当前开始时间 s 的活动
            idx = bisect.bisect_left(ends, s) - 1
            
            if idx >= 0:
                # 存在不重叠的活动，取该位置的前缀最大价值
                ans = max(ans, v + pre_max[idx])
         
        return ans
```

```Java
// java
class Solution {
    public int maxTwoEvents(int[][] events) {
        // 按结束时间排序
        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));
        int n = events.length;
        // 提取排序后的结束时间
        int[] ends = new int[n];
        for (int i = 0; i < n; i++) {
            ends[i] = events[i][1];
        }
        
        // pre_max[i] 表示前 i 个活动中的最大价值
        int[] preMax = new int[n];
        preMax[0] = events[0][2];
        for (int i = 1; i < n; i++) {
            preMax[i] = Math.max(preMax[i - 1], events[i][2]);
        }
            
        int ans = 0;
        
        // 第二个活动
        for (int i = 0; i < n; i++) {
            int s = events[i][0];
            int v = events[i][2];
            // 只参加当前这一个活动
            ans = Math.max(ans, v);
            
            // 找到最后一个结束时间 < 当前开始时间 s 的活动
            int idx = search(ends, s) - 1;
            
            if (idx >= 0) {
                // 存在不重叠的活动，取该位置的前缀最大价值
                ans = Math.max(ans, v + preMax[idx]);
            }
        }
         
        return ans;
    }

    private int search(int[] arr, int x) {
        int low = 0, high = arr.length;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] < x) low = mid + 1;
            else high = mid;
        }
        return low;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $events$ 的长度，快排+二分
- 空间复杂度： $O(n)$，表示数组 $ends,preMax$ 的大小，忽略排序的 $O(logn)$ 栈开销

---

### 最小堆

手动二分寻找还是有些慢，可以利用有序的数据结构，帮助我们快速寻找。

将所有活动 $events$ 按照 “开始时间” 进行升序。同时，使用一个 **最小堆** 来动态维护，已经开始但尚未 “释放” 价值的已经遍历过的活动。

这种方法的 **关键点**：维护一个 “目前为止已结束活动的最大价值” $maxPre$。

- 堆中存储 $(endTime, value)$。
- 遍历当前活动 $(s, e, v)$ 时，检查堆顶元素的 $endTime$。
- 如果堆顶的 $endTime < s$，说明该活动已经结束。将其从堆中弹出，并用它的价值 $val$ + 当前活动价值 $v$，更新答案。

$maxPre$ 始终代表了在当前时刻之前，你可以通过参加 **一个** 活动获得的最大收益。将它与当前活动的价值相加，自然就得到了参加 **两个** 不重叠活动的最大收益。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        # 按开始时间排序
        events.sort()
        # min_heap 存储 (结束时间, 价值)
        min_heap = []
        # 当前活动开始前，已经结束的所有活动中的最大价值
        max_prev = 0
        ans = 0
        
        for s, e, v in events:
            # 这些活动与当前活动不重叠
            while min_heap and min_heap[0][0] < s:
                _, val = heapq.heappop(min_heap)
                max_prev = max(max_prev, val)
            
            # 更新全局最大
            ans = max(ans, max_prev + v)
            # 当前活动放入堆中
            heapq.heappush(min_heap, (e, v))
            
        return ans
```

```Java
// java
class Solution {
    public int maxTwoEvents(int[][] events) {
        // 按开始时间排序
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));
        // min_heap 存储 (结束时间, 价值)
        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        // 当前活动开始前，已经结束的所有活动中的最大价值
        int maxPrev = 0;
        int ans = 0;
        
        for (int[] event : events) {
            int s = event[0], e = event[1], v = event[2];
            // 这些活动与当前活动不重叠
            while (!minHeap.isEmpty() && minHeap.peek()[0] < s) {
                int[] prev = minHeap.poll();
                maxPrev = Math.max(maxPrev, prev[1]);
            }
            
            // 更新全局最大
            ans = Math.max(ans, maxPrev + v);
            // 当前活动放入堆中
            minHeap.offer(new int[]{e, v});
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(n)$

剪枝：如果当前事件价值 $v$ 比之前单个事件的最大价值 $maxPre$ 大，则加入堆，否则就不加入堆。这种方法可以明显缩减堆的大小，但是实测速度反而更慢，这里不再展示。

---

### 双指针

堆操作（插入和弹出）在循环中会带来额外的常数开销。

更优的方案：将所有活动按 **开始时间** 排序，作为第二个活动；同时准备一份按 **结束时间** 排序的副本，作为第一个活动。

- 维护一个指针 $i$，指向 “结束时间” 排序的活动列表。主循环遍历 “开始时间” 排序的活动列表，作为指针 $j$。
- 从前往后遍历，开始时间 $s$ 递增，满足 $endTime < s$ 的活动会不断增加。
- 因此，指针 $i$ 也是线性地向右移动，同理更新 “目前已结束活动的最大价值” $maxPre$。

这种 **“离线处理 + 双指针”** 的技巧，将原本需要动态维护的堆转化成了静态排序后的线性扫描，执行效率最快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        # 按开始时间排序，作为 “当前第二个” 活动
        start_sort = sorted(events, key=lambda x: x[0])
        # 按结束时间排序，作为 “之前第一个” 活动
        end_sort = sorted(events, key=lambda x: x[1])
        # 已经结束的活动中的最大价值
        max_prev = 0
        ans = 0
        # 在 end_sort 中移动
        i = 0
        n = len(events)
        
        # 第二个活动
        for s, e, v in start_sort:
            # 找出所有在当前活动开始时间 s 之前结束的活动
            while i < n and end_sort[i][1] < s:
                if end_sort[i][2] > max_prev:
                    max_prev = end_sort[i][2]
                i += 1
            
            # 更新最大
            if max_prev + v > ans:
                ans = max_prev + v
        
        return ans
```

```Java
// java
class Solution {
    public int maxTwoEvents(int[][] events) {
        int n = events.length;
        // 按开始时间排序，作为 “当前第二个” 活动
        int[][] startSort = events.clone();
        Arrays.sort(startSort, (a, b) -> Integer.compare(a[0], b[0]));
        // 按结束时间排序，作为 “之前第一个” 活动
        int[][] endSort = events.clone();
        Arrays.sort(endSort, (a, b) -> Integer.compare(a[1], b[1]));
        
        // 已经结束的活动中的最大价值
        int maxPrev = 0;
        int ans = 0;
        // 在 endSort 中移动
        int i = 0;
        
        // 第二个活动
        for (int[] event : startSort) {
            int s = event[0], v = event[2];
            // 找出所有在当前活动开始时间 s 之前结束的活动
            while (i < n && endSort[i][1] < s) {
                if (endSort[i][2] > maxPrev) {
                    maxPrev = endSort[i][2];
                }
                i++;
            }
            
            // 更新最大
            if (maxPrev + v > ans) {
                ans = maxPrev + v;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(n)$

经实测，从上往下的三段代码的时间/空间都在同步缩小，第三种方法最优。

如果不限制选几个，那就变为 “区间调度问题”。一个活动要么参加，要么不参加，通常使用 动规+二分 解决。定义 $dp[i]$ 表示参加前 $i$ 个活动能获得的最大价值，并用二分寻找 “最后一个结束时间” $\le$ “当前开始时间”。具体例题是 $1235$，感兴趣的可以去试试。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/two-best-non-overlapping-events/solutions/3863474/san-jie-qian-zhui-zui-da-er-fen-zui-xiao-zklg/)
