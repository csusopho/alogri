[Problem: 904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/description/)

### 方法：滑窗

数字代表水果种类，一棵树上只摘一个水果，必须连续采摘。人话就是：挑选子数组，里面至多有两种数字，求最大长度。

子数组越长，包含的数字种类有可能越多，具有 **单调性**，因此想到 **滑动窗口**。

滑窗的本质就是让一个数从一端进来，让其他数从另一端退出。这样的过程使得暴力双 $for$ 枚举变为了一次遍历，从而降低时间复杂度。具体的原理推导，以及实现过程，可以看看这篇题解 [双指针](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solutions/2901292/yi-ti-shuang-jie-shuang-zhi-zhen-ha-xi-e-cods/)。

**简述**：这里是枚举右指针，也就是找出所有 $r$ 对应的 $l$，只不过滑窗的复用性，使得我们不必再浪费一个 $for$ 去暴力查找 $l$。

对于本题来说，使用双指针维护一个窗口。右指针移入元素，左指针移出元素，就达到了更换子数组的效果。

如何得知窗口内有几种元素？经典做法 —— 使用 **哈希** 进行记录。具体来说，就是定义一个哈希 $Map$，存储窗口内的水果种类。

**过程**：在移动右指针（增加右边界元素）后，更新哈希；一旦出现第三种水果（哈希长度 $>2$），右移左指针（移除左边界元素），直至去除第一种水果。

代码如下，已附加注释：

```Python
# python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        basket = defaultdict(int)  # 记录当前窗口内的水果种类及其数量
        left = 0
        ans = 0
        
        for right in range(len(fruits)):
            basket[fruits[right]] += 1  # 将右边界水果加入篮子
            
            # 如果篮子中的水果种类超过2种，移动左边界
            while len(basket) > 2:
                basket[fruits[left]] -= 1
                if basket[fruits[left]] == 0:
                    del basket[fruits[left]]  # 如果某种水果数量为0，移除该键
                left += 1
            
            # 更新最大子数组长度
            ans = max(ans, right - left + 1)
        
        return ans
```

```Java
// java
class Solution {
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> basket = new HashMap<>(); // 记录当前窗口内的水果种类及其数量
        int left = 0;
        int ans = 0;

        for (int right = 0; right < fruits.length; right++) {
            // 将右边界水果加入篮子
            basket.put(fruits[right], basket.getOrDefault(fruits[right], 0) + 1);

            // 如果篮子中的水果种类超过2种，移动左边界
            while (basket.size() > 2) {
                int count = basket.get(fruits[left]) - 1;
                if (count == 0) {
                    basket.remove(fruits[left]); // 如果某种水果数量为0，移除该键
                } else {
                    basket.put(fruits[left], count);
                }
                left++;
            }

            // 更新最大子数组长度
            ans = Math.max(ans, right - left + 1);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $fruits$ 的长度，双指针最多各移动一遍数组，计算以及更新哈希的时间为 $O(1)$
- 空间复杂度： $O(1)$，表示哈希 $basket$ 的大小

---

### 优化

先叠甲，下面的代码是我查看通过速度最快的示范，这里分享个人思路。

已知窗口内最多两种水果，所以定义 $a,b$ 分别表示 **前一种**，**当前** 的水果种类。这样，只需要检查新加入的水果与这两者的关系，举例：

```Java
过程                a     b
原本值             -1    -1
加入水果 2         -1     2
加入水果 3          2     3
加入水果 2          2     3
加入水果 4          3     4
```

同理，这里 $ans$ 的更新就要放在第三种水果加入时。

最大的 **优化点**：加入第三种水果时，使用指针寻找的是第二种水果的起始位置，从 $r$ 位置倒序查找，**滚动更新** $a$ 为第二种水果，而 $b$ 为第三种水果。

这是懒更新方式，所以最后还要计算一次 $ans$。

代码如下，已附加详细注释帮助理解：

```Python
# python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        left = 0  # 左指针
        a, b = -1, -1  # 当前窗口内，前一种水果，当前水果
        ans = 0

        for right, x in enumerate(fruits):
            if a == -1:  # 两种水果都还没初始化
                a, b = b, x
            elif not (x == a or x == b):  # 遇到第三种水果
                # 此时才进行更新！
                ans = max(ans, right - left)
                # 从右向左找到，当前水果b的起始位置
                i = right - 2
                while i >= 0 and fruits[i] == fruits[right - 1]:
                    i -= 1
                left = i + 1
                a, b = fruits[right - 1], x  # 更新窗口中的两种水果

        ans = max(ans, right - left + 1)  # 最后一段窗口长度更新
        return ans
```

```Java
// java
class Solution {
    public int totalFruit(int[] fruits) {
        int left = 0;         // 左指针
        int a = -1, b = -1;   // 当前窗口内，前一种水果，当前水果
        int ans = 0;

        for (int right = 0; right < fruits.length; right++) {
            int x = fruits[right];

            if (a == -1) {  // 两种水果都还没初始化
                a = b;
                b = x;
            } else if (x != a && x != b) {  // 遇到第三种水果
                // 此时才进行更新！
                ans = Math.max(ans, right - left);

                // 从右向左找到，当前水果b的起始位置
                int i = right - 2;
                while (i >= 0 && fruits[i] == fruits[right - 1]) {
                    i--;
                }

                left = i + 1;              // 移动左指针
                a = fruits[right - 1];     // 更新窗口中的两种水果
                b = x;
            }
        }

        // 最后一段窗口长度更新
        ans = Math.max(ans, fruits.length - left);
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，同理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/fruit-into-baskets/solutions/3741875/hua-chuang-po-su-xie-fa-gun-dong-geng-xi-l3dn/)
