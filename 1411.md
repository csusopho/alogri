[Problem: 1411. 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/description/)

### 方法：DP & 优化 & 数学

为了方便表述，将 “红、黄、绿” 三种颜色记作 $0,1,2$。

**最直观的想法**：枚举当前这一行的所有颜色可能，然后根据当前行的结果，枚举下一行的所有颜色可能，不断递推下去。

比如当前行颜色是 $012$，由于垂直方向颜色必须不同，所以下一行的第一个颜色可能是 $1,2$

```Java
第一个颜色是 1 时
上一行 01，下一行 10    可能
上一行 01，下一行 11    水平不符合
上一行 01，下一行 12    可能

第一个颜色是 2 时
上一行 01，下一行 20    可能
上一行 01，下一行 21    垂直不符合
上一行 01，下一行 22    水平不符合
```

下一行的前两个颜色可能是 $10,12,20$，接着枚举第三个颜色

```Java
第一个颜色是 10 时
上一行 012，下一行 100    水平不符合
上一行 012，下一行 101    可能
上一行 012，下一行 102    垂直不符合

第一个颜色是 12 时
上一行 012，下一行 120    可能
上一行 012，下一行 121    可能
上一行 012，下一行 122    水平不符合

第一个颜色是 20 时
上一行 012，下一行 200    水平不符合
上一行 012，下一行 201    可能
上一行 012，下一行 202    垂直不符合
```

因此，通过三重枚举，得出 $101,120,121,201$ 四种答案。~~本质是树形结构，原谅本人不会画图~~

按行递推，每个子问题的解法相同，将父问题 -> 子问题，可以使用 “动态规划”。

**定义** $dp[i][c_1][c_2][c_3]$ 表示当前正在处理第 $i$ 行，而 $c_1,c_2,c_3$ 的值为 $0,1,2$ 代表三列的颜色。这一行涂成颜色 $(c_1, c_2, c_3)$ 时，从第 $0$ 行到第 $i$ 行所有的合法涂色方案数。

初始化：对于第 $0$ 行，只要 $(c_1, c_2, c_3)$ 满足水平不冲突，即 $c_1 \neq c_2$ 且 $c_2 \neq c_3$，赋值 $1$。

**状态转移**： $dp[i][c_1][c_2][c_3]$ 的值来源于上一行 $dp[i-1][\dots]$ 的所有合法状态之和。也就是说，遍历上一行的颜色 $(p_1, p_2, p_3)$，如果满足垂直不冲突，即 $c_1 \neq p_1, c_2 \neq p_2, c_3 \neq p_3$，就累加。

$$
dp[i][c_1][c_2][c_3] = \sum_{p_1, p_2, p_3} dp[i-i][p_1][p_2][p_3]
$$

最终，第 $n$ 行的结果存储在 $dp[n-1][\dots]$ 中，累加所有可行方案数。

这里有 $6$ 层嵌套循环，当前行颜色 $3$ 层，上一行颜色 $3$ 层。已知 $3^6 = 729$，对于 $n=5000$，计算次数约为 $3.6 \times 10^6$，勉强可以通过。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
        # dp[i][0][1][2] 存储 “第 i 行涂成红-黄-绿” 的累计方案数
        dp = [[[[0] * 3 for _ in range(3)] for _ in range(3)] for _ in range(n)]
        
        # 处理第 0 行
        for c1 in range(3):
            for c2 in range(3):
                for c3 in range(3):
                    # 仅检查行内冲突
                    if c1 != c2 and c2 != c3:
                        dp[0][c1][c2][c3] = 1
        
        # 递推后续行
        for i in range(1, n):
            # 枚举当前行 i 的所有颜色组合
            for c1 in range(3):
                for c2 in range(3):
                    if c1 == c2: continue # 剪枝：行内冲突
                    for c3 in range(3):
                        if c2 == c3: continue # 剪枝：行内冲突
                        
                        # 枚举上一行的所有颜色组合
                        for p1 in range(3):
                            if c1 == p1: continue # 剪枝：垂直冲突
                            for p2 in range(3):
                                if c2 == p2: continue # 剪枝：垂直冲突
                                for p3 in range(3):
                                    if c3 == p3: continue # 剪枝：垂直冲突
                                    
                                    # 状态转移：累加上一行的方案数
                                    dp[i][c1][c2][c3] = (dp[i][c1][c2][c3] + dp[i-1][p1][p2][p3]) % MOD
                                    
        # 统计最后一行的所有方案数
        ans = 0
        for c1 in range(3):
            for c2 in range(3):
                for c3 in range(3):
                    ans = (ans + dp[n-1][c1][c2][c3]) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int numOfWays(int n) {
        int MOD = 1000000007;
        // dp[i][0][1][2] 存储 “第 i 行涂成红-黄-绿” 的累计方案数
        int[][][][] dp = new int[n][3][3][3];

        // 处理第 0 行
        for (int c1 = 0; c1 < 3; c1++) {
            for (int c2 = 0; c2 < 3; c2++) {
                for (int c3 = 0; c3 < 3; c3++) {
                    // 仅检查行内冲突
                    if (c1 != c2 && c2 != c3) {
                        dp[0][c1][c2][c3] = 1;
                    }
                }
            }
        }

        // 递推后续行
        for (int i = 1; i < n; i++) {
            // 枚举当前行 i 的所有颜色组合
            for (int c1 = 0; c1 < 3; c1++) {
                for (int c2 = 0; c2 < 3; c2++) {
                    if (c1 == c2) continue; // 剪枝：行内冲突
                    for (int c3 = 0; c3 < 3; c3++) {
                        if (c2 == c3) continue; // 剪枝：行内冲突

                        // 枚举上一行的所有颜色组合
                        for (int p1 = 0; p1 < 3; p1++) {
                            if (c1 == p1) continue; // 剪枝：垂直冲突
                            for (int p2 = 0; p2 < 3; p2++) {
                                if (c2 == p2) continue; // 剪枝：垂直冲突
                                for (int p3 = 0; p3 < 3; p3++) {
                                    if (c3 == p3) continue; // 剪枝：垂直冲突

                                    // 状态转移：累加上一行的方案数
                                    dp[i][c1][c2][c3] = (dp[i][c1][c2][c3] + dp[i - 1][p1][p2][p3]) % MOD;
                                }
                            }
                        }
                    }
                }
            }
        }

        // 统计最后一行的所有方案数
        int ans = 0;
        for (int c1 = 0; c1 < 3; c1++) {
            for (int c2 = 0; c2 < 3; c2++) {
                for (int c3 = 0; c3 < 3; c3++) {
                    ans = (ans + dp[n - 1][c1][c2][c3]) % MOD;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(C\times n)$，其中 $C=3^6$ 表示枚举次数
- 空间复杂度： $O(D \times n)$，其中 $D=3^3$，表示数组 $dp$ 的大小

---

### 状态压缩

在同一行内，相邻格子颜色不能相同。根据示例 $1$ 可知，一行的合法状态仅有 $12$ 种。因此，每一行的状态只需要从这 $12$ 种里面进行枚举！

同时，每次枚举都需要判断当前行与上一行是否冲突，有些麻烦。提前预处理，计算出每一行与它不冲突的所有状态。比如与 $012$ 不冲突的只有 $101,120,121,201$。

**定义** $dp[i][state]$ 表示第 $i$ 行涂成 $state$ 这种颜色组合的方案总数。

为了节省空间，使用 **位运算** 的方式，将 $(c_1,c_2,c_3)$ 压缩为一维。每种颜色有 $3$ 种可能，所以使用三进制，将集合压缩为 $int$ 类型，规则是 $c_1\times 9 + c_2\times 3 + c_3$。

比如上面的 $012$ 可以变为 $0\times 9+1\times 3+2\times 1=5$，这样确保任意状态不会重复。

**总结**：使用 $pattern$ 记录 $12$ 种合法状态，然后预处理出 $related[i]$ 存储所有可以接在 $pattern[i]$ 后面的状态索引。主循环内，枚举上一行状态，检查当前行，更新 $dp$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
        
        # 预处理所有合法的单行状态
        # 使用三进制数表示：pattern = c1 * 9 + c2 * 3 + c3
        patterns = []
        for i in range(3):
            for j in range(3):
                for k in range(3):
                    # 行内相邻格子颜色不同
                    if i != j and j != k:
                        patterns.append(i * 9 + j * 3 + k)
        
        # 12种合法状态
        m = len(patterns)
        # 预处理状态兼容性
        # related[i] 存储所有可以接在 patterns[i] 后面的状态索引
        related = [[] for _ in range(m)]
        
        for i in range(m):
            # 解析当前行状态 patterns[i] 的三个颜色
            p1 = patterns[i]
            c1, c2, c3 = p1 // 9, (p1 // 3) % 3, p1 % 3

            # 枚举所有可能的下一行
            for j in range(m):
                p2 = patterns[j]
                # 解析
                n1, n2, n3 = p2 // 9, (p2 // 3) % 3, p2 % 3
                # 垂直方向检查
                if c1 != n1 and c2 != n2 and c3 != n3:
                    related[i].append(j)
        
        # dp[i][j] 表示第 i 行采用第 j 种 pattern 时的方案数
        dp = [[0] * m for _ in range(n + 1)]
        
        # 初始化，所有合法 pattern 各有 1 种方案
        for j in range(m):
            dp[1][j] = 1
            
        # 递推后续行
        for i in range(2, n + 1):
            for curr_idx in range(m):
                # 枚举上一行状态 prev_idx
                for prev_idx in range(m):
                    # 检查上一行与当前行是否兼容
                    if curr_idx in related[prev_idx]: 
                        dp[i][curr_idx] = (dp[i][curr_idx] + dp[i - 1][prev_idx]) % MOD

        # 最后一行的所有方案数
        return sum(dp[n]) % MOD
```

```Java
// java
class Solution {
    public int numOfWays(int n) {
        int MOD = 1000000007;

        // 预处理所有合法的单行状态
        // 使用三进制数表示：pattern = c1 * 9 + c2 * 3 + c3
        List<Integer> patterns = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    // 行内相邻格子颜色不同
                    if (i != j && j != k) {
                        patterns.add(i * 9 + j * 3 + k);
                    }
                }
            }
        }

        // 12种合法状态
        int m = patterns.size();
        // 预处理状态兼容性
        // related[i] 存储所有可以接在 patterns[i] 后面的状态索引
        List<Integer>[] related = new ArrayList[m];
        for (int i = 0; i < m; i++) {
            related[i] = new ArrayList<>();
        }

        for (int i = 0; i < m; i++) {
            // 解析当前行状态 patterns[i] 的三个颜色
            int p1 = patterns.get(i);
            int c1 = p1 / 9, c2 = (p1 / 3) % 3, c3 = p1 % 3;

            // 枚举所有可能的下一行
            for (int j = 0; j < m; j++) {
                int p2 = patterns.get(j);
                // 解析
                int n1 = p2 / 9, n2 = (p2 / 3) % 3, n3 = p2 % 3;
                // 垂直方向检查
                if (c1 != n1 && c2 != n2 && c3 != n3) {
                    related[i].add(j);
                }
            }
        }

        // dp[i][j] 表示第 i 行采用第 j 种 pattern 时的方案数
        int[][] dp = new int[n + 1][m];

        // 初始化，所有合法 pattern 各有 1 种方案
        for (int j = 0; j < m; j++) {
            dp[1][j] = 1;
        }

        // 递推后续行
        for (int i = 2; i <= n; i++) {
            for (int curr_idx = 0; curr_idx < m; curr_idx++) {
                // 枚举上一行状态 prev_idx
                for (int prev_idx = 0; prev_idx < m; prev_idx++) {
                    // 检查上一行与当前行是否兼容
                    if (related[prev_idx].contains(curr_idx)) {
                        dp[i][curr_idx] = (dp[i][curr_idx] + dp[i - 1][prev_idx]) % MOD;
                    }
                }
            }
        }

        // 最后一行的所有方案数
        int ans = 0;
        for (int val : dp[n]) {
            ans = (ans + val) % MOD;
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n\times D^2)$，其中 $D=12$ 表示合法状态数
- 空间复杂度： $O(n\times D)$，表示 $dp$ 以及 $related$ 的大小

---

### 滚动

上面代码的逻辑有点冗余，第一个 $for$ 枚举 $pattern$ 中的有效方案，那第二个 $for$ 直接枚举有效的下一行就行，完全没必要再检查。

同时，这种位运算压缩形式实际没有很大提升运行速度。因此，可以考虑使用 `(0, 1, 0)` 元组表示状态，在 $Python$ 中这样的形式运行更快。

使用第一维的 $i$ 就是方便理解，可以使用 **滚动数组** 的形式： $dp$ 字典保存上一行的结果， $newDp$ 保存当前行的计算结果。计算完成后用 $newDp$ 覆盖 $dp$。

实测上面的 $Python$ 耗时为 $671ms$，下面的耗时为 $367ms$。在所有方法中，这种方法消耗的空间最小。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
    
        # 生成所有单行合法的涂色方案
        valid_patterns = []
        for c1 in range(3):
            for c2 in range(3):
                for c3 in range(3):
                    if c1 != c2 and c2 != c3:
                        valid_patterns.append((c1, c2, c3))
        
        # 检查任意两个 pattern 是否可以作为相邻的两行
        # adj[p] 存储所有可以放在 p 下一行的 pattern
        adj = {p: [] for p in valid_patterns}
        for p1 in valid_patterns:
            for p2 in valid_patterns:
                # 检查三列
                if p1[0] != p2[0] and p1[1] != p2[1] and p1[2] != p2[2]:
                    adj[p1].append(p2)
        
        # dp[pattern] 表示当前行涂成 pattern 的方案数
        # 第一行没有任何限制，初始方案数为 1
        dp = {p: 1 for p in valid_patterns}
        
        # 从第 2 行到第 n 行
        for _ in range(n - 1):
            new_dp = {p: 0 for p in valid_patterns}
            
            # 上一行的状态
            for prev_p in valid_patterns:
                # 查找所有能接在 prev_p 下面的当前行状态 curr_p
                for curr_p in adj[prev_p]:
                    new_dp[curr_p] = (new_dp[curr_p] + dp[prev_p]) % MOD
            
            # 更新 dp 表
            dp = new_dp
        
        # 最后一行所有可能状态的方案数之和
        return sum(dp.values()) % MOD
```

```Java
// java
class Solution {
    public int numOfWays(int n) {
        int MOD = 1000000007;

        // 生成所有单行合法的涂色方案
        List<List<Integer>> valid_patterns = new ArrayList<>();
        for (int c1 = 0; c1 < 3; c1++) {
            for (int c2 = 0; c2 < 3; c2++) {
                for (int c3 = 0; c3 < 3; c3++) {
                    if (c1 != c2 && c2 != c3) {
                        valid_patterns.add(Arrays.asList(c1, c2, c3));
                    }
                }
            }
        }

        // 检查任意两个 pattern 是否可以作为相邻的两行
        // adj[p] 存储所有可以放在 p 下一行的 pattern
        Map<List<Integer>, List<List<Integer>>> adj = new HashMap<>();
        for (List<Integer> p : valid_patterns) {
            adj.put(p, new ArrayList<>());
        }

        for (List<Integer> p1 : valid_patterns) {
            for (List<Integer> p2 : valid_patterns) {
                // 检查三列
                if (!p1.get(0).equals(p2.get(0)) && 
                    !p1.get(1).equals(p2.get(1)) && 
                    !p1.get(2).equals(p2.get(2))) {
                    adj.get(p1).add(p2);
                }
            }
        }

        // dp[pattern] 表示当前行涂成 pattern 的方案数
        // 第一行没有任何限制，初始方案数为 1
        Map<List<Integer>, Integer> dp = new HashMap<>();
        for (List<Integer> p : valid_patterns) {
            dp.put(p, 1);
        }

        // 从第 2 行到第 n 行
        for (int i = 0; i < n - 1; i++) {
            Map<List<Integer>, Integer> new_dp = new HashMap<>();
            for (List<Integer> p : valid_patterns) {
                new_dp.put(p, 0);
            }

            // 上一行的状态
            for (List<Integer> prev_p : valid_patterns) {
                // 查找所有能接在 prev_p 下面的当前行状态 curr_p
                for (List<Integer> curr_p : adj.get(prev_p)) {
                    new_dp.put(curr_p, (new_dp.get(curr_p) + dp.get(prev_p)) % MOD);
                }
            }

            // 更新 dp 表
            dp = new_dp;
        }

        // 最后一行所有可能状态的方案数之和
        int ans = 0;
        for (int val : dp.values()) {
            ans = (ans + val) % MOD;
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n\times D^2)$，其中 $D=12$
- 空间复杂度： $O(D)$

---

### 数学

同一行内相邻格子颜色不同，即 $c_1 \neq c_2$ 且 $c_2 \neq c_3$。本质上，只需要关注 **颜色的相对关系**，而不是具体的颜色，比如 “红黄红” 和 “绿蓝绿” 在拓扑结构上是等价的。

根据第一个格子 $c_1$ 和第三个格子 $c_3$ 的颜色是否相同，将一行的涂色方案分为两类：

- $ABA$ 模式，例如 “红-绿-红”。
  - 第 $1$ 个格子有 $3$ 种选择
  - 第 $2$ 个格子有 $2$ 种选择，与第 $1$ 个不同
  - 第 $3$ 个格子有 $1$ 种选择，必须与第 $1$ 个相同
  - 初始方案有 $3 \times 2 \times 1 = 6$ 种
- $ABC$ 模式，例如 “红-绿-黄”。
  - 第 $1$ 个格子有 $3$ 种选择
  - 第 $2$ 个格子有 $2$ 种选择，与第 $1$ 个不同
  - 第 $3$ 个格子有 $1$ 种选择，与第 $1,2$ 个不同
  - 初始方案数有 $3 \times 2 \times 1 = 6$ 种

**情况** $A$：上一行是 $ABA$，比如 $1-2-1$ 时，

- 转移到下一行是 $ABA(x-y-x)$：
  - $x$ 不能是 $1$，所以 $x$ 可以是 $2$ 或 $3$。
  - 如果 $x=2$，与上一行中间相同，则 $y$ 可以取 $1$ 或 $3$，有 $2$ 种。
  - 如果 $x=3$，与上一行中间不同，则 $y$ 只能取 $1$，有 $1$ 种。
  - 合计 $2 + 1 = 3$ 种。
- 转移到下一行是 $ABC(x-y-z)$：
  - 类似上面的逻辑，经过穷举，合法的方案有 $2$ 种。

**情况** $B$：上一行是 $ABC$，比如 $1-2-3$ 时，

- 转移到下一行是 $ABA(x-y-x)$，合法的方案有 $2$ 种。
- 转移到下一行是 $ABC(x-y-z)$，合法的方案有 $2$ 种。

设 $a_i$ 为第 $i$ 行是 $ABA$ 模式的方案数，而 $b_i$ 为第 $i$ 行是 $ABC$ 模式的方案数。根据上面的转移关系，得出转移方程：

$$
a_{i} = a_{i-1} \times 3 + b_{i-1} \times 2 \\
b_{i} = a_{i-1} \times 2 + b_{i-1} \times 2
$$

**总结**：通过 “模式合并” 简化为两个状态 $ABA$ 和 $ABC$，然后简化 $DP$ 流程。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
        # 第一行的方案数
        # aba(Types: 121, 131, 212...) -> 6种
        # abc(Types: 123, 132, 213...) -> 6种
        aba = 6
        abc = 6
        
        # 从第二行开始递推
        for i in range(2, n + 1):
            # 暂存旧的值
            prev_aba = aba
            prev_abc = abc
            
            # 新的ABA = 上一行ABA * 3 + 上一行ABC * 2
            aba = (prev_aba * 3 + prev_abc * 2) % MOD
            # 新的ABC = 上一行ABA * 2 + 上一行ABC * 2
            abc = (prev_aba * 2 + prev_abc * 2) % MOD
        
        # 两类方案之和
        return (aba + abc) % MOD
```

```Java
// java
class Solution {
    public int numOfWays(int n) {
        int MOD = 1000000007;
        // 第一行的方案数
        // aba(Types: 121, 131, 212...) -> 6种
        // abc(Types: 123, 132, 213...) -> 6种
        long aba = 6;
        long abc = 6;

        // 从第二行开始递推
        for (int i = 2; i <= n; i++) {
            // 暂存旧的值
            long prev_aba = aba;
            long prev_abc = abc;

            // 新的ABA = 上一行ABA * 3 + 上一行ABC * 2
            aba = (prev_aba * 3 + prev_abc * 2) % MOD;
            // 新的ABC = 上一行ABA * 2 + 上一行ABC * 2
            abc = (prev_aba * 2 + prev_abc * 2) % MOD;
        }

        // 两类方案之和
        return (int) ((aba + abc) % MOD);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/solutions/3871613/wu-jie-bao-li-si-wei-dp-zhuang-tai-ya-su-b4xt/)
