[Problem: 1680. 连接连续二进制数字](https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/description/)

### 方法：位运算 & 优化

本题无需复杂考虑，原汁原味的 “照着题目字面意思做”。

不使用任何位运算或数学推导，纯 **暴力枚举**：直接用 $1$ ~ $n$ 的字符串拼接，最后再转成 $10$ 进制。代码如下：

```Python
# python
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        s = []
        # 生成 1 到 n 的二进制字符串
        for i in range(1, n + 1):
            s.append(bin(i)[2:])
        
        # 将它们直接拼接成一个超长的字符串
        # 然后转回十进制数字
        return int(''.join(s), 2) % (10 ** 9 + 7)
```

注意，上述解法只适用于 $Python$ 这种能容纳超长整数的语言，其他比如 $Java$ 会溢出，需要用到其他解法。

**观察规律**：数字 $4,5,6,7$ 的二进制分别为 $100,101,110,111$，它们拼接在末尾的效果相同，都是让数字先乘 $8$，所以关键在于先求二进制数字的 **长度**。

解题 **流程**：

- 从 $1$ 遍历到 $n$，每次遇到一个新的数字 $i$，看看 $i$ 的二进制有几位；
- 把累加结果 $ans$ 向左边挪出足够的空位，也就是乘上 $2^{\text{长度}}$ 或者左移对应的位数；
- 再把 $i$ 加到 $ans$ 里面，最后取模即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        MOD = 10**9 + 7
        ans = 0
        
        for i in range(1, n + 1):
            # 获取当前数字 i 的二进制位数
            length = i.bit_length()
            
            # 先左移 length 位，再加上当前的 i
            ans = ((ans << length) + i) % MOD
            
        return ans
```

```Java
// java
class Solution {
    public int concatenatedBinary(int n) {
        int MOD = 1000000007;
        long ans = 0;
        
        for (int i = 1; i <= n; i++) {
            // 获取当前数字 i 的二进制位数
            int length = 32 - Integer.numberOfLeadingZeros(i);
            
            // 先左移 length 位，再加上当前的 i
            ans = ((ans << length) + i) % MOD;
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$，位运算与取模运算都是 $O(1)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

想一想，数字的二进制长度什么时候会增加？

- $1$，只有一位
- $2$ 是 $10$，两位 —— 长度增加
- $3$ 是 $11$，还是两位
- $4$ 是 $100$，变为三位 —— 长度增加
- $5, 6, 7$ 都是三位
- $8$ 是 $1000$，变为四位 —— 长度增加

**规律显而易见**：只有当 $i$ 是 $2^k$，即 $2$ 的整数次幂时，二进制长度才会加 $1$。

而在位运算中，判断一个数是不是 $2$ 的整数次幂，有一个极其经典且极快的公式：`i & (i - 1) == 0`。

例如 $i = 4$ (100)，则 $i-1 = 3$ (011)，此时 `100 & 011 == 000`。

这样，无需使用 $bit()$ 函数，只用一次超级底层的按位与运算，就能在 $O(1)$ 的极短时间内决定 $shift$ 要不要加 $1$。

同时，在 $ans$ 左移 $shift$ 位之后，它的低 $shift$ 位一定是全为 $0$ 的（空出来了位置）。既然全是 $0$，我们把 $i$ 填进去的时候，可以直接用 **按位或 |**。

比如 `1000 | 0011 = 1011`。

在 $CPU$ 底层指令集中，位运算（或）的执行速度通常比普通的算术运算（加法）稍微快一点点。

代码如下，已附加注释：

```Python
# python
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        MOD = 10**9 + 7
        ans = 0
        shift = 0  # 记录当前数字的二进制长度
        
        for i in range(1, n + 1):
            # 如果 i 是 2 的幂，说明二进制进位了
            if (i & (i - 1)) == 0:
                shift += 1
            
            # 使用按位或代替加法
            ans = ((ans << shift) | i) % MOD
            
        return ans
```

```Java
// java
class Solution {
    public int concatenatedBinary(int n) {
        int MOD = 1000000007;
        long ans = 0;
        int shift = 0; // 记录当前数字的二进制长度
        
        for (int i = 1; i <= n; i++) {
            // 如果 i 是 2 的幂，说明二进制进位了
            if ((i & (i - 1)) == 0) {
                shift += 1;
            }
            
            // 使用按位或代替加法
            ans = ((ans << shift) | i) % MOD;
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

很遗憾，优化后的代码速度反而变慢，说明 $Python$ 底层的调库 $C++$ 代码性能很好，直接用就很不错。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/solutions/3910110/shuang-jie-guan-cha-gui-lu-bao-li-wei-yu-4yfz/)
