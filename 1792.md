[Problem: 1792. 最大平均通过率](https://leetcode.cn/problems/maximum-average-pass-ratio/description/)

### 方法：最大堆 & 优化

为了方便表述，将 $extraStudents$ 简记为 $k$。

目标是将这 $\texttt{k}$ 个学生分配到班级中，使得所有班级的 $\textbf{平均通过率}$ 最大。

一个班级的通过率定义为

$$
\text{ratio} = \frac{\text{通过人数}}{\text{总人数}}
$$

平均通过率，是 **所有** 班级通过率的平均值。

直觉上，很多人会觉得 —— $\textbf{通过率最低的班级}$ 应该 $\textbf{优先}$ 加聪明学生，这样才能 “补弱项”。但实际上，这样做不一定是最优的。

**优化目标是平均通过率，而不是最小通过率。**

如果只看“谁最低”，那是想提升整体最差的班级，类似于 $\texttt{max-min}$ 问题。然而本题的目标是 $\textbf{最大化所有班级的平均通过率}$，因此应该把额外的学生分配到能带来 **最大增益** 的班级。

增益公式推导：设某个班级有 $p$ 个通过的学生，总人数为 $t$，当前通过率为

$$
r = \frac{p}{t}
$$

如果额外加入一个聪明学生，新的通过率为

$$
r' = \frac{p+1}{t+1}
$$

提升量（增益）定义为

$$
\text{gain}(p, t) = r' - r = \frac{p+1}{t+1} - \frac{p}{t}
$$

可以看到，这个值与原本的通过率并不简单对应。某些班级虽然通过率低，但分母很大，增益很小；而有些班级通过率中等，但分母小，增益反而更大。

**举反例**，考虑两个例子：

${例 2}$

$$
\text{班级 A: } \frac{1}{9} = 0.1, \quad
\text{班级 B: } \frac{4}{5} = 0.8
$$

分配一个学生：

$$
\text{A: } \frac{2}{10} = 0.2, \quad \Delta = 0.1
$$

$$
\text{B: } \frac{5}{6} \approx 0.8333, \quad \Delta \approx 0.0333
$$

在此情况下，应该把学生分配给 $A$，因为增益更大。  

${例 2}$

$$
\text{班级 A: } \frac{20}{100} = 0.2, \quad
\text{班级 B: } \frac{2}{3} \approx 0.666
$$

分配一个学生：

$$
\text{A: } \frac{21}{101} \approx 0.2079, \quad \Delta \approx 0.0079
$$

$$
\text{B: } \frac{3}{4} = 0.75, \quad \Delta = 0.0833
$$

这时应该把学生分配给 $B$，尽管它的通过率比 $A$ 高。  

**总结**：最优策略不是选择通过率最低的班级，而是选择增加一个聪明学生后，通过率 $\textbf{提升最多}$ 的班级。

因此，需要通过维护一个优先队列来动态选取增益最大的班级，每次给堆顶这个最优选择分配一名学生 —— **最大堆**。

- 对所有班级计算分配一名学生后的增益，用最大堆存储。
- 每次取出增益最大的班级，分配一个聪明学生，更新该班级数据并重新计算增益。

重复上述过程，直到所有 $\texttt{k}$ 分配完毕，最后计算所有班级的平均通过率。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        # 每个班级增加 1 个聪明学生后，通过率的提升量
        def gain(p, t):
            return (p + 1) / (t + 1) - p / t
        
        # 用负数，从而模拟最大堆
        heap = [(-gain(p, t), p, t) for p, t in classes]
        heapq.heapify(heap)

        # 分配聪明学生，贪心
        for _ in range(extraStudents):
            g, p, t = heapq.heappop(heap)
            p, t = p + 1, t + 1
            heapq.heappush(heap, (-gain(p, t), p, t))

        # 计算平均通过率
        total = 0
        while heap:
            _, p, t = heapq.heappop(heap)
            total += p / t
        
        return total / len(classes)
```

```Java
// java
class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        // 定义优先队列（最大堆），按增益排序
        PriorityQueue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                // 计算增益
                double gainA = gain(a[0], a[1]);
                double gainB = gain(b[0], b[1]);
                return Double.compare(gainB, gainA); // 大的优先
            }
        });

        // 初始化堆
        for (int[] c : classes) {
            int p = c[0];
            int t = c[1];
            heap.offer(new int[]{p, t});
        }

        // 分配聪明学生，贪心策略
        for (int i = 0; i < extraStudents; i++) {
            int[] top = heap.poll();
            int p = top[0] + 1;
            int t = top[1] + 1;
            heap.offer(new int[]{p, t});
        }

        // 计算平均通过率
        double total = 0;
        while (!heap.isEmpty()) {
            int[] c = heap.poll();
            total += (double) c[0] / c[1];
        }

        return total / classes.length;
    }

    // 计算增益函数
    private double gain(int p, int t) {
        return (double)(p + 1) / (t + 1) - (double)p / t;
    }
}
```

- 时间复杂度： $O((n+k)\times logn)$，其中 $n$ 为数组 $classes$ 的长度，每一次堆的调整操作耗时 $O(logn)$，计算时间为 $O(1)$
- 空间复杂度： $O(n)$，表示堆 $heap$ 的大小

---

### 数学

将上述的数学公式继续简化，得到

$$
\begin{align}
\text{gain}(p, t) &= \frac{p+1}{t+1} - \frac{p}{t} \\
&= \frac{(p+1)t - p(t+1)}{t(t+1)} \\
&= \frac{pt + t - pt - p}{t(t+1)} \\
&= \frac{t - p}{t(t+1)}
\end{align}
$$

将上述方法变为静态，同时增加负号变为最大堆，并使用更加 $Pythonic$ 的写法。

代码如下，已附加注释：

```Python
# python
class Solution:
    @staticmethod
    def _calculate_gain(p: int, t: int) -> float:
        """计算增加一个学生后的通过率提升值"""
        # 如果班级已满员或通过率100%，则收益为0
        if p == t:
            return 0.0
        # 化简收益公式
        return (p - t) / (t * (t + 1))

    def maxAverageRatio(self, classes: list[list[int]], extraStudents: int) -> float:
        # 优化点 1: 使用列表推导式和 heapq.heapify() 初始化堆
        # 这比循环 push 更简洁，且理论上效率更高 (O(N) vs O(N log N))
        max_heap = [
            (self._calculate_gain(p, t), p, t) for p, t in classes
        ]
        heapq.heapify(max_heap)

        # 优化点 2: 调用的是静态方法
        for _ in range(extraStudents):
            # 弹出收益最大的班级
            _, p, t = heapq.heappop(max_heap)
            
            # 班级人数+1
            p += 1
            t += 1
            
            # 将更新后的班级重新推入堆中
            heapq.heappush(max_heap, (self._calculate_gain(p, t), p, t))

        # 优化点 3: 使用生成器表达式和 sum() 计算最终结果
        return sum(p / t for _, p, t in max_heap) / len(classes)
```

```Java
// java
class Solution {
    // 静态方法：计算增加一个学生后的通过率提升值
    private static double calculateGain(int p, int t) {
        // 如果班级已满员或通过率100%，则收益为0
        if (p == t) return 0.0;
        // 化简收益公式，并增加负号
        return (double)(t - p) / (t * (t + 1));
    }

    public double maxAverageRatio(int[][] classes, int extraStudents) {
        // 初始化最大堆，按增益排序
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                double gainA = calculateGain(a[0], a[1]);
                double gainB = calculateGain(b[0], b[1]);
                return Double.compare(gainB, gainA); // 增益大的优先
            }
        });

        // 初始化堆
        for (int[] c : classes) {
            maxHeap.offer(new int[]{c[0], c[1]});
        }

        // 分配额外学生
        for (int i = 0; i < extraStudents; i++) {
            int[] top = maxHeap.poll(); // 弹出增益最大的班级
            int p = top[0] + 1;         // 班级人数+1
            int t = top[1] + 1;
            maxHeap.offer(new int[]{p, t}); // 更新后重新加入堆
        }

        // 计算平均通过率
        double total = 0.0;
        for (int[] c : maxHeap) {
            total += (double)c[0] / c[1];
        }

        return total / classes.length;
    }
}
```

- 时间复杂度： $O((n+k)\times logn)$，其中 $n$ 为数组 $classes$ 的长度
- 空间复杂度： $O(n)$

---

如果你是 $Python$ 用户，可以继续化简代码，变为 $1011ms$，超越 $100\%$：

```Python
# python
class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        # 默认是小根堆，把增量取相反数，变成大根堆
        h = [((a - b) / (b * (b + 1)), a, b) for a, b in classes]
        heapify(h)  # 堆化，只需 O(n) 时间

        for temp1 in range(extraStudents):
            temp2, a, b = h[0]
            a += 1
            b += 1
            # 这样写比 pop 再 push 更快
            heapreplace(h, ((a - b) / (b * (b + 1)), a, b))

        return sum(a / b for temp2, a, b in h) / len(h)
```

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-average-pass-ratio/solutions/3769204/zui-da-dui-ti-sheng-zeng-yi-er-bu-shi-da-opj7/)
