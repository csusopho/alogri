[Problem: 3714. 最长的平衡子串 II](https://leetcode.cn/problems/longest-balanced-substring-ii/description/)

### 分类讨论

暴力最容易想，枚举所有可能的子串，然后检查每个子串中 $a,b,c$ 的数量。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)
        ans = 0
        
        # 枚举起点
        for i in range(n):
            cnt_a = 0
            cnt_b = 0
            cnt_c = 0
            
            # 枚举终点
            for j in range(i, n):
                # 增量更新
                char = s[j]
                if char == 'a':
                    cnt_a += 1
                elif char == 'b':
                    cnt_b += 1
                else:
                    cnt_c += 1
                
                # 收集所有非零的计数
                non_zero_counts = []
                if cnt_a > 0: non_zero_counts.append(cnt_a)
                if cnt_b > 0: non_zero_counts.append(cnt_b)
                if cnt_c > 0: non_zero_counts.append(cnt_c)
                
                # 判断是否相等
                if len(set(non_zero_counts)) == 1:
                    cur_len = j - i + 1
                    if cur_len > ans:
                        ans = cur_len
                  
        return ans
```

很遗憾，这种 $O(n^2)$ 的解法会超时，卡在 $966/1033$ 样例。

---

### 优化

那就不能枚举所有子串，必须遍历一次字符串得出答案！核心突破点：**字符集很小**，只有 $a,b,c$ 三种。

根据子串中包含的 **字符种类** 进行分类讨论。一个平衡子串只可能是以下三种情况之一：

1. 只包含 $1$ 种字符，比如 $aaaa$
2. 包含 $2$ 种字符，比如 $aabb$
3. 包含 $3$ 种字符，比如 $aabbcc$

**场景 A**：子串只包含 $1$ 种字符。

这是最简单的情况。只需要遍历字符串，找出连续相同的字符构成的最长片段。比如 $...baaaaac...$，最长连续段是 $aaaaa$，长度为 $5$。

**场景 B**：子串中包含 $2$ 种字符，比如只含 $a,b$ 不含 $c$。

目标找到一段区间 $[i, j]$，满足 $count(a)=count(b)$。对它进行数学变换：

$$
CountA[j] - CountA[i-1] = CountB[j] - CountB[i-1]
$$

移项得：

$$
CountA[j] - CountB[j] = CountA[i-1] - CountB[i-1]
$$

注意，这里的 $CountA[j]$ 表示子串 $s[0,j]$ 中所有 $a$ 的数量，也即前缀和。

也就是说，只要两个位置的 `a数量 - b数量` 的差值相等，这两个位置中间的子串就是平衡的。因此，使用 **哈希** 记录 `(前缀和差值, 第一次出现的索引)`。

这里用哈希记录 “第一次” 出现该差值的位置，这样才能让子串最长，且只需要一次遍历。

题目要求子串是连续的，子串里不能有 $c$。如果遇到了 $c$，相当于路断了，之前的统计必须作废，重新开始计算。

**场景 C**：子串中包含 $3$ 种字符。

我们要找 $a=b=c$，也即 $a-b=0$ 且 $b-c=0$。利用上面第二种方法的思路，这等价于

$$
CountA[j] - countB[j] = CountA[i] - countB[i]
$$

且

$$
countB[j] - CountC[j] = countB[i] - CountC[i]
$$

这就是又转化为 “前缀和差值” 问题，只要两个位置的 `(a数量-b撒数量, b数量-c数量)` 这一对 **差值元组** 相同，中间的子串就是三者数量相等的平衡串。

同理，使用哈希记录 `(差值元组, 第一次出现索引)`。然后一次遍历，计算差值并更新哈希，找出最长子串。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)
        ans = 0
        
        # 包含 3 种字符
        # 状态元组: (count_a - count_b, count_b - count_c)
        seen = {(0, 0): -1}
        a = b = c = 0
        for i, char in enumerate(s):
            if char == 'a': a += 1
            elif char == 'b': b += 1
            else: c += 1
            
            diff = (a - b, b - c)
            if diff in seen:
                ans = max(ans, i - seen[diff])
            else:
                seen[diff] = i

        # 包含 2 种字符
        # 辅助函数，寻找只包含 x 和 y，且数量相等的子串
        # forbidden 是不允许出现的字符，遇到它要重置状态
        def check_two_chars(x, y, forbidden):
            nonlocal ans
            # 哈希表记录 (差值, 第一次索引)
            # diff = count(x) - count(y)
            mp = {0: -1}
            diff = 0
            
            for i, char in enumerate(s):
                if char == forbidden:
                    # 重置，新的段从 i 开始算起
                    mp = {0: i} 
                    diff = 0
                else:
                    if char == x:
                        diff += 1
                    elif char == y:
                        diff -= 1
                    
                    # 更新哈希
                    if diff in mp:
                        ans = max(ans, i - mp[diff])
                    else:
                        mp[diff] = i

        check_two_chars('a', 'b', 'c')  # 找 a=b, 无 c
        check_two_chars('a', 'c', 'b')  # 找 a=c, 无 b
        check_two_chars('b', 'c', 'a')  # 找 b=c, 无 a

        # 包含 1 种字符
        cur_len = 0
        last_char = ''
        # 统计连续字符即可
        for char in s:
            if char == last_char:
                cur_len += 1
            else:
                cur_len = 1
                last_char = char
            ans = max(ans, cur_len)

        return ans
```

```Java
// java
class Solution {
    public int longestBalanced(String s) {
        int n = s.length();
        int ans = 0;
        
        // 包含 3 种字符
        // 状态元组: (count_a - count_b, count_b - count_c)
        Map<String, Integer> seen = new HashMap<>();
        seen.put("0,0", -1);
        int a = 0, b = 0, c = 0;
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (ch == 'a') a++;
            else if (ch == 'b') b++;
            else c++;
            
            String diff = (a - b) + "," + (b - c);
            if (seen.containsKey(diff)) {
                ans = Math.max(ans, i - seen.get(diff));
            } else {
                seen.put(diff, i);
            }
        }

        // 包含 2 种字符
        // 分别调用辅助方法
        ans = Math.max(ans, checkTwoChars(s, 'a', 'b', 'c')); // 找 a=b, 无 c
        ans = Math.max(ans, checkTwoChars(s, 'a', 'c', 'b')); // 找 a=c, 无 b
        ans = Math.max(ans, checkTwoChars(s, 'b', 'c', 'a')); // 找 b=c, 无 a

        // 包含 1 种字符
        int curLen = 0;
        char lastChar = ' ';
        // 统计连续字符即可
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (ch == lastChar) {
                curLen++;
            } else {
                curLen = 1;
                lastChar = ch;
            }
            ans = Math.max(ans, curLen);
        }

        return ans;
    }

    // 辅助函数，寻找只包含 x 和 y，且数量相等的子串
    // forbidden 是不允许出现的字符，遇到它要重置状态
    private int checkTwoChars(String s, char x, char y, char forbidden) {
        int maxLen = 0;
        // 哈希表记录 (差值, 第一次索引)
        // diff = count(x) - count(y)
        Map<Integer, Integer> mp = new HashMap<>();
        mp.put(0, -1);
        int diff = 0;
        
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch == forbidden) {
                // 重置，新的段从 i 开始算起
                mp.clear();
                mp.put(0, i); 
                diff = 0;
            } else {
                if (ch == x) {
                    diff++;
                } else if (ch == y) {
                    diff--;
                }
                
                // 更新哈希
                if (mp.containsKey(diff)) {
                    maxLen = Math.max(maxLen, i - mp.get(diff));
                } else {
                    mp.put(diff, i);
                }
            }
        }
        return maxLen;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为串 $s$ 的长度，每种逻辑都是线性遍历
- 空间复杂度： $O(n)$，哈希表在最坏情况下存储 $n$ 个不同差值

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-balanced-substring-ii/solutions/3901885/fen-lei-tao-lun-bao-li-chao-shi-san-chon-m9pc/)
