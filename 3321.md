[Problem: 3321. 计算子数组的 x-sum II](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-ii/description/)

### 方法：滑窗+对顶堆 & 优化

解答本题前，建议先通关前一道 [3318](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/description/)，它与本题完全一致，仅数据量有所差别，题解为 [传送门](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/solutions/3823263/shuang-jie-bao-li-mo-ni-hua-chuang-you-h-2p9p/)。具体的题目解读，以及滑窗推导，请看链接，这里不再赘述。

两个相邻的长度为 $k$ 的子数组，只相差 **首尾** 两个元素，因此前一题我们使用滑窗。但是，在辅助函数里，我们会对窗口进行排序。

为什么要排序？找出频率最大的元素。排序花费的时间太长，能否去除？假如窗口内只含有我们需要的目标元素，那不需要排序了！

引入 **对顶** 思路：定义哈希集合 $in$，它存储窗口内排名在前 $x$ 的 `(数值, 频率)` 的元素对；以及哈希集合 $out$，它存储 **当前窗口内**，除了前 $x$ 个元素之外的剩余元素。

可以想象为，窗口就是一个餐厅，集合 $in$ 是 $VIP$ 座位，而集合 $out$ 是普通座位，剩余的人则在餐厅外。我们仅仅只考虑 $in$ 与 $out$ 的相互转化。

- 窗口左侧元素移出时，判断它是否存在于 $in/out$ 中，两者都更新；
- 窗口内新进入一个元素时，同理更新 $in/out$；
- 此时，维护 $in/out$ 的平衡，确保包含的元素数量正确，且 $in$ 中仍然存储前 $x$。

切记，两个集合中存储的是 “数值-频率”，加入/退出集合时，都是对这个元素对操作，而不是单一的元素 $nums[i]$。最大的难点就在于 “元素对” 的正确处理。

下面的代码不使用堆/有序集合，所以会超时，看一下整体思路即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        # 统计的是窗口内的元素
        counts = defaultdict(int)
        
        # 存储排名前 x 的（频率, 数值）对
        in_set = set()
        # 存储其余的（频率, 数值）对
        out_set = set()
        # 当前子数组的 x-sum 总和
        window_x_sum = 0

        # 滑窗枚举右指针
        for i in range(n):
            # 步骤 1: 如果窗口已满，移除窗口的左侧元素
            if i >= k:
                removed_num = nums[i - k]
                # 获取该元素更新前的（频率, 数值）对
                prev_pair = (counts[removed_num], removed_num)
                counts[removed_num] -= 1
                # 更新后
                current_pair = (counts[removed_num], removed_num)

                # 从 in_set 中移除旧的配对
                if prev_pair in in_set:
                    window_x_sum -= removed_num  # 减去一次
                    in_set.remove(prev_pair)  # 旧配对
                    # 如果该元素在窗口中还存在，加回去新的配对
                    if counts[removed_num] != 0:
                        in_set.add(current_pair)
                # 从 out_set 中移除旧的配对
                elif prev_pair in out_set:
                    out_set.remove(prev_pair)
                    if counts[removed_num] != 0:
                        out_set.add(current_pair)

            # 步骤 2: 将新元素添加到窗口中
            added_num = nums[i]
            prev_pair = (counts[added_num], added_num)
            counts[added_num] += 1
            current_pair = (counts[added_num], added_num)
            
            # 更新 in_set 或 out_set 中的配对
            if prev_pair in in_set:
                in_set.remove(prev_pair)
                # 已经是排名前 x，所以加一次
                window_x_sum += added_num
            else:
                # 有可能变为前 x，加的是全部元素
                window_x_sum += current_pair[0] * current_pair[1]
            
            if prev_pair in out_set:
                out_set.remove(prev_pair)  # 移出

            # 放入 in_set
            in_set.add(current_pair)

            # 步骤 3: 维护 in_set 和 out_set 的平衡
            # 如果 in_set 元素过多，将最小的移到 out_set
            if len(in_set) > x:
                smallest_in = min(in_set)
                window_x_sum -= smallest_in[0] * smallest_in[1]
                in_set.remove(smallest_in)
                out_set.add(smallest_in)

            # 如果 in_set 元素不足且 out_set 有元素，将最大的移入 in_set
            elif len(in_set) < x and out_set:
                largest_out = max(out_set)
                window_x_sum += largest_out[0] * largest_out[1]
                in_set.add(largest_out)
                out_set.remove(largest_out)
            
            # 如果数量刚好，检查 in_set 的最小值和 out_set 的最大值
            if len(in_set) == x and out_set:
                smallest_in = min(in_set)
                largest_out = max(out_set)
                if smallest_in < largest_out:
                    # 更新总和
                    window_x_sum -= smallest_in[0] * smallest_in[1]
                    window_x_sum += largest_out[0] * largest_out[1]
                    # 交换元素
                    in_set.remove(smallest_in)
                    out_set.add(smallest_in)
                    in_set.add(largest_out)
                    out_set.remove(largest_out)
            
            # 步骤 4: 当窗口达到大小 k 时，记录结果
            if i >= k - 1:
                ans.append(window_x_sum)
        
        return ans
```

移入/移出集合后，为了确保前 $x$ 的排行，必须让 $in$ 中的最小值 **大于等于** $out$ 中的最大值。由于 $set$ 没有顺序，所以使用 $min/max$ 进行寻找。

两个集合的大小为 $O(k)$，线性寻找；滑窗是在整个 $nums$ 数组上进行，所以总时间为 $O(n\times k)$。遗憾超时，卡在 $778/784$ 样例。

---

### 有序集合

为什么要查找最小/大？确保 $in$ 中的元素始终是最大的 $k$ 个，否则无法利用之前的结果去计算 $window$ 内的 `x-sum` 值。

因此，我们引入 **堆/有序列表**。让 $in$ 变为最小堆，且 $out$ 是最大堆。这样一来，只需要判断两个堆顶元素的大小，就能判断是否平衡。

**最难** 理清的是移入/移出逻辑。假设元素为 $num$，对应出现次数是 $t$。

- 当窗口内 **增加** 一个新元素时，如果 $t>0$，将 $(t,num)$ 从有序集合中移除，并将 $(t+1,num)$ 加入有序集合。
- 当窗口内 **增加** 一个新元素时，将 $(t,num)$ 从有序集合中移除，并如果 $t>1$，将 $(t-1,num)$ 加入有序集合。

向有序集合中加入 $(t,num)$：

- 如果 $in$ 中的二元组个数小于 $x$，说明列表没满，则将 $(t,num)$ 加入 $in$；
- 如果 $(t,num)$ 比 $in$ 中最小的二元组还要小，频率/数值不符合，说明不能排在前 $x$，直接将它加入 $out$；
- 否则，说明新加入的元素更大，需要调整堆，将 $in$ 中最小的二元组移除并加入 $out$，并将 $(t,num)$ 加入 $in$。

向有序集合中移除 $(t,num)$：

- 先检查 $(t,num)$ 是否在 $in$ 中（比 $in$ 中最小的二元组大一点），将它从 $in$ 中移除。此时如果 $out$ 不为空，则将 $out$ 中最大的二元组取出，加入 $in$ 进行补充；
- 否则，它在 $out$ 中，从 $out$ 中移除。

官解还将移入/移出滑窗的部分，单独也提取为 $add/remove$ 函数。这样的逻辑更加清晰，而核心思路还是上面的 **动态维护** 对顶堆。

为了方便理解，将 $in$ 记作 `top_x_elements`，以及 $out$ 记作 `remaining_elements`。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        # 当前窗口的 x-sum 总和
        window_x_sum = 0
        # 存储频率最高的前 x 个 (频率, 数字) 对，最小堆
        top_x_elements = SortedList()
        # 存储其余的 (频率, 数字) 对，最大堆
        remaining_elements = SortedList()
        # 记录当前窗口内每个数字的频率
        counts = defaultdict(int)
        ans = []
        
        # 将一个 (频率, 数字) 对插入到堆中
        # 维护 top_x_elements 列表，确保其始终包含 x 个最大的元素
        def insert_pair(pair):
            nonlocal window_x_sum
            # 列表未满，或者当前元素>其中的最小元素
            if len(top_x_elements) < x or pair > top_x_elements[0]:
                window_x_sum += pair[0] * pair[1]
                top_x_elements.add(pair)
                
                # 超出大小，将最小的元素移至对顶堆
                if len(top_x_elements) > x:
                    to_remove = top_x_elements[0]
                    window_x_sum -= to_remove[0] * to_remove[1]
                    top_x_elements.remove(to_remove)
                    remaining_elements.add(to_remove)
            else:
                # 否则，同理移至对顶堆
                remaining_elements.add(pair)
        
        # 移除一个 (频率, 数字) 对，同时维护 top_x_elements 列表
        def remove_pair(pair):
            nonlocal window_x_sum
            # 在 top_x_elements 列表中
            # 元组比较会先比较频率，频率相同再比较数值
            if pair >= top_x_elements[0]:
                window_x_sum -= pair[0] * pair[1]
                top_x_elements.remove(pair)
                
                # 从对顶堆中，取出最大元素进行补充
                if remaining_elements:
                    to_add = remaining_elements[-1]
                    window_x_sum += to_add[0] * to_add[1]
                    remaining_elements.remove(to_add)
                    top_x_elements.add(to_add)
            else:
                # 比 top_x_elements 中最小的二元组还要小，说明在另外一个堆中
                remaining_elements.remove(pair)

        # 向滑动窗口中添加一个新数字
        def add(num):
            # 如果数字已存在，先移除旧的 (频率, 数字) 对
            if counts[num] > 0:
                remove_pair((counts[num], num))
            
            # 更新频率，并插入新的 (频率, 数字) 对
            counts[num] += 1
            insert_pair((counts[num], num))

        # 从滑动窗口中移除一个旧数字
        def remove(num):
            # 移除当前的 (频率, 数字) 对
            remove_pair((counts[num], num))
            # 更新
            counts[num] -= 1
            
            # 如果该数字在窗口中仍存在，则插入更新后的 (频率, 数字) 对
            if counts[num] > 0:
                insert_pair((counts[num], num))

        # --- 滑动窗口主循环 ---
        for i in range(len(nums)):
            # 添加到窗口
            add(nums[i])
            # 移除最左侧的元素
            if i >= k:
                remove(nums[i - k])
            # 当窗口大小首次达到 k 时，开始记录结果
            if i >= k - 1:
                ans.append(window_x_sum)

        return ans
```

```Java
// java
class Solution {
    // 当前窗口的 x-sum 总和
    private long window_x_sum;
    // 存储频率最高的前 x 个 (频率, 数字) 对，最小堆
    private TreeSet<int[]> top_x_elements;
    // 存储其余的 (频率, 数字) 对，最大堆
    private TreeSet<int[]> remaining_elements;
    // 记录当前窗口内每个数字的频率
    private Map<Integer, Integer> counts;
    private int x;

    // 辅助函数，比较两个元组
    private int comparePairs(int[] a, int[] b) {
        if (a[0] != b[0]) {
            return Integer.compare(a[0], b[0]);
        }
        return Integer.compare(a[1], b[1]);
    }

    // 将一个 (频率, 数字) 对插入到堆中
    // 维护 top_x_elements 列表，确保其始终包含 x 个最大的元素
    private void insert_pair(int[] pair) {
        // 列表未满，或者当前元素>其中的最小元素
        if (top_x_elements.size() < this.x || comparePairs(pair, top_x_elements.first()) > 0) {
            window_x_sum += (long)pair[0] * pair[1];
            top_x_elements.add(pair);
            
            // 超出大小，将最小的元素移至对顶堆
            if (top_x_elements.size() > this.x) {
                int[] to_remove = top_x_elements.first();
                window_x_sum -= (long)to_remove[0] * to_remove[1];
                top_x_elements.pollFirst();
                remaining_elements.add(to_remove);
            }
        } else {
            // 否则，同理移至对顶堆
            remaining_elements.add(pair);
        }
    }

    // 移除一个 (频率, 数字) 对，同时维护 top_x_elements 列表
    private void remove_pair(int[] pair) {
        // 尝试从 top_x_elements 移除，如果成功，说明它在里面
        if (top_x_elements.remove(pair)) {
            window_x_sum -= (long)pair[0] * pair[1];
            
            // 从对顶堆中，取出最大元素进行补充
            if (!remaining_elements.isEmpty()) {
                int[] to_add = remaining_elements.last();
                window_x_sum += (long)to_add[0] * to_add[1];
                remaining_elements.pollLast();
                top_x_elements.add(to_add);
            }
        } else {
            // 如果不在 top_x_elements 中，那它一定在另外一个堆中
            remaining_elements.remove(pair);
        }
    }

    // 向滑动窗口中添加一个新数字
    private void add(int num) {
        // 如果数字已存在，先移除旧的 (频率, 数字) 对
        int current_count = counts.getOrDefault(num, 0);
        if (current_count > 0) {
            remove_pair(new int[]{current_count, num});
        }
        
        // 更新频率，并插入新的 (频率, 数字) 对
        counts.put(num, current_count + 1);
        insert_pair(new int[]{current_count + 1, num});
    }

    // 从滑动窗口中移除一个旧数字
    private void remove(int num) {
        // 移除当前的 (频率, 数字) 对
        int current_count = counts.get(num);
        remove_pair(new int[]{current_count, num});
        
        // 更新
        counts.put(num, current_count - 1);
        
        // 如果该数字在窗口中仍存在，则插入更新后的 (频率, 数字) 对
        if (counts.get(num) > 0) {
            insert_pair(new int[]{current_count - 1, num});
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        this.window_x_sum = 0;
        this.counts = new HashMap<>();
        this.x = x;
        
        // 先比较频率，频率相同再比较数值
        Comparator<int[]> pairComparator = (a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(a[1], b[1]);
        };
        
        this.top_x_elements = new TreeSet<>(pairComparator);
        this.remaining_elements = new TreeSet<>(pairComparator);
        int n = nums.length;
        long[] ans = new long[n - k + 1];

        // --- 滑动窗口主循环 ---
        for (int i = 0; i < n; i++) {
            // 添加到窗口
            add(nums[i]);
            
            // 移除最左侧的元素
            if (i >= k) {
                remove(nums[i - k]);
            }
            
            // 当窗口大小首次达到 k 时，开始记录结果
            if (i >= k - 1) {
                ans[i - k + 1] = window_x_sum;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(nlogk)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(k)$，表示哈希表 $counts$ 以及两个堆的大小

---

### 优化

我们可以单独 **先计算** 初始的长为 $k$ 的滑窗，将它与 “稳定状态更新” 的阶段进行分离。如此一来，无需对初始的 $k$ 个元素逐一判断。同时，去除 $add$ 辅助函数，简化执行路径。

**总结**：将状态管理（更新哈希）的逻辑保留在主循环中，复杂的数据结构操作（维护两个堆）封装在简单、职责单一的辅助函数里。

这样做会减少函数调用的开销，使速度有较大提升。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        # 记录当前窗口内每个数字的频率
        counts = defaultdict(int)
        # 存放最大的 x 个 (频率, 数字) 对
        top_x_elements = SortedList()
        # 存放剩余的 (频率, 数字) 对
        remaining_elements = SortedList()
        # 当前窗口的 x-sum 总和
        window_x_sum = 0
        ans = []

        # 添加一个 (频率, 数字) 对
        def add_pair(num, freq):
            nonlocal window_x_sum
            pair = (freq, num)
            # 如果 top_x_elements 列表还未满，直接添加
            if len(top_x_elements) < x:
                top_x_elements.add(pair)
                window_x_sum += freq * num
            else:
                # 如果新元素小于 top_x_elements 中的最小元素，则移至对顶堆
                if pair < top_x_elements[0]:
                    remaining_elements.add(pair)
                # 否则，新元素应放入 top_x_elements
                else:
                    top_x_elements.add(pair)
                    # 弹出 top_x_elements 中最小的元素，并移至对顶堆
                    popped_freq, popped_num = top_x_elements.pop(0)
                    remaining_elements.add((popped_freq, popped_num))
                    # 更新总和：加上新进入的，减去被弹出的
                    window_x_sum += freq * num - popped_freq * popped_num

        # 移除一个 (频率, 数字) 对
        def remove_pair(num, freq):
            nonlocal window_x_sum
            pair = (freq, num)
            # 元组比较会先比较频率，频率相同再比较数值
            if pair >= top_x_elements[0]:
                top_x_elements.remove(pair)
                window_x_sum -= freq * num
                # 从对顶堆中，取出最大元素进行补充
                if remaining_elements:
                    popped_freq, popped_num = remaining_elements.pop()
                    top_x_elements.add((popped_freq, popped_num))
                    window_x_sum += popped_freq * popped_num
            else:
                # 说明在另外一个堆中
                remaining_elements.remove(pair)

        # 初始化第一个窗口
        for i in range(k):
            num = nums[i]
            counts[num] += 1
        
        # 将初始窗口的 (频率, 数字) 对添加到两个列表中
        for num, freq in counts.items():
            add_pair(num, freq)
            
        ans.append(window_x_sum)

        # 滑动窗口
        for i in range(len(nums) - k):
            # i 是将要离开窗口的元素的索引
            # i + k 是将要进入窗口的元素的索引

            # 处理离开窗口的元素
            left_num = nums[i]
            remove_pair(left_num, counts[left_num])
            counts[left_num] -= 1
            if counts[left_num] > 0:
                add_pair(left_num, counts[left_num])
            
            # 处理进入窗口的元素
            right_num = nums[i + k]
            if counts[right_num] > 0:
                remove_pair(right_num, counts[right_num])
            counts[right_num] += 1
            add_pair(right_num, counts[right_num])
            
            # 记录答案
            ans.append(window_x_sum)
            
        return ans
```

```Java
// java
class Solution {
    // 记录当前窗口内每个数字的频率
    private Map<Integer, Integer> counts;
    // 存放最大的 x 个 (频率, 数字) 对
    private TreeSet<int[]> top_x_elements;
    // 存放剩余的 (频率, 数字) 对
    private TreeSet<int[]> remaining_elements;
    // 当前窗口的 x-sum 总和
    private long window_x_sum;
    private int x;

    // 辅助函数，比较两个元组
    private int comparePairs(int[] a, int[] b) {
        if (a[0] != b[0]) {
            return Integer.compare(a[0], b[0]);
        }
        return Integer.compare(a[1], b[1]);
    }

    // 添加一个 (频率, 数字) 对
    private void add_pair(int num, int freq) {
        int[] pair = {freq, num};
        // 如果 top_x_elements 列表还未满，直接添加
        if (top_x_elements.size() < this.x) {
            top_x_elements.add(pair);
            window_x_sum += (long)freq * num;
        } else {
            // 如果新元素小于 top_x_elements 中的最小元素，则移至对顶堆
            if (comparePairs(pair, top_x_elements.first()) < 0) {
                remaining_elements.add(pair);
            }
            // 否则，新元素应放入 top_x_elements
            else {
                top_x_elements.add(pair);
                // 弹出 top_x_elements 中最小的元素，并移至对顶堆
                int[] popped = top_x_elements.pollFirst();
                remaining_elements.add(popped);
                // 更新总和：加上新进入的，减去被弹出的
                window_x_sum += (long)freq * num - (long)popped[0] * popped[1];
            }
        }
    }

    // 移除一个 (频率, 数字) 对
    private void remove_pair(int num, int freq) {
        int[] pair = {freq, num};
        // 元组比较会先比较频率，频率相同再比较数值
        if (comparePairs(pair, top_x_elements.first()) >= 0) {
            top_x_elements.remove(pair);
            window_x_sum -= (long)freq * num;
            // 从对顶堆中，取出最大元素进行补充
            if (!remaining_elements.isEmpty()) {
                int[] popped = remaining_elements.pollLast();
                top_x_elements.add(popped);
                window_x_sum += (long)popped[0] * popped[1];
            }
        } else {
            // 说明在另外一个堆中
            remaining_elements.remove(pair);
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        this.counts = new HashMap<>();
        this.window_x_sum = 0;
        this.x = x;
        
        Comparator<int[]> pairComparator = this::comparePairs;
        this.top_x_elements = new TreeSet<>(pairComparator);
        this.remaining_elements = new TreeSet<>(pairComparator);

        if (nums.length < k) {
            return new long[0];
        }

        long[] ans = new long[nums.length - k + 1];

        // 初始化第一个窗口
        for (int i = 0; i < k; i++) {
            int num = nums[i];
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }
        
        // 将初始窗口的 (频率, 数字) 对添加到两个列表中
        for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
            add_pair(entry.getKey(), entry.getValue());
        }
            
        ans[0] = window_x_sum;

        // 滑动窗口
        for (int i = 0; i < nums.length - k; i++) {
            // i 是将要离开窗口的元素的索引
            // i + k 是将要进入窗口的元素的索引

            // 处理离开窗口的元素
            int left_num = nums[i];
            remove_pair(left_num, counts.get(left_num));
            counts.put(left_num, counts.get(left_num) - 1);
            if (counts.get(left_num) > 0) {
                add_pair(left_num, counts.get(left_num));
            }
            
            // 处理进入窗口的元素
            int right_num = nums[i + k];
            if (counts.getOrDefault(right_num, 0) > 0) {
                remove_pair(right_num, counts.get(right_num));
            }
            counts.put(right_num, counts.getOrDefault(right_num, 0) + 1);
            add_pair(right_num, counts.get(right_num));
            
            // 记录答案
            ans[i + 1] = window_x_sum;
        }
            
        return ans;
    }
}
```

优化后，原本的 $Python$ 代码从 $3600ms$ 变为 $2655ms$，从超越 $10\%$ 变为 $92\%$。

- 时间复杂度： $O(nlogk)$
- 空间复杂度： $O(k)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-ii/solutions/3824238/shuang-jie-liang-ha-xi-wei-hu-hua-chuang-br9i/)
