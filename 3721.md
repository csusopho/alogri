[Problem: 3721. 最长平衡子数组 II](https://leetcode.cn/problems/longest-balanced-subarray-ii/description/)

### 线段树

为了方便表述，将子数组中的不同偶数 - 奇数的差值叫做 “去重平衡差”。

定义一个函数 $B(L, R)$ 表示子数组 $nums[L...R]$ 的平衡差。目标是找到一对 $(L, R)$，使得 $B(L, R) = 0$，且 $R - L + 1$ 最大。

使用滑窗的思维，遍历数组的右端点 $R$。对于固定的 $R$，我们需要在 $[0, R]$ 范围内寻找一个最优的左端点 $L$。

当我们从 $R$ 移动到 $R+1$ 时，新加入的元素 $nums[R+1]$ 会如何影响 $B(L, R+1)$ 呢？

对于元素 $x = \text{nums}[R]$ 来说，它只对那些之前 **不包含** $x$ 子数组贡献 “不同计数”。设 $p = prevIdx[R]$ 是 $x$ 上一次出现的位置。那么，对于任意起始点 $L$，如果 $L$ 在区间 $(p, R]$ 之间，那么 $nums[R]$ 对于子数组 $nums[L...R]$ 来说是一个 **新** 的去重元素。

- 如果 $nums[R]$ 是偶数，对于所有 $L \in [p+1, R]$，子数组 $nums[L...R]$ 的 “去重偶数计数” $+1$。即平衡差 $+1$。
- 如果 $nums[R]$ 是奇数，对于所有 $L \in [p+1, R]$，子数组 $nums[L...R]$ 的“去重奇数计数” $+1$。即平衡差 $-1$。
- 对于 $L \le p$ 的子数组，$nums[R]$ 是重复元素，不改变去重计数，平衡差不变。

根据上述分析，我们需要一个数据结构支持：

1. **区间加法**：对区间 $[p+1,R]$ 增加 $val$，其中 $val$ 为 $1$ 或 $-1$。
2. **查找特定值**：在区间 $[0, R]$ 中找到 **最左边** 的 $L$，该区间的平衡差为 $0$。

目标是最长子数组，即 $R-L+1$ 最大，所以在 $R$ 固定的情况下，我们要找 **最小的 L**。

因此，想到使用 **线段树**，每个节点维护区间内平衡差的 “最小值” 和 “最大值”。

- 如果一个节点的 $min > 0$ 或者 $max < 0$，说明该区间内不可能存在值为 $0$ 的位置，直接剪枝。
- 否则，递归查找。优先查左子树（为了找最小的 $L$），如果没找到再查右子树。

假如你想全面了解线段树，可以去看看 [维基百科](https://oi-wiki.org/ds/seg/)，有详细阐释，不过稍微有点难理解，对新手不太友好。推荐一篇我写过的 [题解](https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/2933254/xian-duan-shu-yuan-li-mo-ban-xiang-xi-tu-dlmy/)，里面介绍了链表形式和数组形式的线段树，以及 **动态开点** 做法，包含 *原理*、*模版代码*、*经典例题*。

注意，线段树的下标 $i$ 对应的是子数组的 **起始位置** $L$，而 $tree[i]$ 的值表示，当前遍历到 $R$ 时，子数组 $nums[i...R]$ 的平衡差。

对区间进行加减时，使用 $Lazy$ 懒标记，单次更新时间从 $O(n)$ 变为 $O(logn)$。

定义 $query()$ 函数找到最小的 $L$，使得该位置的值为 $0$。**优先** 递归左子树，一旦在左子树找到 $0$，直接返回，不再看右子树。

如何判断是不同元素？一个数字 $x$ 只有在它 “第一次出现” 在子数组中时，才对该子数组的计数有贡献。使用上面说到的 $prevIdx$ 数组，**预处理** 出每个元素上一次出现的位置。

在辅助线段树部分，套用模版中的 $pushDown$ 以及 $update$ 等函数。在主体部分，类似滑窗，固定 $R$ 更新区间 $(p,R]$，然后查找最左侧的 $L$，计算答案。

代码如下，已附加注释：

```Python
# python
class SegmentTree:
    def __init__(self, n):
        self.n = n
        suit_len = 2 << self.n.bit_length()
        # 维护区间内的最小值
        self.tree_min = [0] * suit_len
        # 维护区间内的最大值
        self.tree_max = [0] * suit_len
        # 懒惰标记，用于区间加法
        self.lazy = [0] * suit_len

    # 向下传递懒惰标记
    def push_down(self, node):
        if self.lazy[node] != 0:
            add_val = self.lazy[node]
            left = node * 2
            right = node * 2 + 1
            
            # 更新左子节点
            self.lazy[left] += add_val
            self.tree_min[left] += add_val
            self.tree_max[left] += add_val
            
            # 更新右子节点
            self.lazy[right] += add_val
            self.tree_min[right] += add_val
            self.tree_max[right] += add_val
            
            # 清除当前节点的标记
            self.lazy[node] = 0

    # 向上更新节点信息
    def push_up(self, node):
        # 当前区间的最小/最大值来源于左右子树
        self.tree_min[node] = min(self.tree_min[node * 2], self.tree_min[node * 2 + 1])
        self.tree_max[node] = max(self.tree_max[node * 2], self.tree_max[node * 2 + 1])

    # 区间更新：将 [l, r] 范围内的值全部加上 val
    def update(self, node, start, end, l, r, val):
        # 区间不重叠，直接返回
        if l > end or r < start:
            return
        
        # 当前区间完全包含在更新范围内
        if l <= start and end <= r:
            self.tree_min[node] += val
            self.tree_max[node] += val
            self.lazy[node] += val
            return
        
        # 否则下放标记，递归更新子节点
        self.push_down(node)
        mid = (start + end) // 2
        self.update(node * 2, start, mid, l, r, val)
        self.update(node * 2 + 1, mid + 1, end, l, r, val)
        
        # 子节点更新完后，更新当前节点
        self.push_up(node)

    # 寻找区间 [l, r] 内 最左边 的值为 0 的位置
    def find_first_zero(self, node, start, end, l, r):
        # 当前区间的最小值 > 0 或 最大值 < 0，不可能有 0
        if self.tree_min[node] > 0 or self.tree_max[node] < 0:
            return -1
        
        # 范围越界
        if l > end or r < start:
            return -1
            
        # 叶子
        if start == end:
            return start if self.tree_min[node] == 0 else -1
        
        # 下放标记
        self.push_down(node)
        mid = (start + end) // 2
        
        # 贪心，优先查左子树，因为我们要找最左边的下标 L
        res = self.find_first_zero(node * 2, start, mid, l, r)
        if res != -1:
            return res
        # 左边没找到，查右边
        return self.find_first_zero(node * 2 + 1, mid + 1, end, l, r)

class Solution:
    def longestBalanced(self, nums: list[int]) -> int:
        n = len(nums)
            
        # 记录每个数字上一次出现的位置
        last_pos = {}  # 值->下标
        prev_occur = [-1] * n  # 下标->下标
        
        for i, x in enumerate(nums):
            if x in last_pos:
                prev_occur[i] = last_pos[x]
            last_pos[x] = i
            
        # 初始化线段树
        st = SegmentTree(n)
        ans = 0
        
        # 移动右端点 R
        for R in range(n):
            val = nums[R]
            
            # 偶数平衡差 +1，奇数平衡差 -1
            change = 1 if val % 2 == 0 else -1
            
            # 新元素 nums[R] 只对起始点 L 位于 (prev_occur[R], R] 之间的子数组是"新"的
            update_l = prev_occur[R] + 1
            update_r = R
            
            # 区间全部加上 change
            st.update(1, 0, n - 1, update_l, update_r, change)
            
            # 在 [0, R] 范围内找最左边的 0
            # 找到一个 L，使得子数组 nums[L...R] 的平衡差为 0
            target_l = st.find_first_zero(1, 0, n - 1, 0, R)
            
            if target_l != -1:
                # 找到，计算长度
                cur_len = R - target_l + 1
                if cur_len > ans:
                    ans = cur_len
                    
        return ans
```

```Java
// java
class SegmentTree {
    int n;
    int[] treeMin;
    int[] treeMax;
    int[] lazy;

    public SegmentTree(int n) {
        this.n = n;
        // 比 4n 空间更小
        int suitLen = 2 << (32 - Integer.numberOfLeadingZeros(n));
        // 维护区间内的最小值
        this.treeMin = new int[suitLen];
        // 维护区间内的最大值
        this.treeMax = new int[suitLen];
        // 懒惰标记，用于区间加法
        this.lazy = new int[suitLen];
    }

    // 向下传递懒惰标记
    private void pushDown(int node) {
        if (this.lazy[node] != 0) {
            int addVal = this.lazy[node];
            int left = node * 2;
            int right = node * 2 + 1;

            // 更新左子节点
            this.lazy[left] += addVal;
            this.treeMin[left] += addVal;
            this.treeMax[left] += addVal;

            // 更新右子节点
            this.lazy[right] += addVal;
            this.treeMin[right] += addVal;
            this.treeMax[right] += addVal;

            // 清除当前节点的标记
            this.lazy[node] = 0;
        }
    }

    // 向上更新节点信息
    private void pushUp(int node) {
        // 当前区间的最小/最大值来源于左右子树
        this.treeMin[node] = Math.min(this.treeMin[node * 2], this.treeMin[node * 2 + 1]);
        this.treeMax[node] = Math.max(this.treeMax[node * 2], this.treeMax[node * 2 + 1]);
    }

    // 区间更新：将 [l, r] 范围内的值全部加上 val
    public void update(int node, int start, int end, int l, int r, int val) {
        // 区间不重叠，直接返回
        if (l > end || r < start) {
            return;
        }

        // 当前区间完全包含在更新范围内
        if (l <= start && end <= r) {
            this.treeMin[node] += val;
            this.treeMax[node] += val;
            this.lazy[node] += val;
            return;
        }

        // 否则下放标记，递归更新子节点
        pushDown(node);
        int mid = (start + end) / 2;
        update(node * 2, start, mid, l, r, val);
        update(node * 2 + 1, mid + 1, end, l, r, val);

        // 子节点更新完后，更新当前节点
        pushUp(node);
    }

    // 寻找区间 [l, r] 内 最左边 的值为 0 的位置
    public int findFirstZero(int node, int start, int end, int l, int r) {
        // 当前区间的最小值 > 0 或 最大值 < 0，不可能有 0
        if (this.treeMin[node] > 0 || this.treeMax[node] < 0) {
            return -1;
        }

        // 范围越界
        if (l > end || r < start) {
            return -1;
        }

        // 叶子
        if (start == end) {
            return this.treeMin[node] == 0 ? start : -1;
        }

        // 下放标记
        pushDown(node);
        int mid = (start + end) / 2;

        // 贪心，优先查左子树，因为我们要找最左边的下标 L
        int res = findFirstZero(node * 2, start, mid, l, r);
        if (res != -1) {
            return res;
        }
        // 左边没找到，查右边
        return findFirstZero(node * 2 + 1, mid + 1, end, l, r);
    }
}

class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;

        // 记录每个数字上一次出现的位置
        Map<Integer, Integer> lastPos = new HashMap<>(); // 值->下标
        int[] prevOccur = new int[n]; // 下标->下标
        Arrays.fill(prevOccur, -1);

        for (int i = 0; i < n; i++) {
            if (lastPos.containsKey(nums[i])) {
                prevOccur[i] = lastPos.get(nums[i]);
            }
            lastPos.put(nums[i], i);
        }

        // 初始化线段树
        SegmentTree st = new SegmentTree(n);
        int ans = 0;

        // 移动右端点 R
        for (int R = 0; R < n; R++) {
            int val = nums[R];

            // 偶数平衡差 +1，奇数平衡差 -1
            int change = (val % 2 == 0) ? 1 : -1;

            // 新元素 nums[R] 只对起始点 L 位于 (prevOccur[R], R] 之间的子数组是"新"的
            int updateL = prevOccur[R] + 1;
            int updateR = R;

            // 区间全部加上 change
            st.update(1, 0, n - 1, updateL, updateR, change);

            // 在 [0, R] 范围内找最左边的 0
            // 找到一个 L，使得子数组 nums[L...R] 的平衡差为 0
            int targetL = st.findFirstZero(1, 0, n - 1, 0, R);

            if (targetL != -1) {
                // 找到，计算长度
                int curLen = R - targetL + 1;
                if (curLen > ans) {
                    ans = curLen;
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，每次查询与更新的时间为 $O(logn)$
- 空间复杂度： $O(n)$，表示数组 $treeMin$ 和 $treeMax$ 的大小

这种解法速度比较慢，但是相对好理解，且空间超越 $100\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-balanced-subarray-ii/solutions/3900767/xian-duan-shu-lan-biao-ji-mo-ban-yu-chu-n87nx/)
