[Problem: 3228. 将 1 移动到末尾的最大操作次数](https://leetcode.cn/problems/maximum-number-of-operations-to-move-ones-to-the-end/description/)

### 方法：贪心 & 优化

题意：如果字符 $1$ 的右侧有 $0$，就需要将 $1$ 右移，直至所有 $1$ 都挪到最右边。

一个重要的发现：**'1'的相对顺序永远不会改变**。一个靠左的 $'1'$ 永远无法移动到它右边某个 $'1'$ 的右侧，因为规定了移动会在遇到另一个 $'1'$ 时停止。

在任何一步，都可能有多个 $'10'$ 的模式可供选择。例如 $s = '1010'$，我们可以选择操作 $i=0$ 处的 $'10'$，也可以选择 $i=2$ 的 $'10'$。

- 如果选择 $i=2$ (最右边的 $'10'$)，将 $'1010'$ 变为 $'1001'$。然后只能选择 $i=0$，将 $'1001'$ 变为 $'0011'$。总共 $2$ 次操作。
- 如果选择 $i=0$ (最左边的 $'10'$)，将 $'1010'$ 变为 $'0110'$。然后选择 $i=2$，将 $'0110'$ 变为 $'0101'$。最后选择 $i=1$，将 $'0101'$ 变为 $'0011'$。总共 $3$ 次操作。

为了让操作数最大，优先处理 **最左边** 的 $'10'$ 模式似乎是一个更优的策略。

为什么这种 **贪心** 思路正确？

将 $'1'$ 向右侧移动，遇到障碍物停止，就是一次操作。想象为马路上堵车，一辆车怎么样会走走停停最多次？那就是有一点空隙 $0$ 就走一段。

把字符串看作是交替出现的 $'1'$ 块和 $'0'$ 块的序列。例如 $s = '110010'$ 可以看作 $(1的块, 大小2)$, $(0的块, 大小2)$, $(1的块, 大小1)$, $(0的块, 大小1)$。

设想有 $k$ 个 $'1'$ 在一个块里，紧接着是 $m$ 个 $'0'$ 在另一个块里，即 $...1...10...0...$。如何移动 **一整块** $1$？从最右边的那个 $'1'$ 开始，

1. 这个 $'1'$ 移动越过 $m$ 个 $'0'$，花费 $1$ 次操作；
2. 原先的第 $k-1$ 个 $'1'$ 的右边是 $'0'$ 了，它也可以移动。它将越过 $m$ 个 $'0'$，又花费 $1$ 次操作；
3. 这个过程会持续 $k$ 次，直到这个块里所有的 $k$ 个 $'1'$ 都移动到了 $m$ 个 $'0'$ 的右边。

所以，一个包含 $k$ 个 $'1'$ 的块要整体移动过一个 $'0'$ 块，需要 $k$ 次操作。

把这个 **逻辑应用** 到整个字符串上。从左到右遍历，并维护一个计数器 $ones$，记录到目前为止遇到的 $'1'$ 的总数。这些 $'1'$ 都需要向右移动，看作 “先头部队”。

当我们遇到一个 $'0'$ 时，如果它的紧邻左侧是一个 $'1'$，即形成一个 $'1' -> '0'$ 的过渡，这意味着前面所有的 $'1'$ 遇到了一个需要穿越的 $'0'$ 块。根据上面的推导，这整个 “部队” 穿越这个 $'0'$ 块需要 $ones$ 次操作。

**总结** 整个流程，得出算法的步骤：

- 第一次遍历计算出串中 $'1'$ 的前缀和，其中 $prefix[i]$ 表示串 $s$ 的前 $i$ 个字符中 $'1'$ 的总数。
- 第二次遍历寻找触发操作的边界，也就是 $'10'$ 模式。如果 `s[i-1] = '1'` 且 `s[i] = '0'`，说明一个 $'1'$ 的区块结束，一个 $'0'$ 的区块开始。此时，将这个 $'0'$ 区块左边的所有 '1' 的数量 $prefix[i]$ 累加到答案中。

什么是前缀和？具体原理及做法，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxOperations(self, s: str) -> int:
        n = len(s)

        # prefix[i] 存储 s[0...i-1] 中 1 的数量
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + (1 if s[i] == '1' else 0)
        
        ans = 0
        # 查找 10 边界并累加结果
        for i in range(1, n):
            if s[i-1] == '1' and s[i] == '0':
                # 边界左侧所有的 1
                ans += prefix[i]
                
        return ans
```

```Java
// java
class Solution {
    public int maxOperations(String s) {
        int n = s.length();

        // prefix[i] 存储 s[0...i-1] 中 1 的数量
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + (s.charAt(i) == '1' ? 1 : 0);
        }
        
        int ans = 0;
        // 查找 10 边界并累加结果
        for (int i = 1; i < n; i++) {
            if (s.charAt(i - 1) == '1' && s.charAt(i) == '0') {
                // 边界左侧所有的 1
                ans += prefix[i];
            }
        }
                
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是字符串 $s$ 的长度
- 空间复杂度： $O(n)$，表示数组 $prefix$ 的长度

---

### 简化

将 “统计前缀和” 与 “累加答案” 的过程合二为一，并使用单一变量 $ones$ 替换上面的 $prefix$ 数组，即可实现一次遍历。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxOperations(self, s: str) -> int:
        ans = 0
        ones = 0
        
        # 标志位，用于判断是否已经遇到过 1
        has_seen_one = False
        
        for i in range(len(s)):
            if s[i] == '1':  # 累加 1 的数量
                ones += 1
            else:
                # 1 块的末尾遇到一个 0 块的开头
                if i > 0 and s[i-1] == '1':
                    ans += ones
         
        return ans
```

```Java
// java
class Solution {
    public int maxOperations(String s) {
        int ans = 0;
        int ones = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '1') { // 累加 1 的数量
                ones++;
            } else {
                // 1 块的末尾遇到一个 0 块的开头
                if (i > 0 && s.charAt(i - 1) == '1') {
                    ans += ones;
                }
            }
        }
         
        return ans;
    }
}
```

上面的代码速度不够快，因为每次遇到 $0$ 都需要判断前一个 $i-1$ 位置是否为 $1$。因此，采用标志位 $flag$，只有上一个位置是 $1$ 且当前是 $0$ 时才累加答案。

```Python
# python
class Solution:
    def maxOperations(self, s: str) -> int:
        ans = 0
        ones = 0
        # 标志位，用于识别从 1 块到 0 块的过渡
        trig_op = False

        for char in s:
            if char == '1':
                ones += 1
                # 设置标志位
                trig_op = True
            elif trig_op:  # 遇到 '0'，并且标志位为 True
                ans += ones
                # 防止同一个连续 '0' 块重复计数
                trig_op = False
        
        return ans
```

```Java
// java
class Solution {
    public int maxOperations(String s) {
        int ans = 0;
        int ones = 0;
        // 标志位，用于识别从 1 块到 0 块的过渡
        boolean trig_op = false;

        for (char c : s.toCharArray()) {
            if (c == '1') {
                ones++;
                // 设置标志位
                trig_op = true;
            } else if (trig_op) { // 遇到 '0'，并且标志位为 True
                ans += ones;
                // 防止同一个连续 '0' 块重复计数
                trig_op = false;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-number-of-operations-to-move-ones-to-the-end/solutions/3830648/tan-xin-cong-zuo-ce-kai-shi-chu-li-qian-vsneo/)
