[Problem: 2977. 转换字符串的最小成本 II](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/)

### Dijkstra & Floyd

相比于前一题 $2976$，本题数据量减小，但是变为多个字符转换，且前一个子串与后一个子串必须是同一个串，或者完全不相交。

将串 $xx$ 转化为串 $yy$，可能需要多步完成！比如 $xx\to ab\to bc\to\dots\to yy$。因此，本题实际上是 **图论**，而不是简单的直接查询 $cost$。

将每一个出现的字符串看作图中的 **节点**。

- 给定的 $original$ 到 $changed$ 的转换可以看作图中的 **有向边**，边的权重就是转换成本 $cost$
- 从字符 $source[i]$ 变成 $target[i]$ 的最小成本，实际上就是在图中寻找从节点 $source[i]$ 到节点 $target[i]$ 的 **最短路径**

按照字符串长度进行分组。即所有长度为 $1$ 的子串构成一个图，长度为 $2$ 的构成另一个图，以此类推。

这里不是经典的单源最短路，但是在当前图内，所有节点都是单独的源。此时，使用多次 $Dijkstra$ 来计算任意两个字符串之间的最小转换代价。

> 最短路问题，对应 $Dijkstra$ 算法。朴素/堆优化版本的原理及模版，请查看这篇 [题解](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/solutions/2848394/po-su-dijkstradui-you-hua-mo-ban-zhao-lu-ve92/)。

如何求解最小成本？到底是截取长度为 $1$ 还是更长的子串？

**定义** $dp[i]$ 表示将字符串 $source$ 的前 $i$ 个字符（即 $source[0...i-1]$）转换为 $target$ 的前 $i$ 个字符（即 $target[0...i-1]$）所需的最小成本。

初始化 $dp[0] = 0$，表示空字符串转换为空字符串的成本为 $0$。以及 $dp[1\dots n]$ 初始化为 $+\infty$，表示尚未计算或不可达。

对于每一个位置 $i$，我们考虑 **最后一步操作** 是什么：

**情况** $A$：最后一个字符不需要转换（或单字符匹配）。

如果 $source[i-1]=target[i-1]$，那可以继承处理完前 $i-1$ 个字符的成本。也即转移方程为

$$
dp[i] = min(dp[i], dp[i-1])
$$

注意，如果字符不相等，这一步不做操作在逻辑上是不可行的，所以只有相等时才考虑从 $dp[i-1]$ 进行无成本转移。如果字符不相等但存在单字符转换规则（如 $a\to b$），这会被归类到下面的情况 $B$ 中。

**情况** $B$：不相等，需要替换子串结尾。

尝试所有可能的替换长度 $L$，其中 $L$ 必须是 $original$ 中出现过的长度。如果我们在结尾处替换了一个长度为 $L$ 的子串，对应 $source[i-L : i]$ 变为 $target[i-L : i]$。前提条件是：

1. 有足够的长度回退，也即 $i\geq L$。
2. $dp[i-L]$ 必须是可达的，不是无穷大。
3. 存在从 $source[i-L : i]$ 到 $target[i-L : i]$ 的转换路径，成本为 $cost$。

此时转移方程为

$$
dp[i] = min(dp[i], dp[i-L] + cost)
$$

**总结**：先预处理收集 $original$ 和 $changed$ 中出现的所有字符串，按长度分组。然后计算每个长度下，所有字符串之间的最短路径。最后跑一遍 $DP$，枚举所有可能的切割方案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        n = len(source)
        
        # 按长度分组建图
        # graph_data[length] 存储该长度下的所有边 (u, v, weight)
        # string_sets[length] 存储该长度下出现的所有唯一字符串
        graph_data = defaultdict(list)
        string_sets = defaultdict(set)
        
        for o, c, w in zip(original, changed, cost):
            l = len(o)
            graph_data[l].append((o, c, w))
            string_sets[l].add(o)
            string_sets[l].add(c)
        
        # 预计算每个长度下的所有点对最短路径
        min_costs = {}
        
        for length, str_set in string_sets.items():
            # 构建邻接表
            graph = defaultdict(list)
            for o, c, w in graph_data[length]:
                graph[o].append((c, w))

            min_costs[length] = {}

            # 对该长度下的每一个起点跑 Dijkstra
            for s in str_set:
                dist = {s: 0}
                # 优先队列，存储 (当前累计成本, 当前节点)
                pq = [(0, s)]

                while pq:
                    cur_dist, u = heapq.heappop(pq)
                    # 已经计算过
                    if cur_dist > dist[u]:
                        continue
                    # 遍历邻居
                    for v, w in graph[u]:
                        new_dist = cur_dist + w
                        # 如果找到了更短的路径，更新并入堆
                        if v not in dist or new_dist < dist[v]:
                            dist[v] = new_dist
                            heapq.heappush(pq, (new_dist, v))

                # 结构存入查找表
                min_costs[length][s] = dist

        # dp[i] 表示 source[0:i] 转换为 target[0:i] 的最小成本
        dp = [inf] * (n + 1)
        dp[0] = 0
        
        # 提取出所有可用的转换长度
        available_lengths = sorted(min_costs.keys())
        
        # 从前向后遍历
        for i in range(1, n + 1):
            # 如果当前字符相等，直接继承
            if source[i-1] == target[i-1]:
                dp[i] = min(dp[i], dp[i-1])
            
            # 尝试应用子串转换
            for length in available_lengths:
                # 必须有足够的字符长度，更长的不用看
                if i < length:
                    break
                
                prev_idx = i - length
                
                # 前置状态都不可达
                if dp[prev_idx] == inf:
                    continue
                
                # 获取子串 source[i-length : i]
                sub_s = source[prev_idx : i]
                sub_t = target[prev_idx : i]
                
                # 查表看是否存在转换路径
                if sub_s in min_costs[length] and sub_t in min_costs[length][sub_s]:
                    cost_val = min_costs[length][sub_s][sub_t]
                    dp[i] = min(dp[i], dp[prev_idx] + cost_val)
        
        return dp[n] if dp[n] != inf else -1
```

```Java
// java
class Solution {
    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {
        int n = source.length();

        // 按长度分组建图
        // graph_data[length] 存储该长度下的所有边 (u, v, weight)
        // string_sets[length] 存储该长度下出现的所有唯一字符串
        Map<Integer, List<Object[]>> graphData = new HashMap<>();
        Map<Integer, Set<String>> stringSets = new HashMap<>();

        for (int i = 0; i < original.length; i++) {
            String o = original[i];
            String c = changed[i];
            int w = cost[i];
            int l = o.length();

            graphData.computeIfAbsent(l, k -> new ArrayList<>())
                     .add(new Object[]{o, c, w});
            stringSets.computeIfAbsent(l, k -> new HashSet<>()).add(o);
            stringSets.get(l).add(c);
        }

        // 预计算每个长度下的所有点对最短路径
        Map<Integer, Map<String, Map<String, Integer>>> minCosts = new HashMap<>();

        for (int length : stringSets.keySet()) {
            Set<String> strSet = stringSets.get(length);

            // 构建邻接表
            Map<String, List<Object[]>> graph = new HashMap<>();
            for (Object[] e : graphData.get(length)) {
                String u = (String) e[0];
                String v = (String) e[1];
                int w = (int) e[2];
                graph.computeIfAbsent(u, k -> new ArrayList<>())
                     .add(new Object[]{v, w});
            }

            minCosts.put(length, new HashMap<>());

            // 对该长度下的每一个起点跑 Dijkstra
            for (String s : strSet) {
                Map<String, Integer> dist = new HashMap<>();
                dist.put(s, 0);
                // 优先队列，存储 (当前累计成本, 当前节点)
                PriorityQueue<Object[]> pq = new PriorityQueue<>(
                        Comparator.comparingInt(a -> (int) a[0])
                );
                pq.offer(new Object[]{0, s});

                while (!pq.isEmpty()) {
                    Object[] cur = pq.poll();
                    int curDist = (int) cur[0];
                    String u = (String) cur[1];
                    // 已经计算过
                    if (curDist > dist.get(u)) continue;
                    // 遍历邻居
                    for (Object[] nxt : graph.getOrDefault(u, Collections.emptyList())) {
                        String v = (String) nxt[0];
                        int w = (int) nxt[1];
                        int newDist = curDist + w;
                        // 如果找到了更短的路径，更新并入堆
                        if (!dist.containsKey(v) || newDist < dist.get(v)) {
                            dist.put(v, newDist);
                            pq.offer(new Object[]{newDist, v});
                        }
                    }
                }
                // 结构存入查找表
                minCosts.get(length).put(s, dist);
            }
        }

        // dp[i] 表示 source[0:i] 转换为 target[0:i] 的最小成本
        long INF = Long.MAX_VALUE / 4;
        long[] dp = new long[n + 1];
        Arrays.fill(dp, INF);
        dp[0] = 0;

        // 提取出所有可用的转换长度
        List<Integer> availableLengths = new ArrayList<>(minCosts.keySet());
        Collections.sort(availableLengths);

        // 从前向后遍历
        for (int i = 1; i <= n; i++) {
            // 如果当前字符相等，直接继承
            if (source.charAt(i - 1) == target.charAt(i - 1)) {
                dp[i] = Math.min(dp[i], dp[i - 1]);
            }

            // 尝试应用子串转换
            for (int length : availableLengths) {
                // 必须有足够的字符长度，更长的不用看
                if (i < length) break;

                int prevIdx = i - length;
                // 前置状态都不可达
                if (dp[prevIdx] == INF) continue;

                // 获取子串 source[i-length : i]
                String subS = source.substring(prevIdx, i);
                String subT = target.substring(prevIdx, i);

                // 查表看是否存在转换路径
                if (minCosts.get(length).containsKey(subS)
                        && minCosts.get(length).get(subS).containsKey(subT)) {
                    dp[i] = Math.min(
                            dp[i],
                            dp[prevIdx] + minCosts.get(length).get(subS).get(subT)
                    );
                }
            }
        }

        return dp[n] == INF ? -1 : (int) dp[n];
    }
}
```

对于固定串长为 $l$ 来说，将不同字符串的个数记作 $p$，转换到其他串的次数记作 $q$。单次建图时间为 $O(\Sigma q)$，单次 $Dijkstra$ 时间为 $O(p(p+q)logp)$。所有长度合并的时间同理是 $O(p(p+q)logp)$，跑一遍 $DP$ 时间为 $O(nL)$。

- 时间复杂度： $O(\Sigma p(p+q)logp+nL)$，其中 $n$ 是串 $source$ 的长度，而 $L$ 是串长的种类数
- 空间复杂度： $O(\Sigma p^2+n)$，表示邻接表 $graph$ 以及数组 $dp$ 等的大小

---

### $Floyd$

由于节点数量比较少，且是稠密图，我们可以使用 $Floyd$ 算法，具体原理看这篇 [题解](https://leetcode.cn/problems/network-delay-time/solutions/2999961/tu-lun-bfs-liang-chong-dijkstra-floyd-be-cfdv/)。

实际上，前置的预处理分组，以及后置的 $DP$ 计算，这两部分 **完全相同**，不需要更改。只需要将 $Dijkstra$ 的部分换成 $Floyd$ 即可。

$Floyd$ 的本质是动规，用它计算最短路径：三层循环遍历所有中间节点 $k$，尝试通过 $k$ 来缩短 $i$ 到 $j$ 的距离，也即

$$
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
$$

不过，最好将子串 **映射** 为数字 $id$ 后再进行 $Floyd$。经本人实测，如果将 $dist$ 换为字符串 $Map$ 而不是二维 $int$ 数组，速度更慢，在 $Python$ 中大概增长 $100ms$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        n = len(source)
        
        # 按长度分组建图
        # graph_data[length] 存储该长度下的所有边 (u, v, weight)
        # string_sets[length] 存储该长度下出现的所有唯一字符串
        graph_data = defaultdict(list)
        string_sets = defaultdict(set)
        
        for o, c, w in zip(original, changed, cost):
            l = len(o)
            graph_data[l].append((o, c, w))
            string_sets[l].add(o)
            string_sets[l].add(c)
        
        # 预计算每个长度下的所有点对最短路径
        min_costs = {}
        
        for length, str_set in string_sets.items():
            # 将字符串映射为 ID
            sorted_strs = list(str_set)
            str_to_id = {s: i for i, s in enumerate(sorted_strs)}
            m = len(sorted_strs)
            
            # 距离矩阵
            dist = [[inf] * m for _ in range(m)]
            for i in range(m):
                dist[i][i] = 0
            
            # 填充初始边
            for o, c, w in graph_data[length]:
                u, v = str_to_id[o], str_to_id[c]
                dist[u][v] = min(dist[u][v], w)
            
            # Floyd
            for k in range(m):
                for i in range(m):
                    if dist[i][k] == inf: continue
                    for j in range(m):
                        if dist[k][j] == inf: continue
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
            
            # 将结果存入查找表
            min_costs[length] = {}
            for i, s_src in enumerate(sorted_strs):
                min_costs[length][s_src] = {}
                for j, s_dst in enumerate(sorted_strs):
                    if dist[i][j] != inf:
                        min_costs[length][s_src][s_dst] = dist[i][j]

        # dp[i] 表示 source[0:i] 转换为 target[0:i] 的最小成本
        dp = [inf] * (n + 1)
        dp[0] = 0
        
        # 提取出所有可用的转换长度
        available_lengths = sorted(min_costs.keys())
        
        # 从前向后遍历
        for i in range(1, n + 1):
            # 如果当前字符相等，直接继承
            if source[i-1] == target[i-1]:
                dp[i] = min(dp[i], dp[i-1])
            
            # 尝试应用子串转换
            for length in available_lengths:
                # 必须有足够的字符长度，更长的不用看
                if i < length:
                    break
                
                prev_idx = i - length
                
                # 前置状态都不可达
                if dp[prev_idx] == inf:
                    continue
                
                # 获取子串 source[i-length : i]
                sub_s = source[prev_idx : i]
                sub_t = target[prev_idx : i]
                
                # 查表看是否存在转换路径
                if sub_s in min_costs[length] and sub_t in min_costs[length][sub_s]:
                    cost_val = min_costs[length][sub_s][sub_t]
                    dp[i] = min(dp[i], dp[prev_idx] + cost_val)
        
        return dp[n] if dp[n] != inf else -1
```

```Java
// java
class Solution {
    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {
        int n = source.length();

        // 按长度分组建图
        // graph_data[length] 存储该长度下的所有边 (u, v, weight)
        // string_sets[length] 存储该长度下出现的所有唯一字符串
        Map<Integer, List<Object[]>> graphData = new HashMap<>();
        Map<Integer, Set<String>> stringSets = new HashMap<>();

        for (int i = 0; i < original.length; i++) {
            String o = original[i];
            String c = changed[i];
            int w = cost[i];
            int l = o.length();

            graphData.computeIfAbsent(l, k -> new ArrayList<>())
                     .add(new Object[]{o, c, w});
            stringSets.computeIfAbsent(l, k -> new HashSet<>()).add(o);
            stringSets.get(l).add(c);
        }

        // 预计算每个长度下的所有点对最短路径
        Map<Integer, Map<String, Map<String, Integer>>> minCosts = new HashMap<>();

        for (int length : stringSets.keySet()) {
            List<String> strs = new ArrayList<>(stringSets.get(length));
            int m = strs.size();
            // 将字符串映射为 ID
            Map<String, Integer> strToId = new HashMap<>();
            for (int i = 0; i < m; i++) {
                strToId.put(strs.get(i), i);
            }

            // 距离矩阵
            int INF = Integer.MAX_VALUE / 4;
            int[][] dist = new int[m][m];
            for (int i = 0; i < m; i++) {
                Arrays.fill(dist[i], INF);
                dist[i][i] = 0;
            }

            // 填充初始边
            for (Object[] e : graphData.get(length)) {
                int u = strToId.get((String) e[0]);
                int v = strToId.get((String) e[1]);
                int w = (int) e[2];
                dist[u][v] = Math.min(dist[u][v], w);
            }

            // Floyd
            for (int k = 0; k < m; k++) {
                for (int i = 0; i < m; i++) {
                    if (dist[i][k] == INF) continue;
                    for (int j = 0; j < m; j++) {
                        if (dist[k][j] == INF) continue;
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }

            // 将结果存入查找表
            minCosts.put(length, new HashMap<>());
            for (int i = 0; i < m; i++) {
                String src = strs.get(i);
                minCosts.get(length).put(src, new HashMap<>());
                for (int j = 0; j < m; j++) {
                    if (dist[i][j] != INF) {
                        minCosts.get(length).get(src)
                                .put(strs.get(j), dist[i][j]);
                    }
                }
            }
        }

        // dp[i] 表示 source[0:i] 转换为 target[0:i] 的最小成本
        long INF = Long.MAX_VALUE / 4;
        long[] dp = new long[n + 1];
        Arrays.fill(dp, INF);
        dp[0] = 0;

        // 提取出所有可用的转换长度
        List<Integer> availableLengths = new ArrayList<>(minCosts.keySet());
        Collections.sort(availableLengths);

        // 从前向后遍历
        for (int i = 1; i <= n; i++) {
            // 如果当前字符相等，直接继承
            if (source.charAt(i - 1) == target.charAt(i - 1)) {
                dp[i] = Math.min(dp[i], dp[i - 1]);
            }

            // 尝试应用子串转换
            for (int length : availableLengths) {
                // 必须有足够的字符长度，更长的不用看
                if (i < length) break;

                int prevIdx = i - length;
                // 前置状态都不可达
                if (dp[prevIdx] == INF) continue;

                // 获取子串 source[i-length : i]
                String subS = source.substring(prevIdx, i);
                String subT = target.substring(prevIdx, i);

                // 查表看是否存在转换路径
                if (minCosts.get(length).containsKey(subS)
                        && minCosts.get(length).get(subS).containsKey(subT)) {
                    dp[i] = Math.min(
                            dp[i],
                            dp[prevIdx] + minCosts.get(length).get(subS).get(subT)
                    );
                }
            }
        }

        return dp[n] == INF ? -1 : (int) dp[n];
    }
}
```

- 时间复杂度： $O(\Sigma p^3+nL)$，三重 $for$ 计算所有字符间的距离
- 空间复杂度： $O(\Sigma p^2+n)$，同理

实测后，第一种 $Dijkstra$ 居然还更快，耗时分别为 $533ms$，超过 $100\%$。而后者耗时 $595ms$，仅超过 $93\%$。至于字典树等解法，本人觉得比较复杂，这里不再介绍。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/solutions/3892317/shuang-jie-dijkstra-floyd-dpwu-xu-zi-dia-j84p/)
