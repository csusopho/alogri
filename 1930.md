[Problem: 1930. 长度为 3 的不同回文子序列](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/)

### 方法：前后缀 & 位运算

回文串长度为 $3$，也就是 $xtx$ 的形式。

总共三个字母，只有两个自由度。一个简单的 **想法**：固定第一个字母为 $x$，也就随之确定最后一个字母为 $x$，只需要判断两个字母之间，有多少不同字母。

从 $s$ 中挑选子序列，如果首尾字母被固定为 $x$，为了让不同的子序列尽可能多，应该使中间字母的可选长度更大，得出一个 **贪心** 思路：找出串 $s$ 中第一次/最后一次出现的 $x$，分别作为子序列的首尾元素。

此时，假设第一次/最后一次出现的索引为 $i,j$，那么以 $x$ 为首尾的不同子序列数，就是 **串 $s[i,j]$ 内部不同字母的个数**。

总结：预处理，找出每种字母第一/最后出现的位置。在主循环内，枚举 $26$ 种字母作为首尾字母，然后截取 $[i,j]$ 子串，统计其中不同字母的个数，累加。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        # 记录每个字符第一次出现的索引
        first = [-1] * 26
        # 最后一次出现的索引
        last = [-1] * 26
        
        for i, char in enumerate(s):
            idx = ord(char) - ord('a')
            # 第一次遇到
            if first[idx] == -1:
                first[idx] = i
            # 最后出现位置
            last[idx] = i

        ans = 0
        # 枚举首尾字母
        for i in range(26):
            first_idx = first[i]
            last_idx = last[i]
            
            # 必须是不同位置
            if first_idx < last_idx:
                # 子字符串
                substring = s[first_idx + 1:last_idx]
                # 不同字符的数量
                ans += len(set(substring))
                
        return ans
```

```Java
// java
class Solution {
    public int countPalindromicSubsequence(String s) {
        // 记录每个字符第一次出现的索引
        int[] first = new int[26];
        Arrays.fill(first, -1);
        // 最后一次出现的索引
        int[] last = new int[26];

        for (int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            // 第一次遇到
            if (first[idx] == -1) {
                first[idx] = i;
            }
            // 最后出现位置
            last[idx] = i;
        }

        int ans = 0;
        // 枚举首尾字母
        for (int i = 0; i < 26; i++) {
            int firstIdx = first[i];
            int lastIdx = last[i];

            // 必须是不同位置
            if (firstIdx < lastIdx) {
                // 子字符串
                // 使用 Set 来统计不同字符的数量
                Set<Character> uniqueChars = new HashSet<>();
                for (int j = firstIdx + 1; j < lastIdx; j++) {
                    uniqueChars.add(s.charAt(j));
                }
                // 不同字符的数量
                ans += uniqueChars.size();
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(|\Sigma|\times n)$，其中 $n$ 是串 $s$ 的长度，而 $|\Sigma|=26$ 表示字符集大小。截取的串长小于 $n$，实际运行时间更短
- 空间复杂度： $O(|\Sigma|+n)$，表示子串 $sub$ 以及数组 $first$ 的大小

当然，如果不想预处理统计 $left$ 数组，可以暴力一点，使用库函数查找。

```Python
# python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        ans = 0 
        elements = 'abcdefghijklmnopqrstuvwxyz'

        for char in elements:  # 遍历符号表，找两侧字符
            left = s.find(char)
            right = s.rfind(char)

            if right - left > 1:  # 截取中间部分
                sub = s[left + 1: right] 

                for j in elements:  # 遍历符号表，找出中间字符
                    if j in sub:
                        ans += 1
        
        return ans 
```

```Java
// java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int ans = 0;
        
        for (char c = 'a'; c <= 'z'; c++) { // 遍历符号表，找两侧字符
            int left = s.indexOf(c);
            int right = s.lastIndexOf(c);

            if (right - left > 1) { // 截取中间部分
                String sub = s.substring(left + 1, right);
                
                for (char j = 'a'; j <= 'z'; j++) { // 遍历符号表，找出中间字符
                    // 如果中间字符 j 在子字符串 sub 中存在
                    if (sub.indexOf(j) != -1) {
                        ans += 1;
                    }
                }
            }
        }
        return ans;
    }
}
```

时间复杂度不变，空间复杂度变为 $O(1)$，具体运行速度与语言相关。实测这段 $Python$ 代码速度最快（估计 $Java$ 不是），时间为 $3ms$，超过 $98.5\%$。

有些小伙伴，会使用 *前缀和* 加快 “统计不同字符” 的过程，实际上效果没加速，反而使得总时间变为 $1494ms$。算是一种好思路，不过本题的数据量较小，所以结果相反。对代码感兴趣的话，评论区留言，我再附上。

---

### 枚举中间

仿照灵神的思路，上面的做法是枚举首尾字母，如果换成枚举 **中间字母**，怎么做？

核心 **思路**：固定中间字符为 $t$，向左/向右寻找相同的字母。

因此，我们提前 **预处理**，找出每个字符左侧的所有唯一字符，以及右侧的所有唯一字符。假设当前字符的左侧含有 $a,b,x$，右侧含有 $g,t,x$，则相同字符就是两者的 **交集**，也即 $\{x\}$，长度为 $1$ 说明有一个相同字符。

**流程**：预处理，得出每个字符左/右侧的字符集合；主循环中，统计中间字符左右的相同字符数，累加。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        # prefix_sets[i] 存储 s[0...i] 中所有唯一字符的集合
        prefix_sets = [set() for _ in range(n)]
        cur_set = set()
        for i in range(n):
            cur_set.add(s[i])
            prefix_sets[i] = cur_set.copy()

        # suffix_sets[i] 存储 s[i...n-1] 中所有唯一字符的集合
        suffix_sets = [set() for _ in range(n)]
        cur_set = set()
        for i in range(n - 1, -1, -1):
            cur_set.add(s[i])
            suffix_sets[i] = cur_set.copy()

        # res_sets[k] 将存储当中间字符是'a'+k时，所有可用的外围字符的集合
        res_sets = [set() for _ in range(26)]
        # 枚举中间字符
        for i in range(1, n - 1):
            # 左侧（s[0...i-1]）的字符集
            left_set = prefix_sets[i - 1]
            # 右侧（s[i+1...n-1]）的字符集
            right_set = suffix_sets[i + 1]
            
            # 找到同时存在于左右两侧的字符
            common_outers = left_set.intersection(right_set)
            # 当前中间字符的索引
            middle_char_idx = ord(s[i]) - ord('a')
            # 将所有共同的外围字符，添加到当前中间字符的结果集中
            res_sets[middle_char_idx].update(common_outers)

        # 累加的是所有 (中间字符, 外围字符) 的唯一配对数
        ans = 0
        for outer_set in res_sets:
            ans += len(outer_set)
            
        return ans
```

```Java
// java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        // prefix_sets[i] 存储 s[0...i] 中所有唯一字符的集合
        Set<Character>[] prefix_sets = new HashSet[n];
        Set<Character> cur_set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            cur_set.add(s.charAt(i));
            prefix_sets[i] = new HashSet<>(cur_set);
        }

        // suffix_sets[i] 存储 s[i...n-1] 中所有唯一字符的集合
        Set<Character>[] suffix_sets = new HashSet[n];
        cur_set = new HashSet<>();
        for (int i = n - 1; i >= 0; i--) {
            cur_set.add(s.charAt(i));
            suffix_sets[i] = new HashSet<>(cur_set);
        }

        // res_sets[k] 将存储当中间字符是'a'+k时，所有可用的外围字符的集合
        Set<Character>[] res_sets = new HashSet[26];
        for(int i = 0; i < 26; i++) {
            res_sets[i] = new HashSet<>();
        }

        // 枚举中间字符
        for (int i = 1; i < n - 1; i++) {
            // 左侧（s[0...i-1]）的字符集
            Set<Character> left_set = prefix_sets[i - 1];
            // 右侧（s[i+1...n-1]）的字符集
            Set<Character> right_set = suffix_sets[i + 1];
            
            // 找到同时存在于左右两侧的字符
            Set<Character> common_outers = new HashSet<>(left_set);
            common_outers.retainAll(right_set); // 取交集

            // 当前中间字符的索引
            int middle_char_idx = s.charAt(i) - 'a';
            // 将所有共同的外围字符，添加到当前中间字符的结果集中
            res_sets[middle_char_idx].addAll(common_outers);
        }

        // 累加的是所有 (中间字符, 外围字符) 的唯一配对数
        int ans = 0;
        for (Set<Character> outer_set : res_sets) {
            ans += outer_set.size();
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(|\Sigma|\times n)$
- 空间复杂度： $O(|\Sigma|\times n)$

---

### 位运算

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 对应的二进制数为 $10011$。

应用到数组中，数 $5=101$ 可以代表数组中的第 $0$ 个和第 $2$ 个元素被选中，其余元素都没选择。

通过 **移位** 的方式，可以快速判断某个数是否在集合中或者添加某个数到集合中。第 $i$ 位为 $1$ 就表示 $nums[i]$ 在集合中，增加一个数就代表将第 $i$ 位置 $1$。

如果换成字符，举个例子，状态 $0010$ 表示包含第二个字母 $b$，而 $0010|(1<<2) = 0110$ 就表示在此基础上，增加一个字符 $c$。

只需要稍微修改，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        # prefix_mask[i] 存储 s[0...i] 中所有唯一字符的位掩码
        prefix_mask = [0] * n
        cur_mask = 0
        for i in range(n):
            cur_mask |= (1 << (ord(s[i]) - ord('a')))
            prefix_mask[i] = cur_mask

        # suffix_mask[i] 存储 s[i...n-1] 中所有唯一字符的位掩码
        suffix_mask = [0] * n
        cur_mask = 0
        for i in range(n - 1, -1, -1):
            cur_mask |= (1 << (ord(s[i]) - ord('a')))
            suffix_mask[i] = cur_mask

        # res_mask[k] 将存储当中间字符是'a'+k时，所有可用外围字符的位掩码
        res_mask = [0] * 26
        # 枚举中间字符
        for i in range(1, n - 1):
            # 左侧（s[0...i-1]）的字符集掩码
            left_mask = prefix_mask[i - 1]
            # 右侧（s[i+1...n-1]）的字符集掩码
            right_mask = suffix_mask[i + 1]
            
            # 找到同时存在于左右两侧的字符
            common_mask = left_mask & right_mask
            # 当前中间字符的索引
            middle_char_idx = ord(s[i]) - ord('a')
            # 关联
            res_mask[middle_char_idx] |= common_mask

        # 累加的是所有 (中间字符, 外围字符) 的唯一配对数
        ans = 0
        for mask in res_mask:
            ans += mask.bit_count()
            
        return ans
```

```Java
// java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();

        // suffix_sets[i] 存储 s[i+1:] 中所有唯一字符的集合
        Set<Character>[] suffix_sets = new HashSet[n];
        for(int i = 0; i < n; i++) {
            suffix_sets[i] = new HashSet<>();
        }
        Set<Character> cur_suffix = new HashSet<>();
        // 从右向左遍历
        for (int i = n - 2; i >= 0; i--) {
            // 加入到当前后缀集合中
            cur_suffix.add(s.charAt(i + 1));
            // 存入数组 (需要拷贝)
            suffix_sets[i] = new HashSet<>(cur_suffix);
        }

        // res[k] 将存储当外围字符是'a'+k时，所有唯一的中间字符
        Set<Character>[] res = new HashSet[26];
        for(int i = 0; i < 26; i++) {
            res[i] = new HashSet<>();
        }
        Set<Character> left_chars = new HashSet<>();

        // 枚举中间字符
        for (int i = 1; i < n - 1; i++) {
            // 左边字符加入集合
            left_chars.add(s.charAt(i - 1));
            // 当前字符
            char middle_char = s.charAt(i);
            // 右侧字符集合
            Set<Character> right_chars = suffix_sets[i];

            // 计算在 s[i] 左边和右边都出现过的字符集
            Set<Character> common_outers = new HashSet<>(left_chars);
            common_outers.retainAll(right_chars); // 取交集

            // 对于每一个共同的外围字符
            // 将当前中间字符，添加到对应外围字符的结果集合中
            for (char outer_char : common_outers) {
                int outer_idx = outer_char - 'a';
                res[outer_idx].add(middle_char);
            }
        }
        
        // 对每个外围字符，其结果集合的大小就是不同中间字符的个数
        int ans = 0;
        for (Set<Character> middle_char_set : res) {
            ans += middle_char_set.size();
        }

        return ans;
    }
}
```

- 时间复杂度： $O(|\Sigma|+n)$，注意这里不是相乘
- 空间复杂度： $O(|\Sigma|+n)$

如果将统计 $prefix$ 的过程与 “枚举中间” 的过程合二为一，变为三个 $for$ 循环，实测速度会慢上很多倍，变为 $1775ms$。这最后一版代码运行时间为 $295ms$，与灵神的最终优化代码，时间相差无几。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solutions/3838259/si-jie-mei-ju-shou-wei-zhong-jian-zi-mu-4nan6/)
