[Problem: 799. 香槟塔](https://leetcode.cn/problems/champagne-tower/description/)

### 方法：动规 & 空间优化

当杯子装满时，只会留住 $1$ 单位的香槟，其余量向左右平均溢出。

什么叫做左右？下标容易混淆？

```Java
   x
  x x
 x x x
x x x x
```

把它拉直，再看看呢？

```Java
值                对应下标
x                 (0,0)
x x               (1,0), (1,1)
x x x             (2,0), (2,1), (2,2)
x x x x           (3,0), (3,1), (3,2), (3,3)
```

当前坐标位于 $(i,j)$，则下一层的左侧坐标为 $(i+1,j)$，右侧坐标为 $(i+1,j+1)$。

不需要按照 “时间” 去一滴滴模拟，而是按照 **层级** 来模拟。

- 初始时，把所有的香槟全部一股脑倒进第 $0$ 层的那个杯子里。
- 从上往下遍历每一层。如果某个杯子里的酒超过了 $1$，它就会把 **多出来的部分** 平分给下一层左右两边的杯子。
- 遍历到指定行数后，就能得出目标杯子里有多少酒。

**定义** $tower[i][j]$ 表示第 $i$ 层第 $j$ 个杯子接收到的香槟总量。

> 这个定义是每一杯总接收量，允许 $>1$，而不是剩余量。

按层模拟，代码如下，已附加注释：

```Python
# python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # tower[i][j] 表示第 i 层第 j 个杯子接收到的香槟总量
        tower = [[0] * 102 for _ in range(102)]
    
        # 把所有酒先倒进第一个杯子
        tower[0][0] = poured
        
        # 从第一层开始处理
        for r in range(query_row):
            for c in range(r + 1):
                # 当前杯子的酒量
                current_volume = tower[r][c]
                
                # 酒溢出了
                if current_volume > 1:
                    # 溢出的平分
                    overflow = (current_volume - 1) / 2.0
                    
                    # 流向下一层的左边
                    tower[r+1][c] += overflow
                    # 流向下一层的右边
                    tower[r+1][c+1] += overflow
                    
        # 最大不能超过 1
        return min(1.0, tower[query_row][query_glass])
```

```Java
// java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        // tower[i][j] 表示第 i 层第 j 个杯子接收到的香槟总量
        double[][] tower = new double[102][102];
    
        // 把所有酒先倒进第一个杯子
        tower[0][0] = (double) poured;
        
        // 从第一层开始处理
        for (int r = 0; r < query_row; r++) {
            for (int c = 0; c <= r; c++) {
                // 当前杯子的酒量
                double current_volume = tower[r][c];
                
                // 酒溢出了
                if (current_volume > 1) {
                    // 溢出的平分
                    double overflow = (current_volume - 1) / 2.0;
                    
                    // 流向下一层的左边
                    tower[r + 1][c] += overflow;
                    // 流向下一层的右边
                    tower[r + 1][c + 1] += overflow;
                }
            }
        }
                    
        // 最大不能超过 1
        return Math.min(1.0, tower[query_row][query_glass]);
    }
}
```

按层遍历，总共 $query\_row$ 层，将它简记为 $r$。

- 时间复杂度： $O(r^2)$，第 $x$ 层有 $x$ 杯香槟，总共 $r$ 层
- 空间复杂度： $O(r^2)$，代码中固定为 $102\times 102$

---

### 优化

本质上，上面的这种解法属于动态规划。由于 $tower[r+1]$ 只用到 $tower[r]$ 的值，所以可以对上述解法进行空间优化。

使用队列 $tower$ 存储当前层的所有杯香槟。按照 $BFS$ 的逻辑，一次遍历一层。

代码如下，已附加注释：

```Python
# python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # 只保留当前层的香槟量
        layer = [float(poured)]
        
        for r in range(query_row):
            # 下一层的大小是当前层长度 + 1
            next_layer = [0.0] * (len(layer) + 1)
            
            for c in range(len(layer)):
                volume = layer[c]
                # 溢出
                if volume > 1:
                    excess = (volume - 1) / 2.0
                    next_layer[c] += excess
                    next_layer[c+1] += excess
            
            # 更新 layer 为下一层
            layer = next_layer
        
        return min(1.0, layer[query_glass])
```

```Java
// java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        // 只保留当前层的香槟量
        double[] layer = { (double) poured };
        
        for (int r = 0; r < query_row; r++) {
            // 下一层的大小是当前层长度 + 1
            double[] next_layer = new double[layer.length + 1];
            
            for (int c = 0; c < layer.length; c++) {
                double volume = layer[c];
                // 溢出
                if (volume > 1) {
                    double excess = (volume - 1) / 2.0;
                    next_layer[c] += excess;
                    next_layer[c + 1] += excess;
                }
            }
            
            // 更新 layer 为下一层
            layer = next_layer;
        }
        
        return Math.min(1.0, layer[query_glass]);
    }
}
```

- 时间复杂度： $O(r^2)$
- 空间复杂度： $O(r)$

经实测，第二种 $Python$ 解法耗时 $19ms$，超过 $100\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/champagne-tower/solutions/3902464/shuang-jie-bfsan-ceng-mo-ni-er-wei-dp-ko-uxn4/)
