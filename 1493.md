[Problem: 1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/)

### 方法：DFS & DP & 滑窗 & 分组

寻找子数组，中间 **必须删除** 一个元素，求能得到的连续 $1$ 的子数组的最大长度。

**暴力** 想法：每个元素都可能作为子数组开头，找出所有子数组的时间为 $O(n^2)$。题目限制 $n\leq 10^5$，所以铁定超时。

怎么挑选子数组？本质上看，每个元素只有「选」或「不选」加入当前子数组。至于删除，那也是从这个子数组中删除，不会影响构造。—— 联想到 **递归**。

**定义** $dfs(i,flag)$ 表示以 $nums[i]$ 结尾，且是否删除一次 $flag$ 的情况下，能得到的最长连续 $1$ 的长度。

任意元素都可以作为子数组末尾，所以递归起点是 $i\in[0,n)$。

状态转移：不断向前寻找，尝试将元素拼接进来，确保子数组的连续性，标志位 $flag$ 确保最多添加入一次 $0$。

如果 $nums[2]$ 和 $nums[3]$ 都是 $1$，那么以 $nums[3]$ 结尾的长度一定比 $nums[2]$ 大！那就没必要在 $2$ 处计算两次！整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        ans, n = 0, len(nums)

        @cache
        def dfs(i, deleted):
            if i < 0:
                return 0
            if nums[i] == 1:
                # 当前是 1，长度 = 前一个长度 + 1
                return dfs(i - 1, deleted) + 1
            else:
                if deleted:
                    # 已经删除过 0，再遇到 0 → 中断
                    return 0
                else:
                    # 删除当前这个 0，继续往前算
                    return dfs(i - 1, True)

        # 遍历每个位置，取最大值
        for i in range(n):
            ans = max(ans, dfs(i, False))

        # 如果全是 1，必须删掉一个
        return ans - 1 if ans == n else ans
```

```Java
// java
class Solution {
    private int[] nums;
    private int[][] memo;

    public int longestSubarray(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.memo = new int[n][2];  // deleted: 0=未删除，1=已删除

        int ans = 0;
        // 遍历每个位置，取最大值
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, dfs(i, 0)); 
        }

        // 如果全是 1，必须删掉一个
        return ans == n ? ans - 1 : ans;
    }

    // 深度优先搜索函数
    // i: 当前下标
    // deleted: 是否已经删除过一个 0 (0=否, 1=是)
    private int dfs(int i, int deleted) {
        if (i < 0) {
            return 0;
        }
        if (memo[i][deleted] != 0) {
            return memo[i][deleted];
        }

        int res;
        if (nums[i] == 1) {
            // 当前是 1，长度 = 前一个长度 + 1
            res = dfs(i - 1, deleted) + 1;
        } else {
            if (deleted == 1) {
                // 已经删除过 0，再遇到 0 → 中断
                res = 0;
            } else {
                // 删除当前这个 0，继续往前算
                res = dfs(i - 1, 1);
            }
        }

        memo[i][deleted] = res;
        return res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(2n)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n)$。

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示递归栈的深度

---

### $DP$

将递归 $1:1$ 转为递推。

**定义** $dp[i][j]$ 表示以 $nums[i]$ 结尾，且是否删除一次 $j$ 的情况下，能得到的最长连续 $1$ 的长度。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        ans, n = 0, len(nums)
        # dp[i][1]代表删除过一次0
        # dp[i][0]代表没删除过元素
        dp = [[0] * 2 for _ in range(n + 1)]

        for i in range(n):
            if nums[i] == 1:  # 不需要删
                dp[i + 1][1] = dp[i][1] + 1
                dp[i + 1][0] = dp[i][0] + 1
            else:  # 需要删除
                dp[i + 1][0] = 0
                dp[i + 1][1] = dp[i][0]
            ans = max(ans, dp[i + 1][1], dp[i + 1][0])
        
        return ans - 1 if ans == n else ans
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;
        int ans = 0;

        // dp[i][1]代表删除过一次0
        // dp[i][0]代表没删除过元素
        int[][] dp = new int[n + 1][2];

        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {  // 不需要删
                dp[i + 1][1] = dp[i][1] + 1;
                dp[i + 1][0] = dp[i][0] + 1;
            } else {  // 需要删除
                dp[i + 1][0] = 0;
                dp[i + 1][1] = dp[i][0];
            }
            ans = Math.max(ans, Math.max(dp[i + 1][1], dp[i + 1][0]));
        }

        // 如果全是 1，必须删掉一个
        return ans == n ? ans - 1 : ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示数组 $dp$ 的大小

---

### 空间优化

可以发现， $dp[i+1]$ 的状态仅由 $dp[i]$ 的状态决定，所以能优化掉第一维。第二维是线性空间，因此只需要使用两个变量替换即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        # f0: 不删元素时的连续1长度, f1: 已删一个0后的连续1长度
        f0 = f1 = 0

        for i in range(1, n + 1):
            if nums[i - 1] == 1:
                # 当前是1，两种状态都加1
                f0 += 1
                f1 += 1
            else:
                # 当前是0
                # f1: 可以把这个0删掉，所以等于之前的f0
                # f0: 必须断开，归零
                f1 = f0
                f0 = 0
            ans = max(ans, f1)  # 更新最大值

        # 如果全是1，必须删一个
        return ans - 1 if ans == n else ans
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;
        int ans = 0;
        // f0: 不删元素时的连续1长度, f1: 已删一个0后的连续1长度
        int f0 = 0, f1 = 0;

        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                // 当前是1，两种状态都加1
                f0 += 1;
                f1 += 1;
            } else {
                // 当前是0
                // f1: 可以把这个0删掉，所以等于之前的f0
                // f0: 必须断开，归零
                f1 = f0;
                f0 = 0;
            }
            // 更新最大值
            ans = Math.max(ans, f1);
        }

        // 如果全是1，必须删一个
        return ans == n ? ans - 1 : ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 滑窗

数组长度越大，越有可能包含更多的 $0$ 导致不符合，两者具有 **单调性**。

流程：使用 **不定长** 滑窗，其中至多有一个 $0$。枚举右边界，一旦窗口内超过一个 $0$，就移动左指针，直至只包含一个 $0$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        # 滑动窗口，保证窗口中至多有 1 个 0
        ans = 0
        left = 0  # 窗口左边界
        zero_count = 0   # 当前窗口中 0 的数量

        for right in range(len(nums)):
            if nums[right] == 0:
                zero_count += 1

            # 如果窗口里有超过 1 个 0，就缩小左边界
            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1

            # 窗口长度是 right-left+1，但我们必须删掉 1 个元素
            ans = max(ans, right - left)

        return ans
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        // 滑动窗口，保证窗口中至多有 1 个 0
        int ans = 0;
        int left = 0;        // 窗口左边界
        int zeroCount = 0;   // 当前窗口中 0 的数量

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }

            // 如果窗口里有超过 1 个 0，就缩小左边界
            while (zeroCount > 1) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }

            // 窗口长度是 right-left+1，但我们必须删掉 1 个元素
            ans = Math.max(ans, right - left);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 分组

我们可以在 $0,1$ 之间加上挡板，将 $nums$ 进行分块。因为统计连续的 $0/1$ 没有意义，只有在交界处才会影响答案。

比如数组 $[1,1,1,0,0,1,1]$ 会被记录为 $\{(1:3),(0:2),(1:2)\}$，只需要遍历这个新的哈希，从而加速计算。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        # 分组统计：得到 [(数字, 长度), ...]
        groups = [(k, len(list(g))) for k, g in groupby(nums)]
        
        ans = 0
        found_one = False
        
        for i, (val, length) in enumerate(groups):
            if val == 1:
                found_one = True
                ans = max(ans, length)  # 单独取一段 1
            else:
                # 如果删除这个 0，看看能不能连接左右的 1 段
                left = groups[i - 1][1] if i - 1 >= 0 and groups[i - 1][0] == 1 else 0
                right = groups[i + 1][1] if i + 1 < len(groups) and groups[i + 1][0] == 1 else 0
                if length == 1:
                    # 删除这个 0，可以把两侧的 1 合并
                    ans = max(ans, left + right)
                else:
                    # 删除一个 0 仍然剩下 0，无法连通两侧，只能取较大的一侧
                    ans = max(ans, max(left, right))
        
        # 如果整个数组全是 1，必须删掉一个
        if len(groups) == 1 and groups[0][0] == 1:
            return groups[0][1] - 1
        
        return ans if found_one else 0
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        // 分组统计：得到 List<int[]>，每个元素是 {数字, 长度}
        List<int[]> groups = new ArrayList<>();
        int n = nums.length;
        int i = 0;
        while (i < n) {
            int val = nums[i];
            int len = 0;
            while (i < n && nums[i] == val) {
                len++;
                i++;
            }
            groups.add(new int[]{val, len});
        }

        int ans = 0;
        boolean foundOne = false;

        for (int j = 0; j < groups.size(); j++) {
            int val = groups.get(j)[0];
            int length = groups.get(j)[1];
            if (val == 1) {
                foundOne = true;
                ans = Math.max(ans, length);  // 单独取一段 1
            } else {
                // 如果删除这个 0，看看能不能连接左右的 1 段
                int left = (j - 1 >= 0 && groups.get(j - 1)[0] == 1) ? groups.get(j - 1)[1] : 0;
                int right = (j + 1 < groups.size() && groups.get(j + 1)[0] == 1) ? groups.get(j + 1)[1] : 0;
                if (length == 1) {
                    // 删除这个 0，可以把两侧的 1 合并
                    ans = Math.max(ans, left + right);
                } else {
                    // 删除一个 0 仍然剩下 0，无法连通两侧，只能取较大的一侧
                    ans = Math.max(ans, Math.max(left, right));
                }
            }
        }

        // 如果整个数组全是 1，必须删掉一个
        if (groups.size() == 1 && groups.get(0)[0] == 1) {
            return groups.get(0)[1] - 1;
        }

        return foundOne ? ans : 0;
    }
}
```

---

如果不想开辟哈希，或者不想将 $0/1$ 分开记录。可以使用一个新的列表 $ones$，记录连续的每一块中 $1$ 的 **长度**。

比如 $[1,1,0,0,1,1,1]$ 被记为 $[2,0,3]$，同质化处理，从而使代码更简洁。

> $ps$：简化后，代码速度会变慢！从 $7ms$ 的 $99.9\%$ 变为 $36ms$ 的 $95.8\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ones = []  # 存储每段连续 1 的长度
        prev = -1  # 记录上一个 0 的位置

        # 遍历数组，计算被 0 分隔开的连续 1 的长度
        # 比如 [1,1,0,0,1,1,1] 被记为 [2,0,3]
        for i in range(n):
            if nums[i] == 0:
                ones.append(i - prev - 1)
                prev = i

        # 如果最后不是 0，则补充到末尾
        ones.append(n - prev - 1)

        # 计算删除某个 0 后，能连接的最大连续 1 长度
        ans = 0
        for i in range(len(ones) - 1):
            ans = max(ans, ones[i] + ones[i + 1])

        # 如果全是 1，必须删掉一个
        if len(ones) == 1:
            return n - 1

        return ans
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;
        List<Integer> ones = new ArrayList<>();  // 存储每段连续 1 的长度
        int prev = -1;  // 记录上一个 0 的位置

        // 遍历数组，计算被 0 分隔开的连续 1 的长度
        // 比如 [1,1,0,0,1,1,1] 被记为 [2,0,3]
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                ones.add(i - prev - 1);
                prev = i;
            }
        }

        // 如果最后不是 0，则补充到末尾
        ones.add(n - prev - 1);

        // 计算删除某个 0 后，能连接的最大连续 1 长度
        int ans = 0;
        for (int i = 0; i < ones.size() - 1; i++) {
            ans = Math.max(ans, ones.get(i) + ones.get(i + 1));
        }

        // 如果全是 1，必须删掉一个
        if (ones.size() == 1) {
            return n - 1;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solutions/3761995/liu-jie-ji-yi-hua-dfs-er-wei-dp-kong-jia-necv/)
