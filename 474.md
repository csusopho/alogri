[Problem: 474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

### 方法：DFS & DP & 空间优化

解读题意：数组 $strs$ 中包含很多个 $gay$ 佬派对，我们需要从中挑几个派对，使得 $1$ 的总数量不超过 $n$ 个，$0$ 不超过 $m$ 个，求最多能邀请几个派对来参加。

**暴力** 想法：生成 $strs$ 的所有可能的子集。对于每一个子集，计算其中所有字符串的 $0$ 和 $1$ 的总数。如果这个子集的 $0$ 和 $1$ 的总数分别不超过 $m$ 和 $n$，那么它就是一个有效的子集。

如果数组 $strs$ 长度为 $t$，而平均串长为 $L$，则时间复杂度为 $O(L\times 2^t)$，所以会超时，卡在 $25/77$ 样例。即使加上记忆化，卡在 $66/77$ 样例。

本质上，这题是一个 $0-1$ 背包问题。什么是 $0-1$ 背包？

- 一个容量为 $W$ 的背包，有 $N$ 个物品；
- 每个物品的重量是 $w_i$，价值是 $v_i$；
- 目标是在不超过背包容量 $W$ 的前提下，让所选物品的总价值最大；
- 每个物品只能选 $0$ 次或 $1$ 次。

这类问题的通解是「记忆化」或「动规」，具体原理及推导，可以看这篇 [题解]((https://leetcode.cn/problems/partition-equal-subset-sum/solutions/3642816/0-1bei-bao-ji-yi-hua-sou-suo-er-wei-dp-y-ljap/))。

本题只是稍微变形，换成了 **两个背包**，

- 最多包含 $m$ 个 $0$ 以及 $n$ 个 $1$ -> 背包总容量分别是 $m,n$。一共 $0$ 和 $1$ 两种物品，一个背包放 $0$，一个背包放 $1$；
- 每个串中包含 $0/1$ -> $0,1$ 的个数是两种物品的重量；
- 从 $strs$ 中挑选子集 -> 每个串只能选/不选。

每个串仅有「选」或「不选」两种可能，因此联想到 **递归**。

**定义** $dfs(i,curM,curN)$ 表示从前往后处理到第 $i$ 个串时，剩余背包容量是 $curM$ 和 $curN$ 时，继续选择能得到的最大长度。

由于串已经提前给定，可以 **预先计算** 每个串中包含 $0/1$ 的个数。转移过程、递归边界等都相对容易，这里不再阐述。

**核心**：选/不选当前串，注意两个背包都不能超出上限，然后选择两种决策的最优值。

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数有三个，所以记忆化数组需要三维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        # 预计算 '0' 和 '1' 的数量
        counts = [(s.count('0'), s.count('1')) for s in strs]

        # 当前索引，剩余m/n的容量
        @cache
        def dfs(index, cur_m, cur_n):
            # 检查完所有字符串
            if index == len(strs):
                return 0

            # 不选择当前字符串 strs[index]
            res_skip = dfs(index + 1, cur_m, cur_n)
            
            # 选择
            zeros, ones = counts[index]
            res_include = 0
            if cur_m >= zeros and cur_n >= ones:
                # 扣除当前消耗
                res_include = 1 + dfs(index + 1, cur_m - zeros, cur_n - ones)

            # 返回两种决策中的最优解
            return max(res_skip, res_include)

        # 从头开始
        return dfs(0, m, n)
```

```Java
// java
class Solution {
    // 记忆化数组
    private Integer[][][] memo;
    // 预计算的 '0' 和 '1' 的数量
    private int[][] counts;

    public int findMaxForm(String[] strs, int m, int n) {
        // 初始化
        memo = new Integer[strs.length][m + 1][n + 1];
        counts = new int[strs.length][2];
        
        // 预计算 '0' 和 '1' 的数量
        for (int i = 0; i < strs.length; i++) {
            int zeros = 0;
            for (char c : strs[i].toCharArray()) {
                if (c == '0') {
                    zeros++;
                }
            }
            counts[i][0] = zeros;
            counts[i][1] = strs[i].length() - zeros;
        }

        // 从头开始
        return dfs(0, m, n);
    }

    // 当前索引，剩余m/n的容量
    private int dfs(int index, int cur_m, int cur_n) {
        // 检查完所有字符串
        if (index == counts.length) {
            return 0;
        }
        
        // 如果当前状态已计算过，直接返回结果
        if (memo[index][cur_m][cur_n] != null) {
            return memo[index][cur_m][cur_n];
        }

        // 不选择当前字符串 strs[index]
        int res_skip = dfs(index + 1, cur_m, cur_n);
        
        // 选择
        int zeros = counts[index][0];
        int ones = counts[index][1];
        int res_include = 0; // 如果不能选择，则包含它的结果为0
        if (cur_m >= zeros && cur_n >= ones) {
            // 扣除当前消耗
            res_include = 1 + dfs(index + 1, cur_m - zeros, cur_n - ones);
        }

        // 返回两种决策中的最优解，并存入记忆化数组
        memo[index][cur_m][cur_n] = Math.max(res_skip, res_include);
        return memo[index][cur_m][cur_n];
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共三个，状态个数等于 $O(t\times m\times n)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(t\times m\times n)$。

- 时间复杂度： $O(t\times m\times n)$，其中 $t$ 是数组 $strs$ 的长度
- 空间复杂度： $O(t\times m\times n)$，表示备忘录 $memo$ 的大小，递归栈深度为 $O(t)$，数组 $counts$ 的大小为 $O(mn)$

---

### $DP$

将递归 $1:1$ 转化为递推。

同理，**定义** $dp[i][j][k]$ 表示从前 $i$ 个串中，使用不超过 $j$ 个 $0$ 和 $k$ 个 $1$ 所能构成的最大子集长度。

先遍历物品，再遍历背包，得到如下 **状态转移方程**：

$$
dp[i][j][k] = max(dp[i][j][k], dp[i-1][j - zeros][k - ones]+1)
$$

其中， $i-1$ 表示前面的状态，当前串包含 $zeros$ 个 $0$ 以及 $ones$ 个 $1$。

注意，这里使用了 $i-1$，所以为了避免越界，将枚举的范围变为 $[1,t]$，状态定义变为 $dp[i+1]$ 是前 $i$ 个串，而真实下标 $-1$ 即可得到。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        slen = len(strs)
        
        # dp[i][j][k] 表示从前 i 个字符串中，
        # 使用不超过 j 个 '0' 和 k 个 '1' 能构成的最大子集长度
        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(slen + 1)]

        # 遍历每一个字符串（“物品”）
        for i in range(1, slen + 1):
            # 获取当前字符串的 '0' 和 '1' 的数量（“重量”）
            s = strs[i - 1]
            zeros = s.count('0')
            ones = s.count('1')
            
            # 背包维度1
            for j in range(m + 1):
                # 背包维度2
                for k in range(n + 1):
                    # 不选择当前的字符串 strs[i-1]
                    dp[i][j][k] = dp[i-1][j][k]

                    # 选择
                    if j >= zeros and k >= ones:
                        # 在前 i-1 个字符串中，使用剩余容量
                        dp[i][j][k] = max(dp[i][j][k], 1 + dp[i-1][j - zeros][k - ones])
        
        return dp[slen][m][n]
```

```Java
// java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int slen = strs.length;
        
        // dp[i][j][k] 表示从前 i 个字符串中，
        // 使用不超过 j 个 '0' 和 k 个 '1' 能构成的最大子集长度
        int[][][] dp = new int[slen + 1][m + 1][n + 1];

        // 遍历每一个字符串（“物品”）
        for (int i = 1; i <= slen; i++) {
            // 获取当前字符串的 '0' 和 '1' 的数量（“重量”）
            String s = strs[i - 1];
            int zeros = 0;
            for (char c : s.toCharArray()) {
                if (c == '0') {
                    zeros++;
                }
            }
            int ones = s.length() - zeros;
            
            // 背包维度1
            for (int j = 0; j <= m; j++) {
                // 背包维度2
                for (int k = 0; k <= n; k++) {
                    // 不选择当前的字符串 strs[i-1]
                    dp[i][j][k] = dp[i-1][j][k];

                    // 选择
                    if (j >= zeros && k >= ones) {
                        // 在前 i-1 个字符串中，使用剩余容量
                        dp[i][j][k] = Math.max(dp[i][j][k], 1 + dp[i-1][j - zeros][k - ones]);
                    }
                }
            }
        }
        
        return dp[slen][m][n];
    }
}
```

- 时间复杂度： $O(t\times m\times n)$
- 空间复杂度： $O(t\times m\times n)$，表示数组 $dp$ 的大小

---

### 空间优化

可以发现，计算状态 $dp[i]$ 时，只会用到 $dp[i-1]$ 的值，不会用到比 $i-1$ 更早的状态。所以能采用 **滚动数组**，优化掉第一维。

回想一下，为什么 $0-1$ 背包问题优化后是倒序枚举？为了避免 **数据污染**。

在 $0-1$ 背包的一维数组中，刚进入第 $i$ 个轮次时，这个 $dp$ 数组存储的是 $i-1$ 状态的值。如果选择正序枚举，即 `dp[i]+=dp[i-k]`，会造成重复计算！

举个例子，如果 $dp[3]+=dp[0],dp[6]+=dp[3]$，相当于 $nums[i]$ 重复选择了两次，违反了 $0-1$ 背包的约束！

本质 **原因**：用 $dp[i]$ 转移得到 $dp[j]$ 时， $dp[i]$ 可能已经被本次迭代中的计算修改过，所以导致错误计算。

本题同理，如果还是选择从前往后枚举 $j$，那么当前更新 $dp[j]$ 时，使用的是上一轮更新过的 $dp[j-zero]$，即 $dp[i][j-zero]$，而不是我想要的 $dp[i-1][j-zero]$。

倒序枚举后两维度，代码如下，已附加注释：

```Python
# python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        # dp[i][j] 表示使用 i 个 '0' 和 j 个 '1' 能构成的最大子集长度
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # 遍历每一个字符串（物品）
        for s in strs:
            zeros = s.count('0')
            ones = s.count('1')

            # 必须从后往前遍历，确保每个物品只被使用一次
            for i in range(m, zeros - 1, -1):
                for j in range(n, ones - 1, -1):
                    # 不选择/选择
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
        
        return dp[m][n]
```

```Java
// java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // dp[i][j] 表示使用 i 个 '0' 和 j 个 '1' 能构成的最大子集长度
        int[][] dp = new int[m + 1][n + 1];

        // 遍历每一个字符串（物品）
        for (String s : strs) {
            int zeros = 0;
            for (char c : s.toCharArray()) {
                if (c == '0') {
                    zeros++;
                }
            }
            int ones = s.length() - zeros;

            // 必须从后往前遍历，确保每个物品只被使用一次
            for (int i = m; i >= zeros; i--) {
                for (int j = n; j >= ones; j--) {
                    // 不选择/选择
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
```

- 时间复杂度： $O(t\times m\times n)$
- 空间复杂度： $O(m\times n)$，优化掉第一维

经实测，第一版 $DFS$ 代码速度最快，而第二版代码速度最慢。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/ones-and-zeroes/solutions/3828864/san-jie-0-1bei-bao-wen-ti-ji-yi-hua-dfs-ph0y2/)
