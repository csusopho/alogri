[Problem: 1304. 和为零的 N 个不同整数](https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/description/)

### 方法：等差 & 随机

题意：数组中的所有元素 **互不相同**，最终和为 $0$。

简单思路：**取相反数**，构造形如 $[-2,-1,0,1,2]$ 形式的数组。代码如下：

```Python
# python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        ans = []
        if n % 2 == 1:  # 奇数记得加 0
            ans.append(0)
        for i in range(1, n//2+1):  # 对称添加
            ans.append(i)
            ans.append(-i)
        return ans
```

```Java
// java
class Solution {
    public int[] sumZero(int n) {
        int[] ans = new int[n];
        int index = 0;
        
        if (n % 2 == 1) {  // 奇数记得加 0
            ans[index++] = 0;
        }
        
        for (int i = 1; i <= n / 2; i++) {  // 对称添加
            ans[index++] = i;
            ans[index++] = -i;
        }
        
        return ans;
    }
}
```

利用数组下标，变换为更加 **简洁** 优雅的写法：

```Python
# python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        ans = [0] * n
        for i in range(n // 2):
            ans[i] = -(n - i)
            ans[-i - 1] = n - i
        return ans
```

```Java
// java
class Solution {
    public int[] sumZero(int n) {
        int[] ans = new int[n];
        
        for (int i = 0; i < n / 2; i++) {
            ans[i] = -(n - i);       // 前半部分负数
            ans[n - 1 - i] = n - i;  // 后半部分对应正数
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为给定数字，且 $n\leq 10^3$
- 空间复杂度： $O(1)$，返回数组 $ans$ 一般不计入复杂度

---

### 等差

本质上来说，上面的写法就是 **公差** 为 $1$ 的等差数列。如果换成公差为 $2$ 的数列，

- 长度为偶数，则为 `[-3, -1, 1, 3]` 的形式，就是不断生成相邻奇数；
- 长度为奇数，则中间置 $0$，不断生成相邻偶数，即 `[-2, 0, 2]` 的形式；

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        # 生成 n 个相邻的奇数：1-n, 3-n, 5-n, ..., (2n-1)-n
        # 它们关于 0 对称，和为 0，且两两不同
        return [2*i + 1 - n for i in range(n)]
```

```Java
// java
class Solution {
    public int[] sumZero(int n) {
        int[] ans = new int[n];
        // 生成 n 个相邻的奇数：1-n, 3-n, 5-n, ..., (2n-1)-n
        // 它们关于 0 对称，和为 0，且两两不同
        for (int i = 0; i < n; i++) {
            ans[i] = 2 * i + 1 - n;
        }
        return ans;
    }
}
```

如果推广至 **任意** 公差（步长）的情况，那还是需要取相反的对称数字，代码为：

```Python
# python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        step = 3  # 任意公差
        ans = []
        half = n // 2
        # 偶数：只生成正负对称
        for i in range(1, half + 1):
            ans.extend([i * step, -i * step])
        # 奇数：中间加 0
        if n % 2 == 1:
            ans.append(0)
        return ans
```

```Java
// java
class Solution {
    public int[] sumZero(int n) {
        int step = 3;              // 任意公差
        int[] ans = new int[n];
        int index = 0;
        int half = n / 2;
        
        // 偶数：只生成正负对称
        for (int i = 1; i <= half; i++) {
            ans[index++] = i * step;
            ans[index++] = -i * step;
        }
        
        // 奇数：中间加 0
        if (n % 2 == 1) {
            ans[index++] = 0;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 随机

如果想达到完全/纯随机，那就生成 $n-1$ 个不同数字，然后求和，取相反数添加至最后一项。如果 **冲突**，那就重复该过程。

为了防止 $int$ 溢出，上限是 $10^9$，总共 $10^3$ 个数字，所以范围取为 $10^6$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        low = -10**6
        high = 10**6
        while True:  # 循环直到生成合法解
            # 先随机取 n-1 个不同的数
            nums = random.sample(range(low, high), n-1)
            total = sum(nums)
            last = -total
            # 如果最后一个数不冲突，就返回
            if last not in nums:
                nums.append(last)
                return nums
            # 否则重新生成
```

```Java
// java
class Solution {
    public int[] sumZero(int n) {
        int low = -1_000_000;
        int high = 1_000_000;
        Random rand = new Random();
        
        while (true) {  // 循环直到生成合法解
            Set<Integer> numsSet = new HashSet<>();
            // 先随机取 n-1 个不同的数
            while (numsSet.size() < n - 1) {
                // 生成 [low, high) 范围内的随机数
                int num = rand.nextInt(high - low) + low;
                numsSet.add(num);
            }
            
            List<Integer> nums = new ArrayList<>(numsSet);
            int total = 0;
            for (int num : nums) {
                total += num;
            }
            int last = -total;
            // 如果最后一个数不冲突，就返回
            if (!numsSet.contains(last)) {
                nums.add(last);
                // 转为数组返回
                int[] result = new int[nums.size()];
                for (int i = 0; i < nums.size(); i++) {
                    result[i] = nums.get(i);
                }
                return result;
            }
            // 否则重新生成
        }
    }
}
```

- 时间复杂度： $O(n)$，一次生成的时间为 $O(n)$，范围设置较宽，冲突概率非常低，最坏情况下无限循环
- 空间复杂度： $O(n)$，表示中间的哈希 $set$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/solutions/3774413/wu-jie-qu-xiang-fan-shu-deng-chai-shu-li-10ey/)
