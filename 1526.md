[Problem: 1526. 形成目标数组的子数组最少增加次数](https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description/)

### 方法：递归 & 差分

每次操作，会将一个子数组的海拔高度提升 $1$。反过来看，操作一次相当于消减 $1$，最终是将所有 “山峰山谷” 都削至 $0$。

**贪心** 想法：子数组中的 “最小值” 是 $x$，则对其中的所有元素都消减 $x$，这样耗费的操作数最少。

比如数组 $[1,1]$，可以整体减 $1$，或者分段减 $1$，明显前者操作更少。因为数组最小值为 $mn$，则至少有 $mn$ 次操作是作用于当前整个区间。因此，这 $mn$ 次操作是必须的。

最开始对整个 $nums$ 操作，消减后会出现 $0$，根据 $0$ 划分子数组，则又可以继续对子数组进行上述消减操作 —— 从父问题变为子问题，联想到 **递归**。

- 寻找：在当前子数组中，找到最小值 $mn$。
- 消减：将当前区间中的所有元素都减去 $mn$。
- 分割：新生成的 $0$ 会将数组分割成若干个互不相干的子数组。例如，数组变成了 $[2, 0, 3, 4, 0, 1]$，它就被 $0$ 分割成了 $[2]$、 $[3, 4]$ 和 $[1]$ 这三个独立的子问题。
- 递归：对每个分割出来的非空子数组，递归地调用此函数，并将所有子问题的结果与当前层级的 $mn$ 相加，就是最终的答案。

其他细节这里不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        # 计算将全零数组变为 arr 所需的最少操作次数
        def dfs(arr):
            # 子数组为空
            if not arr:
                return 0

            # 找到当前数组中的最小值
            min_val = min(arr)
            # 累加
            operations = min_val
            # 每个元素中减去最小值
            remain_arr = [x - min_val for x in arr]
            
            # 根据 0 将数组分割
            start_index = 0
            for i in range(len(remain_arr)):
                if remain_arr[i] == 0:
                    # 前面的部分构成一个子问题
                    if start_index < i:
                        operations += dfs(remain_arr[start_index:i])
                    # 更新起始点
                    start_index = i + 1
            
            # 如果数组不是以 0 结尾
            if start_index < len(remain_arr):
                operations += dfs(remain_arr[start_index:])
            
            return operations
        
        # 开始
        return dfs(target)
```

递归的深度是 $O(n)$，每层递归都会创建大小为 $O(n)$ 的新数组。根据等差数列的求和公式可知，空间复杂度为 $O(n^2)$。

题目指定 $n\leq 10^5$，所以超空间，卡在 $127/129$ 样例。

如果取消创建新数组的操作，改成 **原地** 操作，并增加一个 $base$ 参数避免真实修改，可以得到下面的代码，已附加注释：

```Python
# python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        # 将子数组 [start, end] 变为全零，所需的最少操作次数
        def dfs(start, end, base):
            # 子数组为空
            if start >= end:
                return 0
            
            # 找到当前数组中的最小值
            min_val = min(target[start:end])
            # 当前区间的最小值与已经完成的基准高度的差值
            operations = min_val - base

            # 根据 0 将数组分割
            start_index = start
            for i in range(start, end):
                # 前面的部分构成一个子问题
                if target[i] == min_val:
                    operations += dfs(start_index, i, min_val)
                    start_index = i + 1
            
            # 数组可能以 0 结尾
            operations += dfs(start_index, end, min_val)
            return operations
        
        return dfs(0, len(target), 0)
```

每层寻找时间为 $O(n)$，最优递归是二分，深度至少为 $O(logn)$，最坏情况下还是 $O(n)$。因此，总时间为 $O(n^2)$，遗憾超时，卡在同样的样例。

---

### 差分

仔细分析流程，从 $[1,2,3,2,1]$ 开始，每次减少 $1$ 的时候，看看对多少个区间进行了 $-1$ 操作。变成 $0$，则不再继续减少。

```Java
[1,2,3,2,1]
-> [0,1,2,1,0]   耗费 1 次操作
-> [0,0,1,0,0]   耗费 1 次操作
-> [0,0,0,0,0]   耗费 1 次操作
```

总操作次数为 $3$，分别耗费在首位 $1$、从 $1\to$ 的递增、从 $2\to 3$ 的递增。同理：

```Java
[3,1,1,2]
-> [2,0,0,1]   耗费 1 次操作
-> [1,0,0,1]   耗费 1 次操作
-> [1,0,0,0]   耗费 1 次操作
-> [0,0,0,0]   耗费 1 次操作
```

总操作次数为 $4$，分别耗费在首位 $3$、从 $1\to 2$ 的递增。

**总结**：如果前一个比当前元素大，当前元素可以跟随前一个被消除。若当前元素更大，则必须额外操作 **差值** 次。

构建差分数组，统计每个位置 $i$ 与前面 $i-1$ 的差值，代码如下：

```Python
# python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        n = len(target)
        
        # 构建差分数组
        diff = [0] * n
        diff[0] = target[0]
        for i in range(1, n):
            diff[i] = target[i] - target[i-1]

        # 每次 "+1" 都是一次新操作的开始，所以累加所有正值即可
        ans = 0
        for val in diff:
            if val > 0:
                ans += val
        
        return ans
```

```Java
// java
class Solution {
    public int minNumberOperations(int[] target) {
        int n = target.length;

        // 构建差分数组
        int[] diff = new int[n];
        diff[0] = target[0];
        for (int i = 1; i < n; i++) {
            diff[i] = target[i] - target[i - 1];
        }

        // 每次 "+1" 都代表一次新操作的开始，所以累加所有正值即可得到总操作数
        int ans = 0;
        for (int val : diff) {
            if (val > 0) {
                ans += val;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，两次遍历
- 空间复杂度： $O(n)$，表示数组 $diff$ 的大小

---

### 简化

实际上，我们并不需要 $diff$ 数组，直接比较相邻两数即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        # 从 0 开始
        ans = target[0]

        for i in range(1, len(target)):
            # 需要增加的操作次数就是它们的高度差
            if target[i] > target[i-1]:
                ans += target[i] - target[i-1]
            # 如果当前元素不高于前一个元素，不需要额外操作
        
        return ans
```

```Java
// java
class Solution {
    public int minNumberOperations(int[] target) {
        // 从 0 开始
        int ans = target[0];

        for (int i = 1; i < target.length; i++) {
            // 需要增加的操作次数就是它们的高度差
            if (target[i] > target[i - 1]) {
                ans += target[i] - target[i - 1];
            }
            // 如果当前元素不高于前一个元素，不需要额外操作
        }
        
        return ans;
    }
}
```

运行速度比修改前还更慢一点？

可以 **换种思路**：计算数值 “下降” 的总量，以及最后的高度，累加在一起得到答案。

代码如下，速度非常快，超过 $96\%$：

```Python
# python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans = pre = 0

        for x in target:
            if x < pre:
                ans += pre - x
            pre = x
        
        return ans + pre
```

```Java
// java
class Solution {
    public int minNumberOperations(int[] target) {
        int ans = 0;
        int pre = 0;

        for (int x : target) {
            // 出现了一次“下降”
            if (x < pre) {
                ans += pre - x;
            }
            // 更新 pre 为当前元素的值
            pre = x;
        }
        
        // pre 是数组的最后一个元素
        return ans + pre;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/solutions/3819338/si-jie-tan-xin-bao-li-dfs-chai-fen-jian-hl46o/)
