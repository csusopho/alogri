[Problem: 3479. 水果成篮 III](https://leetcode.cn/problems/fruits-into-baskets-iii/description/)

### 方法：线段树

本题和前一题 [水果 II](https://leetcode.cn/problems/fruits-into-baskets-ii/description/) 的题干一模一样，这里不再解读。

假设两数组的长度分别为 $n,m$，题目限定 $n,m\le 10^5$。如果使用暴力解法，则时间复杂度为 $O(n\times m)$，铁定超时。该如何优化？

其他人的解法中，我只看到了 **线段树** 或者 **树状数组**，本质思想都是 **分块**。这里就介绍一种线段树解法，有其他解法欢迎评论区分享。

为什么想到线段树？线段树到底有什么作用？

实际上，我们是想加速寻找 $baskets$ 中容量 $\ge$ 当前水果数量，而线性 $for$ 枚举的速度太慢。假设数组 $baskets=[4,6,5,7]$，如果将它一分为二，前一半 $[4,6]$ 的最大值为 $6$，后一半 $[5,7]$ 的最大值为 $7$。

- 如果水果数量为 $5$，则前半部分就已经满足，搜索前半；
- 如果水果数量为 $7$，则前半部分不满足，搜索后半。

这种 **折半** 的思路，使得原本的 $O(m)$ 枚举变为 $log$ 级别，大大降低时间。

但是，一旦找到某个篮子，就必须删除该篮子，则有可能会影响该部分的最大值。比如上面的 $6$ 删除后，前半部分的最值就变为 $4$。

也即，我们的需求是：记录区间最值、搜索区间、单点修改。 —— **线段树**。

线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。它可以在 $O(log N)$ 的时间内实现 区间修改、区间查询 等操作。

---

牢牢把握住一点：线段树的 **每个节点代表一个区间**。

线段树是一棵近似的完全二叉树。它将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。

假如你想全面了解线段树，可以去看看 [维基百科](https://oi-wiki.org/ds/seg/)，有详细阐释，不过稍微有点难理解，对新手不太友好。

再推荐一篇我写过的 [题解](https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/2933254/xian-duan-shu-yuan-li-mo-ban-xiang-xi-tu-dlmy/)，里面介绍了链表形式和数组形式的线段树，以及 **动态开点** 做法，包含 *原理*、*模版代码*、*经典例题*。

下面我就不再去介绍线段树的基础知识，感兴趣的小伙伴去看链接的内容。

线段树的 **重点** 在于二分，通过递归的形式完成各种操作。最需要记忆的部分就是区间的更新与查询，面对限制更高的题，那就记一下动态开点的部分。没打过竞赛，或者接触线段树的次数很少，那就很难应对这种题。把模版记住，解题就轻松很多。

在本题中，主要 **流程** 为：

- 将数组 $baskets$ 传入，节点中存储当前区间的最大值；
- 总区间为 $[0,m)$，不断二分，看看当前区间 $[l,r)$ 的最大值是否满足要求；如果符合，就继续缩小区间；如果不符合，就更换区间；
- 找到篮子 $i$ 后，将该篮子置为 $-1$ 表示已经使用，那就需要更新整棵树；否则没找到，无需更新。

代码如下，已附加详细注释：

速度非常慢， $Python$ 语言耗时 $22329ms$，差一点超时。

```Python
# python
class SegmentTree:
    def __init__(self, data):
        # 单点/区间存储篮子容量的最大值
        # 线段树大小取 2 * 2^{⌈log2 n⌉}
        self.n = len(data)
        self.size = 1
        while self.size < self.n:
            self.size *= 2
        self.tree = [-1] * (2 * self.size)
        # 初始化叶子节点（树底层）
        for i in range(self.n):
            self.tree[self.size + i] = data[i]
        # 自底向上，构建区间最大值
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1])

    def update(self, pos, value):
        # 将位置 pos 叶子节点更新为 value
        pos += self.size
        self.tree[pos] = value
        # 然后向上更新其祖先节点的最大值
        while pos > 1:
            pos //= 2
            self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1])

    def query(self, l, r):
        # 查询区间 [l, r) 内的最大值
        l += self.size
        r += self.size
        res = -1
        # 不断向上
        while l < r:
            if l % 2 == 1:
                res = max(res, self.tree[l])
                l += 1
            if r % 2 == 1:
                r -= 1
                res = max(res, self.tree[r])
            l //= 2
            r //= 2
        return res

    def find_first(self, qty):
        l, r = 0, self.n
        res = -1
        # 二分查找第一个区间最大值 >= qty 的位置
        while l < r:
            m = (l + r) // 2
            # 满足，说明这个区间里有篮子容量满足条件
            if self.query(0, m + 1) >= qty:
                res = m
                r = m
            else:  # 否则，更换区间
                l = m + 1
        return res

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        tree = SegmentTree(baskets)
        ans = 0

        for qty in fruits:
            # 找第一个容量 >= 当前水果重量的篮子
            idx = tree.find_first(qty)
            if idx == -1:
                # 找不到合适篮子，水果无法放置
                ans += 1
            else:
                # 找到后，更新该篮子为-1表示已使用
                tree.update(idx, -1)
                baskets[idx] = -1

        return ans
```

```Java
// java
class SegmentTree {
    private int[] tree;
    private int n;
    private int size;

    public SegmentTree(int[] data) {
        // 单点/区间存储篮子容量的最大值
        // 线段树大小取 2 * 2^{⌈log2 n⌉}
        this.n = data.length;
        this.size = 1;
        while (this.size < n) {
            this.size *= 2;
        }
        this.tree = new int[2 * this.size];
        Arrays.fill(this.tree, -1);

        // 初始化叶子节点（树底层）
        for (int i = 0; i < n; i++) {
            this.tree[this.size + i] = data[i];
        }

        // 自底向上，构建区间最大值
        for (int i = this.size - 1; i > 0; i--) {
            this.tree[i] = Math.max(this.tree[i * 2], this.tree[i * 2 + 1]);
        }
    }

    public void update(int pos, int value) {
        // 将位置 pos 叶子节点更新为 value
        pos += this.size;
        this.tree[pos] = value;

        // 然后向上更新其祖先节点的最大值
        while (pos > 1) {
            pos /= 2;
            this.tree[pos] = Math.max(this.tree[2 * pos], this.tree[2 * pos + 1]);
        }
    }

    public int query(int l, int r) {
        // 查询区间 [l, r) 内的最大值
        l += this.size;
        r += this.size;
        int res = -1;

        // 不断向上
        while (l < r) {
            if (l % 2 == 1) {
                res = Math.max(res, this.tree[l]);
                l++;
            }
            if (r % 2 == 1) {
                r--;
                res = Math.max(res, this.tree[r]);
            }
            l /= 2;
            r /= 2;
        }

        return res;
    }

    public int findFirst(int qty) {
        int l = 0, r = this.n;
        int res = -1;

        // 二分查找第一个区间最大值 >= qty 的位置
        while (l < r) {
            int m = (l + r) / 2;
            // 满足，说明这个区间里有篮子容量满足条件
            if (this.query(0, m + 1) >= qty) {
                res = m;
                r = m;
            } else {  // 否则，更换区间
                l = m + 1;
            }
        }

        return res;
    }
}

class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        SegmentTree tree = new SegmentTree(baskets);
        int ans = 0;

        for (int qty : fruits) {
            // 找第一个容量 >= 当前水果重量的篮子
            int idx = tree.findFirst(qty);
            if (idx == -1) {
                // 找不到合适篮子，水果无法放置
                ans++;
            } else {
                // 找到后，更新该篮子为-1表示已使用
                tree.update(idx, -1);
                baskets[idx] = -1;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logm)$，其中 $n,m$ 分别为为数组 $fruits,baskets$ 的长度
- 空间复杂度： $O(m)$，表示数组 $tree$ 的大小

---

### 优化

实际上，在 $findFirst$ 函数中，根本没必要二分，每次舍弃一半区间，那直接使用递推就行，利用树的父子关系，每次向下传递也能舍弃一半区间。

同时，内部无需使用 $query$ 方法，可以利用节点存储的值来判断大小，从而省去 $query$ 方法，仅保留一个 $findFirst$ 函数即可！

代码如下，已附加详细注释：

```Python
# python
class SegmentTree:
    def __init__(self, data):
        self.n = len(data)
        # 线段树大小取 2 * 2^{⌈log2 n⌉}
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.tree = [0] * (2 * size)
        # 建树：把 data 放到叶子区间
        for i, v in enumerate(data):
            self.tree[size + i] = v
        # 自底向上维护每个父节点的 max
        for i in range(size - 1, 0, -1):
            self.tree[i] = max(self.tree[2*i], self.tree[2*i+1])

    def update(self, idx, val):
        # 将位置 pos 叶子节点更新为 value
        pos = self.size + idx
        self.tree[pos] = val
        pos //= 2
        # 然后向上更新其祖先节点的最大值
        while pos:
            self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1])
            pos //= 2

    def find_first(self, val):
        if self.tree[1] < val:  # 根节点都不够大
            return -1
        # 从根节点开始找
        idx = 1
        while idx < self.size:  # 还没到叶子
            # 左子树的最大值
            if self.tree[2 * idx] >= val:
                idx = 2 * idx
            else:
                idx = 2 * idx + 1
        # idx 是叶子，映射回原数组下标
        return idx - self.size


class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        tree = SegmentTree(baskets)
        ans = 0

        for qty in fruits:
            i = tree.find_first(qty)
            if i == -1:  # 没找到
                ans += 1
            else:
                # 用过之后把这个篮子容量置为 -1 表示已使用
                tree.update(i, -1)

        return ans
```

```Java
// java
class SegmentTree {
    private int[] tree;
    private int size;
    private int n;

    public SegmentTree(int[] data) {
        this.n = data.length;

        // 线段树大小取 2 * 2^{⌈log2 n⌉}
        int size = 1;
        while (size < n) {
            size <<= 1;
        }
        this.size = size;
        this.tree = new int[2 * size];

        // 建树：把 data 放到叶子区间
        for (int i = 0; i < n; i++) {
            this.tree[size + i] = data[i];
        }

        // 自底向上维护每个父节点的 max
        for (int i = size - 1; i > 0; i--) {
            this.tree[i] = Math.max(this.tree[2 * i], this.tree[2 * i + 1]);
        }
    }

    public void update(int idx, int val) {
        // 将位置 idx 叶子节点更新为 val
        int pos = size + idx;
        tree[pos] = val;
        pos /= 2;

        // 然后向上更新其祖先节点的最大值
        while (pos > 0) {
            tree[pos] = Math.max(tree[2 * pos], tree[2 * pos + 1]);
            pos /= 2;
        }
    }

    public int findFirst(int val) {
        if (tree[1] < val) {  // 根节点都不够大
            return -1;
        }

        // 从根节点开始找
        int idx = 1;
        while (idx < size) {  // 还没到叶子
            // 左子树的最大值
            if (tree[2 * idx] >= val) {
                idx = 2 * idx;
            } else {
                idx = 2 * idx + 1;
            }
        }

        // idx 是叶子，映射回原数组下标
        return idx - size;
    }
}

class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        SegmentTree tree = new SegmentTree(baskets);
        int ans = 0;

        for (int qty : fruits) {
            int i = tree.findFirst(qty);
            if (i == -1) {
                // 没找到合适的篮子
                ans++;
            } else {
                // 用过之后把这个篮子容量置为 -1 表示已使用
                tree.update(i, -1);
            }
        }

        return ans;
    }
}
```

这种方法速度最快， $Python$ 耗时 $1628ms$，超过 $98\%$。

- 时间复杂度： $O(n\times logm)$，同理
- 空间复杂度： $O(m)$

---

### 递归

如果一定要套用模版，也就是 **构建树** $build$ 以及 **更新** $update$ 的部分使用递归，而不是递推。那么代码总体更美观，不过阅读性会稍降。

代码如下，已附加详细注释：

```Python
# python
class SegmentTree:
    def __init__(self, baskets):
        self.arr = baskets
        n = len(baskets)
        # 线段树数组，存储篮子容量的最大值
        self.tree = [0] * (2 << (n - 1).bit_length())
        # 递归构建线段树
        self.build(1, 0, n - 1)

    def pushUp(self, o):
        # 维护当前节点的最大值：取左右子节点最大值
        self.tree[o] = max(self.tree[o * 2], self.tree[o * 2 + 1])

    # 前三个参数：当前节点，要搜索区间的左边界，右边界，后面都同理
    def build(self, o, l, r):
        # 到达叶子节点
        if l == r:
            self.tree[o] = self.arr[l]
            return
        m = (l + r) // 2  # 左/右孩子的分界线
        # 递，更新孩子
        self.build(o * 2, l, m)
        self.build(o * 2 + 1, m + 1, r)
        # 归，用孩子更新父
        self.pushUp(o)

    # 一边寻找，一边更新树
    def find_update(self, o, l, r, x):
        if self.tree[o] < x:  # 当前区间最大值都不够放
            return -1
        if l == r:  # 找到叶子节点，更新为 -1 表示已用
            self.tree[o] = -1
            return l
        m = (l + r) // 2
        # 优先在左子树找
        i = self.find_update(o * 2, l, m, x)
        if i < 0:  # 左子树没找到，去右子树找
            i = self.find_update(o * 2 + 1, m + 1, r, x)
        self.pushUp(o)  # 上推
        return i  # 更新完树，最后返回答案


class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        tree = SegmentTree(baskets)
        n = len(baskets)
        ans = 0
        for fruit in fruits:
            # 寻找并更新树
            if tree.find_update(1, 0, n - 1, fruit) < 0:
                ans += 1
        return ans
```

```Java
// java
class SegmentTree {
    private int[] tree;
    private int[] arr;
    private int n;

    public SegmentTree(int[] baskets) {
        this.arr = baskets;
        this.n = baskets.length;
        // 线段树数组，存储篮子容量的最大值
        this.tree = new int[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];
        // 递归构建线段树
        build(1, 0, n - 1);
    }

    // 维护当前节点的最大值：取左右子节点最大值
    private void pushUp(int o) {
        tree[o] = Math.max(tree[o * 2], tree[o * 2 + 1]);
    }

    // 当前节点 o，处理区间 [l, r]
    private void build(int o, int l, int r) {
        // 到达叶子节点
        if (l == r) {
            tree[o] = arr[l];
            return;
        }
        int m = (l + r) / 2;  // 左/右孩子的分界线
        // 递，更新孩子
        build(o * 2, l, m);
        build(o * 2 + 1, m + 1, r);
        // 归，用孩子更新父
        pushUp(o);
    }

    // 一边寻找，一边更新树，返回叶子节点的下标（原数组下标）
    public int findUpdate(int o, int l, int r, int x) {
        if (tree[o] < x) {  // 当前区间最大值都不够放
            return -1;
        }
        if (l == r) {  // 找到叶子节点，更新为 -1 表示已用
            tree[o] = -1;
            return l;
        }
        int m = (l + r) / 2;
        // 优先在左子树找
        int i = findUpdate(o * 2, l, m, x);
        if (i < 0) {
            // 左子树没找到，去右子树找
            i = findUpdate(o * 2 + 1, m + 1, r, x);
        }
        // 上推
        pushUp(o);
        return i;
    }
}

class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        SegmentTree tree = new SegmentTree(baskets);
        int n = baskets.length;
        int ans = 0;

        for (int fruit : fruits) {
            // 寻找并更新树
            if (tree.findUpdate(1, 0, n - 1, fruit) < 0) {
                ans++;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logm)$，同理
- 空间复杂度： $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/fruits-into-baskets-iii/solutions/3743955/xian-duan-shu-po-su-di-tui-er-fen-he-bin-k6xy/)
