[Problem: 2043. 简易银行系统](https://leetcode.cn/problems/simple-bank-system/description/)

### 方法：模拟

简单业务题，账户的初始余额的 $balance$ 数组甚至直接提供给我们。一般而言，其他题会让我们自己 $new$ 创建，然后不断存钱+取钱，计算中间余额。

这题很容易，但是小心 **边界问题**：

- 账户是否合法？账户的下标必须在 $[1,n]$ 中间；
- 金额是否会溢出？精度问题？这里无需考虑，都使用的是 $long$；
- 金额是否负数？这里无需考虑，题目已经限制 $\geq 0$；
- 转出是否有足够余额？进行增减时，记得提前判断；
- 对自己转账？真有这样的测试样例，自行尝试。

直接模拟，代码如下，已附加详细注释：

```Python
# python
class Bank:
    def __init__(self, balance: List[int]):
        # 存储这个数组
        self.balance = balance
        # 账户总数
        self.n = len(balance)
    
    def check(self, account: int) -> bool:
        # 检查账户编号是否有效
        return 1 <= account <= self.n
    
    def transfer(self, account1: int, account2: int, money: int) -> bool:
        # 检查账户编号是否有效以及转出账户是否有足够的余额
        if (self.check(account1) and
                self.check(account2) and
                self.balance[account1 - 1] >= money):
            self.balance[account1 - 1] -= money
            self.balance[account2 - 1] += money
            return True
        return False

    def deposit(self, account: int, money: int) -> bool:
        # 检查账户编号是否有效
        if self.check(account):
            self.balance[account - 1] += money
            return True
        return False

    def withdraw(self, account: int, money: int) -> bool:
        # 检查账户编号是否有效以及账户是否有足够的余额
        if self.check(account) and self.balance[account - 1] >= money:
            self.balance[account - 1] -= money
            return True
        return False
```

```Java
// java
class Bank {
    // 存储账户余额
    private long[] balance;
    // 账户总数
    private int n;

    public Bank(long[] balance) {
        this.balance = balance;
        this.n = balance.length;
    }

    // 检查账户编号是否有效
    private boolean check(int account) {
        return account >= 1 && account <= n;
    }

    public boolean transfer(int account1, int account2, long money) {
        // 检查账户编号是否有效以及转出账户是否有足够的余额
        if (check(account1) && check(account2) && balance[account1 - 1] >= money) {
            balance[account1 - 1] -= money;
            balance[account2 - 1] += money;
            return true;
        }
        return false;
    }

    public boolean deposit(int account, long money) {
        // 检查账户编号是否有效
        if (check(account)) {
            balance[account - 1] += money;
            return true;
        }
        return false;
    }

    public boolean withdraw(int account, long money) {
        // 检查账户编号是否有效以及账户是否有足够的余额
        if (check(account) && balance[account - 1] >= money) {
            balance[account - 1] -= money;
            return true;
        }
        return false;
    }
}
```

- 时间复杂度：三个函数均是 $O(1)$，调用次数最多为 $O(10^4)$
- 空间复杂度： $O(1)$，复用 $balance$ 数组，仅使用常数个额外变量

---

### 复用

实际上，函数 $transfer$ 没有作用，直接用 $deposit$ 以及 $withdraw$ 实现即可。

注意，下面的直接复用有问题！这个 $transfer$ 操作应该具有 **原子性**，如果 $a$ 取款成功而 $b$ 存款失败，那么钱就会凭空消失！

```Python
# 这是一个有问题的、非原子性的实现
def non_atomic_transfer(self, account1, account2, money):
    if self.withdraw(account1, money):  # 步骤1：取款成功
        # 如果此时 account2 是一个无效账户，deposit会失败
        # 但钱已经从 account1 扣除了！
        self.deposit(account2, money)   # 步骤2：存款
        return True # 错误地返回了True
    return False
```

因此，遇到任何失败时，两个账户的状态都应该恢复到操作开始之前的样子。

代码如下，已附加注释：

```Python
# python
class Bank:
    def __init__(self, balance: list[int]):
        # 存储账户余额
        self.balance = balance
        # 账户总数
        self.n = len(self.balance)

    def check(self, account: int) -> bool:
        return 1 <= account <= self.n

    def transfer(self, account1: int, account2: int, money: int) -> bool:
        # 检查 account1
        if self.withdraw(account1, money):
            # deposit 方法会检查 account2
            if self.deposit(account2, money):
                # 存款也成功，整个转账操作完成
                return True
            else:
                # 如果存款失败，必须将钱还给 account1
                print(f"警告：从账户 {account1} 取款成功，但向账户 {account2} 存款失败。正在回滚交易")
                self.deposit(account1, money)
                return False
        
        return False

    def deposit(self, account: int, money: int) -> bool:
        if self.check(account):
            self.balance[account - 1] += money
            return True
        return False

    def withdraw(self, account: int, money: int) -> bool:
        if self.check(account) and self.balance[account - 1] >= money:
            self.balance[account - 1] -= money
            return True
        return False
```

```Java
// java
class Bank {
    // 存储账户余额
    private long[] balance;
    // 账户总数
    private int n;

    public Bank(long[] balance) {
        this.balance = balance;
        this.n = balance.length;
    }

    private boolean check(int account) {
        return account >= 1 && account <= n;
    }

    public boolean transfer(int account1, int account2, long money) {
        // 检查 account1
        if (this.withdraw(account1, money)) {
            // deposit 方法会检查 account2
            if (this.deposit(account2, money)) {
                // 存款也成功，整个转账操作完成
                return true;
            } else {
                // 如果存款失败，必须将钱还给 account1
                System.out.printf("警告：从账户 %d 取款成功，但向账户 %d 存款失败。正在回滚交易\n", account1, account2);
                this.deposit(account1, money);
                return false;
            }
        }
        return false;
    }

    public boolean deposit(int account, long money) {
        if (check(account)) {
            balance[account - 1] += money;
            return true;
        }
        return false;
    }

    public boolean withdraw(int account, long money) {
        if (check(account) && balance[account - 1] >= money) {
            balance[account - 1] -= money;
            return true;
        }
        return false;
    }
}
```

- 时间复杂度：三个函数均是 $O(1)$
- 空间复杂度： $O(1)$

后者速度更慢一点，如果将方法中 $if$ 检查的逻辑拆分，不使用连续的 `&&` 判断，而是换成多个 $if$ 判断，速度会稍微提升，运行时间减少 $1ms$ 左右。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/simple-bank-system/solutions/3815635/shuang-jie-zhi-jie-mo-ni-han-shu-fu-yong-rfmp/)
