[Problem: 67. 二进制求和](https://leetcode.cn/problems/add-binary/description/)

### 方法：调库 & 模拟 & 递归

题意很清晰。记得数学运算是从最低位开始相加，而字符串的第 $0$ 位是数字的最高位。

不想考虑那么多，那就直接调库，代码如下：

```Python
# python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        return bin(int(a, 2) + int(b, 2))[2:]
```

```Java
// java
import java.math.BigInteger;

class Solution {
    public String addBinary(String a, String b) {
        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);
    }
}
```

- 时间复杂度： $O(n+m)$，分别表示串 $a,b$ 的长度
- 空间复杂度： $O(n+m)$，存储两个封装类对象

---

### 模拟

模拟竖式加法，从数字的低位，字符串的高位，逐位相加。

代码如下，已附加注释：

```Python
# python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry = 0
        res = []
        i, j = len(a) - 1, len(b) - 1

        while i >= 0 or j >= 0:
            # 获取当前位的数字，如果 i 或 j 小于 0，说明这一位没有数字，取 0
            bit_a = int(a[i]) if i >= 0 else 0
            bit_b = int(b[j]) if j >= 0 else 0

            # 当前位相加以及进位
            total = bit_a + bit_b + carry
            carry = total // 2
            res.append(str(total % 2))

            # 移动到下一个位置
            i -= 1
            j -= 1

        # 最后如果有进位，加入结果
        if carry:
            res.append('1')

        # 反转结果并连接成字符串
        return ''.join(res[::-1])
```

```Java
// java
class Solution {
    public String addBinary(String a, String b) {
        int carry = 0;
        StringBuilder res = new StringBuilder();
        int i = a.length() - 1, j = b.length() - 1;

        while (i >= 0 || j >= 0) {
            // 获取当前位的数字，如果 i 或 j 小于 0，说明这一位没有数字，取 0
            int bit_a = (i >= 0) ? a.charAt(i) - '0' : 0;
            int bit_b = (j >= 0) ? b.charAt(j) - '0' : 0;

            // 当前位相加以及进位
            int total = bit_a + bit_b + carry;
            carry = total / 2;
            res.append(total % 2);

            // 移动到下一个位置
            i--;
            j--;
        }

        // 最后如果有进位，加入结果
        if (carry != 0) {
            res.append('1');
        }

        // 反转结果并连接成字符串
        return res.reverse().toString();
    }
}
```

- 时间复杂度： $O(n+m)$
- 空间复杂度： $O(n+m)$

---

### 递归

二进制加法既可以使用递推形式，也可以用递归形式，完全把数字当作字符串处理。

递归边界：如果字符串为空，返回另一个字符串。

核心处理逻辑：看两个字符串的 **最后一位**：

- 都是 $1$：结果的最后一位肯定是 $0$，并且产生进位。进位如何处理？我们将剩下的前缀相加后，再加一个 $1$。也即 $add(prefix\_a, prefix\_b) + 1$。
- 都是 $0$：结果最后一位是 $0$，剩下的前缀直接相加。
- 一个 $0$ 一个 $1$：结果最后一位是 $1$，剩下的前缀直接相加。

代码如下，已附加注释：

```Python
# python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        # 边界情况
        if not a: return b
        if not b: return a
        
        # 获取最后一位字符
        last_a, last_b = a[-1], b[-1]
        
        if last_a == '1' and last_b == '1':
            # 1 + 1 = 10
            # add(前缀a, 前缀b) 的结果 再加上 '1'
            return self.addBinary(self.addBinary(a[:-1], b[:-1]), '1') + '0'
        
        elif last_a == '0' and last_b == '0':
            # 0 + 0 = 0
            # 当前位是 '0'，无进位
            return self.addBinary(a[:-1], b[:-1]) + '0'
            
        else:
            # 1 + 0 = 1
            # 当前位是 '1'，无进位
            return self.addBinary(a[:-1], b[:-1]) + '1'
```

```Java
// java
class Solution {
    public String addBinary(String a, String b) {
        // 边界情况
        if (a.isEmpty()) return b;
        if (b.isEmpty()) return a;
        
        // 获取最后一位字符
        char last_a = a.charAt(a.length() - 1);
        char last_b = b.charAt(b.length() - 1);
        
        // 截取前缀
        String prefix_a = a.substring(0, a.length() - 1);
        String prefix_b = b.substring(0, b.length() - 1);
        
        if (last_a == '1' && last_b == '1') {
            // 1 + 1 = 10
            // add(前缀a, 前缀b) 的结果 再加上 '1'
            return addBinary(addBinary(prefix_a, prefix_b), "1") + "0";
            
        } else if (last_a == '0' && last_b == '0') {
            // 0 + 0 = 0
            // 当前位是 '0'，无进位
            return addBinary(prefix_a, prefix_b) + "0";
            
        } else {
            // 1 + 0 = 1
            // 当前位是 '1'，无进位
            return addBinary(prefix_a, prefix_b) + "1";
        }
    }
}
```

- 时间复杂度： $O((n+m)^2)$，每次递归都会拷贝全新的 $string$ 对象
- 空间复杂度： $O(n+m)$，表示递归调用栈的最大深度

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/add-binary/solutions/3903021/san-jie-diao-ku-shu-shi-mo-ni-di-gui-zon-yxl7/)
