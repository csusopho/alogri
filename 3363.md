[Problem: 3363. 最多可收集的水果数目](https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/description/)

### 方法：DFS/DP

第一个小朋友从左上角 $(0,0)$ 出发，能往正下、正右、右下三个方向移动；第二个小朋友从右上角 $(0,n-1)$ 出发，能往左下、正左、右下三个方向移动；第三个小朋友从左下角 $(n-1,0)$ 出发，往右上、正右、右下三个方向移动。示意图：

```Java
      第一个         第二个        第三个
        ⭢            ↙
         ↘           ↘           ↗↘⭢
          ↓            ↓
```

本题的 **难点**：一个小朋友收集完房间的水果后，下一个人收集不了！三个人一起移动，交叉在一起不好分析。怎么办？

实际上，三个小朋友的路径根本不会交叉！

正方形边长为 $n$，每个人只能走 $n-1$ 步，第一个小朋友想从左上到右下，横纵方向的增量必须都是 $n-1$，也即必须沿着 **主对角线** 方向。

将正方形沿着主对角线方向划开，分为 “左下角” 区域和 “右上角” 区域，两个小朋友分别在其中移动，不会越过这条线！为什么？

以第二个小朋友举例，他的起点是 $(0,n-1)$，终点是 $(n-1,n-1)$。左下方移动一次，使得纵坐标 $y-1$；右下方移动一次，使得纵坐标 $y+1$。起点和终点的 $y$ 值相同，说明 “左下” 和 “右下” 的次数相同。但是，想要越过中间这条 $x=y$ 的线，必须让 “左下” 的次数超过 $(n-1)/2$，但总次数为 $n-1$，则无法到达终点。

> 具体例子不再说明，可以对照示例 $1$ 的图。

因此，我们得知了本题的 **关键点**：三个人的路径不会交叉！不用担心重复情况！

第一个人就是主对角线方向，第二/三个人就是在网格中移动，寻找每条 “起点-终点” 的路径和，然后找出最大值即可！

这种网格图搜索问题，很经典的 $DFS/DP$ 问题，这里就不赘述细节，直接 **定义** $dfs(i,j)$ 表示走到 $(i,j)$ 位置时的路径累加和。后两个人的路径不同，所以定义两个 $dfs$ 函数。

同样地，要使用 **记忆化** 手段，避免重复搜索。一个简单的例子：右上角出发，走到 $(2,n-1)$ 有两种路径，但是参数却相同，后续的搜索会重叠，因此需要避免。在 $Java$ 中使用 $memo$ 数组记录，而 $Python$ 中直接用 $@cache$ 装饰器即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        # 第一个人走对角线
        total = sum(fruits[i][i] for i in range(n))

        # 第二个人走右上角区域 i < j
        @cache
        def dfs2(i, j):
            # 递归边界
            if not (0 <= i < n and 0 <= j < n):
                return float('-inf')
            if i == n - 1 and j == n - 1:
                return 0
            if i >= j:
                return float('-inf')
            return fruits[i][j] + max(
                dfs2(i + 1, j),
                dfs2(i + 1, j - 1),
                dfs2(i + 1, j + 1),
            )

        # 第三个人走左下角区域 i > j
        @cache
        def dfs3(i, j):
            # 递归边界
            if not (0 <= i < n and 0 <= j < n):
                return float('-inf')
            if i == n - 1 and j == n - 1:
                return 0
            if i <= j:
                return float('-inf')
            return fruits[i][j] + max(
                dfs3(i, j + 1),
                dfs3(i - 1, j + 1),
                dfs3(i + 1, j + 1),
            )

        return total + dfs2(0, n - 1) + dfs3(n - 1, 0)
```

```Java
// java
public class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        // 第一个人走对角线
        int total = 0;
        for (int i = 0; i < n; i++) {
            total += fruits[i][i];
        }

        // 第二个人走右上角区域
        int[][] memo2 = new int[n][n];
        int dfs2 = dfs2(0, n - 1, fruits, n, memo2);

        // 第三个人走左下角区域
        int[][] memo3 = new int[n][n];
        int dfs3 = dfs3(n - 1, 0, fruits, n, memo3);

        return total + dfs2 + dfs3;
    }

    // 右上角区域 i < j
    private int dfs2(int i, int j, int[][] fruits, int n, int[][] memo) {
        // 递归边界
        if (i < 0 || i >= n || j < 0 || j >= n) return 0;
        if (i == n - 1 && j == n - 1) return 0;
        if (i >= j) return 0;
        // 记忆化
        if (memo[i][j] != 0) return memo[i][j];

        memo[i][j] = fruits[i][j] + Math.max(
            Math.max(dfs2(i + 1, j, fruits, n, memo),
                     dfs2(i + 1, j - 1, fruits, n, memo)),
                     dfs2(i + 1, j + 1, fruits, n, memo)
        );

        return memo[i][j];
    }

    // 左下角区域 i > j
    private int dfs3(int i, int j, int[][] fruits, int n, int[][] memo) {
        // 递归边界
        if (i < 0 || i >= n || j < 0 || j >= n) return 0;
        if (i == n - 1 && j == n - 1) return 0;
        if (i <= j) return 0;
        // 记忆化
        if (memo[i][j] != 0) return memo[i][j];

        memo[i][j] = fruits[i][j] + Math.max(
            Math.max(dfs3(i, j + 1, fruits, n, memo),
                     dfs3(i - 1, j + 1, fruits, n, memo)),
                     dfs3(i + 1, j + 1, fruits, n, memo)
        );

        return memo[i][j];
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(n^2)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n^2)$。

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $fruits$ 的长度
- 空间复杂度： $O(n^2)$，表示数组 $memo$ 的大小

---

### 合并

两个函数大致相同，可以进行复用，只需要增加一个参数 $who$ 表示是第几个人，从而正确进行方向选择。同时，增加方向数组 $directions$ 使代码更美观。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        # 第一个人走对角线
        total = sum(fruits[i][i] for i in range(n))
        directions = {
            0: [(1, 0), (1, -1), (1, 1)],   # 第二个人
            1: [(0, 1), (-1, 1), (1, 1)],  # 第三个人
        }

        @cache
        def dfs(i, j, who):
            # 边界条件
            if not (0 <= i < n and 0 <= j < n):
                return float('-inf')
            if i == n - 1 and j == n - 1:
                return 0

            # 不能碰到或越过对角线
            if i == j or (who == 0 and i > j) or (who == 1 and i < j):
                return float('-inf')

            best = float('-inf')
            for dx, dy in directions[who]:
                ni, nj = i + dx, j + dy
                best = max(best, dfs(ni, nj, who) + fruits[i][j])
            return best

        # who=0: 第二个人从右上出发；who=1: 第三个人从左下出发
        return total + dfs(0, n - 1, 0) + dfs(n - 1, 0, 1)
```

```Java
// java
public class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        // 第一个人走对角线
        int total = 0;
        for (int i = 0; i < n; i++) {
            total += fruits[i][i];
        }

        // 定义方向，who=0 第二个人，who=1 第三个人
        int[][][] directions = new int[2][][];
        directions[0] = new int[][]{{1, 0}, {1, -1}, {1, 1}};
        directions[1] = new int[][]{{0, 1}, {-1, 1}, {1, 1}};

        int[][][] memo = new int[n][n][2];
        // 初始化为一个特殊值，表示未访问
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                memo[i][j][0] = -1;
                memo[i][j][1] = -1;
            }
        }

        int dfs0 = dfs(0, n - 1, 0, fruits, n, directions, memo);
        int dfs1 = dfs(n - 1, 0, 1, fruits, n, directions, memo);

        return total + dfs0 + dfs1;
    }

    // dfs方法，who=0 or 1 区分第二、第三个人
    private int dfs(int i, int j, int who, int[][] fruits, int n, int[][][] directions, int[][][] memo) {
        // 边界条件
        if (i < 0 || i >= n || j < 0 || j >= n) return -1;
        if (i == n - 1 && j == n - 1) return 0;

        // 不能碰到或越过对角线
        if (i == j || (who == 0 && i > j) || (who == 1 && i < j)) return -1;

        // 记忆化查询
        if (memo[i][j][who] != -1) return memo[i][j][who];

        int best = -1;
        for (int[] d : directions[who]) {  // 三个方向
            int ni = i + d[0], nj = j + d[1];
            int val = dfs(ni, nj, who, fruits, n, directions, memo);
            if (val != -1) {
                best = Math.max(best, val + fruits[i][j]);
            }
        }

        memo[i][j][who] = best;
        return best;
    }
}
```

- 时间复杂度： $O(n^2)$，同理
- 空间复杂度： $O(n^2)$

---

### $DP$

将递归 $1:1$ 转为递推，**定义** $dp[i][j]$ 表示走到 $(i,j)$ 格子时的路径和。

这里的 $DP$ 难点在于 **递推方向**：

- 从右上角出发时，不断向下方移动，所以先枚举横坐标 $i$，再枚举纵坐标 $j$，逐行遍历；
- 从左下角出发时，不断向右方移动，所以先枚举 $j$ 再枚举 $i$，逐列遍历。

从先前的三个方向 **转移** 状态，其他细节不再阐述。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        # 第一个人走主对角线
        ans = sum(fruits[i][i] for i in range(n))
        NEG_INF = float('-inf')  # 用负无穷表示不可达状态

        # 第二个人从右上角 (0, n-1) 出发，走在矩阵右上半部分（i < j）
        dp = [[NEG_INF] * n for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]  # 起点
        
        # 遍历行，从第二行开始，到倒数第二行
        for i in range(1, n - 1):
            for j in range(i + 1, n):  # 右上半i<j区域
                max_prev = NEG_INF  # 记录从上一行可达的状态
                
                # 检查左上、正上、右上
                if j - 1 >= 0 and dp[i - 1][j - 1] != NEG_INF:
                    max_prev = max(max_prev, dp[i - 1][j - 1])
                if dp[i - 1][j] != NEG_INF:
                    max_prev = max(max_prev, dp[i - 1][j])
                if j + 1 < n and dp[i - 1][j + 1] != NEG_INF:
                    max_prev = max(max_prev, dp[i - 1][j + 1])
                
                # 更新
                if max_prev != NEG_INF:
                    dp[i][j] = max_prev + fruits[i][j]
        
        # 第二个人路径终点
        ans += dp[n - 2][n - 1]

        # 第三个人从左下角 (n-1, 0) 出发，走在矩阵左下半部分（i > j）
        dp = [[NEG_INF] * n for _ in range(n)]
        dp[n - 1][0] = fruits[n - 1][0]  # 起点
        
        # 遍历列，从第二列开始，到倒数第二列
        for j in range(1, n - 1):
            for i in range(j + 1, n):  # 左下半i>j区域
                max_prev = NEG_INF  # 记录从左边可达的状态
                
                # 检查左上、正左、左下
                if i - 1 >= 0 and j - 1 >= 0 and dp[i - 1][j - 1] != NEG_INF:
                    max_prev = max(max_prev, dp[i - 1][j - 1])
                if j - 1 >= 0 and dp[i][j - 1] != NEG_INF:
                    max_prev = max(max_prev, dp[i][j - 1])
                if i + 1 < n and j - 1 >= 0 and dp[i + 1][j - 1] != NEG_INF:
                    max_prev = max(max_prev, dp[i + 1][j - 1])
                
                # 更新
                if max_prev != NEG_INF:
                    dp[i][j] = max_prev + fruits[i][j]
        
        # 第三个人路径终点
        ans += dp[n - 1][n - 2]
        return ans
```

```Java
// java
public class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int NEG_INF = Integer.MIN_VALUE; // 用负无穷表示不可达状态
        int ans = 0;

        // 第一个人走主对角线
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
        }

        // 第二个人从右上角 (0, n-1) 出发，走在矩阵右上半部分（i < j）
        int[][] dp = new int[n][n];
        for (int[] row : dp) {
            java.util.Arrays.fill(row, NEG_INF);
        }
        dp[0][n - 1] = fruits[0][n - 1]; // 起点

        // 遍历行，从第二行开始，到倒数第二行
        for (int i = 1; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) { // 右上半 i < j 区域
                int maxPrev = NEG_INF; // 记录从上一行可达的状态

                // 检查左上、正上、右上
                if (j - 1 >= 0 && dp[i - 1][j - 1] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i - 1][j - 1]);
                }
                if (dp[i - 1][j] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i - 1][j]);
                }
                if (j + 1 < n && dp[i - 1][j + 1] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i - 1][j + 1]);
                }

                // 更新
                if (maxPrev != NEG_INF) {
                    dp[i][j] = maxPrev + fruits[i][j];
                }
            }
        }

        // 第二个人路径终点
        ans += dp[n - 2][n - 1];

        // 第三个人从左下角 (n-1, 0) 出发，走在矩阵左下半部分（i > j）
        for (int[] row : dp) {
            java.util.Arrays.fill(row, NEG_INF); // 重置dp数组
        }
        dp[n - 1][0] = fruits[n - 1][0]; // 起点

        // 遍历列，从第二列开始，到倒数第二列
        for (int j = 1; j < n - 1; j++) {
            for (int i = j + 1; i < n; i++) { // 左下半 i > j 区域
                int maxPrev = NEG_INF; // 记录从左边可达的状态

                // 检查左上、正左、左下
                if (i - 1 >= 0 && j - 1 >= 0 && dp[i - 1][j - 1] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i - 1][j - 1]);
                }
                if (j - 1 >= 0 && dp[i][j - 1] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i][j - 1]);
                }
                if (i + 1 < n && j - 1 >= 0 && dp[i + 1][j - 1] != NEG_INF) {
                    maxPrev = Math.max(maxPrev, dp[i + 1][j - 1]);
                }

                // 更新
                if (maxPrev != NEG_INF) {
                    dp[i][j] = maxPrev + fruits[i][j];
                }
            }
        }

        // 第三个人路径终点
        ans += dp[n - 1][n - 2];

        return ans;
    }
}
```

---

对代码进行究极简化，得到如下形式，已附加详细注释：

```Python
# python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        # 第一个人走主对角线
        diag = sum(fruits[i][i] for i in range(n))
        # dp[i][j] 表示当前走到 (i, j) 的最大采果数
        dp = [[0] * n for _ in range(n)]
        # 第二个人从右上角出发，初始化起点
        dp[0][n - 1] = fruits[0][n - 1]

        # 只能在右上三角区域
        for i in range(1, n - 1):
            for j in range(max(i + 1, n - 1 - i), n):
                if j < n - 1:
                    dp[i][j] = fruits[i][j] + max(
                        dp[i - 1][j - 1],
                        dp[i - 1][j],
                        dp[i - 1][j + 1]
                    )
                else:
                    dp[i][j] = fruits[i][j] + max(
                        dp[i - 1][j - 1],
                        dp[i - 1][j]
                    )

        # 第三个人从左下角出发，初始化起点
        dp[n - 1][0] = fruits[n - 1][0]

        # 只能在左下三角区域
        for j in range(1, n - 1):
            for i in range(max(j + 1, n - 1 - j), n):
                if i < n - 1:
                    dp[i][j] = fruits[i][j] + max(
                        dp[i - 1][j - 1],
                        dp[i][j - 1],
                        dp[i + 1][j - 1]
                    )
                else:
                    dp[i][j] = fruits[i][j] + max(
                        dp[i - 1][j - 1],
                        dp[i][j - 1]
                    )

        # 返回三人采集的总水果数
        return diag + dp[n - 2][n - 1] + dp[n - 1][n - 2]
```

```Java
// java
public class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;

        // 第一个人走主对角线
        int diag = 0;
        for (int i = 0; i < n; i++) {
            diag += fruits[i][i];
        }

        // dp[i][j] 表示当前走到 (i, j) 的最大采果数
        int[][] dp = new int[n][n];

        // 第二个人从右上角出发，初始化起点
        dp[0][n - 1] = fruits[0][n - 1];

        // 只能在右上三角区域
        for (int i = 1; i < n - 1; i++) {
            for (int j = Math.max(i + 1, n - 1 - i); j < n; j++) {
                if (j < n - 1) {
                    dp[i][j] = fruits[i][j] + Math.max(
                        Math.max(dp[i - 1][j - 1], dp[i - 1][j]),
                        dp[i - 1][j + 1]
                    );
                } else {
                    dp[i][j] = fruits[i][j] + Math.max(
                        dp[i - 1][j - 1],
                        dp[i - 1][j]
                    );
                }
            }
        }

        // 第三个人从左下角出发，初始化起点
        dp[n - 1][0] = fruits[n - 1][0];

        // 只能在左下三角区域
        for (int j = 1; j < n - 1; j++) {
            for (int i = Math.max(j + 1, n - 1 - j); i < n; i++) {
                if (i < n - 1) {
                    dp[i][j] = fruits[i][j] + Math.max(
                        Math.max(dp[i - 1][j - 1], dp[i][j - 1]),
                        dp[i + 1][j - 1]
                    );
                } else {
                    dp[i][j] = fruits[i][j] + Math.max(
                        dp[i - 1][j - 1],
                        dp[i][j - 1]
                    );
                }
            }
        }

        // 返回三人采集的总水果数
        return diag + dp[n - 2][n - 1] + dp[n - 1][n - 2];
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n^2)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/solutions/3745114/si-jie-shuang-dfs-he-bing-er-wei-dp-jian-2y7l/)
