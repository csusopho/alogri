[Problem: 1625. 执行操作后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/)

### 方法：BFS & 优化

累加操作：每个下标为奇数的位置都会加上 $a$，并对 $10$ 取模。比如 $s=2456,a=5$，则第 $1$ 位的 $4+5=9$，第三位的 $(6+5)\%10=1$，则结果为 $2951$。

轮转操作：将 $s$ 当作循环串，移出末尾的数字会回到开头，比如 $2456\to 6245$。

我们可以把这个问题看作一个 **图的遍历** 问题。每个唯一的字符串是一个节点，操作（累加、轮转）是连接节点的边。我们从初始字符串 $s$ 开始，通过 $BFS$ 或 $DFS$ 来探索所有可以到达的字符串状态。

**暴力**：模拟所有可能的操作，找出所有能生成的字符串，然后比较大小。

具体来说，创建一个队列 $q$，存储每个新生成的串；一个集合 $visited$，用来存放已经处理过的字符串，防止重复计算和无限循环。

流程：

- 当队列 $q$ 不为空时，从队列中取出一个字符串 $curStr$；
- 与最小的 $ans$ 比较，如果 $curStr$ 的字典序更小，就更新 $ans$；
- **累加** 操作：一次“累加”，得到新字符串 $addStr$。如果 $addStr$ 不在 $visited$ 集合中，就将其加入队列 $q$ 和 $visited$ 集合；
- **轮转** 操作：一次“轮转”，得到新字符串 $rotatStr$。如果 $rotatStr$ 不在 $visited$ 集合中，就将其加入队列 $q$ 和 $visited$ 集合；
- 当队列为空时，说明所有可能的状态都已经探索完毕，此时 $ans$ 中存储的就是最终答案。

这种方法生成了所有可达的字符串，并全部进行了比较，所以答案的字典序最小。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        q = deque([s])
        # 存储已访问过的字符串
        visited = {s}
        ans = s

        while q:
            # 取出一个字符串
            cur_s = q.popleft()

            # 比已知的最小字符串还要小
            if cur_s < ans:
                ans = cur_s
            
            # --- 操作1：累加 ---
            # 将当前字符串转换为列表，方便修改
            s_list = list(cur_s)
            # 遍历奇数下标的元素
            for i in range(1, len(s_list), 2):
                # 将字符转换为数字，加上 a，然后对 10 取模
                new_digit = (int(s_list[i]) + a) % 10
                s_list[i] = str(new_digit)
            
            # 将列表转换回字符串
            added_s = "".join(s_list)
            # 未被访问过
            if added_s not in visited:
                visited.add(added_s)
                q.append(added_s)
            
            # --- 操作2：轮转 ---
            rotated_s = cur_s[-b:] + cur_s[:-b]
            # 未被访问过
            if rotated_s not in visited:
                visited.add(rotated_s)
                q.append(rotated_s)
                
        # 当队列为空时，所有可达状态均已访问
        return ans
```

```Java
// java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        Queue<String> q = new ArrayDeque<>();
        // 存储已访问过的字符串
        Set<String> visited = new HashSet<>();

        // 初始化
        q.add(s);
        visited.add(s);
        String ans = s;

        while (!q.isEmpty()) {
            // 取出一个字符串
            String currentS = q.poll();

            // 比已知的最小字符串还要小，则更新
            if (currentS.compareTo(ans) < 0) {
                ans = currentS;
            }

            // --- 操作1：累加 ---
            StringBuilder sBuilder = new StringBuilder(currentS);
            // 遍历奇数下标的元素
            for (int i = 1; i < sBuilder.length(); i += 2) {
                // 获取字符并转换为数字
                int digit = sBuilder.charAt(i) - '0';
                // 将数字加上 a，然后对 10 取模
                int newDigit = (digit + a) % 10;
                sBuilder.setCharAt(i, (char) (newDigit + '0'));
            }

            String addedS = sBuilder.toString();
            // 如果累加后的字符串未被访问过
            if (!visited.contains(addedS)) {
                visited.add(addedS);
                q.add(addedS);
            }

            // --- 操作2：轮转 ---
            int n = currentS.length();
            String rotatedS = currentS.substring(n - b) + currentS.substring(0, n - b);
            // 如果轮转后的字符串未被访问过
            if (!visited.contains(rotatedS)) {
                visited.add(rotatedS);
                q.add(rotatedS);
            }
        }

        // 当队列为空时，所有可达状态均已访问
        return ans;
    }
}
```

在 $BFS$ 中，时间复杂度通常表示为 $O(V + E)$，其中 $V$ 是顶点（状态）的数量， $E$ 是边（操作）的数量。

- $V$：可以生成的所有唯一字符串的数量，也就是 $visited$ 集合的最终大小。
- $E$：从每个状态出发，执行累加和轮转两种操作，所以 $E=2 * V$。
- 处理成本：包含字符串比较、转换、切片、哈希等操作，时间是 $O(n)$。

因此，整体的时间复杂度是 $O(V * n)$，关键就在于估算 $V$ 的大小。

- 累加操作中，一个数字可以变成多少个不同的数字？是 $10 / gcd(10, a)$，简记为  $C_a$，后面证明。
- 轮转操作中，循环的长度是多少？是 $n / gcd(n, b)$，简记为 $C_b$，后面证明。

当 $b$ 是奇数时，所有位置的数字都可以被修改，状态数 $V$ 的一个宽松上界是 $C_b * (C_a)^n$；当 $b$ 是偶数时，只有奇数位的数字可以被 “累加” 操作修改，状态数 $V$ 的上界大约是 $C_b * (C_a)^{n/2}$。

综合来看，时间复杂度的上界可以表达为：

$$
O(n * V) = O(n * (n / gcd(n, b)) * (10 / gcd(10, a)) ^ k)
$$

其中 $k$ 在 $b$ 是偶数时为 $n/2$，在其他情况下更接近 $n$。

- 时间复杂度： $O(n\times t^k)$，其中 $n$ 是串 $s$ 的长度，其他细节在上方已表述
- 空间复杂度： $O(n\times t^k)$，表示哈希表 $visited$ 以及队列 $q$ 的大小，状态是一个串

---

### 优化

对于第 $0$ 位数字来说，它能轮转到哪？`0, b % n, 2b % n, 3b % n, ...`，根据 **裴蜀定理** 可知，这些位置都是 $gcd(b, n)$ 的倍数，其中 $gcd$ 是最大公约数。

> 裴蜀定理，能表示两个整数的线性组合，具体 $Wiki$ 百科为 [链接](https://oi-wiki.org/math/number-theory/bezouts/)。

这意味着，通过轮转操作，我们只能生成 $n / gcd(b, n)$ 种不同的字符排列。以这些排列为基础，在此之上进行“累加”操作即可。

对于任何一个可以被累加的数字位，我们可以对其进行任意次累加，则该位置的数字 $d$ 可以变为 $(d + k*a) % 10$ 中的任何一个。

当字符排列固定时，所有奇数位的数字会作为 **一个整体** 被累加。也就是说，如果我们对字符串执行 $k$ 次累加操作，那么所有奇数位的数字都会被加上 $k*a$，不能独立地修改。

**结论一**：奇偶位两组互相独立，组内累加次数相同。

字符串 $s$ 的长度是偶数，

- 如果轮转的位数 $b$ 是 **偶数**，那么奇数位上的数字在轮转后永远在奇数位，偶数位永远在偶数位。这意味着，“累加” 操作永远只能影响到初始字符串中的奇数位数字，偶数位的数字永远不变。
- 如果 $b$ 是 **奇数**，轮转一次会使奇偶位置互换。这意味着，初始字符串中的 *每一个* 数字都有机会被移动到奇数位上并被累加，奇/偶数位都可以修改。

**结论二**：如果 $b$ 是偶数，只需要修改第一个奇数位数字；反之，还需要考虑第一个偶数位数字。

为了使整个字符串的字典序最小，我们应该让高位的数字尽可能小。

**总结**：让这一组的初始数字（第一个奇/偶数位的数字）变成最小，求出累加次数，然后将这个次数应用到所有相关的数字位上。

初始：计算 $b$ 和字符串长度 $n$ 的最大公约数 $g$，则轮转一共会产生 $n/g$ 种基础排列。

**流程**：对于每一种排列，

- 对所有奇数位进行 “最优” 累加，使得它们作为一个整体，形成的数字尽可能小。
- 如果 $b$ 是奇数，再对所有偶数位也进行同样的最优累加。

每步操作后，能得到一个候选的最小字符串，从中选出最小值返回。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        ans = s

        # 找到一个累加次数，使得 start 上的数字最小
        # 然后将这个累加次数应用到所有位置上
        def optimal_add(s_list, start):
            # 记录能得到的最小数字，以及需要累加的次数
            min_digit = 10
            cnt = 0

            # 尝试 0 到 9 次累加，找到最优次数
            for i in range(10):
                # 计算 start 上的数字经过 i 次累加后的值
                cur_digit = (int(s_list[start]) + i * a) % 10
                if cur_digit < min_digit:
                    min_digit = cur_digit
                    cnt = i
            
            # 如果需要累加
            if cnt > 0:
                # 将这个最优累加次数应用到所有相关数字位上
                for i in range(start, n, 2):
                    s_list[i] = str((int(s_list[i]) + cnt * a) % 10)

        # 轮转操作的步长是 b 和 n 的最大公约数
        step = gcd(b, n)
        # 延长一倍，方便截取
        double_s = s + s

        # 轮转
        for i in range(0, n, step):
            # 获取一个轮转后的字符串
            rotated_s = list(double_s[i : i + n])

            # 累加操作始终可以作用于奇数位
            optimal_add(rotated_s, 1)

            # 如果 b 是奇数，意味着累加可以作用于所有位
            if b % 2 == 1:
                optimal_add(rotated_s, 0)
            
            # 更新全局最小
            candidate_s = "".join(rotated_s)
            ans = min(ans, candidate_s)
            
        return ans
```

```Java
// java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        int n = s.length();
        String ans = s;

        // 轮转操作的步长是 b 和 n 的最大公约数
        int step = gcd(b, n);
        // 将字符串延长一倍，方便截取子串
        String doubleS = s + s;

        // 轮转
        for (int i = 0; i < n; i += step) {
            // 获取一个轮转后的字符串
            char[] rotatedSArray = doubleS.substring(i, i + n).toCharArray();

            // 累加操作始终可以作用于奇数位
            optimalAddition(rotatedSArray, 1, a, n);

            // 如果 b 是奇数，轮转可以使奇偶位互换，对偶数位进行最优累加
            if (b % 2 == 1) {
                optimalAddition(rotatedSArray, 0, a, n);
            }

            // 转换回字符串
            String candidateS = new String(rotatedSArray);
            // 更新全局最小
            if (candidateS.compareTo(ans) < 0) {
                ans = candidateS;
            }
        }

        return ans;
    }

    // 使用欧几里得算法，计算最大公约数
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // 找到一个累加次数，使得 start 上的数字最小
    // 将这个累加次数应用到所有位置上，会修改传入的数组
    private void optimalAddition(char[] sArray, int start, int a, int n) {
        // 记录能得到的最小数字，以及需要累加的次数
        int minDigit = 10;
        int optimalAddCount = 0;

        // 尝试 0 到 9 次累加，找到能使 start 位置数字最小的最优次数
        for (int i = 0; i < 10; i++) {
            // 计算 start 位置上的数字经过 i 次累加后的值
            int currentDigit = ((sArray[start] - '0') + i * a) % 10;
            if (currentDigit < minDigit) {
                minDigit = currentDigit;
                optimalAddCount = i;
            }
        }

        // 如果需要累加
        if (optimalAddCount > 0) {
            // 将这个最优累加次数应用到所有相关数字位上
            for (int i = start; i < n; i += 2) {
                int newDigit = ((sArray[i] - '0') + optimalAddCount * a) % 10;
                sArray[i] = (char) (newDigit + '0');
            }
        }
    }
}
```

- 时间复杂度： $O(n^2\times d)$，其中 $d=10$ 是枚举累加次数的上限
- 空间复杂度： $O(n)$，表示中间变量 $doubleS$ 等的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/solutions/3809989/shuang-jie-bfsmo-ni-pei-shu-ding-li-fen-ql467/)
