[Problem: 3195. 包含所有 1 的最小矩形面积 I](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-i/description/)

### 方法：模拟

矩形必须包含全部的 $1$。为了让矩形最小，一个简单的 **贪心** 想法：“贴边” 将这些 $1$ 给圈起来，保证所有 $1$ 在内的同时不包含更多的 $0$。

根据示例 $1$，我们发现：

- 矩形的上边取决于最上方的 $1$；
- 矩形的左边取决于最左方的 $1$；
- 矩形的下边取决于最下方的 $1$；
- 矩形的右边取决于最右方的 $1$。

因此，统计所有 $1$ 出现的 **最小/大** 的行、列下标。代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumArea(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        top = m          # 1出现的最小行
        bottom = -1      # 1出现的最大行
        left = n         # 1出现的最小列
        right = -1       # 1出现的最大列

        # 扫描每个元素，更新边界
        for r in range(m):
            for c in range(n):
                if grid[r][c] == 1:
                    if r < top: top = r
                    if r > bottom: bottom = r
                    if c < left: left = c
                    if c > right: right = c

        # 数学计算
        height = bottom - top + 1
        width = right - left + 1
        return height * width
```

```Java
// java
class Solution {
    public int minimumArea(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int top = m;       // 1 出现的最小行
        int bottom = -1;   // 1 出现的最大行
        int left = n;      // 1 出现的最小列
        int right = -1;    // 1 出现的最大列

        // 扫描每个元素，更新边界
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (grid[r][c] == 1) {
                    if (r < top) top = r;
                    if (r > bottom) bottom = r;
                    if (c < left) left = c;
                    if (c > right) right = c;
                }
            }
        }

        // 数学计算
        int height = bottom - top + 1;
        int width = right - left + 1;
        return height * width;
    }
}
```

- 时间复杂度： $O(m\times n)$，其中 $m,n$ 分别为矩阵 $grid$ 的行数、列数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 展开

如果我们将上述的一次遍历，展开为四次遍历。分别统计行、列下标，找出最小/大值后，立刻 $break$ 退出，**本质** 就是不再搜索中间的 $1$，速度会更快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumArea(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        # 从上往下找第一个含有 1 的行
        top = -1
        for r in range(m):
            for c in range(n):
                if grid[r][c] == 1:
                    top = r
                    break
            if top != -1:
                break

        # 从下往上找第一个含有 1 的行
        bottom = -1
        for r in range(m - 1, -1, -1):
            for c in range(n):
                if grid[r][c] == 1:
                    bottom = r
                    break
            if bottom != -1:
                break

        # 从左往右找第一个含有 1 的列
        left = -1
        for c in range(n):
            for r in range(m):
                if grid[r][c] == 1:
                    left = c
                    break
            if left != -1:
                break

        # 从右往左找第一个含有 1 的列
        right = -1
        for c in range(n - 1, -1, -1):
            for r in range(m):
                if grid[r][c] == 1:
                    right = c
                    break
            if right != -1:
                break

        height = bottom - top + 1
        width = right - left + 1
        return height * width
```

```Java
// java
class Solution {
    public int minimumArea(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // 从上往下找第一个含有 1 的行
        int top = -1;
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (grid[r][c] == 1) {
                    top = r;
                    break;
                }
            }
            if (top != -1) break;
        }

        // 从下往上找第一个含有 1 的行
        int bottom = -1;
        for (int r = m - 1; r >= 0; r--) {
            for (int c = 0; c < n; c++) {
                if (grid[r][c] == 1) {
                    bottom = r;
                    break;
                }
            }
            if (bottom != -1) break;
        }

        // 从左往右找第一个含有 1 的列
        int left = -1;
        for (int c = 0; c < n; c++) {
            for (int r = 0; r < m; r++) {
                if (grid[r][c] == 1) {
                    left = c;
                    break;
                }
            }
            if (left != -1) break;
        }

        // 从右往左找第一个含有 1 的列
        int right = -1;
        for (int c = n - 1; c >= 0; c--) {
            for (int r = 0; r < m; r++) {
                if (grid[r][c] == 1) {
                    right = c;
                    break;
                }
            }
            if (right != -1) break;
        }

        int height = bottom - top + 1;
        int width = right - left + 1;
        return height * width;
    }
}
```

- 时间复杂度： $O(m\times n)$，同理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-i/solutions/3760367/mo-ni-yi-ci-bian-li-si-ci-bian-li-you-ya-pb02/)
