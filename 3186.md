[Problem: 3186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/)

### 方法：DFS & DP & 优化

题意：使用值为 $x$ 的咒语，则值为 $x-2,x-1,x+1,x+2$ 的咒语都不能用，求咒语的最大累加和。注意，值为 $x$ 的也能用！

假设我们已经选了值为 $2,5,\dots$ 一系列咒语，怎么知道新的咒语不会和它们冲突？因此，我们手动 **升序**，从小到大遍历，新咒语只需要和前一个选择的咒语比较。

同时，一个很自然的 **贪心** 思路：选择一个值为 $x$ 的咒语后，可以将所有值为 $x$ 的咒语全部选择，它们互不影响，只会使答案增大。

**总结**：使用哈希表 $counts$ 统计每个值的出现次数，并对该哈希进行排序。后续思路中，可以将一个值看作独特的咒语，不再需要考虑重复值的情况。

每个咒语只能使用一次，那就是「选」或「不选」两种可能。在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

**定义** $dfs(i)$ 表示从第 $i$ 个咒语开始，最终所能获得的最大累加和。

- 如果我们不选择该咒语，则直接变为下一个状态 $dfs(i+1)$；
- 反之，假设咒语值为 $power[i]=x$，则该咒语的累加和是 $x\times counts[x]$。此时，我们需要跳过 $x+1,x+2$ 的咒语，假设新下标为 $j$，新状态就是 $dfs(j)$。

两种方案都可行，选择较大者，转移方程为：

$$
dfs(i)=\max\left(dfs(i+1),dfs(j)\right)
$$

如何得知这个新下标 $j$？只需要用一个指针，寻找第一个大于 $x+2$ 的下标。

**递归边界**： $i=n$ 时说明所有咒语选择完成，返回 $0$ 表示结束。

**递归入口**： $dfs(0)$，表示从下标 $0$ 开始搜索，直至搜索完 $n$ 个咒语。

从 $dfs(1)\to dfs(4)$ 或者 $dfs(1)\to dfs(2)\to dfs(3)\to dfs(4)$，两个过程会导致重复计算 $dfs(4)$。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有一个，所以记忆化数组只需要一维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

记忆化数组的初始值只要不等于某个 $dfs$ 的状态值即可，因为咒语值一定 $>0$，这里不用赋初值，默认为 $0$ 表示方案无效。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        # 统计每个伤害值的总伤害，并排序
        counts = Counter(power)
        sorted_powers = sorted(counts.keys())
        n = len(sorted_powers)

        # 从 sorted_powers[i] 到结尾所能获得的最大伤害
        @cache
        def dfs(i):
            # 边界情况
            if i >= n:
                return 0

            cur_power = sorted_powers[i]
            # 不选当前的咒语
            res_skip = dfs(i + 1)
            # 选择当前的咒语
            damage_take = cur_power * counts[cur_power]
            
            # 寻找下一个可以使用的咒语的索引
            # 需要跳过所有伤害值 <= cur_power + 2 的咒语
            next_i = i + 1
            while next_i < n and sorted_powers[next_i] <= cur_power + 2:
                next_i += 1
            
            # 递归到下一个合法位置
            res_take = damage_take + dfs(next_i)
            # 两种决策中的最大值
            return max(res_skip, res_take)

        return dfs(0)
```

```Java
// java
class Solution {
    private int[] sortedPowers;
    private Map<Integer, Integer> counts;
    private long[] memo;
    private int n;

    public long maximumTotalDamage(int[] power) {
        // 统计每个伤害值的总伤害
        this.counts = new TreeMap<>();
        for (int p : power) {
            counts.put(p, counts.getOrDefault(p, 0) + 1);
        }

        // 将伤害值排序并存入数组
        this.n = counts.size();
        this.sortedPowers = new int[n];
        int index = 0;
        for (int p : counts.keySet()) {
            sortedPowers[index++] = p;
        }

        // 初始化记忆化数组
        this.memo = new long[n];
        return dfs(0);
    }

    // 计算从 sortedPowers[i] 到结尾所能获得的最大伤害
    private long dfs(int i) {
        // 边界情况
        if (i >= n) {
            return 0;
        }

        // 如果当前状态已经计算过，直接从记忆化数组中返回结果
        if (memo[i] != 0) {
            return memo[i];
        }

        int curPower = sortedPowers[i];
        
        // 不选当前的咒语
        long resSkip = dfs(i + 1);

        // 选择当前的咒语
        long damageTake = (long) curPower * counts.get(curPower);

        // 寻找下一个可以使用的咒语的索引
        // 需要跳过所有伤害值 <= curPower + 2 的咒语
        int next_i = i + 1;
        while (next_i < n && sortedPowers[next_i] <= curPower + 2) {
            next_i++;
        }

        // 递归到下一个合法位置，并加上当前获得的伤害
        long resTake = damageTake + dfs(next_i);
        
        // 两种决策中的最大值存入记忆化数组并返回
        memo[i] = Math.max(resSkip, resTake);
        return memo[i];
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数只有一个，状态个数等于 $O(n)$，因为已采用哈希优化，指针 $j$ 最多搜索两次，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n)$。

- 时间复杂度： $O(nlogU+U)$，其中 $n$ 为数组 $power$ 的长度，而 $U$ 是数组中不重复的元素个数，前者是排序花费时间。由于 $n,U$ 相近，后续都将两者看作相同
- 空间复杂度： $O(U)$，表示哈希表 $counts$，记忆化数组 $memo$，数组 $sortPowers$，递归栈的开销

---

### $DP$

将递归 $1:1$ 转化为递推。

同理，**定义** $dp[i]$ 表示从第 $i$ 个咒语开始，最终所能获得的最大累加和。

同理递推，得到 **状态转移方程**：

$$
dp[i] = \max\left(dp[i+1],dp[j]\right)
$$

**方向**：从大到小枚举！因为 $dp[i]$ 的值需要状态 $dp[i+1]$ 的值，必须先算出后者！

逻辑保持不变，递推边界等其他细节与递归几乎相同，这里不再阐述。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        # 统计每个伤害值的总伤害，并排序
        counts = Counter(power)
        sorted_powers = sorted(counts.keys())
        n = len(sorted_powers)

        # dp[i] 表示从 sorted_powers[i] 到结尾的咒语所能获得的最大伤害
        dp = [0] * (n + 1)
        
        # 倒序
        for i in range(n - 1, -1, -1):
            cur_power = sorted_powers[i]
            
            # 不选择当前咒语
            res_skip = dp[i + 1]
            # 选择当前咒语
            damage_take = cur_power * counts[cur_power]
            
            # 找到下一个可以选择的咒语的索引 next_i
            next_i = i + 1
            while next_i < n and sorted_powers[next_i] <= cur_power + 2:
                next_i += 1
            # 与 next_i 开始的最大伤害相加
            res_take = damage_take + dp[next_i]
            # 两种决策中的最大值
            dp[i] = max(res_skip, res_take)
            
        return dp[0]
```

```Java
// java
class Solution {
    public long maximumTotalDamage(int[] power) {
        // 统计每个伤害值的总伤害，并排序
        Map<Integer, Integer> counts = new TreeMap<>();
        for (int p : power) {
            counts.put(p, counts.getOrDefault(p, 0) + 1);
        }

        // 将排序后的唯一伤害值存入数组
        int n = counts.size();
        int[] sortedPowers = new int[n];
        int index = 0;
        for (int p : counts.keySet()) {
            sortedPowers[index++] = p;
        }

        // dp[i] 表示从 sorted_powers[i] 到结尾的咒语所能获得的最大伤害
        long[] dp = new long[n + 1];
        
        // 倒序遍历，从后向前计算 dp 值
        for (int i = n - 1; i >= 0; i--) {
            int curPower = sortedPowers[i];
            
            // 不选择当前咒语
            long resSkip = dp[i + 1];
            
            // 选择当前咒语
            long damageTake = (long) curPower * counts.get(curPower);
            
            // 找到下一个可以选择的咒语的索引 next_i
            // 需要跳过所有伤害值 <= cur_power + 2 的咒语
            int next_i = i + 1;
            while (next_i < n && sortedPowers[next_i] <= curPower + 2) {
                next_i++;
            }
            
            // 与 next_i 开始的最大伤害相加
            long resTake = damageTake + dp[next_i];
            
            // 两种决策中的最大值
            dp[i] = Math.max(resSkip, resTake);
        }
        
        return dp[0];
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(n)$

注意，强烈不推荐将寻找 $j$ 的部分换成 **二分**！也就是下面代码的形式：

```Python
# python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        # 统计每个伤害值的总伤害，并排序
        counts = Counter(power)
        sorted_powers = sorted(counts.keys())
        n = len(sorted_powers)

        # dp[i] 表示从 sorted_powers[i] 到结尾的咒语所能获得的最大伤害
        dp = [0] * (n + 1)
        
        # 倒序
        for i in range(n - 1, -1, -1):
            cur_power = sorted_powers[i]
            
            # 不选择当前咒语
            res_skip = dp[i + 1]
            # 选择当前咒语
            damage_take = cur_power * counts[cur_power]
            
            # 二分查找开始
            # 找到第一个 > cur_power + 2 的元素索引
            target = cur_power + 2
            
            # 左右边界
            left, right = i + 1, n - 1
            next_i = n 
            
            while left <= right:
                mid = left + (right - left) // 2
                
                if sorted_powers[mid] > target:
                    # 这个是可能答案，并尝试在左半部分寻找更早的位置
                    next_i = mid
                    right = mid - 1
                else:
                    # 肯定不是答案，需要在右半部分继续查找
                    left = mid + 1
            
            # 与 next_i 开始的最大伤害相加
            res_take = damage_take + dp[next_i]
            # 两种决策中的最大值
            dp[i] = max(res_skip, res_take)
            
        return dp[0]
```

实际运行效率大大降低，从 $413ms$ 跳到 $1434ms$。这是因为，原本已经采用了哈希优化，再使用二分，会将寻找的时间从 $O(1)$ 提高至 $O(logn)$。

---

### 正向 $DP$

能不能正向进行递推呢？当然可以，只不过需要修改 $dp$ 的定义。

**定义** $dp[i]$ 表示前 $i$ 种咒语所能获得的最大伤害。

注意，这里是前 $i$ 种，也就是 $max$ 的含义。那么，就不用再浪费一个 $for$ 循环查找。

在循环内部，派出 $j$ 指针，它会搜索 **第一个** 伤害值不小于 `powers[i] - 2` 的咒语的索引。也即，所有在 $j$ 之前的咒语 $[0,i]$ 能获得的最大伤害存储在 $dp[j]$ 中！

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        # 统计每个伤害值的总伤害，并排序
        counts = Counter(power)
        sorted_powers = sorted(counts.keys())
        n = len(sorted_powers)

        # dp[i] 表示 前 i 种咒语所能获得的最大伤害
        dp = [0] * (n + 1)
        # j 指针表示第一个伤害值不小于 cur_power - 2 的咒语的索引
        j = 0
        
        # 正向
        for i in range(1, n + 1):
            cur_power = sorted_powers[i-1]
            
            # 不选择当前咒语
            res_skip = dp[i-1]
            # 选择当前咒语
            cur_damage = cur_power * counts[cur_power]
            
            # 找到上一个可以兼容的咒语
            while j < i - 1 and sorted_powers[j] < cur_power - 2:
                j += 1
            
            # 此时，所有在 j 之前的咒语能获得的最大伤害存储在 dp[j] 中
            prev_damage = dp[j]
            res_take = cur_damage + prev_damage

            # 两种决策中的最大值
            dp[i] = max(res_skip, res_take)
            
        return dp[n]
```

```Java
// java
class Solution {
    public long maximumTotalDamage(int[] power) {
        // 统计每个伤害值的总伤害，并自动排序
        Map<Integer, Integer> counts = new TreeMap<>();
        for (int p : power) {
            counts.put(p, counts.getOrDefault(p, 0) + 1);
        }

        // 将排序后的唯一伤害值存入数组
        int n = counts.size();
        int[] sortedPowers = new int[n];
        int index = 0;
        for (int p : counts.keySet()) {
            sortedPowers[index++] = p;
        }

        // dp[i] 表示前 i 种咒语所能获得的最大伤害
        long[] dp = new long[n + 1];
        
        // j 指针表示第一个伤害值不小于 cur_power - 2 的咒语的索引
        int j = 0;
        
        // 正向
        for (int i = 1; i <= n; i++) {
            int curPower = sortedPowers[i-1];
            
            // 不选择当前咒语
            // 如果不选，最大伤害等于考虑前 i-1 种咒语时的最大伤害
            long resSkip = dp[i-1];
            
            // 选择当前咒语
            long curDamage = (long) curPower * counts.get(curPower);
            
            // 找到上一个可以兼容的咒语
            while (j < i - 1 && sortedPowers[j] < curPower - 2) {
                j++;
            }
            
            // 此时，所有在 j 之前的咒语都与 cur_power 兼容
            // 能获得的最大伤害存储在 dp[j] 中
            long prevDamage = dp[j];
            long resTake = curDamage + prevDamage;

            // 两种决策中的最大值
            dp[i] = Math.max(resSkip, resTake);
        }
        
        return dp[n];
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(n)$

---

### 空间优化

如果不想使用哈希进行预处理，而是直接对 $power$ 排序，那么就需要将重复的咒语化作一组，统一进行累加计算。

仔细观察 $DP$ 代码，其实只涉及 $3$ 个变量：前 $x-2$、前 $x-1$、前 $x$ 为止的最值。

因此，只需要定义大小为 $3$ 的动规数组，包含上述三个变量，然后 **滚动更新** 即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        power.sort()
        
        # dp[0]: 包含到 prev_power-2 的最大伤害
        # dp[1]: 包含到 prev_power-1 的最大伤害
        # dp[2]: 包含 prev_power 的最大伤害
        dp = [0, 0, 0]
        
        # 上一个处理过的独特伤害值
        prev_power = -3 

        i = 0
        while i < len(power):
            cur_power = power[i]
            
            # 重复的 cur_power 咒语看作一组
            group_damage = 0
            group_end_idx = i
            while group_end_idx < len(power) and power[group_end_idx] == cur_power:
                group_damage += cur_power
                group_end_idx += 1

            power_diff = cur_power - prev_power

            # 保存旧的DP状态，因为更新是相互依赖的
            prev_minus2 = dp[0]
            prev_minus1 = dp[1]
            prev_damage = dp[2]
            
            # 获取到上一个状态为止的总最大伤害
            max_prev = max(prev_damage, prev_minus1)

            if power_diff == 1:
                # 当前是 prev_power + 1，选择它就不能选 prev_power 和 prev_power-1
                # 新的 dp[2] = 之前到 prev_power-2 的最大伤害 + 当前组伤害
                dp[2] = prev_minus2 + group_damage
                # 新的 dp[1] = 之前到 prev_power 的最大伤害
                dp[1] = max_prev
                # 新的 dp[0] = 之前到 prev_power-1 的最大伤害
                dp[0] = prev_minus1

            elif power_diff == 2:
                # 当前是 prev_power + 2，选择它就不能选 prev_power+1 和 prev_power
                # 新的 dp[2] = 之前到 prev_power-1 的最大伤害 + 当前组伤害
                dp[2] = prev_minus1 + group_damage
                # 新的 dp[1] = 之前到 prev_power 的最大伤害
                dp[1] = max_prev
                # 新的 dp[0] = 之前到 prev_power 的最大伤害
                dp[0] = max_prev
            
            else: # power_diff > 2 或者一个新的开始
                # 差值很大，选择 cur_power 与之前的选择不冲突
                # 新的 dp[2] = 之前所有情况的最大伤害 + 当前组伤害
                dp[2] = max_prev + group_damage
                # 新的 dp[1] 和 dp[0] 都更新为之前所有情况的最大伤害
                dp[1] = max_prev
                dp[0] = max_prev
            
            # 更新 prev_power 并移动到下一个独特的伤害值
            prev_power = cur_power
            i = group_end_idx
            
        # 所有状态中的最大值
        return max(dp)
```

```Java
// java
class Solution {
    public long maximumTotalDamage(int[] power) {
        // 对 power 数组进行排序
        Arrays.sort(power);
        
        // dp[0]: 包含到 prev_power-2 的最大伤害
        // dp[1]: 包含到 prev_power-1 的最大伤害
        // dp[2]: 包含到 prev_power 的最大伤害
        long[] dp = new long[3];
        
        // 上一个处理过的独特伤害值
        int prev_power = -3; 

        int i = 0;
        while (i < power.length) {
            int cur_power = power[i];
            
            // 将重复的 cur_power 咒语看作一组，并计算其总伤害
            long group_damage = 0;
            int group_end_idx = i;
            while (group_end_idx < power.length && power[group_end_idx] == cur_power) {
                group_damage += cur_power;
                group_end_idx++;
            }

            int power_diff = cur_power - prev_power;

            // 保存旧的DP状态，因为更新是相互依赖的
            long prev_minus2 = dp[0];
            long prev_minus1 = dp[1];
            long prev_damage = dp[2];
            
            // 获取到上一个状态为止的总最大伤害
            long max_prev = Math.max(prev_damage, prev_minus1);

            if (power_diff == 1) {
                // 当前是 prev_power + 1，选择它就不能选 prev_power 和 prev_power-1
                // 新的 dp[2] = 之前到 prev_power-2 的最大伤害 + 当前组伤害
                dp[2] = prev_minus2 + group_damage;
                // 新的 dp[1] = 之前到 prev_power 的最大伤害
                dp[1] = max_prev;
                // 新的 dp[0] = 之前到 prev_power-1 的最大伤害
                dp[0] = prev_minus1;

            } else if (power_diff == 2) {
                // 当前是 prev_power + 2，选择它就不能选 prev_power+1 和 prev_power
                // 新的 dp[2] = 之前到 prev_power-1 的最大伤害 + 当前组伤害
                dp[2] = prev_minus1 + group_damage;
                // 新的 dp[1] = 之前到 prev_power 的最大伤害
                dp[1] = max_prev;
                // 新的 dp[0] = 之前到 prev_power 的最大伤害
                dp[0] = max_prev;
            
            } else { // power_diff > 2 或者这是一个新的开始
                // 差值很大，选择 cur_power 与之前的选择不冲突
                // 新的 dp[2] = 之前所有情况的最大伤害 + 当前组伤害
                dp[2] = max_prev + group_damage;
                // 新的 dp[1] 和 dp[0] 都更新为之前所有情况的最大伤害
                dp[1] = max_prev;
                dp[0] = max_prev;
            }
            
            // 更新 prev_power 并移动到下一个独特的伤害值
            prev_power = cur_power;
            i = group_end_idx;
        }
            
        // 最终结果是所有状态中的最大值
        return Math.max(dp[0], Math.max(dp[1], dp[2]));
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 的栈开销

实际测试下来，“反向 $DP$” 的速度最快，其次是 “空间优化 $DP$”。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/3803188/cong-ling-tui-dao-ji-yi-hua-dfs-zheng-fa-zo21/)
