[Problem: 2598. 执行操作后的最大 MEX](https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/description/)

### 方法：哈希 & 优化

从 $0$ 开始递增 $x$，判断数组中是否含有这个 $x$，**第一个** 不在数组中的 $x$ 就叫做 $MEX$。

注意，不限操作次数，所以每个元素可以 “加减” $value$ 任意次数。那么，元素 $nums[i]$ 到底会变成什么？应该怎么找答案？

找规律：假设当前元素 $x=3$，而 $value=5$：

- 加一次 $5$，则 $3+5=8$，有 `8 % 5 = 3`；
- 加两次 $5$，则 $8+5=13$，有 `13 % 5 = 3`；
- $\dots$
- 加 $t$ 次 $5$，则有 `(3 + 5t) % 5 = 3`。

它们除以 $value$ 的 **余数** 是完全相同的。也即，一个数字 $x$ 只能被转换成，与它对 $value$ **同余** 的任何其他数字，永远无法变成一个余数不同的数。

这时候，我们思考从 $0$ 递增，去寻找 $MEX$：

- 为了凑出 $0$：我们必须找到数组 $nums$ 中一个原始的数字 $x$，并且这个 $x$ 可以被变成 $0$。也即 `x % value == 0 % value`，也就是 `x % value == 0`；
- 为了凑出 $1$：我们必须用掉 $nums$ 中一个原始数字 $y$，使得 `y % value == 1 % value`，也就是 `y % value == 1`；
- $\dots$
- 为了凑出 $m$：我们必须用掉 $nums$ 中一个原始数字 $z$，使得 `z % value == m % value`。

这样一来，问题就清晰了。将取余结果看作 “仓库”，数组 $nums$ 的元素看作 “原材料”。

原始数组 $nums$ 中的每一个数字，根据它对 $value$ 取模的余数，被划分到了不同的 “仓库” 里。要生产 $m$，需要从 `m % value` 号仓库取一个 “原材料”。

**做法**：使用哈希表统计 $nums$ 中每个元素模 $value$ 的余数的 **出现次数**，然后从小到大尝试构造 $0,1,2,\dots$，直到某个数无法被构造出来为止。

注意， $MEX$ 一定是非负数，所以要先将负数变为正数！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        # 使用哈希表统计 nums 中每个元素模 value 后的余数频率
        # 注意，负数取模结果为正，例如 -1 % 3 = 2
        counts = Counter(x % value for x in nums)
        
        mex = 0
        # 贪心尝试从小到大构造非负整数 0, 1, 2, ...
        while True:
            # 需要的余数是 rem
            rem = mex % value
            
            # 如果哈希表中还有该余数可用
            if counts[rem] > 0:
                counts[rem] -= 1  # 消耗
                mex += 1          # 尝试下一个数
            else:
                # 无法找到
                break
                
        return mex
```

```Java
// java
class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        // 使用哈希表统计 nums 中每个元素模 value 后的余数频率
        Map<Integer, Integer> counts = new HashMap<>();
        for (int x : nums) {
            // 负数取模会得到负余数，例如 -1 % 3 = -1
            // 使用先 %value 再 +value 的技巧
            int remainder = ((x % value) + value) % value;
            counts.put(remainder, counts.getOrDefault(remainder, 0) + 1);
        }

        int mex = 0;
        // 贪心尝试从小到大构造非负整数 0, 1, 2, ...
        while (true) {
            // 需要的余数是 rem
            int rem = mex % value;

            // 如果哈希表中还有该余数可用
            if (counts.getOrDefault(rem, 0) > 0) {
                // 消耗
                counts.put(rem, counts.get(rem) - 1);
                // 尝试下一个数
                mex++;
            } else {
                // 无法找到
                break;
            }
        }

        return mex;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，统计哈希后，最多构造 $n$ 个数字，内部计算都是 $O(1)$
- 空间复杂度： $O(min(n,value))$，哈希表中最多只会有 $value$ 个不同的键

---

### 优化

从 $0\to +\infty$ 一步步向上走有点慢，如何解决？找出构造过程中的 **瓶颈**！

统计哈希后，我们会轮流从余数为 $0, 1, 2, \dots$ 的组中取出数字。哪一组的数字 **最少**，它就会最先被用完，成为构造过程的瓶颈。

假设出现次数最少的余数是 $r$，它出现了 $k$ 次。这意味着我们可以完成 $k$ 轮完整的构造，即对于每个余数 $i\in [0,value-1]$，我们都能成功构造出

$$
i, i + value, ..., i + (k-1)*value
$$

因此，所有从 $0$ 到 $k\times value - 1$ 的数字都可以被构造出来。

接下来，我们开始第 $k+1$ 轮构造。当需要构造 $k\times value + r$ 时，我们发现余数为 $r$ 的那一组数字已经用完了。所以，第一个无法被构造的数就是 $k\times value + r$，这便是最大的 $MEX$。

**流程**：统计哈希后，遍历哈希所有的键，找出最小的出现次数以及对应的键。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        # 使用哈希数组统计
        cnts = [0] * value
        for x in nums:
            cnts[x % value] += 1
        
        min_freq = float('inf')  # 最少出现次数
        min_rem = -1  # 出现次数最少的余数
        
        for i, count in enumerate(cnts):
            if count < min_freq:
                min_freq = count
                min_rem = i
        
        # 完整轮数 * value + 瓶颈余数
        return min_freq * value + min_rem
```

```Java
// java
class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        // 数组哈希
        int[] cnts = new int[value];
        for (int x : nums) {
            // 负数取模会得到负余数，例如 -1 % 3 = -1
            // 使用先 %value 再 +value 的技巧
            int remainder = ((x % value) + value) % value;
            cnts[remainder]++;
        }

        int minFreq = Integer.MAX_VALUE; // 最少出现次数
        int minRem = -1;  // 出现次数最少的余数

        for (int i = 0; i < value; i++) {
            if (cnts[i] < minFreq) {
                minFreq = cnts[i];
                minRem = i;
            }
        }

        // 完整轮数 * value + 瓶颈余数
        return minFreq * value + minRem;
    }
}
```

- 时间复杂度： $O(n+value)$，两次遍历
- 空间复杂度： $O(value)$，表示数组 $cnts$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/solutions/3807805/tong-yu-xun-zhao-gui-lu-ha-xi-mo-ni-shu-8gkru/)
