[Problem: 3433. 统计用户被提及情况](https://leetcode.cn/problems/count-mentions-per-user/description/)

### 方法：排序

最大大大难点：读懂题意。

想象有一个广告推销，他想给不同用户发短信。如果是 $MESSAGE$ 类型，他会在 $timestamp$ 时间给以下三种用户群之一，**发一次消息**：

- 指定用户，比如 $id0,id1\dots$；
- 所有用户 $ALL$，不管在线与否；
- 所有在线用户 $HERE$，必须在线。

用户会选择 **手动离线**，避免被消息轰炸。如果是 $OFFLINE$ 类型，用户 $x$ 在 $timestamp$ 离线 $60$ 秒，并在 $60$ 秒后重新上线。

最终，我们需要统计每个用户收到短信的次数。

这个题目的坑非常多，一定要仔细。什么叫做 “状态变更” 在 “消息” 之前？如果用户在第 $61$ 秒离线，推销同样选择在第 $61$ 秒给在线用户发短信，则该用户收不到。同理，如果 $1$ 秒离线 $61$ 秒立刻上线，则正好该用户能收到短信。

如果用户在第 $x$ 秒处于离线状态，但是推销选择 **指定他** 发送，照样能收到短信！

注意，发消息的时候用户是 $id0,id1,id0$ 的字符串格式，且此时推销可以重复给一个用户发多次。而用户手动离线时，是 $0$ 或者 $x$ 的数字格式。

读到这，想必大家已经发现，本题的重点是 **时间**！如果推销给所有在线用户发消息，某个用户离线，则接收不到。因此，我们应该按照时间 **从前往后** 的顺序处理。

怎么知道用户是否在线？使用一个数组 $online$，其中 $online[i]$ 表示用户 $i$ 下一次恢复上线的时间。初始时值为 $0$，之后则是离线时间 $+60$。

而在同一时刻，“状态变更” 优先于 “事件”，因此 $OFFLINE$ 的优先级高于 $MESSAGE$。

**核心**：将事件变为 `(timestamp, priority, type, mentions)` 类型。首先按照时间戳升序，相同时按照优先级升序。对排序后的数组，从前往后模拟即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:
        # 将事件转换为 (timestamp, priority, type, mentions)
        parsed_events = []
        for e in events:
            event_type, ts, mentions = e
            timestamp = int(ts)
            priority = 0 if event_type == "OFFLINE" else 1
            parsed_events.append((timestamp, priority, event_type, mentions))
        
        # 按时间戳升序排序，时间相同时按优先级排序
        parsed_events.sort()

        res = [0] * numberOfUsers
        # 记录每个用户恢复在线的时间点
        online_time = [0] * numberOfUsers
        
        # 模拟
        for ts, _, event_type, data in parsed_events:
            if event_type == "OFFLINE":
                user_id = int(data)
                # 60 秒后上线
                online_time[user_id] = ts + 60
            
            elif event_type == "MESSAGE":
                if data == "ALL":
                    # 所有用户
                    for i in range(numberOfUsers):
                        res[i] += 1
                        
                elif data == "HERE":
                    # 所有在线用户
                    for i in range(numberOfUsers):
                        if online_time[i] <= ts:
                            res[i] += 1
                            
                else:
                    # 按空格分割并处理每个 id
                    ids = data.split(" ")
                    for token in ids:
                        user_id = int(token[2:])
                        res[user_id] += 1
        
        return res
```

```Java
// java
class Solution {
    private static class Event implements Comparable<Event> {
        int timestamp;
        int priority;
        String type;
        String data;

        Event(int timestamp, int priority, String type, String data) {
            this.timestamp = timestamp;
            this.priority = priority;
            this.type = type;
            this.data = data;
        }

        // 按时间戳升序排序，时间相同时按优先级排序
        @Override
        public int compareTo(Event other) {
            if (this.timestamp != other.timestamp) {
                return Integer.compare(this.timestamp, other.timestamp);
            }
            return Integer.compare(this.priority, other.priority);
        }
    }

    public int[] countMentions(int numberOfUsers, List<List<String>> events) {
        // 将事件转换为 (timestamp, priority, type, mentions)
        List<Event> parsedEvents = new ArrayList<>();
        for (List<String> e : events) {
            String eventType = e.get(0);
            int ts = Integer.parseInt(e.get(1));
            String mentions = e.get(2);
            int timestamp = ts;
            int priority = eventType.equals("OFFLINE") ? 0 : 1;
            parsedEvents.add(new Event(timestamp, priority, eventType, mentions));
        }
        
        Collections.sort(parsedEvents);
        int[] res = new int[numberOfUsers];
        // 记录每个用户恢复在线的时间点
        int[] onlineTime = new int[numberOfUsers];

        // 模拟
        for (Event event : parsedEvents) {
            int ts = event.timestamp;
            String eventType = event.type;
            String data = event.data;

            if (eventType.equals("OFFLINE")) {
                int userId = Integer.parseInt(data);
                // 60 秒后上线
                onlineTime[userId] = ts + 60;

            } else if (eventType.equals("MESSAGE")) {
                if (data.equals("ALL")) {
                    // 所有用户
                    for (int i = 0; i < numberOfUsers; i++) {
                        res[i]++;
                    }

                } else if (data.equals("HERE")) {
                    // 所有在线用户
                    for (int i = 0; i < numberOfUsers; i++) {
                        if (onlineTime[i] <= ts) {
                            res[i]++;
                        }
                    }

                } else {
                    // 按空格分割并处理每个 id
                    String[] ids = data.split(" ");
                    for (String token : ids) {
                        int userId = Integer.parseInt(token.substring(2));
                        res[userId]++;
                    }
                }
            }
        }

        return res;
    }
}
```

- 时间复杂度： $O(nm+mlogmlogt)$，其中 $n$ 是用户数，而 $m$ 是数组 $events$ 的长度 $t$ 是时间戳大小，快排；一共 $m$ 个事件，每个事件处理时间为 $O(n)$
- 空间复杂度： $O(m+n)$，表示列表 $parse$ 以及数组 $online$ 的大小，返回值 $res$ 一般不计入复杂度，排序的栈开销为 $O(logmlogt)$

---

### 原地

实际上，没必要创建 $parse$ 列表去存储新定义的结构，直接在 $events$ 上原地排序即可。先比较时间戳是 $int$ 类型，然后比较优先级是 $bool$ 类型。

整体逻辑不变，代码如下：

```Python
# python
class Solution:
    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:
        res = [0] * numberOfUsers
        # 记录用户 i 恢复上线的时间戳
        online_time = [0] * numberOfUsers
        # 按时间戳升序，时间相同时按优先级排序
        events.sort(key=lambda e: (int(e[1]), e[0] == "MESSAGE"))

        # 模拟
        for event_type, ts, content in events:
            cur_time = int(ts)

            if event_type == "MESSAGE":
                if content == "ALL":
                    # 所有用户
                    for i in range(numberOfUsers):
                        res[i] += 1

                elif content == "HERE":
                    # 所有在线用户
                    for i, t in enumerate(online_time):
                        if t <= cur_time:
                            res[i] += 1

                else:
                    # 按空格分割并处理每个 id
                    for token in content.split():
                        user_id = int(token[2:])
                        res[user_id] += 1

            else:
                # 60 秒后上线
                user_id = int(content)
                online_time[user_id] = cur_time + 60
        
        return res
```

```Java
// java
class Solution {
    public int[] countMentions(int numberOfUsers, List<List<String>> events) {
        int[] res = new int[numberOfUsers];
        // 记录用户 i 恢复上线的时间戳
        int[] onlineTime = new int[numberOfUsers];
        
        // 按时间戳升序，时间相同时按优先级排序
        Collections.sort(events, (a, b) -> {
            int timeA = Integer.parseInt(a.get(1));
            int timeB = Integer.parseInt(b.get(1));
            if (timeA != timeB) {
                return Integer.compare(timeA, timeB);
            }
            // MESSAGE == "MESSAGE" -> true (1), OFFLINE == "MESSAGE" -> false (0)
            // 升序排列：0 在前 (OFFLINE), 1 在后 (MESSAGE)
            int priorityA = a.get(0).equals("MESSAGE") ? 1 : 0;
            int priorityB = b.get(0).equals("MESSAGE") ? 1 : 0;
            return Integer.compare(priorityA, priorityB);
        });

        // 模拟
        for (List<String> event : events) {
            String eventType = event.get(0);
            int curTime = Integer.parseInt(event.get(1));
            String content = event.get(2);

            if (eventType.equals("MESSAGE")) {
                if (content.equals("ALL")) {
                    // 所有用户
                    for (int i = 0; i < numberOfUsers; i++) {
                        res[i]++;
                    }

                } else if (content.equals("HERE")) {
                    // 所有在线用户
                    for (int i = 0; i < numberOfUsers; i++) {
                        if (onlineTime[i] <= curTime) {
                            res[i]++;
                        }
                    }

                } else {
                    // 按空格分割并处理每个 id
                    String[] tokens = content.split(" ");
                    for (String token : tokens) {
                        int userId = Integer.parseInt(token.substring(2));
                        res[userId]++;
                    }
                }

            } else {
                // 60 秒后上线
                int userId = Integer.parseInt(content);
                onlineTime[userId] = curTime + 60;
            }
        }

        return res;
    }
}
```

- 时间复杂度： $O(nm+mlogmlogt)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-mentions-per-user/solutions/3855304/shuang-jie-ren-hua-jie-du-ti-yi-tui-dao-yvvmx/)
