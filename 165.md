[Problem: 165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/description/)

### 方法：调库 & 双指针

试问， $9.9$ 和 $9.11$ 谁更大？没错，在当前场景下， $9.9$ 更大，比较的是版本好，而不是单纯的数字，比如 $version 3.1.4$ 与 $version 3.1.11$。

**总结**：根据小数点 `.` 进行分割，然后比较每个部分的数字大小。

直接调库，代码如下，已附加注释：

```Python
# python
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        # 按 '.' 分割版本号
        levels1 = version1.split('.')
        levels2 = version2.split('.')
        length = max(len(levels1), len(levels2))
        
        # 从左到右逐个比较修订号
        for i in range(length):
            # 将缺失的修订号视为 0
            v1 = int(levels1[i]) if i < len(levels1) else 0
            v2 = int(levels2[i]) if i < len(levels2) else 0
            
            if v1 < v2: return -1
            if v1 > v2: return 1
            
        # 走到这，说明版本号相等
        return 0
```

```Java
// java
class Solution {
    public int compareVersion(String version1, String version2) {
        // 按 '.' 分割版本号
        String[] levels1 = version1.split("\\.");
        String[] levels2 = version2.split("\\.");
        int length = Math.max(levels1.length, levels2.length);

        // 从左到右逐个比较修订号
        for (int i = 0; i < length; i++) {
            // 将缺失的修订号视为 0
            int v1 = i < levels1.length ? Integer.parseInt(levels1[i]) : 0;
            int v2 = i < levels2.length ? Integer.parseInt(levels2[i]) : 0;

            if (v1 < v2) {
                return -1;
            }
            if (v1 > v2) {
                return 1;
            }
        }

        // 走到这，说明版本号相等
        return 0;
    }
}
```

- 时间复杂度： $O(n+m)$，其中 $n,m$ 分别为串 $version1,version2$ 的长度
- 空间复杂度： $O(n+m)$，表示数组 $levels1,levels2$ 的大小

---

### 双指针

上面的代码速度偏慢，而且没有什么技术含量。这里我们可以使用指针 $i,j$ 指向两个串，然后分别进行计数，最后比较。

**思路**：将小数点 `.` 当作障碍物，每段都用一个指针进行遍历，得出当前段的对应数字。

如何计算？根据数学知识可知， $156=15\times 10+6$，只要不断乘 $10$ 并末尾累加，就能得到真实数字。

代码如下，已附加注释：

```Python
# python
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        i, j = 0, 0
        while i < len(version1) or j < len(version2):
            # 找到 version1 中下一个数字
            num1 = 0
            while i < len(version1) and version1[i] != '.':
                num1 = num1 * 10 + int(version1[i])
                i += 1
            i += 1  # 跳过点号
            
            # 找到 version2 中下一个数字
            num2 = 0
            while j < len(version2) and version2[j] != '.':
                num2 = num2 * 10 + int(version2[j])
                j += 1
            j += 1  # 跳过点号
            
            if num1 != num2:
                return 1 if num1 > num2 else -1
        
        return 0
```

```Java
// java
class Solution {
    public int compareVersion(String version1, String version2) {
        int i = 0, j = 0;
        while (i < version1.length() || j < version2.length()) {
            // 找到 version1 中下一个数字
            int num1 = 0;
            while (i < version1.length() && version1.charAt(i) != '.') {
                num1 = num1 * 10 + (version1.charAt(i) - '0');
                i++;
            }
            i++;  // 跳过点号
            
            // 找到 version2 中下一个数字
            int num2 = 0;
            while (j < version2.length() && version2.charAt(j) != '.') {
                num2 = num2 * 10 + (version2.charAt(j) - '0');
                j++;
            }
            j++;  // 跳过点号
            
            if (num1 != num2) {
                return num1 > num2 ? 1 : -1;
            }
        }
        
        return 0;
    }
}
```

- 时间复杂度： $O(n+m)$，每个指针各自移动一遍
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/compare-version-numbers/solutions/3789787/shuang-jie-diao-ku-fen-ge-shuang-zhi-zhe-jtnq/)
