[Problem: 1970. 你能穿过矩阵的最后一天](https://leetcode.cn/problems/last-day-where-you-can-still-cross/description/)

### 方法：二分 & 并查集 & 对偶

原本全是陆地，逐渐增加水域，从某一天开始，不能从第一行出发，走到最后一行。

- 如果在第 $i$ 天可以从最上面走到最下面，那么在第 $i-1$ 天（水更少，陆地更多）一定也可以。
- 如果在第 $i$ 天无法通过，那么在第 $i+1$ 天（水更多）也一定无法通过。

天数越大，越可能无法通过，这种 **单调性** 决定了我们可以对 “天数” 进行 **二分**。

怎么判断第 $day$ 天，是否能从最上走到最下？

首先，由于已经过去了 $day$ 天。准备一个网格 $grid$，标记 $cells$ 前 $day$ 个的位置为水域 $1$，其余为陆地 $0$。

然后，**定义** $dfs(r,c)$ 表示从 $(r,c)$ 开始搜索，能否到达最后一行。

- 从第一行的所有陆地格子出发。
- 向上下左右四个方向探索。
- 某条路径能到达最后一行，说明该天数可行，返回 $True$。
- 所有路径都不行，说明该天数不行，返回 $False$。

为了防止重复访问，递归过程中需要使用 $visited$ 数组。不过由于 $grid$ 只会使用一次，直接原地修改 $grid$ 值，访问过就标记为水域 $1$，这样就不会再次遍历。

在二分过程中，下界是第 $0$ 天，有 $left = 0$；上界是所有水域都出现，有 $right = len(cells)$。

- 如果 $mid$ 天可行，说明答案可能是 $mid$ 或更大，记录 $mid$ 并尝试右半部分。
- 如果 $mid$ 天不可行，说明水太多了，需要在左半部分找。

这里使用最容易理解的 **闭区间二分**，其他 $DFS$ 细节不再阐述。

代码如下，已附加注释：

```Python
# python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        left, right = 0, len(cells)
        DIRS = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        ans = 0
        
        # 判断在第 day 天是否能从顶到底
        def check(day):
            grid = [[0] * col for _ in range(row)]
            for i in range(day):
                r, c = cells[i]
                # 下标从 1 开始
                grid[r-1][c-1] = 1
            
            # 从 (r,c) 开始向下
            def dfs(r, c):
                # 到达最后一行
                if r == row - 1:
                    return True
                
                # 标记当前格已访问
                grid[r][c] = 1
                
                # 遍历四个方向
                for dr, dc in DIRS:
                    nr, nc = r + dr, c + dc
                    # 检查边界及是否为陆地
                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:
                        if dfs(nr, nc):
                            return True
                return False

            # 第一行的每一个陆地格子出发
            for c in range(col):
                if grid[0][c] == 0:
                    if dfs(0, c):
                        return True
            
            return False
        
        # 二分
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid        # 可行，尝试更大天数
                left = mid + 1
            else:
                right = mid - 1  # 不可行，减少天数
        
        return ans
```

```Java
// java
class Solution {
    private int[][] DIRS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int latestDayToCross(int row, int col, int[][] cells) {
        int left = 0, right = cells.length;
        int ans = 0;

        // 二分
        while (left <= right) {
            int mid = (left + right) / 2;
            if (check(mid, row, col, cells)) {
                ans = mid;        // 可行，尝试更大天数
                left = mid + 1;
            } else {
                right = mid - 1;  // 不可行，减少天数
            }
        }

        return ans;
    }

    // 判断在第 day 天是否能从顶到底
    private boolean check(int day, int row, int col, int[][] cells) {
        int[][] grid = new int[row][col];
        for (int i = 0; i < day; i++) {
            int r = cells[i][0];
            int c = cells[i][1];
            // 下标从 1 开始
            grid[r - 1][c - 1] = 1;
        }

        // 第一行的每一个陆地格子出发
        for (int c = 0; c < col; c++) {
            if (grid[0][c] == 0) {
                if (dfs(0, c, row, col, grid)) {
                    return true;
                }
            }
        }

        return false;
    }

    // 从 (r,c) 开始向下
    private boolean dfs(int r, int c, int row, int col, int[][] grid) {
        // 到达最后一行
        if (r == row - 1) {
            return true;
        }

        // 标记当前格已访问
        grid[r][c] = 1;

        // 遍历四个方向
        for (int[] dir : DIRS) {
            int nr = r + dir[0];
            int nc = c + dir[1];
            // 检查边界及是否为陆地
            if (nr >= 0 && nr < row && nc >= 0 && nc < col && grid[nr][nc] == 0) {
                if (dfs(nr, nc, row, col, grid)) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

- 时间复杂度： $O(rc\times logn)$，其中 $r,c$ 为矩阵的行数/列数，而 $n$ 为数组 $cells$ 的长度，且题目指定 $n=rc$，数量级为 $O(10^4)$
- 空间复杂度： $O(rc)$，表示中途创建 $grid$ 的大小，以及递归深度

---

### $BFS$

将递归改为递推。

- 第一行所有陆地格子的坐标加入队列，并标记为已访问。
- 不断从队列取出坐标，向四周扩散。
- 一旦扩散到最后一行，立即返回 $True$。
- 如果队列空了仍未到达最后一行，返回 $False$。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        left, right = 0, len(cells)
        DIRS = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        ans = 0
        
        # 判断在第 day 天是否能从顶到底
        def check(day):
            grid = [[0] * col for _ in range(row)]
            for i in range(day):
                r, c = cells[i]
                grid[r-1][c-1] = 1
            
            queue = deque()
            # 将第一行所有是陆地的点加入队列
            for c in range(col):
                if grid[0][c] == 0:
                    queue.append((0, c))
                    grid[0][c] = 1  # 标记为已访问
            
            # 开始 BFS
            while queue:
                r, c = queue.popleft()
                # 如果到达最后一行，说明通路存在
                if r == row - 1:
                    return True
                
                # 向四个方向扩散
                for dr, dc in DIRS:
                    nr, nc = r + dr, c + dc
                    # 检查边界及是否为未访问的陆地
                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:
                        grid[nr][nc] = 1    # 标记已访问
                        queue.append((nr, nc))
            
            return False

        # 二分
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid        # 可行，尝试更大天数
                left = mid + 1
            else:
                right = mid - 1  # 不可行，减少天数
        
        return ans
```

```Java
// java
class Solution {
    private int[][] DIRS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int latestDayToCross(int row, int col, int[][] cells) {
        int left = 0, right = cells.length;
        int ans = 0;

        // 二分
        while (left <= right) {
            int mid = (left + right) / 2;
            if (check(mid, row, col, cells)) {
                ans = mid;        // 可行，尝试更大天数
                left = mid + 1;
            } else {
                right = mid - 1;  // 不可行，减少天数
            }
        }

        return ans;
    }

    // 判断在第 day 天是否能从顶到底
    private boolean check(int day, int row, int col, int[][] cells) {
        int[][] grid = new int[row][col];
        for (int i = 0; i < day; i++) {
            int r = cells[i][0];
            int c = cells[i][1];
            // 下标从 1 开始，转为 0 索引
            grid[r - 1][c - 1] = 1;
        }

        Queue<int[]> queue = new ArrayDeque<>();
        // 将第一行所有是陆地的点加入队列
        for (int c = 0; c < col; c++) {
            if (grid[0][c] == 0) {
                queue.offer(new int[]{0, c});
                grid[0][c] = 1;  // 标记为已访问
            }
        }

        // 开始 BFS
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int r = curr[0];
            int c = curr[1];

            // 如果到达最后一行，说明通路存在
            if (r == row - 1) {
                return true;
            }

            // 向四个方向扩散
            for (int[] dir : DIRS) {
                int nr = r + dir[0];
                int nc = c + dir[1];
                // 检查边界及是否为未访问的陆地
                if (nr >= 0 && nr < row && nc >= 0 && nc < col && grid[nr][nc] == 0) {
                    grid[nr][nc] = 1;    // 标记已访问
                    queue.offer(new int[]{nr, nc});
                }
            }
        }

        return false;
    }
}
```

- 时间复杂度： $O(n\times logn)$
- 空间复杂度： $O(n)$

---

### 倒序

正向过程中，不断有陆地消失，这在图论中属于 “删点” 或 “删边” 操作。并查集 $DSU$ 擅长处理 “加边/连通” 问题，但不擅长处理 “断开” 问题。具体题解看 [这篇](https://leetcode.cn/problems/redundant-connection/solutions/2966966/bing-cha-ji-bao-li-mei-ju-zhao-huan-you-k08ct/)。

实际上，我们可以从 **逆向思维（时光倒流）** 的角度看问题。

站在时间线的尽头，此时网格中水最多，陆地最少。倒着遍历，从 $cells$ 列表的最后一个元素开始，把水域变回陆地。**问题转化**：随着时间推移，陆地不断增加，哪一刻起点和终点连通？

为了快速判断 “第一行” 和 最后一行” 是否连通，引入两个虚拟节点：

- 源点 $Top$
- 汇点 $Bottom$

如果格子和第一行连通，就与 $Top$ 合并；和最后一行连通，就与 $Bottom$ 合并。

最后一天 $cells$ 中的点全是水，构建最终状态的网格。遍历网格中的那些陆地，将它们之间以及与 $Top/Bottom$ 进行合并。倒序遍历 $cells$：

- 取出当前天数 $i$ 对应的格子 $(r, c)$，把它变回陆地。
- 将它与四周的陆地邻居合并。
- 如果它在第一行，与 $Top$ 合并；如果在最后一行，与 $Bottom$ 合并。

一旦 $find(Top)$ 等于 $find(Bottom)$，说明 **上下连通**，返回 $i$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        # 虚拟节点索引
        # 如果是第一行，连 Top；如果是最后一行，连 Bottom
        top = row * col
        bottom = row * col + 1
        # 初始化
        parent = list(range(row * col + 2))
        DIRS = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        # 查找祖先，路径压缩
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        # 合并，把路径短的作为父节点
        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return
            if px < py:
                parent[py] = px
            else:
                parent[px] = py

        # 二维坐标转一维索引
        def get_idx(r, c):
            return r * col + c

        # 初始化网格
        grid = [[0] * col for _ in range(row)]
        for r, c in cells:
            grid[r-1][c-1] = 1
        
        # 如果是陆地，则与左、上的陆地合并
        for r in range(row):
            for c in range(col):
                if grid[r][c] == 0:
                    idx = get_idx(r, c)
                    # 边界连接
                    if r == 0: union(idx, top)
                    if r == row - 1: union(idx, bottom)
                    if r > 0 and grid[r-1][c] == 0: union(idx, get_idx(r-1, c))
                    if c > 0 and grid[r][c-1] == 0: union(idx, get_idx(r, c-1))

        # 倒序遍历
        for i in range(len(cells) - 1, -1, -1):
            r, c = cells[i][0] - 1, cells[i][1] - 1
            
            # 将当前水域变回陆地
            grid[r][c] = 0
            idx = get_idx(r, c)
            
            # 边界连接
            if r == 0: union(idx, top)
            if r == row - 1: union(idx, bottom)
            
            # 与四周的陆地合并
            for dr, dc in DIRS:
                nr, nc = r + dr, c + dc
                if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:
                    union(idx, get_idx(nr, nc))
            
            # 检查是否连通
            if find(top) == find(bottom):
                return i
        
        return 0
```

```Java
// java
class Solution {
    private int[] parent;

    public int latestDayToCross(int row, int col, int[][] cells) {
        // 虚拟节点索引
        // 如果是第一行，连 Top；如果是最后一行，连 Bottom
        int top = row * col;
        int bottom = row * col + 1;

        // 初始化
        parent = new int[row * col + 2];
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
        }

        int[][] DIRS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // 初始化网格
        int[][] grid = new int[row][col];
        for (int[] cell : cells) {
            grid[cell[0] - 1][cell[1] - 1] = 1;
        }

        // 如果是陆地，则与左、上的陆地合并
        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                if (grid[r][c] == 0) {
                    int idx = r * col + c;
                    // 边界连接
                    if (r == 0) union(idx, top);
                    if (r == row - 1) union(idx, bottom);
                    if (r > 0 && grid[r - 1][c] == 0) union(idx, (r - 1) * col + c);
                    if (c > 0 && grid[r][c - 1] == 0) union(idx, r * col + (c - 1));
                }
            }
        }

        // 倒序遍历
        for (int i = cells.length - 1; i >= 0; i--) {
            int r = cells[i][0] - 1;
            int c = cells[i][1] - 1;

            // 将当前水域变回陆地
            grid[r][c] = 0;
            int idx = r * col + c;

            // 边界连接
            if (r == 0) union(idx, top);
            if (r == row - 1) union(idx, bottom);

            // 与四周的陆地合并
            for (int[] dir : DIRS) {
                int nr = r + dir[0];
                int nc = c + dir[1];
                if (nr >= 0 && nr < row && nc >= 0 && nc < col && grid[nr][nc] == 0) {
                    union(idx, nr * col + nc);
                }
            }

            // 检查是否连通
            if (find(top) == find(bottom)) {
                return i;
            }
        }

        return 0;
    }

    // 查找祖先，路径压缩
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 合并，把路径短的作为父节点
    private void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) {
            return;
        }
        if (px < py) {
            parent[py] = px;
        } else {
            parent[px] = py;
        }
    }
}
```

同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\alpha(n))$，其中 $\alpha$ 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间，可以认为是一个很小的常数。[证明](https://oi-wiki.org/ds/dsu-complexity/) 在这。

- 时间复杂度： $O(n\times \alpha(n))$
- 空间复杂度： $O(n)$，表示 $parent$ 以及 $grid$ 的大小

---

### 对偶

先叠甲，我查看了运行速度最快的代码，下面是一点经验总结。

在二维网格图中，存在一个拓扑学的对偶性质：

- 原问题：是否存在一条从 **第一行** 到 **最后一行** 的 **陆地** 路径？
- 对偶问题：是否存在一条从 **第一列** 到 **最后一列** 的 **水域** 防线？

如果存在一条从左到右的 “水墙”，那么从上到下的陆地路径一定会被切断。

使用一个 $state$ 矩阵，用于记录水域的连通状态：

- $0$：陆地
- $1$：孤立或未连接到左边界的水域（“死水”）
- $2$：已连接到最左侧 **第一列** 的水域（“活水”）。

注意 $DIRS$ 要包含 **8个方向**，上下左右+四个对角线。为了切断 $4$ 连通的陆地，水域只需要 $8$ 连通即可。例如两个水域对角相邻，陆地就穿不过去。

在主函数中，正向遍历:

- 当前格子 $(r,c)$ 变为普通水域。
- 检查当前格子是否在第一列。或者，检查当前格子的 $8$ 邻域内是否有状态为 $2$ 的格子。

**定义** $dfs$ 辅助函数，如果当前格子满足 “左侧连通” 条件，触发 $DFS$。

- 递归目的：把当前格子标记为 $2$ 活水，并顺着 $8$ 个方向去感染邻居中状态为 $1$ 的水域。
- 如果 $DFS$ 搜索到了最后一列，说明水域防线从左贯穿到了右，终止。

一旦 $dfs$ 返回 $True$，说明防线形成，直接返回当前的 $day$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def latestDayToCross(self, m: int, n: int, cells: List[List[int]]) -> int:
        # 切记 8 个方向
        DIRS = (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1)

        # 0：陆地
        # 1：孤立或未连接到左边界的水域
        # 2：已连接到最左侧第一列的水域
        state = [[0] * n for _ in range(m)]

        # 能否从左侧第一列到达第 c 列
        def can_reach_from_left(r, c):
            if c == 0:  # 已经是第一列
                return True
            for dx, dy in DIRS:
                x, y = r + dx, c + dy
                if 0 <= x < m and 0 <= y < n and state[x][y] == 2:
                    return True
            return False

        def dfs(r, c):
            if c == n - 1:
                return True
            state[r][c] = 2  # 感染
            for dx, dy in DIRS:
                x, y = r + dx, c + dy
                if 0 <= x < m and 0 <= y < n and state[x][y] == 1 and dfs(x, y):
                    return True
            return False

        for day, (r, c) in enumerate(cells):
            r -= 1  # 下标记得 -1
            c -= 1
            state[r][c] = 1  # 未被感染的水
            if can_reach_from_left(r, c) and dfs(r, c):
                return day
```

```Java
// java
class Solution {
    // 切记 8 个方向
    private int[][] DIRS = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};

    public int latestDayToCross(int row, int col, int[][] cells) {
        int m = row;
        int n = col;

        // 0：陆地
        // 1：孤立或未连接到左边界的水域
        // 2：已连接到最左侧第一列的水域
        int[][] state = new int[m][n];

        for (int day = 0; day < cells.length; day++) {
            int r = cells[day][0] - 1; // 下标记得 -1
            int c = cells[day][1] - 1;
            
            state[r][c] = 1; // 未被感染的水

            if (canReachFromLeft(r, c, m, n, state) && dfs(r, c, m, n, state)) {
                return day;
            }
        }
        return 0;
    }

    // 能否从左侧第一列到达第 c 列
    private boolean canReachFromLeft(int r, int c, int m, int n, int[][] state) {
        if (c == 0) {  // 已经是第一列
            return true;
        }
        for (int[] dir : DIRS) {
            int x = r + dir[0];
            int y = c + dir[1];
            if (x >= 0 && x < m && y >= 0 && y < n && state[x][y] == 2) {
                return true;
            }
        }
        return false;
    }

    private boolean dfs(int r, int c, int m, int n, int[][] state) {
        if (c == n - 1) {
            return true;
        }
        state[r][c] = 2; // 感染
        for (int[] dir : DIRS) {
            int x = r + dir[0];
            int y = c + dir[1];
            if (x >= 0 && x < m && y >= 0 && y < n && state[x][y] == 1 && dfs(x, y, m, n, state)) {
                return true;
            }
        }
        return false;
    }
}
```

每个格子从 $0$ 变 $1$，再从 $1$ 变 $2$ 是 **单向** 的。一个格子一旦被标记为 $2$，就不会再次被 $DFS$ 访问。因此，每个格子最多被 $DFS$ 处理一次。

绝大多数掉落的水域可能是 “孤岛”，或者在中间不靠边。辅助函数 $canReach$ 只检查周围，如果一个水域掉在中间，周围没有连通左边的水，代码根本不会启动 $DFS$。

这个方法相当于动态维护了一个 “连通分量”，而且只关心 “即时” 的变化。实测 $Python$ 代码耗时 $55ms$，超过 $100\%$。

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/last-day-where-you-can-still-cross/solutions/3869904/si-jie-zheng-xiang-er-fen-dfsbfs-fan-xia-1rho/)
