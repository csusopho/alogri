[Problem: 3494. 酿造药水需要的最少总时间](https://leetcode.cn/problems/find-the-minimum-amount-of-time-to-brew-potions/description/)

### 方法：模拟 & 优化

最大难点：读懂题意。

本质上就是 **流水线** 问题。将 $n$ 个巫师想象成一个有 $n$ 个工序的流水线，而 $m$ 种魔药就是 $m$ 个需要在这条流水线上加工的任务。

加工完一个魔药后，**立刻** 传给下一个巫师，所有魔药都必须按照 $0\to 1\to ...\to n-1$ 的顺序经过每一个巫师。

**核心：一个巫师不能同时做两件事！**

看看示例 $1$，为什么巫师 $1$ 直到 $t=52$ 才开始工作？因为上一个魔药传给巫师 $3$，他在 $t=60$ 才完成。因此，最早只能在 $t=60$ 将下一个魔药传给巫师 $3$。往前倒推，最早只能 $t=52$ 给巫师 $1$。

也即，**魔药必须连续加工！** 巫师可以休息，但魔药不能中途等待。

怎么解题？以第 $i$ 名巫师为例。

- 先假设不推迟，计算他 “遇到” 当前这一个魔药的时间点 $cur$；
- 他 “完成” 上一个魔药的时间点为 $prev$，将两者进行比较；
- 如果 $prev\leq cur$，说明该巫师空闲，可以直接加工；
- 否则，说明该巫师正在忙着加工上一个，必须推迟 $cur-prev$ 的时间。

遍历这 $n$ 个巫师，计算出 **最大** 需要推迟的时间 $delay$。只要让第一个巫师延迟工作 $delay$ 时间，则一定让当前这一个魔药能连续完成！

如果用 **动态规划** 的角度理解，定义 $dp[i][j]$ 为第 $i$ 个巫师完成第 $j$ 种魔药的时间点。如果没有延迟，则第 $i$ 名巫师是紧接着第 $i-1$ 名巫师，即

$$
dp[i][j] = dp[i-1][j] + skill[i] * mana[j]
$$

但是，由于事件不能交叉，需要计算 `dp[i + 1][j] - dp[i][j + 1]` 中的最大值 $delay$。然后加在每一项 $dp[i][j]$ 中，表示真正时间。

> 直接使用 $DP$ 会超空间，卡在 $735/744$ 样例，代码附在评论区。

我们在解题的时候，直接 **模拟** 上述过程（本质是动规的优化）。定义 $time[i]$ 表示第 $i$ 名巫师完成上一个魔药的时间点。

**流程**：先计算推迟时间，然后累加处理时间，最后更新每一项为真正时间。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n = len(skill)
        # time[i] 存储第 i 个巫师完成上一批魔药的时间点
        time = [0] * n

        for val in mana:
            # 到第 i-1 个巫师为止，不考虑等待的累计处理时间
            total = 0
            # 为满足所有巫师的空闲时间，当前这批魔药需要整体推迟的时间
            delay = 0
            
            # 计算 delay 和不包含 delay 的新完成时间
            for i in range(n):
                # 如果巫师 i 还没空闲，流水线就必须等待
                delay = max(delay, time[i] - total)
                # 累加当前巫师处理当前魔药的时间
                total += skill[i] * val
                # 暂时将 time[i] 更新为不考虑 delay 的相对完成时间
                time[i] = total
        
            # 将计算出的全局 delay 加到每个巫师的完成时间上
            for i in range(n):
                time[i] += delay
            
        # 最后一个巫师完成最后一批魔药
        return time[-1]
```

```Java
// java
class Solution {
    public long minTime(int[] skill, int[] mana) {
        int n = skill.length;
        // time[i] 存储第 i 个巫师完成上一批魔药的时间点
        long[] time = new long[n];

        for (int val : mana) {
            // 到第 i-1 个巫师为止，不考虑等待的累计处理时间
            long total = 0;
            // 为满足所有巫师的空闲时间，当前这批魔药需要整体推迟的时间
            long delay = 0;
            
            // 计算 delay 和不包含 delay 的新完成时间
            for (int i = 0; i < n; i++) {
                // 如果巫师 i 还没空闲，流水线就必须等待
                // time[i] 是上批魔药完成时间, total 是这批魔药到上一个巫师处理完的时间点
                delay = Math.max(delay, time[i] - total);
                // 累加当前巫师处理当前魔药的时间
                total += (long) skill[i] * val;
                // 暂时将 time[i] 更新为不考虑 delay 的相对完成时间
                time[i] = total;
            }
        
            // 将计算出的全局 delay 加到每个巫师的完成时间上
            for (int i = 0; i < n; i++) {
                time[i] += delay;
            }
        }
            
        // 最后一个巫师完成最后一批魔药
        return time[n - 1];
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n,m$ 分别为数组 $skill,mana$ 的长度
- 空间复杂度： $O(n)$，表示数组 $time$ 的大小

---

### 前缀和

对于 $total$ 的计算，本质就是 `skill[i] * mana[j]` 的不断累加，没有 “相减” 等多余操作，所以可以单独将 $skill$ 的累加部分提取出来，这样循环时只需要乘一次 $mana[j]$。

“前缀和” 的具体原理及做法，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n = len(skill)
        # 前缀和
        prefix = list(accumulate(skill))
        # time[i] 存储第 i 个巫师完成上一批魔药的时间点
        time = [0] * n

        for val in mana:
            # 为满足所有巫师的空闲时间，当前这批魔药需要整体推迟的时间
            delay = 0
            
            # 获得累计处理时间
            for i in range(n):
                # 到第 i-1 个巫师为止，不考虑等待的累计处理时间
                total = prefix[i-1] * val if i > 0 else 0
                # 如果巫师 i 还没空闲，流水线就必须等待
                delay = max(delay, time[i] - total)

            # 新时间 = 整体启动延迟(delay) + 从头开始到当前巫师的累计处理时间
            for i in range(n):
                time[i] = delay + prefix[i] * val
        
        return time[-1]
```

```Java
// java
class Solution {
    public long minTime(int[] skill, int[] mana) {
        int n = skill.length;
        // 前缀和, 使用 long 类型防止溢出
        long[] prefix = new long[n];
        prefix[0] = skill[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + skill[i];
        }

        // time[i] 存储第 i 个巫师完成上一批魔药的时间点
        long[] time = new long[n];
        
        for (int val : mana) {
            // 为满足所有巫师的空闲时间，当前这批魔药需要整体推迟的时间
            long delay = 0;
            
            // 获得累计处理时间
            for (int i = 0; i < n; i++) {
                // 到第 i-1 个巫师为止，不考虑等待的累计处理时间
                long total = (i > 0) ? prefix[i - 1] * val : 0;
                // 如果巫师 i 还没空闲，流水线就必须等待
                delay = Math.max(delay, time[i] - total);
            }

            // 新时间 = 整体启动延迟(delay) + 从头开始到当前巫师的累计处理时间
            for (int i = 0; i < n; i++) {
                time[i] = delay + prefix[i] * val;
            }
        }
        
        return time[n - 1];
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(n)$

---

### 倒推

使用 “前缀和” 与否，几乎对代码速度无影响，那不如直接不用，还节省一点空间。

从操作系统的底层来说，数组写入，控制的是 **内存** 中的变量；临时变量，用到的则是寄存器。后者速度要远比前者更快。

因此，我们采用 **倒序填充**。先正向计算巫师处理 “当前” 魔药的时间，然后与 “之前” 的结果比较，反向倒推出前面 $n-1$ 名巫师的时间。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n = len(skill)
        # last[i] 存储第 i 名巫师完成【上一瓶】药水的时间点
        last = [0] * n
        
        for val in mana:
            # total 代表第 i-1 个巫师完成【当前】药水的时间
            total = 0
            for current_skill, prev_finish_time in zip(skill, last):
                # 巫师i开始做当前药水的时间
                if prev_finish_time > total:
                    total = prev_finish_time
                # 加上巫师i处理当前药水的时间
                total += current_skill * val
            
            # 循环结束后，total 是最后一个巫师完成【当前】药水的时间
            
            # 反向，更新所有巫师的完成时间
            last[-1] = total
            # 倒推出前面每个巫师的完成时间
            for i in range(n - 2, -1, -1):
                last[i] = last[i + 1] - skill[i + 1] * val

        return last[-1]
```

```Java
// java
class Solution {
    public long minTime(int[] skill, int[] mana) {
        int n = skill.length;
        // last[i] 存储第 i 名巫师完成【上一瓶】药水的时间点
        long[] last = new long[n];

        for (int val : mana) {
            // total 代表流水线上，魔药流到第 i-1 个巫师处理完【当前】药水的时间点
            long total = 0;
            
            // 正向循环，计算最后一个巫师完成当前药水的时间
            for (int i = 0; i < n; i++) {
                long currentSkill = skill[i];
                long prevFinishTime = last[i];

                // 巫师i开始做当前药水的时间，必须同时满足两个条件：
                // 1. 前一个巫师已经把【当前】药水传过来 (时间点 total)
                // 2. 巫师i自己已经完成了【上一瓶】药水 (时间点 prevFinishTime)
                // 因此开始时间是这两者的最大值
                total = Math.max(total, prevFinishTime);
                
                // 加上巫师i处理当前药水的时间，得到巫师i完成【当前】药水的时间点
                total += currentSkill * val;
            }
            
            // 循环结束后，total 是最后一个巫师完成【当前】药水的时间
            
            // 反向，更新所有巫师的完成时间，为计算下一瓶药水做准备
            last[n - 1] = total;
            // 倒推出前面每个巫师的完成时间
            for (int i = n - 2; i >= 0; i--) {
                // 巫师i的完成时间 = 巫师i+1的完成时间 - 巫师i+1处理该药水花费的时间
                last[i] = last[i + 1] - (long) skill[i + 1] * val;
            }
        }

        return last[n - 1];
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-minimum-amount-of-time-to-brew-potions/solutions/3801252/mo-ni-dpchao-chu-kong-jian-jie-du-ti-yi-o0fc1/)
