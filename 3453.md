[Problem: 3453. 分割正方形 I](https://leetcode.cn/problems/separate-squares-i/description/)

### 二分 & 差分

寻找一个 $y$ 值，使得所有正方形在 $y$ 线以下部分的面积之和等于总面积的一半。

想象一下，有一条水平线 $y = h$ 从最下方缓缓向上移动：

1. 当 $h$ 很小时，水平线在所有正方形下方，线下方的面积为 $0$；
2. 当 $h$ 逐渐增大，水平线开始穿过正方形，线下方的累积面积 **只会增加，不会减少**；
3. 当 $h$ 很大时，水平线在所有正方形上方，线下方的面积等于所有正方形的总面积。

“线下方面积” 随着 $y$ 的增加是单调递增的，所以能使用 **二分查找** 来逼近那个能让面积正好等于总面积一半的 $y$ 值。

如何确定 $y=h$ 这条线以下的面积是多少？

对于列表中的每一个正方形 $(x_i, y_i, l_i)$，我们单独计算它在 $y=h$ 以下部分的面积：

- **完全在下方**：正方形的顶部 $y_i + l_i \le h$，则该正方形贡献面积 = $l_i \times l_i$；
- **完全在上方**：正方形的底部 $y_i \ge h$，则该正方形贡献面积 = $0$。
- **被线穿过**：也即 $y_i < h < y_i + l_i$，那么正方形位于线以下的高度是 $h - y_i$，则该正方形贡献面积 = $l_i \times (h - y_i)$。

把上述逻辑简化。对于任意一个正方形，它在 $h$ 线以下的 **有效高度** 是：

$$
\text{height} = \max(0, \min(y_i + l_i, h) - y_i)
$$

面积贡献就是 $\text{height} \times l_i$。遍历所有正方形，累加得到总面积。

**二分下界**：所有正方形最低的 $y$ 坐标，或者简单设为 $0$；**二分上界**：所有正方形最高的顶部坐标 $max(y + l)$。

**终止条件**：因为是浮点数，我们不能用 $low\le high$，通常采用两种方式之一：

1. $high - low > 10^{-6}$：当区间缩小到足够小时停止。
2. **固定次数**：循环 $50$ 次。对于二分法，循环 $50$ 次可以将区间缩小 $2^{50}$ 倍，精度远超题目要求的 $10^{-5}$，且不用担心死循环。

在每一轮二分中，如果 $check(mid)\ge target$，说明线正好或者太高，面积包含太多，需要往下找，更新 `high = mid`；反之，说明线太低，面积不够，需要往上找，更新 `low = mid`。

使用 **闭区间二分**，代码如下，已附加注释：

```Python
# python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        # 总面积的一半作为目标值
        total_area = sum(l * l for _, _, l in squares)
        target = total_area / 2.0
        
        #计算直线 y = h 下方的总面积
        def get_area_below(h):
            area = 0
            for _, y, l in squares:
                # 正方形顶部 y坐标
                top = y + l
                # 计算该正方形在 h 线以下的高度
                height = max(0, min(top, h) - y)
                area += height * l
            return area

        # 下界：所有正方形中最小的 y
        # 上界：所有正方形中最大的 (y + l)
        min_y = min(s[1] for s in squares)
        max_y = max(s[1] + s[2] for s in squares)
        
        low, high = float(min_y), float(max_y)
        
        # 保证精度远超 10^-5
        for _ in range(50):
            mid = (low + high) / 2
            if get_area_below(mid) >= target:
                # 面积足够，说明分界线在 mid 或更下方
                high = mid
            else:
                # 面积不够，说明分界线在 mid 上方
                low = mid
        
        return high
```

```Java
// java
class Solution {
    public double separateSquares(int[][] squares) {
        // 总面积的一半作为目标值
        double totalArea = 0;
        for (int[] sq : squares) {
            totalArea += (double) sq[2] * sq[2];
        }
        double target = totalArea / 2.0;

        // 下界：所有正方形中最小的 y
        // 上界：所有正方形中最大的 (y + l)
        double minY = squares[0][1];
        double maxY = squares[0][1] + squares[0][2];
        for (int[] sq : squares) {
            minY = Math.min(minY, sq[1]);
            maxY = Math.max(maxY, sq[1] + sq[2]);
        }

        double low = minY, high = maxY;

        // 保证精度远超 10^-5
        for (int i = 0; i < 50; i++) {
            double mid = low + (high - low) / 2;
            if (getAreaBelow(squares, mid) >= target) {
                // 面积足够，说明分界线在 mid 或更下方
                high = mid;
            } else {
                // 面积不够，说明分界线在 mid 上方
                low = mid;
            }
        }

        return high;
    }

    // 计算直线 y = h 下方的总面积
    private double getAreaBelow(int[][] squares, double h) {
        double area = 0;
        for (int[] sq : squares) {
            int y = sq[1];
            int l = sq[2];
            // 正方形顶部 y坐标
            double top = y + l;
            // 计算该正方形在 h 线以下的高度
            double height = Math.max(0, Math.min(top, h) - y);
            area += height * l;
        }
        return area;
    }
}
```

- 时间复杂度： $O(n\times K)$，其中 $n$ 是数组 $squares$ 的长度，而 $K=50$ 表示二分次数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 差分

本质是寻找一个 $y$ 值，使得所有正方形在 $y$ 线以下部分的面积之和等于总面积的一半。正方形的 $x$ 轴坐标与本题无关，无需关注。

将二维的正方形投影到 $y$ 轴上，看作是一系列带有 “宽度(边长)” 的垂直线段。

**离散化**：

- 对于每个正方形 $(x_i, y_i, l_i)$，它在高度方向覆盖的范围是 $[y_i, y_i + l_i]$。
- 在这个范围内，该正方形为水平截面贡献了 $l_i$ 的宽度。
- 把正方形的上下边界看作 “事件”：在 $y_i$ 处，有效总宽度增加了 $l_i$。在 $y_i + l_i$ 处，有效总宽度减少了 $l_i$。

将所有边界 `(y坐标,边长)` 存入一个列表 $events$，并按 $y$ 坐标 **升序** 排列。

维护变量 $curWidth$，表示当前所有被切割到的正方形的总边长。以及变量 $curArea$，表示总共累加的总面积。

我们线性遍历列表 $events$，将上一个坐标记作 $y_{prev}$，当前坐标记作 $y_{curr}$。**核心逻辑**：

- 在两个相邻的边界 $y_{prev}$ 和 $y_{curr}$ 之间，新增的正方形宽为 $curWidth$，这部分增加的面积 = $curWidth \times (y_{curr} - y_{prev})$。
- 累加这个面积。一旦累加面积超过或等于 $target$，说明分割线就在 $y_{prev}$ 和 $y_{curr}$ 之间。

假设分割线在 $y_{prev}$ 上方距离 $h$ 的位置，则有 $curArea + h \times curWidth = target$，解得 $h = (target - curArea) / curWidth$，那么最终答案为 $y_{prev} + h$。

**总结**：题目中提到 “重叠区域应该被多次计数”，意味着如果有两个边长为 $2$ 的正方形完全重合，该区域的面积算作 $4+4=8$。这就把二维平面的并集面积问题简化为了 **一维线段权重的累积问题**。我们在 $y$ 轴上每一处切一刀，切到的长度就是所有覆盖该高度的正方形边长之和。

代码如下，已附加注释：

```Python
# python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        # 所有正方形的总面积
        total_area = sum(sq[2] ** 2 for sq in squares)
        target = total_area / 2.0
        
        # 存储 (y坐标, 宽度变化量)
        events = []
        for x, y, l in squares:
            events.append((y, l))
            events.append((y + l, -l))
        
        # 按照 y 坐标升序
        events.sort(key=lambda x: x[0])
        
        cur_area = 0.0  # 当前累积的面积
        cur_width = 0   # 当前水平切线的总截取宽度
        prev_y = events[0][0] # 上一个处理的 y 坐标
        
        # 累积面积
        for y, diff_l in events:
            # 计算从 prev_y 到当前 y 这一高度区间内产生的面积
            height = y - prev_y
            if height > 0:
                # 当前区间内的面积增量
                segment_area = height * cur_width
                
                # 加上增量后超过或等于目标，说明分割线在这个区间内
                if cur_area + segment_area >= target:
                    # 需要补充的面积
                    missing_area = target - cur_area
                    # 需要的高度 = 缺少的面积 / 当前的总宽度
                    return prev_y + missing_area / cur_width
                
                # 否则累加面积，继续向上扫描
                cur_area += segment_area
            
            # 更新当前的总宽度 和 上一个 y 坐标
            cur_width += diff_l
            prev_y = y
        
        # 走不到这
        return prev_y
```

```Java
// java
class Solution {
    public double separateSquares(int[][] squares) {
        // 所有正方形的总面积
        double totalArea = 0;
        for (int[] sq : squares) {
            totalArea += (double) sq[2] * sq[2];
        }
        double target = totalArea / 2.0;

        // 存储 (y坐标, 宽度变化量)
        int n = squares.length;
        int[][] events = new int[2 * n][2];
        for (int i = 0; i < n; i++) {
            int y = squares[i][1];
            int l = squares[i][2];
            events[2 * i][0] = y;
            events[2 * i][1] = l;
            events[2 * i + 1][0] = y + l;
            events[2 * i + 1][1] = -l;
        }

        // 按照 y 坐标升序
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));

        double curArea = 0.0;  // 当前累积的面积
        long curWidth = 0;     // 当前水平切线的总截取宽度
        int prevY = events[0][0]; // 上一个处理的 y 坐标

        // 累积面积
        for (int[] event : events) {
            int y = event[0];
            int diffL = event[1];

            // 计算从 prev_y 到当前 y 这一高度区间内产生的面积
            int height = y - prevY;
            if (height > 0) {
                // 当前区间内的面积增量
                double segmentArea = (double) height * curWidth;

                // 加上增量后超过或等于目标，说明分割线在这个区间内
                if (curArea + segmentArea >= target) {
                    // 需要补充的面积
                    double missingArea = target - curArea;
                    // 需要的高度 = 缺少的面积 / 当前的总宽度
                    return prevY + missingArea / curWidth;
                }

                // 否则累加面积，继续向上扫描
                curArea += segmentArea;
            }

            // 更新当前的总宽度 和 上一个 y 坐标
            curWidth += diffL;
            prevY = y;
        }

        // 走不到这
        return prevY;
    }
}
```

- 时间复杂度： $O(n\times logn)$，性能瓶颈在于快排
- 空间复杂度： $O(n)$，表示列表 $events$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/separate-squares-i/solutions/3879291/shuang-jie-bi-qu-jian-er-fen-chi-san-hua-ikbm/)
