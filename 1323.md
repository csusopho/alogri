[Problem: 1323. 6 和 9 组成的最大数字](https://leetcode.cn/problems/maximum-69-number/description/)

### 方法：贪心

**最多** 翻转一次，只能 $6,9$ 互相转化，求修改后的最大数字。

**贪心** 思路：将最高位（左侧）的 $6$ 变为 $9$。数学知识，这里不再证明。

转为字符串的调库写法，代码如下：

```Python
# python
class Solution:
    def maximum69Number (self, num: int) -> int:
        return int(str(num).replace('6', '9', 1))
```

```Java
// java
class Solution {
    public int maximum69Number (int num) {
        // 将数字转为字符串，并替换第一个 '6' 为 '9'
        String s = String.valueOf(num).replaceFirst("6", "9");
        return Integer.parseInt(s);
    }
}
```

手动寻找：

```Python
# python
class Solution:
    def maximum69Number (self, num: int) -> int:
        # 转成字符串方便处理
        num_str = list(str(num))
        for i in range(len(num_str)):
            if num_str[i] == '6':
                num_str[i] = '9'  # 只改第一个 6
                break
        return int("".join(num_str))
```

```Java
// java
class Solution {
    public int maximum69Number (int num) {
        // 转成字符串方便处理
        char[] numStr = String.valueOf(num).toCharArray();
        
        for (int i = 0; i < numStr.length; i++) {
            if (numStr[i] == '6') {
                numStr[i] = '9';  // 只改第一个 6
                break;
            }
        }
        
        return Integer.parseInt(new String(numStr));
    }
}
```

这里将 $num$ 简记为 $n$。

- 时间复杂度： $O(logn)$，其中 $n$ 为题目给定数字，逐位遍历
- 空间复杂度： $O(logn)$，表示字符串 $numStr$ 的空间

---

### 数学

不使用字符串，利用 `%` 以及 `/` 运算，从高位到低位，直接查找数字的每一位。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximum69Number (self, num: int) -> int:
        temp = num
        position = -1  # 记录最靠左的 6 的位置
        pos = 0
        
        while temp > 0:
            digit = temp % 10
            if digit == 6:
                position = pos
            temp //= 10
            pos += 1
        
        # 如果找到 6，将它变为 9
        if position != -1:
            num += 3 * (10 ** position)
        
        return num
```

```Java
// java
class Solution {
    public int maximum69Number (int num) {
        int temp = num;
        int position = -1;  // 记录最靠左的 6 的位置
        int pos = 0;
        
        while (temp > 0) {
            int digit = temp % 10;
            if (digit == 6) {
                position = pos;
            }
            temp /= 10;
            pos++;
        }
        
        // 如果找到 6，将它变为 9
        if (position != -1) {
            num += 3 * Math.pow(10, position);
        }
        
        return num;
    }
}
```

由于本题限制 $num\le 10^4$，所以我们可以从千位开始查找，代码简化为：

```Python
# python
class Solution:
    def maximum69Number (self, num: int) -> int:
        i = 1000
        while i >= 1:
            if (num // i) % 10 == 6:
                return num + (9 - 6) * i
            i //= 10
        return num
```

```Java
// java
class Solution {
    public int maximum69Number (int num) {
        int i = 1000;  // 从千位开始
        while (i >= 1) {
            if ((num / i) % 10 == 6) {
                return num + (9 - 6) * i;  // 将 6 改为 9
            }
            i /= 10;  // 继续检查下一位
        }
        return num;
    }
}
```

- 时间复杂度： $O(logn)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-69-number/solutions/3754417/tan-xin-zhuan-zi-fu-chuan-or-shu-xue-si-jujb8/)
