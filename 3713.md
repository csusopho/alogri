[Problem: 3713. 最长的平衡子串 I](https://leetcode.cn/problems/longest-balanced-substring-i/description/)

### 枚举

题意很清晰，这里不再赘述。

**暴力** 做法：遍历所有可能的子串，然后检查每一个子串是否平衡。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)
        ans = 0
        
        # 枚举所有子串
        for i in range(n):
            for j in range(i, n):
                # 截取
                sub = s[i : j + 1]
                # 统计频率
                counts = Counter(sub)
                # 获取所有出现的次数的集合
                freq_set = set(counts.values())

                # 次数相同
                if len(freq_set) == 1:
                    ans = max(ans, len(sub))
                    
        return ans
```

这种做法的时间为 $O(n^3)$，会超时，经实测，卡在 $976/1701$ 样例。

---

### 优化

上面的过程非常冗余。子串 $s[i,j+1]$ 就是 $s[i,j]$ 向右扩展一次，统计完短的子串 $s[i,j]$ 后，没必要再重新扫描 $s[i,j+1]$。

我们可以 **固定起点**，动态地向右扩展来消除重复计算。

假设一个子串长度为 $L$，其中有 $k$ 种不同的字符，且它是平衡的。那么，这 $k$ 种字符每一种出现的次数必须是同一个数，设为 $mx$。

**平衡的充要条件**：

$$
\text{子串长度 } L = \text{不同字符数量 } k \times \text{最大出现频次 } \text{max\_freq}
$$

比如 $aabbcc$，长度 $L=6$，不同字符 $k=3$，最大频次 $mx=2$。则有 $3 \times 2 = 6$，等式成立，是平衡子串。

反之比如 $aab$，长度 $L=3$，不同字符 $k=2$，最大频次 $mx=2$ ('a'出现了两次)。则有 $2 \times 2 = 4 \neq 3$，等式不成立，不是平衡子串。

**总结**：外层循环枚举起点 $i$，内层循环枚举终点 $j$。维护 $mx$ 记录当前窗口内单个字符出现的最大次数，以及 $distCnt$ 记录当前窗口内不同字符的个数。

同时，使用 $cnt$ 记录窗口内每个字符数，随着 $j$ 向右移动，我们只需要将新加入的字符 $s[j]$ 的计数加 $1$。然后，利用上面的公式进行 $O(1)$ 判断。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)
        ans = 0
        
        # 枚举起始位置
        for i in range(n):
            # 数组代替哈希
            cnt = [0] * 26
            max_freq = 0      # 当前窗口内字符出现的最大频次
            distinct_cnt = 0  # 当前窗口内有多少种不同的字符
            
            # 枚举结束位置
            for j in range(i, n):
                idx = ord(s[j]) - ord('a')
                
                # 之前没出现过
                if cnt[idx] == 0:
                    distinct_cnt += 1
                
                # 更新计数
                cnt[idx] += 1
                # 更新最大频次
                if cnt[idx] > max_freq:
                    max_freq = cnt[idx]
                
                cur_len = j - i + 1
                # 平衡子串的长度 = 不同字符数 * 每个字符的频次
                if max_freq * distinct_cnt == cur_len:
                    if cur_len > ans:
                        ans = cur_len
                        
        return ans
```

```Java
// java
class Solution {
    public int longestBalanced(String s) {
        int n = s.length();
        int ans = 0;
        
        // 枚举起始位置
        for (int i = 0; i < n; i++) {
            // 数组代替哈希
            int[] cnt = new int[26];
            int maxFreq = 0;      // 当前窗口内字符出现的最大频次
            int distinctCnt = 0;  // 当前窗口内有多少种不同的字符
            
            // 枚举结束位置
            for (int j = i; j < n; j++) {
                int idx = s.charAt(j) - 'a';
                
                // 之前没出现过
                if (cnt[idx] == 0) {
                    distinctCnt++;
                }
                
                // 更新计数
                cnt[idx]++;
                // 更新最大频次
                if (cnt[idx] > maxFreq) {
                    maxFreq = cnt[idx];
                }
                
                int curLen = j - i + 1;
                // 平衡子串的长度 = 不同字符数 * 每个字符的频次
                if (maxFreq * distinctCnt == curLen) {
                    if (curLen > ans) {
                        ans = curLen;
                    }
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为串 $s$ 的长度
- 空间复杂度： $O(|\Sigma|)$，其中 $|\Sigma|=26$ 表示字符集大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-balanced-substring-i/solutions/3901280/mei-ju-bao-li-chao-shi-hua-chuang-you-hu-ldg1/)
