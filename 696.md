[Problem: 696. 计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/description/)

### 方法：分组计数 & 优化

合法的子串是以下两种形式之一：

- $00...011...1$，也即 $k$ 个 0 后跟 $k$ 个 $1$
- $11...100...0$，也即 $k$ 个 1 后跟 $k$ 个 $0$

像 $0101$ 这种虽然 $0$ 和 $1$ 数量相等，但不满足 “成组连续”，不合法。

**最直观** 的思路：双 $for$ 枚举所有可能的子串，检查它们是否符合条件。然而，子串数量是 $O(n^2)$，优化后的时间也很难低于 $O(n^2)$，会超时！

必须观察规律。

**观察 1**：合法的子串必然跨越了 $0$ 和 $1$ 的边界。

例如字符串 $s = ...00011...$，

- 在 $0$ 和 $1$ 的交界处，我们可以向左取 1 个 $0$，向右取 1 个 $1$，组成 $01$。
- 向左取 $2$ 个 $0$，向右取 $2$ 个 $1$，组成 $0011$。
- 我们能不能组成 $000111$？不能，因为右边只有两个 $1$。

**结论 1**：在某一个交界处，能组成的合法子串数量，取决于交界处 **左边连续** 字符的个数和 **右边连续** 字符的个数，取两者的最小值。

**观察 2**：把字符串压缩成 “组”。

既然关键在于连续字符的个数，可以先把字符串转换成一个计数数组。

比如 $s = 001110011$，从前往后看

1. 首先 $00$ -> $2$ 个
2. 然后 $111$ -> $3$ 个
3. 接着 $00$ -> $2$ 个
4. 最后 $11$ -> $2$ 个

转换后的计数数组 $groups = [2, 3, 2, 2]$。

**观察 3**：计算相邻组的贡献。

数组 $[2, 3, 2, 2]$ 代表了字符变化： $0(2个) -> 1(3个) -> 0(2个) -> 1(2个)$。

- 第 $1$ 组 $00$ 和第 $2$ 组 $111$：
  - 左边有 $2$ 个，右边有 $3$ 个。
  - 能组成 $01$ 和 $0011$。
  - 个数 = $min(2, 3) = 2$。
- 第 $2$ 组 $111$ 和第 $3$ 组 $00$：
  - 左边有 $3$ 个，右边有 $2$ 个。
  - 能组成 $10$, $1100$。
  - 个数 = $min(3, 2) = 2$。
- 第 $3$ 组 $00$ 和第 $4$ 组 $11$：
  - 同理，个数 = $min(2, 2) = 2$。

最终答案就是 $2 + 2 + 2 = 6$。

**总结**：统计连续相同字符的长度，存入 $groups$ 数组。然后遍历它，计算相邻两个元素的最小值，累加到结果中。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        counts = []
        ptr = 0
        n = len(s)
        
        # 统计连续字符的长度
        while ptr < n:
            count = 0
            c = s[ptr]
            while ptr < n and s[ptr] == c:
                ptr += 1
                count += 1
            counts.append(count)
        
        # 计算相邻组的最小值之和
        ans = 0
        for i in range(1, len(counts)):
            ans += min(counts[i], counts[i-1])
            
        return ans
```

```Java
// java
class Solution {
    public int countBinarySubstrings(String s) {
        List<Integer> counts = new ArrayList<>();
        int ptr = 0;
        int n = s.length();
        
        // 统计连续字符的长度
        while (ptr < n) {
            int count = 0;
            char c = s.charAt(ptr);
            while (ptr < n && s.charAt(ptr) == c) {
                ptr++;
                count++;
            }
            counts.add(count);
        }
        
        // 计算相邻组的最小值之和
        int ans = 0;
        for (int i = 1; i < counts.size(); i++) {
            ans += Math.min(counts.get(i), counts.get(i - 1));
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为字符串 $s$ 的长度
- 空间复杂度： $O(n)$，表示数组 $counts$ 的大小

---

### 空间优化

遍历字符串时，动态更新 $prev$ 表示 **上一组长度**，以及 $cur$ 表示 **当前组长度**。每当字符发生变化时，结算一次答案，并更新 $prev$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        # prev 表示上一组连续字符的个数
        # cur 表示当前这一组连续字符的个数
        prev = 0
        cur = 1
        ans = 0
        
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                # 当前字符和前一个相同，当前组长度 +1
                cur += 1
            else:
                # 不同
                # 首先，结算上一对组的贡献
                ans += min(prev, cur)
                # 开启新的“当前组”
                prev = cur
                cur = 1
        
        # 不要忘记最后两组的比较
        ans += min(prev, cur)
        return ans
```

```Java
// java
class Solution {
    public int countBinarySubstrings(String s) {
        // prev 表示上一组连续字符的个数
        // cur 表示当前这一组连续字符的个数
        int prev = 0;
        int cur = 1;
        int ans = 0;
        
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                // 当前字符和前一个相同，当前组长度 +1
                cur++;
            } else {
                // 不同
                // 首先，结算上一对组的贡献
                ans += Math.min(prev, cur);
                // 开启新的“当前组”
                prev = cur;
                cur = 1;
            }
        }
        
        // 不要忘记最后两组的比较
        ans += Math.min(prev, cur);
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，一次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-binary-substrings/solutions/3904714/shuang-jie-guan-cha-gui-lu-fen-zu-ji-shu-4r9n/)
