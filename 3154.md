[Problem: 3154. 到达第 K 级台阶的方案数](https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description/)

### 方法：记忆化搜索

题意：从原点开始跳跃台阶，一次可以向上跳或者向下跳，求到达终点的方案数。

读完题，可以发现几个 **限制**：

- 如果向下跳了一次，下一次就不能再向下跳
- 如果这一次向上跨越 $x$ 个台阶，下一次向上跳就变成 $2*x$ 个台阶
- 每次向下跳时，都只能跨越 $1$ 个台阶

假如当前站在第 $i$ 个台阶处，此时就有「向上」或「向下」两种 **选择**。根据上面的分析中可知，此时不管选择哪个，都会受到上一次选择的影响。

如果用文字表示一下当前问题：

- 上一次向上跳后，求本次到达终点 $k$ 的方案数
- 上一次向下跳后，求本次到达终点 $k$ 的方案数

这意味着，在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

如果采用了 $DFS$ 的方式，就要根据“影响”选定递归参数。在本题中，每一次选择受到了 $2$ 个限制，同时还要用一个参数表示当前位置。参数如下：

1. 当前所在台阶数 $i$
2. 已经“向上跳”的次数 $j$
3. 上一次是否为“向上跳” $isDown$

根据上面的状态，定义 $dfs(i,j,isDown)$ 表示已经向上跳了 $j$ 次，且上一次选择或未选择向下跳时，从当前位置 $i$ 跳到终点 $k$ 的方案数。

推导一下状态的转移：

- 如果本次选择向上跳，那么台阶数就要增加 $2^j$，同时自增向上跳的次数 $j$，状态表示为 $\text{dfs}(i + 2^j, j + 1, \text{false})$；
- 如果本次选择向下跳，首先要判断上一次 $isDown$ 是否为向下 $true$，如果不是才让台阶数减一，同时记录这一次是下跳，状态表示为 $\text{dfs}(i - 1, j, \text{true})$。

**特别注意**，一旦当前到达了终点，还是可以继续跳跃。题目中指出了 `到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案`！！！

那么，对于当前位置 $i$ 来说，可能是终点 $k$，所以此时的方案数就是 $1$，一定是累加到 $dfs$ 状态中，而不是直接返回！

**状态转移方程** 如下：

$$
\text{dfs}(i,j,\text{isDown}) = \text{dfs}(i + 2^j, j + 1, \text{false}) + \text{dfs}(i - 1, j, \text{true}) + 1
$$

后两者需要进行判断，如果符合条件才进行相加，否则不含这两项。

**递归边界**：如果当前位置 $i$ 在终点的前面 $2$ 个台阶以上，一定跳不回去，表示为 $i > k + 1$，此时就返回 $0$ 表示非法。

**递归入口**： $dfs(1,0,false)$，表示在起点且未进行任何跳跃的状态。

**记忆化**：递归的常用套路，加上 $memo$ 数组用来记忆化，避免重复搜索。它能极大地缩减搜索空间，在树中的表现就是减少很多分支，从而降低复杂度。

递归用到了 $3$ 个参数，所以记忆化数组也可以使用三维。这里使用位运算的方式，将三个维度压缩到一维，即 `(long)(i << 32) | j << 1 | isDown` 的形式。

**补充**：使用数组或者位运算各有好处，一般来说使用位运算去降低空间复杂度，应对空间限制的题以及空间动态变化从而导致超时的题；而数组是常规解，空间小或者时间卡住 $map$ 的时候使用。

本题用 $Map$ 实现来美化代码，而在 $Python$ 中加入 $@cache$ 就能实现自动记忆化。

具体实现时，第三个参数 $isDown$ 使用 $int$ 更方便，方便进行位运算。

```Python
# python
class Solution:
    def waysToReachStair(self, k: int) -> int:
        # 记忆化
        # 当前位于台阶i，向上跳了j次，上一步是否为下跳
        @cache
        def dfs(i, j, isDown):
            if i > k + 1:  # 不能跳回到终点
                return 0
            res = 0
            if i == k:  # 达到终点
                res = 1
            res += dfs(i + (1 << j), j + 1, 0)  # 向上跳
            if not isDown and i > 0:
                res += dfs(i - 1, j, 1)  # 向下跳
            return res
        # 递归入口
        return dfs(1, 0, 0)
```

```java
// java
class Solution {
    private int k;
    private final Map<Long, Integer> memo = new HashMap<>();

    public int waysToReachStair(int k) {
        this.k = k;
        return dfs(1, 0, 0);
    }

    // 当前位于台阶i，向上跳了j次，上一步是否为下跳
    private int dfs(int i, int j, int isDown) {
        if (i > k + 1) {  // 无法跳回到终点
            return 0;
        }
        // 用一个 long 表示状态
        long p = ((long) i << 32) | j << 1 | isDown;
        if (memo.containsKey(p)) { // 之前算过了
            return memo.get(p);
        }
        int res = 0;
        if(i == k)  // 达到终点
            res = 1;
        res += dfs(i + (1 << j), j + 1, 0); // 向上跳
        if (isDown == 0 && i > 0) {
            res += dfs(i - 1, j, 1); // 向下跳
        }
        memo.put(p, res); // 记忆化
        return res;
    }
}
```

由于 $i>k+1$ 就会结束递归，而 $i$ 最小就是由不断的 $2^j$ 累加与 $-1$ 的累减得到，则 $\sum_{0}^{x} 2^j-x>k+1$，所以 $j$ 的上界是 $O(logk)$。 $i$ 受到 $j$ 的影响，只能是 $j=0,1,2...$ 后累加的结果，即有 $O(j)$ 个 $i$。

状态数由 $i,j,isDown$ 共同影响，所以总状态就是 $\mathcal{O}(\log^2 k)$ 个，且单个状态的计算时间是 $O(1)$。总时间 = 状态个数 × 单个状态的计算时间。

- 时间复杂度： $\mathcal{O}(\log^2 k)$，其中 $k$ 是给定终点
- 空间复杂度： $\mathcal{O}(\log^2 k)$，使用多少状态，对应多少空间

---

由于跳跃的台阶数是有规律的，只能是 $2$ 的次方，那本题的关注点就不在于台阶数跨越了多少，而是向上或向下 **跳跃的次数** 是多少。

这时候就能用到组合数学去解题，从而将时间复杂度降低到 $O(1)$。~~果然，算法的尽头是数学。~~

这里不再阐述，感兴趣的小伙伴去隔壁的题解看看吧。

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/solutions/2886826/ji-yi-hua-sou-suo-xiang-xi-chan-shu-tui-3vfcb/)
