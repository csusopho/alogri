[Problem: 3484. 设计电子表格](https://leetcode.cn/problems/design-spreadsheet/description/)

### 方法：模拟 & 简化

题意比较清晰，这里不再赘述。

简单 **思路**：将 `'A12'` 等的每个单元格都作为哈希的键，对应数字作为哈希值。计算公式的值，就是根据 $+$ 切割，找出相应的单元格。

代码如下，已附加详细注释：

```Python
# python
class Spreadsheet:
    def __init__(self, rows: int):
        # 使用哈希表来存储非零的单元格值
        self.cells = {}

    def setCell(self, cell: str, value: int) -> None:
        self.cells[cell] = value

    def resetCell(self, cell: str) -> None:
        # 移除它，因为我们将缺失的单元格视为 0
        if cell in self.cells:
            del self.cells[cell]
    
    def get_operand_value(self, operand: str) -> int:
        # 是否为整数
        if operand.isdigit():
            return int(operand)
        # 否则，它是一个单元格引用
        return self.cells.get(operand, 0)

    def getValue(self, formula: str) -> int:
        # 移除公式开头的 "="
        expression = formula[1:]
        operands = expression.split('+')
        
        # 第一个操作数
        val1 = self.get_operand_value(operands[0])
        # 第二个操作数
        val2 = self.get_operand_value(operands[1])
        
        return val1 + val2
```

```Java
// java
public class Spreadsheet {

    // 使用哈希表来存储非零的单元格值
    private final Map<String, Integer> cells;

    public Spreadsheet(int rows) {
        this.cells = new HashMap<>();
    }

    public void setCell(String cell, int value) {
        // 将单元格引用和值存入哈希表
        this.cells.put(cell, value);
    }

    public void resetCell(String cell) {
        // 从哈希表中移除该单元格
        this.cells.remove(cell);
    }

    private int getOperandValue(String operand) {
        // 尝试将操作数解析为整数
        try {
            return Integer.parseInt(operand);
        } catch (NumberFormatException e) {
            // 如果解析失败，说明它是一个单元格引用
            return this.cells.getOrDefault(operand, 0);
        }
    }

    public int getValue(String formula) {
        // 移除公式开头的 "="
        String expression = formula.substring(1);

        // 按 "+" 分割表达式
        String[] operands = expression.split("\\+");

        // 获取第一个操作数的值
        int val1 = getOperandValue(operands[0]);
        // 获取第二个操作数的值
        int val2 = getOperandValue(operands[1]);

        // 返回两数之和
        return val1 + val2;
    }
}
```

可以不使用 $getOperandValue$ 这个自定义函数，而是整合在代码中，从而简化：

```Python
# python
class Spreadsheet:
    def __init__(self, rows: int):
        self.cells = {}

    def setCell(self, cell: str, value: int) -> None:
        self.cells[cell] = value

    def resetCell(self, cell: str) -> None:
        self.cells.pop(cell,None)

    def getValue(self, formula: str) -> int:
        ans = 0
        for x in formula[1:].split('+'):
            ans += self.cells.get(x,0) if x[0].isupper() else int(x)
        return ans
```

```Java
// java
public class Spreadsheet {

    // 使用哈希表来存储非零的单元格值
    private final Map<String, Integer> cells;

    public Spreadsheet(int rows) {
        this.cells = new HashMap<>();
    }

    public void setCell(String cell, int value) {
        this.cells.put(cell, value);
    }

    public void resetCell(String cell) {
        // 移除它
        this.cells.remove(cell);
    }

    public int getValue(String formula) {
        int ans = 0;
        // 移除公式开头的 "="
        for (String x : formula.substring(1).split("\\+")) {
            // 如果第一个字符是大写字母，则认为是单元格引用
            if (Character.isUpperCase(x.charAt(0))) {
                ans += this.cells.getOrDefault(x, 0);
            } else {
                // 否则，它是一个整数
                ans += Integer.parseInt(x);
            }
        }
        return ans;
    }
}
```

- 时间复杂度：
  - $init$ 函数： $O(1)$
  - $setCell$ 函数： $O(1)$
  - $resetCell$ 函数： $O(1)$
  - $getValue$ 函数： $O(L)$，其中 $L$ 是串 $formula$ 的长度
- 空间复杂度： $O(n)$，其中 $n$ 是最大 $set$ 次数

---

### 数组

我们也可以使用 **数组替换** 哈希，行数为 $rows$，列数为 $26$。比如说，单元格 `D15` 就是在数组的第 $14$ 行第 $3$ 列。

如此设置，更符合企业级规范（题目的严格形式），重点在于理解思路。

代码如下，已附加详细注释：

```Python
# python
class Spreadsheet:
    def __init__(self, rows: int):
        self.grid = [[0 for _ in range(26)] for _ in range(rows)]

    def parse_cell(self, cell: str) -> tuple[int, int]:
        # 将单元格字符串解析为行和列的 0-based 索引
        col_index = ord(cell[0]) - ord('A')
        row_index = int(cell[1:]) - 1
        return row_index, col_index

    def setCell(self, cell: str, value: int) -> None:
        row_idx, col_idx = self.parse_cell(cell)
        # 直接设置
        self.grid[row_idx][col_idx] = value

    def resetCell(self, cell: str) -> None:
        row_idx, col_idx = self.parse_cell(cell)
        # 重置回 0
        self.grid[row_idx][col_idx] = 0
    
    def get_operand_value(self, operand: str) -> int:
        # 检查操作数是否为整数
        if operand.isdigit():
            return int(operand)
        
        # 否则，它是一个单元格引用
        row_idx, col_idx = self.parse_cell(operand)
        return self.grid[row_idx][col_idx]

    def getValue(self, formula: str) -> int:
        # 移除公式开头的 "="
        expression = formula[1:]
        operands = expression.split('+')
        
        # 第一个操作数
        val1 = self.get_operand_value(operands[0])
        # 第二个操作数
        val2 = self.get_operand_value(operands[1])
        
        return val1 + val2
```

```Java
// java
public class Spreadsheet {

    private final int[][] grid;

    public Spreadsheet(int rows) {
        // 初始化一个二维数组，默认为0
        this.grid = new int[rows][26];
    }

    private int[] parseCell(String cell) {
        // 'A' -> 0, 'B' -> 1, ...
        int colIndex = cell.charAt(0) - 'A';
        int rowIndex = Integer.parseInt(cell.substring(1)) - 1;
        return new int[]{rowIndex, colIndex};
    }

    public void setCell(String cell, int value) {
        int[] indices = parseCell(cell);
        int rowIndex = indices[0];
        int colIndex = indices[1];
        // 直接设置
        this.grid[rowIndex][colIndex] = value;
    }

    public void resetCell(String cell) {
        int[] indices = parseCell(cell);
        int rowIndex = indices[0];
        int colIndex = indices[1];
        // 重置回 0
        this.grid[rowIndex][colIndex] = 0;
    }

    private int getOperandValue(String operand) {
        // 检查操作数是否为整数
        try {
            return Integer.parseInt(operand);
        } catch (NumberFormatException e) {
            // 如果解析失败，则它是一个单元格引用
            int[] indices = parseCell(operand);
            return this.grid[indices[0]][indices[1]];
        }
    }

    public int getValue(String formula) {
        // 移除公式开头的 "="
        String expression = formula.substring(1);
        String[] operands = expression.split("\\+");

        // 第一个操作数
        int val1 = getOperandValue(operands[0]);
        // 第二个操作数
        int val2 = getOperandValue(operands[1]);

        return val1 + val2;
    }
}
```

- 时间复杂度：
  - $init$ 函数： $O(1)$
  - $setCell$ 函数： $O(1)$
  - $resetCell$ 函数： $O(1)$
  - $getValue$ 函数： $O(L)$，其中 $L$ 是串 $formula$ 的长度
- 空间复杂度： $O(n\times |\Sigma|)$，其中 $|\Sigma|=26$ 表示字符集大小

从上往下，三种方法的时间逐渐增大，从 $87ms\to 313ms$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/design-spreadsheet/solutions/3786448/mo-ni-zhi-jie-ha-xi-jian-hua-shu-zu-xing-djn5/)
