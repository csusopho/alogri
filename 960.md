[Problem: 960. 删列造序 III](https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/description/)

### 方法：DP & 优化

删除列，让每一行都保持递增。比如示例 $1$ 删除后是 $bc,az$，每个串递增，但是串之间无所谓。从连续的串中删除，剩下的是子序列。

**转化思路**：删除最少列，等价保留最多列。

用符号表示为，找到一个最大的列索引集合 $\{j_1, j_2, \dots, j_k\}$，使得 $strs$ 中的任意一行字符串 $s$，都有 $s[j_1]\leq s[j_2]\leq \dots\leq s[j_k]$ 成立。

这样来看，问题就非常类似「**最长递增子序列** $LIS$」。

在传统 $LIS$ 问题中，比较单个数组中的两个数字 $arr[i]$ 和 $arr[j]$。而在本题中，比较两个 **列向量**，满足 **所有行** 的 $s[i] \le s[j]$。

总结：相同位置的最长递增子序列（多行共同的 $LIS$）。

**定义** $dp[j]$ 表示以第 $j$ 列结尾时，能够保留的最大列数。

对于每一个当前列 $j$，遍历它之前的列 $i$，其中 $0 \le i < j$。只有当第 $i$ 列和第 $j$ 列满足：**在所有行中**，第 $i$ 列的字符都小于或等于第 $j$ 列的字符时，第 $j$ 列才可以接到第 $i$ 列后面。

因此，得到 **状态转移方程：**

$$
dp[j] = \max(dp[j], dp[i] + 1)
$$

不确定最长序列以哪一列结尾，所以 $max(dp)$ 表示最大的保留列数，答案 $m- \max(dp)$。

**初始化** $dp[j]=1$ 表示每一列可以单独保留。

注意，普通的 $LIS$ 可以使用贪心+二分优化，这里不行！因为列与列之间不是全序关系，可能第 $i$ 列在某些行大于 $j$，而在另一些行小于 $j$，这种 “多准则” 判定导致我们无法维护一个单调的替换列表。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        m = len(strs[0])
        # dp[j] 表示以第 j 列作为结尾时，最多可以保留的列数
        dp = [1] * m
        
        # 当前结尾列
        for j in range(m):
            # 之前的保留列
            for i in range(j):
                
                # 检查是否所有行都满足：第 i 列字符 <= 第 j 列字符
                is_valid = True
                for r in range(n):
                    if strs[r][i] > strs[r][j]:
                        is_valid = False
                        break
                
                # 如果满足条件，尝试更新以 j 结尾的最大长度
                if is_valid:
                    if dp[i] + 1 > dp[j]:
                        dp[j] = dp[i] + 1
        
        # 最大保留列数
        max_keep = max(dp)
        # 最小删除次数 = 总列数 - 最大保留列数
        return m - max_keep
```

```Java
// java
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs.length;
        int m = strs[0].length();
        // dp[j] 表示以第 j 列作为结尾时，最多可以保留的列数
        int[] dp = new int[m];
        Arrays.fill(dp, 1);
        
        // 当前结尾列
        for (int j = 0; j < m; j++) {
            // 之前的保留列
            for (int i = 0; i < j; i++) {
                
                // 检查是否所有行都满足：第 i 列字符 <= 第 j 列字符
                boolean is_valid = true;
                for (int r = 0; r < n; r++) {
                    if (strs[r].charAt(i) > strs[r].charAt(j)) {
                        is_valid = false;
                        break;
                    }
                }
                
                // 如果满足条件，尝试更新以 j 结尾的最大长度
                if (is_valid) {
                    if (dp[i] + 1 > dp[j]) {
                        dp[j] = dp[i] + 1;
                    }
                }
            }
        }
        
        // 最大保留列数
        int max_keep = 0;
        for (int val : dp) {
            if (val > max_keep) max_keep = val;
        }
        // 最小删除次数 = 总列数 - 最大保留列数
        return m - max_keep;
    }
}
```

- 时间复杂度： $O(m^2\times n)$，其中 $n$ 是数组 $strs$ 的长度，每个串长为 $m$
- 空间复杂度： $O(m)$，表示数组 $dp$ 的大小

---

### 优化

观察上面的代码，发现每个 $dp[j]$ 在循环内只会存储一个最大值，后续再也不会更新之前的 $dp[i]$。因此，我们没必要使用 $dp$ 数组形式，而是换成 $dp$ 列表。

动态增长 $dp$ 列表，并使用一个变量 $mx$ 代表全局最大，每次计算出局部最大值 $dp[j]$ 后去更新 $mx$，这样无需最后加一步 $max(dp)$，稍微提升速度。

代码如下，已附加注释，实测 $Python$ 代码耗时 $40ms$，超过 $97.56\%$：

```Python
# python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs[0])
        # dp_list 存储每一列作为结尾时，能保留的最大列数
        dp_list = []
        # 全局最大保留列数
        max_keep = 0
        
        # 当前列
        for i in range(n):
            max_prev_len = 0
            
            # 之前所有列
            for j in range(len(dp_list)):
                # 检查所有行
                for row in strs:
                    if row[j] > row[i]:
                        break
                else:
                    # 如果所有行都合法，记录下之前列中最大的 DP 值
                    if dp_list[j] > max_prev_len:
                        max_prev_len = dp_list[j]
            
            # 当前列的最大长度 = 最佳前驱长度 + 1
            curr_best = max_prev_len + 1
            dp_list.append(curr_best)
            
            # 更新
            if curr_best > max_keep:
                max_keep = curr_best

        return n - max_keep
```

```Java
// java
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs[0].length();
        // dp_list 存储每一列作为结尾时，能保留的最大列数
        List<Integer> dp_list = new ArrayList<>();
        // 全局最大保留列数
        int max_keep = 0;
        
        // 当前列
        for (int i = 0; i < n; i++) {
            int max_prev_len = 0;
            
            // 之前所有列
            for (int j = 0; j < dp_list.size(); j++) {
                // 检查所有行
                boolean isValid = true;
                for (String row : strs) {
                    if (row.charAt(j) > row.charAt(i)) {
                        isValid = false;
                        break;
                    }
                }
                
                if (isValid) {
                    // 如果所有行都合法，记录下之前列中最大的 DP 值
                    if (dp_list.get(j) > max_prev_len) {
                        max_prev_len = dp_list.get(j);
                    }
                }
            }
            
            // 当前列的最大长度 = 最佳前驱长度 + 1
            int curr_best = max_prev_len + 1;
            dp_list.add(curr_best);
            
            // 更新
            if (curr_best > max_keep) {
                max_keep = curr_best;
            }
        }

        return n - max_keep;
    }
}
```

- 时间复杂度： $O(m^2\times n)$
- 空间复杂度： $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/solutions/3862678/shuang-jie-tong-bu-jin-xing-de-di-zeng-z-j8sq/)
