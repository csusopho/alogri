[Problem: 3240. 最少翻转次数使二进制矩阵回文 II](https://leetcode.cn/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-ii/description/)

### 方法：模拟

题意：给定一个矩阵，希望让它的所有行 **和** 所有列变成回文，并且 $1$ 的数量能被 $4$ 整除。矩阵中只有 $0$ 和 $1$，一次操作能将两个数字相互反转，求问最小操作次数。

### 对称

暂且不考虑被 $4$ 整除，先处理回文。

**回文** 是指正着读和反着读都相同的词语、句子或数字。对于本题来说，目标就是让行或列变成 $[1,0,1]$ 或者 $[1,1,1]$ 等形式。

如何让一行的所有数字变成回文形式？**相向** 双指针。

假定回文数组为 $arr$，长度为 $n$。如果在数组的正中间立一根轴，回文数字呈现出一个特点 —— 中轴对称，也即 $arr[i]=arr[n-i-1]$。

那么，对于任意一个数组，只需要它的左半部分与右半部分对称，它就是一个回文数组。

本题是二维数组，怎么让行和列都回文？假设数组 $arr$ 一共 $n$ 行 $m$ 列。

对于元素 $arr[i][j]$ 来说，同一行的对称位置是 $arr[i][m-j-1]$，同一列的对称位置是 $arr[n-i-1][j]$，对角位置是 $arr[n-i-1][m-j-1]$。

它们四个相互对称，也就是说，想要让行和列同时回文，这 $4$ 个值必须相同（四指针）。

### 特殊情况

将上面的过程进行类比，可以想象成 “剥洋葱”。

- 先处理最外层的第 $0,n-1$ 行，以及第 $0,m-1$ 列，让这 $4$ 个一维数组相互对称；
- 然后处理次外层的第 $1,n-2$ 行，以及第 $1,m-2$ 列，再让它们相互对称；
- $\dots$

一圈一圈的处理过程，就好似 “剥洋葱” 般一层一层向内。

注意到，这里的 “一圈” 同时处理两行两列。假如二维数组 $grid$ 是奇数行，或者奇数列，就会剩下多余的一行或者一列没有处理。

就像示例 $2$，处理完一圈后，剩下的中间第 $1$ 行没有处理。

此时，就退化成了 [前一题](https://leetcode.cn/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/description/)，也就是单独处理一维数组。不过，需要考虑题目中提到的 “被 $4$ 整除” 这个限制条件。

### 分析

“一圈” 同时处理四个角，对称的四个位置数值一定相等，天然被 $4$ 整除。不过，单独的行或列，处理后的结果就不一定。

双指针移动时，对称的两个位置只有 $0,0$、 $0,1(1,0)$、 $1,1$ 三种情况，它们相加后的值分别为 $0,1,2$。

我们用一个数组 $cnt$ 记录这些数据有几对。其中， $cnt[0]$ 表示相同的 $0$ 的数对个数， $cnt[1]$ 表示 $0,1$ 的数对个数， $cnt[2]$ 表示相同的 $1$ 的数对个数。

毋庸置疑，想要回文，肯定会对相加为 $1$ 的情况进行操作。同时，如果想要累加和被 $4$ 整除，没准也要处理 $0$ 或 $2$ 的数对。

怎么协调？**分类讨论**。

先明确一点，数对为 $0$ 或 $2$ 的所有组，对它们进行累加得到 $sum$，而 $sum$ 整除 $4$ 后，一定余 $0$ 或 $2$，将这个余数记作 $x$。

- 如果 $x=0$，那么只需要让所有的 $0,1$ 数对的数都变成 $0$，那么总和一定能整除 $4$，操作次数为 $cnt[1]$；
- 如果 $x=2$，也就意味着多了两个 $1$。假如不存在 $0,1$ 数对，那么肯定是让某一组 $1$ 全变 $0$，解决掉这个问题，总和就能被 $4$ 整除，操作次数为 $cnt[2]\times 2$ % $4$；
- 如果 $x=2$，且存在 $0,1$ 数对时，最简单的办法就是增加两个 $1$ 与多余的两个 $1$ 进行组合。也即，让一组 $0,1$ 全变 $1$，剩下的其他 $0,1$ 组全部变 $0$，操作次数为 $cnt[1]$。

将这些情况汇总，得出下面的结论：

- 如果存在 $0,1$ 数对，操作次数为 $cnt[1]$
- 如果不存在 $0,1$ 数对，操作次数为 $cnt[2]\times 2$ % $4$

**答疑**：为什么余数 $x=2$ 时，不能让某一组 $0$ 变 $1$ 呢？

因为不确定是否存在数对为 $0$ 的组，所以让 $1$ 变 $0$ 是最稳妥的操作。同时，即使存在数对为 $0$ 的组，让 $0$ 变 $1$ 需要的操作次数也是乘 $2$ 后模 $4$，答案是相同的。

**注意**：在上面的推导中，每次操作都是 *成对* 进行；如果不太清楚答案的由来，请仔细看看描述，到底使用了几个数字。

### 总结

**做法**：先进行 “圈处理”，每次处理 $4$ 个对称数字，直至遍历完外层的所有数；接着单独处理奇数行或列，累加 $cnt$ 数组，最后汇总操作次数。

用位运算优化，右移 $>>1$ 或者整除 $/2$ 进行对称；与运算 & $1$ 进行奇数判断。

**补充**：要记得处理正中间的那个数字。比如，矩阵是 $3\times 3$ 规格，一圈处理后会剩下一个数字 $arr[1][1]$。如果是 $0$ 就不管，如果是 $1$ 就反转。

实现上面的推导过程，代码如下：

```Python
# python
class Solution:
    def minFlips(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        ans = 0
        for i in range(n // 2):
            for j in range(m // 2):
                one = grid[i][j] + grid[n - i - 1][j] + \
                      grid[i][m - j - 1] + grid[n - i - 1][m - j - 1]
                ans += min(one, 4 - one)
        
        # 统计相加后的数字
        # cnt[0]表示相同的0的数对，cnt[1]表示不同的数对，cnt[2]表示相同的1的数对
        cnt = [0] * 3
        if n & 1:  # 中间这一行
            for j in range(m // 2):
                cnt[grid[n // 2][j] + grid[n // 2][m - j - 1]] += 1
        if m & 1:  # 中间这一列
            for i in range(n // 2):
                cnt[grid[i][m // 2] + grid[n - i - 1][m // 2]] += 1
        if n & 1 and m & 1:  # 正中间这个数必须是0
            ans += grid[n // 2][m // 2]

        return ans + (cnt[1] if cnt[1] else cnt[2] * 2 % 4)
```

```Java
// java
class Solution {
    public int minFlips(int[][] grid) {
        int n = grid.length, m = grid[0].length;
        int ans = 0;

        // 处理对称位置
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < m / 2; j++) {
                int one = grid[i][j] + grid[n - i - 1][j] +
                          grid[i][m - j - 1] + grid[n - i - 1][m - j - 1];
                ans += Math.min(one, 4 - one);
            }
        }

        // 统计相加后的数字
        // cnt[0] 表示相同的 0 的数对，cnt[1] 表示不同的数对，cnt[2] 表示相同的 1 的数对
        int[] cnt = new int[3];

        if ((n & 1) == 1) { // 中间这一行
            for (int j = 0; j < m / 2; j++) {
                cnt[grid[n / 2][j] + grid[n / 2][m - j - 1]]++;
            }
        }
        if ((m & 1) == 1) { // 中间这一列
            for (int i = 0; i < n / 2; i++) {
                cnt[grid[i][m / 2] + grid[n - i - 1][m / 2]]++;
            }
        }
        if ((n & 1) == 1 && (m & 1) == 1) { // 正中间这个数必须是 0
            ans += grid[n / 2][m / 2];
        }

        // 根据统计结果更新答案
        ans += (cnt[1] > 0) ? cnt[1] : (cnt[2] * 2 % 4);

        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n$ 和 $m$ 分别为矩阵 $grid$ 的行数和列数，且 $n\times m\leq 2\times 10^5$，一次遍历矩阵，两次一维遍历
- 空间复杂度： $O(1)$，仅用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-ii/solutions/2990315/ji-shu-bo-yang-cong-fa-tui-dao-fen-lei-t-e0z4/)
