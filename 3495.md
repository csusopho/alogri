[Problem: 3495. 使数组元素都变为零的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/description/)

### 方法：前缀和 + 分块

注意，每个 $\texttt{queries[i]}$ 表示了从 $[l,r]$ 的 **所有** 元素，也即

$$
\texttt{nums} = [l, l+1, \dots, r]
$$

我们需要把 $\texttt{nums}$ 中所有数变为 $0$。

对于 **单个整数** $x$，需要的操作次数等于把它不断除以 $4$ 直到 $0$ 的步数：

$$
f(x) =
\begin{cases}
0 & x = 0 \\
1 + f(\lfloor x/4 \rfloor) & x > 0
\end{cases}
$$

例如：

$$
x=1，则 \quad 1 \to 0 \quad \text{需要 1 步}\\
x=5，则 \quad 5 \to 1 \to 0 \quad \text{需要 2 步}\\
x=20，则 \quad 20 \to 5 \to 1 \to 0 \quad \text{需要 3 步}
$$

因此，如果逐个数独立处理，总操作次数为

$$
\sum_{x=l}^{r} f(x)
$$

因为一次操作可以处理两个数，例如：

$$
a=5, \ f(5)=2; \quad b=20, \ f(20)=3.
$$

如果独立计算，则总共需要 $2+3=5$ 步。但是我们可以将它们配对，一起操作：

$$
(5,20) \to (1,5) \to (0,1) \to (0,0),
$$

只需 $3$ 步。结果正好是

$$
\left\lceil \tfrac{2+3}{2} \right\rceil = 3
$$

一次操作可以 “消耗” 两个数的 $1$ 步需求。已知总需求为 $S=\sum_{x=l}^{r} f(x)$，而最多一次能消耗 $2$，所以 **总操作次数** 就是：

$$
\left\lceil \frac{\sum_{x=l}^r f(x)}{2} \right\rceil
$$

本题的 **最终结果**：套用上述公式处理每一个 $query$，然后对所有 $\texttt{queries}$ 求和。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        # --- 辅助函数 ---
        # 计算单个整数 x 变成 0 的最少操作次数
        def steps_to_zero(x):
            steps = 0
            while x > 0:
                x //= 4
                steps += 1
            return steps

        ans = 0

        # --- 遍历每个查询 ---
        for l, r in queries:
            prefix = 0  # 前缀和

            # 计算该范围内所有元素的总步数
            for num in range(l, r + 1):
                prefix += steps_to_zero(num)

            # 每次操作可以同时处理两个元素
            # 所以总操作次数 = ceil(总步数 / 2)
            ops = math.ceil(prefix / 2)

            ans += ops

        return ans
```

假设 $\texttt{queries}$ 的长度是 $q$，最大右端点是 $R = \max(r_i)$，而每个区间的平均长度为 $k$。则整体复杂度为：

$$
O\Bigg(\sum_{i=1}^{q} (r_i - l_i + 1) \cdot \log r_i\Bigg)\approx O(q \cdot k \cdot \log R)
$$

本题限定 $q\leq 10^5$ 而 $r_i\leq 10^9$，所以会超时，卡在 $591/646$ 样例。

---

### 分块

每次的操作都是 $x \mathbin{/\!/} 4$，所以 $\text{steps}(x)$ 就是 $x$ 的 “以 $4$ 为底的对数高度”。用公式表示单次操作：

$$
\text{steps}(x) =
\begin{cases}
0, & x = 0 \\
1 + \text{steps}(\lfloor x/4 \rfloor), & x > 0
\end{cases}
$$

这等价于：

$$
\text{steps}(x) = 1 + \lfloor \log_4(x) \rfloor
$$

举例验证：

- $x=1，而 \log_4(1)=0，则有 1+0=1$
- $x=5，而 \log_4(5)=1.x，且 \lfloor \cdot \rfloor=0，则有 1+1=2$
- $x=20，而 \log_4(20)=2.x，且 \lfloor \cdot \rfloor=0，则有 1+2=3$

所以，公式能 **转变** 为：

$$
\text{steps}(x) =
\begin{cases}
0, & x = 0\\
\lfloor \log_4(x) \rfloor + 1, & x > 0
\end{cases}
$$

在本题中，我们要计算

$$
\sum_{x=l}^{r} \text{steps}(x)
$$

根据上面的公式，可以得知 $\text{steps}(x)$ 只在区间 $[4^k, 4^{k+1}-1]$ 内是 **常数** $k+1$。例如：

- $[1,3] \rightarrow \text{steps}=1$
- $[4,15] \rightarrow \text{steps}=2$
- $[16,63] \rightarrow \text{steps}=3$

所以我们可以 **分块计算**，不必逐个遍历。

根据 **前缀和** 的知识可知，区间 $[l,r]$ 是由区间 $[1,r]$ 减去 $[1,l-1]$ 得到。具体原理及做法，可以看看我的 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

那么，我们在计算 $[1,n]$ 的总步数时，

- 从小到大遍历 $k=0..\lfloor \log_4(n) \rfloor$
- 当前块为 $[4^k, \min(4^{k+1}-1,n)]$，左右边界分别记为 $l,r$，它包含元素个数为 $r-l+1$，这一块的 $step$ 固定为 $k+1$
- 则当前块的总操作次数 = 个数 $\times$ 步数 = $(r-l+1)\times (k+1)$

将上述方法包装为 $calcPrefix$，利用前缀和，可以快速计算出

$$
\sum_{x=l}^{r} \text{steps}(x) = \text{calcPrefix}(r) - \text{calcPrefix}(l-1)
$$

那么，最终的操作次数为

$$
\left\lceil \frac{\sum \text{steps}}{2} \right\rceil
$$

代码如下，已附加注释：

```Python
# python
class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        # 计算从 1 到 n 的总步数
        # 在 [4^k, 4^(k+1)-1] 区间内 steps(x) 恒为 (k+1)
        # 按区间分块进行累加
        def calc_prefix(n):
            total = 0
            k = 0
            # 遍历每个 log4 区间
            while (1 << (2 * k)) <= n:   # 1<<(2k) 等价于 4^k
                left = 1 << (2 * k)      # 区间起点 4^k
                right = min((1 << (2 * (k + 1))) - 1, n)  # 区间终点
                count = right - left + 1   # 区间内元素个数
                total += count * (k + 1)     # 贡献 = 个数 * 步数
                k += 1
            return total

        ans = 0

        for l, r in queries:
            # 区间和 = 前缀和差
            pre = calc_prefix(r) - calc_prefix(l-1)
            # 每次操作可处理两个 → 向上取整除以2
            ops = (pre + 1) // 2
            ans += ops

        return ans
```

```Java
// java
class Solution {
    public long minOperations(int[][] queries) {
        long ans = 0;

        // --- 遍历每个查询 ---
        for (int[] query : queries) {
            int l = query[0];
            int r = query[1];
            
            // 区间和 = 前缀和差
            long pre = calcPrefix(r) - calcPrefix(l - 1);
            
            // 每次操作可处理两个 → 向上取整除以2
            long ops = (pre + 1) / 2;
            ans += ops;
        }

        return ans;
    }

    // --- 辅助函数 ---
    // 计算从 1 到 n 的总步数
    // 在 [4^k, 4^(k+1)-1] 区间内 steps(x) 恒为 (k+1)
    // 按区间分块进行累加
    private long calcPrefix(int n) {
        long total = 0;
        int k = 0;
        // 遍历每个 log4 区间
        while ((1L << (2 * k)) <= n) {   // 1<<(2k) 等价于 4^k
            long left = 1L << (2 * k);    // 区间起点 4^k
            long right = Math.min((1L << (2 * (k + 1))) - 1, n);  // 区间终点
            long count = right - left + 1;   // 区间内元素个数
            total += count * (k + 1);        // 贡献 = 个数 * 步数
            k += 1;
        }
        return total;
    }
}
```

- 时间复杂度： $O(q\times log_4R)$，其中 $q$ 为数组 $queries$ 的长度，而 $R$ 为每个查询的区间长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/solutions/3774126/shu-xue-qian-zhui-he-chao-shi-fen-kuai-y-hwq5/)
