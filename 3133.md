[Problem: 3133. 数组最后一个元素的最小值](https://leetcode.cn/problems/minimum-array-end/description/)

### 方法：位运算+贪心

题意：让 $n$ 个数相与，最终结果为 $x$；这 $n$ 个数递增，求最后那个数最小是多少。

相与 $AND$ 的特点是什么？只有 $1$ & $1=1$，其余的 & 结果都是 $0$。

从二进制角度看，为了让所有数相与的结果为 $x$，那么 $x$ 的二进制中的每一位 $1$，这些数的对应位置也必须是 $1$。

一旦某个数的的第 $i$ 位是 $0$，而 $x$ 的第 $i$ 位是 $1$，那么相与后得出的那个数，第 $i$ 位一定是 $0$，不符合要求。

通过上面的论述，可以得知，这 $n$ 个数中的每个数都必须满足： $x$ 中的 $1$ 都包含，只看 $1$ 的情况下，就是 $x$ 的 **超集**！

对于 $x$ 中的 $0$ 位置，这些数就可以随机发挥，只要最后相与结果为 $0$。上面说到了超集，那就拿示例一举例。

如果 $nums=[4,5,6]$，也就是 $[100,101,110]$，而 $x=4=100$。数组中的三个数都满足了第 $2$ 位填 $1$ 这个要求，其他位随机填成 $00,01,10$。

上面的数有什么规律？在确保每个数都是 $x$ 的超集的前提下，示例一中的最优解的其他位是 $00,01,10$ 这种递增形式。

这时候，就引出了 **贪心** 思路：每个数都固定 $x$ 中 $1$ 的那些位置，其他位置从前往后排列成 $00000,00001,00010,00011,00100...$ 这种形式。

为什么这种思路正确？必须明确一点，当 $x$ 中 $1$ 的那些位置固定时，其他位置是随机填。题目要求这些数必须递增，如果第一个数填了 $0010$，那么第二个数一定是大于等于 $0011$，同理后面所有数。

也即，只看这些位置时，所有数是上面排列中的 **子序列**！那就很清晰了，选择长为 $n$ 的 *递增* 子序列时，为了让最后一个数最小，必须尽量让它们都“向前挤”。最优方案就是截取最前面的长为 $n$ 的子数组，也就达到了理论最小。

啰嗦了这么久，得到一个 **结论**：这 $n$ 个数的其他位置，贪心地排列成 $00,01,10$ 的形式。

那么，这 $n$ 个数中，第一个数就是 $x$，毕竟固定了 $1$ 的位置，而其他位置都填 $0$，不就是 $x$ 本身嘛！

直接暴力枚举 $n$ 个数，代码如下。不断 $+1$，得到的就是递增序列；用 “或 $|$ ”运算，保留住 $x$ 和当前数中的 $1$。

```Python
# python
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        ans = x  # 初始为 x
        # 不断枚举
        for _ in range(n - 1):
            ans = ans + 1
            ans = ans | x
        return ans
```

```Java
// java
class Solution {
    public long minEnd(int n, int x) {
        long ans = x;  // 初始为 x
        // 不断枚举
        for (int i = 0; i < n - 1; i++) {
            ans = ans + 1;
            ans = ans | x;
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n\leq10^8$，勉强能过
- 空间复杂度： $O(1)$，仅用常数个额外空间

---

### 优化

题目只要求最后一个数，没必要一个一个向后找。通过上面的论述，我们已经知道，截取的是前 $n$ 个数，而这个序列递增，换算成数字就是 $0,1,2...$，所以最后一个数就对应 $n-1$。

现在，只需要将 $n-1$ 的二进制“塞到” $x$ 中的其他位置，也就是那些没固定为 $1$ 的位置，即 $x$ 中 $0$ 的位置。

当然，如果将 $n-1$ 中的 $0$ 填入到 $x$ 中的 $0$，那就没有意义。所以，具体实现时，从前往后枚举 $n-1$ 的二进制，当前位为 $1$ 时，填到对应位置。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        # 位运算
        n -= 1  # 填入n-1
        i = 0  # 当前位
        while n:  # 枚举直到n-1遍历完
            # 找到x中0的位置
            while n and x & (1 << i):
                i += 1
            # 将n-1的对应位置填入该位置
            x |= (n & 1) << i
            # 更新
            n >>= 1
            i += 1
        return x
```

```java
// java
class Solution {
    public long minEnd(int n, int x) {
        // 位运算
        n -= 1;  // 填入n-1
        int i = 0;  // 当前位
        while (n > 0) {  // 枚举直到n-1遍历完
            // 找到x中0的位置
            while (n > 0 && (x & (1 << i)) != 0) {
                i++;
            }
            // 将n-1的对应位置填入该位置
            x |= (n & 1) << i;
            // 更新
            n >>= 1;
            i++;
        }
        return x;
    }
}
```

- 时间复杂度： $O(logx+logn)$，其中 $x$ 和 $k$ 的范围题目已给定
- 空间复杂度： $O(1)$，仅用常数个额外空间


如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-array-end/solutions/2889071/wei-yun-suan-cong-bao-li-on-kai-shi-you-8yezw/)
