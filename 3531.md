[Problem: 3531. 统计被覆盖的建筑](https://leetcode.cn/problems/count-covered-buildings/description/)

### 方法：哈希

题意很清晰，如果暴力双 $for$，检查上下左右四个方向，则复杂度为 $O(m^2)$。由于题目限制 $m\leq 10^5$，所以遗憾超时，卡在 $616/634$ 样例。~~不要问我为什么知道~~

如何优化？仔细观察，一个建筑 $(x,y)$ 被覆盖，等价于：

- 在第 $x$ 行中，它是既非最左也非最右的建筑；
- 在第 $y$ 列中，它是既非最上也非最下的建筑。

因此 **预处理**，记录每一行出现的最小和最大 $y$ 值，每一列出现的最小和最大 $x$ 值。

**做法**：使用四个哈希表，分别记录每行的 `min/max` 列坐标，和每列的 `min/max` 行坐标。

处理完成后，直接查表，判断当前建筑是否在 $[min,max]$ 范围内。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:
        # 每行的最小/大列索引 y
        row_min = defaultdict(lambda: float('inf'))
        row_max = defaultdict(lambda: float('-inf'))
        
        # 每列的最小/大行索引 x
        col_min = defaultdict(lambda: float('inf'))
        col_max = defaultdict(lambda: float('-inf'))

        # 构建最值映射
        for x, y in buildings:
            # 更新行信息
            if y < row_min[x]: row_min[x] = y
            if y > row_max[x]: row_max[x] = y
            
            # 更新列信息
            if x < col_min[y]: col_min[y] = x
            if x > col_max[y]: col_max[y] = x

        ans = 0
        # 检查是否在水平/垂直的最值之间
        for x, y in buildings:
            row_covered = row_min[x] < y < row_max[x]
            col_covered = col_min[y] < x < col_max[y]
            
            if row_covered and col_covered:
                ans += 1
         
        return ans
```

```Java
// java
class Solution {
    public int countCoveredBuildings(int n, int[][] buildings) {
        // 每行的最小/大列索引 y
        Map<Integer, Integer> rowMin = new HashMap<>();
        Map<Integer, Integer> rowMax = new HashMap<>();
        
        // 每列的最小/大行索引 x
        Map<Integer, Integer> colMin = new HashMap<>();
        Map<Integer, Integer> colMax = new HashMap<>();

        // 构建最值映射
        for (int[] b : buildings) {
            int x = b[0];
            int y = b[1];
            
            // 更新行信息
            rowMin.put(x, Math.min(rowMin.getOrDefault(x, 10001), y));
            rowMax.put(x, Math.max(rowMax.getOrDefault(x, -1), y));
            
            // 更新列信息
            colMin.put(y, Math.min(colMin.getOrDefault(y, 10001), x));
            colMax.put(y, Math.max(colMax.getOrDefault(y, -1), x));
        }

        int ans = 0;
        // 检查是否在水平/垂直的最值之间
        for (int[] b : buildings) {
            int x = b[0];
            int y = b[1];
            
            boolean rowCovered = rowMin.get(x) < y && y < rowMax.get(x);
            boolean colCovered = colMin.get(y) < x && x < colMax.get(y);
            
            if (rowCovered && colCovered) {
                ans++;
            }
        }
         
        return ans;
    }
}
```

- 时间复杂度： $O(m)$，其中 $m$ 是数组 $buildings$ 的大小，两次遍历
- 空间复杂度： $O(m)$，表示四个哈希的大小

---

### 数组

将哈希 $Map$ 替换为数组哈希，速度能提升一大截。正好有小伙伴好奇，本题的 $n$ 好像没有用过？ $n$ 的实际含义是坐标的数值上界，因此能作为开辟 **数组大小** 的参考。

整体逻辑不变，两次遍历，代码如下：

```Python
# python
class Solution:
    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:
        row_min = [n + 1] * (n + 1)
        row_max = [0] * (n + 1)
        col_min = [n + 1] * (n + 1)
        col_max = [0] * (n + 1)
        
        for x,y in buildings:
            if x < row_min[y]: row_min[y] = x
            if x > row_max[y]: row_max[y] = x
            if y < col_min[x]: col_min[x] = y
            if y > col_max[x]: col_max[x] = y
        
        ans = 0
        for x,y in buildings:
            if row_min[y] < x < row_max[y] and col_min[x] < y < col_max[x]:
                ans += 1
        
        return ans
```

```Java
// java
class Solution {
    public int countCoveredBuildings(int n, int[][] buildings) {
        int[] rowMin = new int[n + 1];
        int[] rowMax = new int[n + 1];
        int[] colMin = new int[n + 1];
        int[] colMax = new int[n + 1];
        
        // 数组默认值为0，所以初始化两个最小数组
        Arrays.fill(rowMin, n + 1);
        Arrays.fill(colMin, n + 1);
        
        for (int[] b : buildings) {
            int x = b[0];
            int y = b[1];
            
            if (x < rowMin[y]) rowMin[y] = x;
            if (x > rowMax[y]) rowMax[y] = x;
            if (y < colMin[x]) colMin[x] = y;
            if (y > colMax[x]) colMax[x] = y;
        }
        
        int ans = 0;
        for (int[] b : buildings) {
            int x = b[0];
            int y = b[1];
            
            if (rowMin[y] < x && x < rowMax[y] && colMin[x] < y && y < colMax[x]) {
                ans++;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(m+n)$，数组初始化需要 $O(n)$ 时间
- 空间复杂度： $O(n)$，表示四个数组的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-covered-buildings/solutions/3854356/shuang-jie-ji-lu-xing-lie-minmaxsuo-yin-f2lba/)
