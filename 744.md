[Problem: 744. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/)

### 二分

数组 $letters$ 升序，在其中寻找第一个大于 $target$ 的字符。

暴力遍历的解法非常直观，这里不再阐述。数组具有 **单调性**，所以能使用二分。有序数组中查找特定元素，联想到二分。

这里就复习一下二分的 **两种写法**：闭区间二分、开区间二分。

闭区间写法如下，已附加注释：

```Python
# python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        l, r = 0, len(letters) - 1
        
        # 如果目标字符不小于数组中的所有字符，返回首字母
        if letters[r] <= target:
            return letters[0]
        
        # 闭区间二分
        while l <= r:
            mid = l + (r - l) // 2
            if letters[mid] <= target:
                l = mid + 1
            else:
                r = mid - 1
        
        # l=r+1，l是目标
        return letters[l]
```

```Java
// java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int l = 0, r = letters.length - 1;
        
        // 如果目标字符不小于数组中的所有字符，返回首字母
        if (letters[r] <= target) {
            return letters[0];
        }
        
        // 闭区间二分
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (letters[mid] <= target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        
        // l=r+1，l是目标
        return letters[l];
    }
}
```

开区间写法如下，已附加注释：

```Python
# python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        # left 指向 <= target 的位置
        # right 指向 > target 的位置
        left, right = -1, n

        while left + 1 < right:
            mid = (left + right) // 2
            
            if letters[mid] > target:
                # 满足条件，尝试往左找更小的
                right = mid
            else:
                # 不满足条件，必须往右找
                left = mid
        
        # 都不满足时，right 会停在 n，取模
        return letters[right % n]
```

```Java
// java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int n = letters.length;
        // left 指向 <= target 的位置
        // right 指向 > target 的位置
        int left = -1, right = n;

        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            
            if (letters[mid] > target) {
                // 满足条件，尝试往左找更小的
                right = mid;
            } else {
                // 不满足条件，必须往右找
                left = mid;
            }
        }
        
        // 都不满足时，right 会停在 n，取模
        return letters[right % n];
    }
}
```

- 时间复杂度： $O(logn)$，其中 $n$ 是数组 $letters$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solutions/3892969/er-fen-fu-xi-yi-xia-bi-qu-jian-kai-qu-ji-sjbe/)
