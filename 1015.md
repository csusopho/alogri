[Problem: 1015. 可被 K 整除的最小整数](https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/)

### 方法：数学

整数 $n$ 是十进制，仅包含 $1$，即 $1,11,111,\dots$ 的形式。

如何得知 $n$ 能被 $k$ 整除？两者有什么数学关系？如果我们暴力地不断拼接 $1$，由于 $k$ 的长度是 $O(10^5)$ 量级，这样一定会超空间，而且不好计算。

从简单的 $k=4$ 开始 **寻找规律**：

- $1/4$，余数为 $1$；
- $2/4$，余数为 $2$；
- $2/4$，余数为 $3$；
- $4/4$，余数为 $0$；
- $\dots$

如果一个数字 $x$ 小于 $4$，整除后商为 $0$ 余数是 $x$；反之，如果它大于 $4$，整除后商是 $⌊x/4⌋$，余数是 $x\%4$。很容易发现，我们只关心是否整除，也即 **余数** 是否为 $0$，商是多少根本不重要。

任何数字，都可以写成 $x=tk+m$ 的形式，其中 $t$ 是商 $m$ 是余数。我们只关心余数，因此对它整除 $k$，只 **保留余数** $m$！回顾题目，在 $x$ 后面拼接 $1$，新数字是 $10x+1$。它有多大不重要，重点是对 $k$ 取模后的余数 $m$ 是否为 $0$！

因此，将新数字变为 $(10x+1)\%k$，不影响结果判断，且不会超出空间。

那小伙伴疑问，不会无限循环吗？既然我们对 $k$ 取模，那么余数只有 $0,1,\dots,k-1$ 这 $k$ 种可能。因此，**总循环次数** 不会超过 $k$！

> $ps$：这就叫做鸽巢原理，最多循环 $k$ 次就会遇到重复的余数。

**总结**：模 $k$ 得到的余数 $m=0$，那就是找到；余数 $m$ 重复出现过，就说明进入死循环。

因此，这里引入一个哈希 $set$ 集合，存储出现过的余数。我们在主流程中，不断拼接 $1$，并判断余数的情况。

代码如下，已附加注释：

```Python
# python
class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        if k == 1:
            return 1
        # 记录已出现数字
        seen = set()
        # 不断拼接1
        x = 1

        while x and x not in seen:
            seen.add(x)
            x = (x * 10 + 1) % k
        
        return -1 if x else len(seen) + 1
```

```Java
// java
class Solution {
    public int smallestRepunitDivByK(int k) {
        if (k == 1) {
            return 1;
        }
        // 记录已出现数字
        Set<Integer> seen = new HashSet<>();
        // 不断拼接1
        int x = 1;

        while (x != 0 && !seen.contains(x)) {
            seen.add(x);
            x = (x * 10 + 1) % k;
        }
        
        return x != 0 ? -1 : seen.size() + 1;
    }
}
```

- 时间复杂度： $O(k)$，循环不超过 $k$ 次
- 空间复杂度： $O(k)$，表示哈希 $set$ 的大小

---

### 优化

在上面已经指出，循环次数不超过 $k$。因此，我们没必要使用 $set$，**直接** $for$ 循环，当前是第几次循环，就说明拼接了几次 $1$。

这里 `1 % k` 是求余数，当 $k=1$ 结果为 $0$，其他 $k>1$ 的结果为 $1$。

同时，由于数字 $n$ 的末位是 $1$，不可能是偶数或 $5$ 的倍数。提前判断，速度更快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        # 末位是 1，不可能是偶数或 5 的倍数
        if k % 2 == 0 or k % 5 == 0:
            return -1
        # 余数
        x = 1 % k
        
        # 只有这 k 种情况
        for i in range(1, k + 1):
            # 整除
            if x == 0:
                return i
            # 计算下一个数的余数
            x = (x * 10 + 1) % k
            
        return -1
```

```Java
// java
class Solution {
    public int smallestRepunitDivByK(int k) {
        // 末位是 1，不可能是偶数或 5 的倍数
        if (k % 2 == 0 || k % 5 == 0) {
            return -1;
        }
        // 余数
        int x = 1 % k;
        
        // 只有这 k 种情况
        for (int i = 1; i <= k; i++) {
            // 整除
            if (x == 0) {
                return i;
            }
            // 计算下一个数的余数
            x = (x * 10 + 1) % k;
        }
            
        return -1;
    }
}
```

- 时间复杂度： $O(k)$
- 空间复杂度： $O(1)$

数学方法可以优化至 $log$ 级别，枚举 $\sqrt m$ 因子，本人搞不懂，具体可以看灵神的题解。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/3841613/shu-xue-ge-chao-yuan-li-shuo-ming-yu-shu-7kiv/)
