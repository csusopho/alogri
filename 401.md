[Problem: 401. 二进制手表](https://leetcode.cn/problems/binary-watch/description/)

### 方法：枚举+位运算

虽然题目涉及到 “二进制”，但因为手表的时间范围是固定的（小时 $0-11$，分钟 $0-59$），所以总的可能性非常少，只有 $12 \times 60 = 720$ 种情况。

那就不需要去深究位运算的底层逻辑，只需要遍历 **所有可能的时间**，检查每个时间对应的二进制中有多少个 $1$，判断是否和输入 $turnedOn$ 一致。

代码如下，已附加注释：

```Python
# python
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = []
        
        # 枚举所有可能的小时
        for h in range(12):
            # 枚举分钟
            for m in range(60):
                # 计算小时 h 和分钟 m 的二进制表示中 '1' 的个数
                if bin(h).count('1') + bin(m).count('1') == turnedOn:
                    # 格式化输出
                    time_str = f"{h}:{m:02d}"
                    ans.append(time_str)
        
        return ans
```

```Java
// java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<>();

        // 枚举所有可能的小时
        for (int h = 0; h < 12; h++) {
            // 枚举分钟
            for (int m = 0; m < 60; m++) {
                // 计算小时 h 和分钟 m 的二进制表示中 '1' 的个数
                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    // 格式化输出
                    String time_str = String.format("%d:%02d", h, m);
                    ans.add(time_str);
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(1)$，总共 $720$ 次循环
- 空间复杂度： $O(1)$，返回值 $ans$ 不计入复杂度

---

### 另类枚举

实际上，手表上面只有 $10$ 个灯，小时有 $4$ 种，分钟有 $6$ 种。

我们可以枚举所有 “亮-暗” 的可能，一共 $2^{10}=1024$ 种 **开关方案**。

枚举到 $x$ 时，它的高 $4$ 位为小时，低 $6$ 位为分钟。计算 $x$ 二进制中 $1$ 的个数，判断是否和输入 $turnedOn$ 一致。

代码如下，已附加注释：

```Python
# python
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = list()
        # 枚举所有方案
        for i in range(1024):
            h, m = i >> 6, i & 0x3f   # 用位运算取出高 4 位和低 6 位
            if h < 12 and m < 60 and bin(i).count("1") == turnedOn:
                ans.append(f"{h}:{m:02d}")
        return ans

        # 不调库，直接用位运算统计1的个数，替换上面的 bin 即可
        def countbin(x):
            ans = 0
            while x:
                x = x & (x - 1)
                ans += 1
            return ans
```

```Java
// java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<>();
        // 枚举所有方案
        for (int i = 0; i < 1024; i++) {
            int h = i >> 6;
            int m = i & 0x3f;   // 用位运算取出高 4 位和低 6 位
            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {
                ans.add(String.format("%d:%02d", h, m));
            }
        }
        return ans;
    }

    // 不调库，直接用位运算统计1的个数
    private int countbin(int x) {
        int ans = 0;
        while (x != 0) {
            x = x & (x - 1);
            ans += 1;
        }
        return ans;
    }
}
```

- 时间复杂度： $O(1)$，总共 $1024$ 次循环
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/binary-watch/solutions/3903882/shuang-jie-mei-ju-shi-jian-or-mei-ju-led-2iv6/)
