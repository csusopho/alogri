[Problem: 2106. 摘水果](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/)

### 方法：前缀和+二分/滑窗

题意比较清晰，就是从 $startPos$ 出发，判断往哪走能获得最多水果。

一维坐标系中，只有可能 “向左” 或 “向右” 移动，并且两个方向加起来的步数不超过 $k$。**贪心** 地可知，向左移动 $t$ 步后，向右走时，一定会将 $k-t$ 步全部用完。

因此，有一个简单的 **想法**：枚举向左/右的步数，将剩下的步数向右/左进行，分别计算不同情况下，能获得的水果数量。

假设移动过程中，最大左边界为 $l$，最大右边界为 $r$，则区间 $[l,r]$ 内的水果都能全部获取。在数组 $fruits$ 中，第一维是位置 $pos$，第二维是数量 $amt$。我们想寻找 “位置” 范围内的 “数量”，因此将两个维度分开，记作数组 $positions$ 和 $amounts$。

由于数组 $positions$ 升序，具有 **单调性**，在其中寻找范围 $[l,r]$，想到 **二分**。

注意，这里二分得到的是下标！假设区间 $[l,r]$ 对应的下标为 $[i,j]$，由于两个数组是一一对应，所以水果总数 = 子数组 $amounts[i:j]$ 的总和。

如何快速的求解子数组累加和？想到 **前缀和**。它是一种能将 $O(n)$ 的统计转化为 $O(1)$ 的快速方法。具体原理及做法，可以看看我的 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

在本题中，定义数组 $prefix$，其中 $prefix[i+1]$ 表示前 $i$ 个位置中水果的总数。注意这里的量词是 “个”，第 $0$ 个位置会有 $amounts[0]$ 个水果。

**总结**：枚举向左/右移动的步数 $step$，剩下 $k-step$ 的步数向右/左移动。分别计算出距离区间 $[l,r]$，然后通过二分找出下标区间 $[i,j]$，利用前缀和得出答案。

二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~

这里使用最容易理解的 **闭区间** 二分（复用的写法），代码如下，已附加注释：

```Python
# python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        # 将位置和水果数量分别提取出来
        positions = [pos for pos, _ in fruits]
        amounts = [amt for _, amt in fruits]
        
        # 前缀和 prefix[i] 表示前 i 个位置中水果的总数
        prefix = [0] * (len(fruits) + 1)
        for i in range(len(fruits)):
            prefix[i + 1] = prefix[i] + fruits[i][1]

        ans = 0

        # 先左再右
        for steps_left in range(k + 1):
            steps_right = k - 2 * steps_left
            if steps_right < 0:
                break  # 超过步数限制
            # 可达区间
            l = startPos - steps_left
            r = startPos + steps_right
            # 对应下标
            i = bisect.bisect_left(positions, l)
            j = bisect.bisect_right(positions, r)
            ans = max(ans, prefix[j] - prefix[i])

        # 先右再左
        for steps_right in range(k + 1):
            steps_left = k - 2 * steps_right
            if steps_left < 0:
                break
            # 可达区间
            l = startPos - steps_left
            r = startPos + steps_right
            # 对应下标
            i = bisect.bisect_left(positions, l)
            j = bisect.bisect_right(positions, r)
            ans = max(ans, prefix[j] - prefix[i])

        return ans
```

```Java
// java
public class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        // 将位置和水果数量分别提取出来
        int n = fruits.length;
        int[] positions = new int[n];
        int[] amounts = new int[n];
        for (int i = 0; i < n; i++) {
            positions[i] = fruits[i][0];
            amounts[i] = fruits[i][1];
        }

        // 前缀和 prefix[i] 表示前 i 个位置中水果的总数
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + amounts[i];
        }

        int ans = 0;

        // 先左后右
        for (int stepsLeft = 0; stepsLeft <= k; stepsLeft++) {
            int stepsRight = k - 2 * stepsLeft;
            if (stepsRight < 0) break;  // 超过步数限制
            // 可达区间
            int l = startPos - stepsLeft;
            int r = startPos + stepsRight;
            // 对应下标
            int i = lowerBound(positions, l);
            int j = lowerBound(positions, r + 1) - 1;
            if (i <= j) {
                ans = Math.max(ans, prefix[j + 1] - prefix[i]);
            }
        }

        // 先右后左
        for (int stepsRight = 0; stepsRight <= k; stepsRight++) {
            int stepsLeft = k - 2 * stepsRight;
            if (stepsLeft < 0) break;
            // 可达区间
            int l = startPos - stepsLeft;
            int r = startPos + stepsRight;
            // 对应下标
            int i = lowerBound(positions, l);
            int j = lowerBound(positions, r + 1) - 1;
            if (i <= j) {
                ans = Math.max(ans, prefix[j + 1] - prefix[i]);
            }
        }

        return ans;
    }

    // 返回第一个 >= target 的下标
    private int lowerBound(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int res = arr.length;  // 默认不存在
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= target) {
                res = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return res;
    }
}
```

能否在 “向左再向右” 或 “向右再向左” 中省去一个？最好不要。走法不同，能走到的区间长度也可能不同，两者区间并不对称或重合，必须都进行枚举。

- 时间复杂度： $O(k\times logn)$，其中 $n$ 为数组 $fruits$ 的长度，一共 $O(k)$ 次二分，每次在数组 $positions$ 上进行二分
- 空间复杂度： $O(n)$，表示数组 $positions$ 以及 $amounts$ 的大小

---

### 滑窗

我们已经知道，答案就是一段区间 $[i, j]$ 中的水果和。因此，问题就是求哪一段区间能使答案最大。从 $startPos$ 出发，究竟有哪些区间？

> 注意，这里的 $i,j$ 都是指 $n$ 个位置中的某一个（下标），而不是具体的坐标值！别混淆下标 $i,j$ 与坐标值 $l,r$ 的区别！

假设向右到达第 $j$ 个位置，此时向左最多到达第 $i$ 个位置。由于 $positions$ 升序，所以区间 $[i+1,j]$ 也一定在 $k$ 步内可达。区间越短，越有可能符合要求。具有 **单调性**，所以想到 **滑动窗口**。

**思路**：枚举区间的右边界 $j$，坐标值为 $r=positions[j]$，滑动左边界 $i$，对应的坐标值为 $l=positions[i]$，直至在 $k$ 步内能确保 $[l,r]$ 可达，计算 $[i,j]$ 内的水果数。

那么，如何计算 $[i,j]$ 对应的 $[l,r]$ 是在 $k$ 步内可达呢？因为我们是从 $startPos$ 出发，所以一定是 “先向右再向左” 或者 “先向左后向右” 两种方案之一，分别计算所需步数即可！

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        n = len(fruits)
        ans = 0
        total = 0  # 当前窗口内水果数量总和
        left = 0   # 滑动窗口左边界

        for right in range(n):
            total += fruits[right][1]  # 加入右边界的水果

            # 检查当前窗口是否可行
            while left <= right:
                left_pos = fruits[left][0]
                right_pos = fruits[right][0]

                # 两种走法：左→右 或 右→左，取最小步数
                min_steps = min(
                    abs(startPos - left_pos) + (right_pos - left_pos),
                    abs(startPos - right_pos) + (right_pos - left_pos)
                )

                if min_steps <= k:
                    break  # 当前窗口合法，退出检查
                # 否则窗口太远，收缩左边界
                total -= fruits[left][1]
                left += 1

            # 更新最大值
            ans = max(ans, total)

        return ans
```

```Java
// java
public class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int n = fruits.length;
        int ans = 0;
        int total = 0; // 当前窗口内水果数量总和
        int left = 0;  // 滑动窗口左边界

        for (int right = 0; right < n; right++) {
            total += fruits[right][1]; // 加入右边界的水果

            // 检查当前窗口是否可行
            while (left <= right) {
                int leftPos = fruits[left][0];
                int rightPos = fruits[right][0];

                // 两种走法：左→右 或 右→左，取最小步数
                int minSteps = Math.min(
                    Math.abs(startPos - leftPos) + (rightPos - leftPos),
                    Math.abs(startPos - rightPos) + (rightPos - leftPos)
                );

                if (minSteps <= k) {
                    break; // 当前窗口合法，退出检查
                }

                // 否则窗口太远，收缩左边界
                total -= fruits[left][1];
                left++;
            }

            // 更新最大值
            ans = Math.max(ans, total);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $fruits$ 的长度，两个指针最多各移动一遍数组
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/)
