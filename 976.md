[Problem: 976. 三角形的最大周长](https://leetcode.cn/problems/largest-perimeter-triangle/description/)

### 方法：贪心

给定三条边 $a,b,c$，它们能否组成三角形？也就是判断，两边之和大于第三边。

一种 **暴力** 想法：直接三重 $for$ 循环，枚举所有三元组。假设数组 $nums$ 的长度为 $n$，而题目限定 $n\leq 10^4$，因此 $O(n^3)$ 会超时！

**贪心** 思路：如果数组中最大的三条边能组成三角形，那周长一定是最大的！因此，我们想到 **排序**，边长选择 **相邻** 的三条。

对于任意三个已排序的边长 $a\leq b\leq c$，它们能构成三角形的 **唯一条件** 是 `a + b > c`。（因为 $c$ 最长，`a + c > b` 和 `b + c > a` 必然成立）。

如何证明答案最大？如何证明是相邻组？分为两部分。

---

**如果最大的三个元素能构成三角形，那么它的周长一定是最大的。**

假设数组中最大的三个元素是 $n_{k-2}, n_{k-1}, n_k$。

1. 我们检查它们是否能构成三角形，即 $n_{k-2} + n_{k-1} > n_k$。

2. 假设这个条件成立，那么我们找到了一个有效的三角形，其周长为 $P = n_{k-2} + n_{k-1} + n_k$。

3. 现在，我们需要证明 **不存在** 另一个由数组中其他元素组成的三角形 $(a, b, c)$，其周长 $P' = a + b + c$ 能大于 $P$。

    - 让我们从数组中任选另外三个元素 $a, b, c$，并假设 $a ≤ b ≤ c$；
    - 为了让周长 $P'$ 大于 $P$，至少有一个边长需要大于 $n_{k-2}, n_{k-1}, n_k$ 中的对应边长；
    - 然而， $n_k$ 是整个数组中最大的元素。所以，任何其他组合的最大边 $c$ 必然满足 $c ≤ n_k$。同理， $b ≤ n_{k-1}$ 且 $a ≤ n_{k-2}$；
    - 因此， $a + b + c ≤ n_{k-2} + n_{k-1} + n_k$，这意味着任何其他组合的周长 $P'$ 都不可能大于 $P$。

**结论**：如果最大的三个元素能构成三角形，它们的周长就是全局最大周长。

---

**如果最大的三个元素不能构成三角形，那么最大元素 $n_k$ 不可能成为任何有效三角形的一部分。**

1. 这三个元素无法构成三角形，则有 $n_{k-2} + n_{k-1} ≤ n_k$。

2. 现在，我们想知道 $n_k$ 能否和数组中 **其他** 的元素 $a, b$（其中 $a, b$ 都小于 $n_{k-1}$）构成三角形。

    - 为了与 $n_k$ 构成三角形，我们需要找到两个元素 $a, b$ 满足 $a + b > n_k$；
    - 为了让 $a + b$ 的值最大，我们应该在剩下的元素中选择最大的两个。在不选择 $n_{k-1}$ 和 $n_{k-2}$ 的情况下，能选到的最大两个数也必然小于 $n_{k-1}$ 和 $n_{k-2}$；
    - 我们已知，就连最大的可能组合 $n_{k-2} + n_{k-1}$ 都无法满足 $> n_k$ 的条件；
    - 由于数组是排序的，任何其他两个元素 $a, b$（其中 $a, b < n_{k-1}$）的和 $a + b$ 必然小于 $n_{k-2} + n_{k-1}$；
    - 所以， $a + b < n_{k-2} + n_{k-1} ≤ n_k$，这意味着 $a + b$ 绝对不可能大于 $n_k$。

**结论**：如果 $n_{k-2} + n_{k-1} ≤ n_k$，那么 $n_k$ 这个元素就太大了，数组中不存在任何两个元素的和能超过它。因此， $n_k$ 可以被安全地 **排除**，我们只需要在剩下的 $n_1, ..., n_{k-1}$ 中继续寻找最大周长的三角形。

这两个结论进行整合，得到 **推论**：每次都从数组中挑选最大的三个（相邻）元素，如果不能构成三角形，则排除最大，在剩下的数组中继续进行挑选。

代码非常容易，只需要从大到小遍历即可：

```Python
# python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()  # 升序

        for i in range(len(nums) - 1, 1, -1):
            # 从最大的边长开始尝试，第一个满足，必然最大
            if nums[i] < nums[i - 1] + nums[i - 2]:
                return nums[i] + nums[i - 1] + nums[i - 2]
        
        return 0
```

```Java
// java
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);  // 升序

        // 从数组末尾向前遍历，这样可以先处理最大的边
        for (int i = nums.length - 1; i >= 2; i--) {
            // 从最大的边长开始尝试，第一个满足条件的组合，其周长必然是最大的
            if (nums[i] < nums[i - 1] + nums[i - 2]) {
                return nums[i] + nums[i - 1] + nums[i - 2];
            }
        }
        
        // 没有找到
        return 0;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(logn)$，表示排序的栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/largest-perimeter-triangle/solutions/3794038/tan-xin-wei-shi-yao-pai-xu-zheng-que-fan-d312/)
