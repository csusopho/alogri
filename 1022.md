[Problem: 1022. 从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/description/)

### 方法：DFS & BFS

如何把遍历过程中的二进制位转换成十进制数？

假设我们已经有了一个二进制数 $10$（十进制 $2$），现在遇到一个新的位 $1$，组成 $101$（十进制 $5$）。数学 **计算公式** 是：新值 = 老值 $\times 2$ + 新位的值。

在位运算中，这等价于：新值 = (老值 << $1$) + 新位的值。

由于原函数 $sumRootToLeaf$ 只有一个参数 $root$，没法把 “之前累加的数字” 传给下一层。因此，**定义** 一个辅助函数 $dfs(node, num)$，其中 $num$ 代表 **从根节点到当前节点父节点** 所累积的数值。

根据上面的公式，从父节点遍历到 $node$ 时，当前路径和 $num = num * 2 + node.val$。

边界情况：

- 如果当前节点是空节点，说明没有路径，返回 $0$
- 如果当前节点是叶子节点，说明一条路径结束了，返回计算好的路径总和 $num$

**递归分解**：如果不是叶子节点，那么整棵树的路径和 = 左子树的路径和 + 右子树的路径和。也即 $dfs(node.left, num) + dfs(node.right, num)$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        # 当前节点，路径总和
        def dfs(node, num):
            # 递归边界
            if not node:
                return 0
            
            # 核心计算：老值 * 2 + 当前节点值
            num = num * 2 + node.val
            # 叶子，说明一条路径收集完毕
            if not node.left and not node.right:
                return num
            # 结果为左右子树路径和的累加
            return dfs(node.left, num) + dfs(node.right, num)
        
        return dfs(root, 0)
```

```Java
// java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        return dfs(root, 0);
    }

    // 当前节点，路径总和
    private int dfs(TreeNode node, int num) {
        // 递归边界
        if (node == null) {
            return 0;
        }
        
        // 核心计算：老值 * 2 + 当前节点值
        num = num * 2 + node.val;
        // 叶子，说明一条路径收集完毕
        if (node.left == null && node.right == null) {
            return num;
        }
        // 结果为左右子树路径和的累加
        return dfs(node.left, num) + dfs(node.right, num);
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为是树中节点个数，每个节点遍历一次
- 空间复杂度： $O(n)$，表示递归调用栈的深度

---

### 另类 $DFS$

不使用辅助函数 $dfs$ 可以吗？

既然不能用形参 $num$ 往下传，我们需要找个地方 “记住” 路径累加的值。因为二叉树节点有 $val$ 属性，可以直接把当前累加的数值 **存进子节点** 的 $val$ 中。

**处理逻辑：**

- 当前节点 $root$，它此时的 $root.val$ 已经包含了从真正的根节点到它的完整数值
- 如果它有左孩子 $root.left$，那么左孩子更新后的值应该是：`旧的左孩子值 + 当前节点值 * 2`。也即 $root.left.val += (root.val << 1)$
- 对右孩子做同样的处理

边界情况：

- 如果节点为空，返回 $0$。
- 如果是叶子节点，因为它的 $val$ 已经被父节点修改过了，现在里面存的刚好就是整条路径的值，所以直接返回 $root.val$。

**递归分解**：继续递归左右子节点，并将结果相加。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        # 递归边界
        if not root:
            return 0
        # 叶子节点
        if not root.left and not root.right:
            return root.val

        # 核心逻辑：把父节点累积的值，推入到子节点中
        if root.left:
            root.left.val += (root.val << 1)
        if root.right:
            root.right.val += (root.val << 1)
        
        # 递归左右子树
        return self.sumRootToLeaf(root.left) + self.sumRootToLeaf(root.right)
```

```Java
// java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        // 递归边界
        if (root == null) {
            return 0;
        }
        // 叶子节点
        if (root.left == null && root.right == null) {
            return root.val;
        }

        // 核心逻辑：把父节点累积的值，推入到子节点中
        if (root.left != null) {
            root.left.val += (root.val << 1);
        }
        if (root.right != null) {
            root.right.val += (root.val << 1);
        }
        
        // 递归左右子树
        return sumRootToLeaf(root.left) + sumRootToLeaf(root.right);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### $BFS$

在队列中，不仅要存下节点本身，还要存下从根节点走到该节点时的 **累加数值**。因此队列里的元素是一个元组：`(当前节点, 到达该节点时的数值)`。

按层遍历：

- 每次从队列弹出一个节点及其对应的数值
- 如果它是叶子节点，说明这条路走到底了，把数值加到总和 $ans$ 中
- 如果它有左右孩子，将孩子节点以及计算后的新数值 `当前数值 * 2 + 孩子节点值` 压入队列

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        ans = 0
        # 队列存放：(节点, 走到该节点为止代表的数值)
        queue = deque([(root, root.val)])
        
        while queue:
            node, cur_num = queue.popleft()

            # 叶子，将当前路径累积的数字加入总和
            if not node.left and not node.right:
                ans += cur_num
            
            # 左子节点，计算左子节点处的新数值，并入队
            if node.left:
                # 新值 = 老值 * 2 + 左子节点的值
                queue.append((node.left, cur_num * 2 + node.left.val))
                
            # 右子节点
            if node.right:
                queue.append((node.right, cur_num * 2 + node.right.val))
                
        return ans
```

```Java
// java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        int ans = 0;
        if (root == null) {
            return 0;
        }
        
        // 队列存放：(节点, 走到该节点为止代表的数值)
        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();
        queue.offer(new Pair<>(root, root.val));
        
        while (!queue.isEmpty()) {
            Pair<TreeNode, Integer> curr = queue.poll();
            TreeNode node = curr.getKey();
            int cur_num = curr.getValue();

            // 叶子，将当前路径累积的数字加入总和
            if (node.left == null && node.right == null) {
                ans += cur_num;
            }
            
            // 左子节点，计算左子节点处的新数值，并入队
            if (node.left != null) {
                // 新值 = 老值 * 2 + 左子节点的值
                queue.offer(new Pair<>(node.left, cur_num * 2 + node.left.val));
            }
            
            // 右子节点
            if (node.right != null) {
                queue.offer(new Pair<>(node.right, cur_num * 2 + node.right.val));
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/solutions/3907237/san-jie-fu-zhu-dfs-zi-shen-di-gui-bfsxia-ib10/)
