[Problem: 3573. 买卖股票的最佳时机 V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/)

### 方法：三/二/一维DP

传统的股票问题通常只允许 “买入后卖出”（做多），而本题增加了 “卖出后买回”（做空）的操作。

一笔完整的交易包括 “开仓” 和 “平仓”。

- 普通交易：空仓 $\to$ 买入（多头） $\to$ 卖出（空仓）。
- 做空交易：空仓 $\to$ 卖出（空头） $\to$ 买回（空仓）。

每一天交易结束后，我们只可能处于以下三种状态之一：

1. 空仓 $Flat$：当前手中没有持有股票，也没有欠股票。
2. 多头 $Long$：手中持有股票（已买入），等待卖出。
3. 空头 $Short$：手中欠股票（已做空），等待买回。

题目限制最多 $k$ 笔交易，因此我们需要记录当前 **已经完成** 了多少笔交易。同时，每天只能交易一笔，且一个交易完成后才能交易下一笔，所以需要记录天数和完成交易数。

**定义** $dp[i][j][state]$ 表示第 $i$ 天，已完成 $j$ 笔交易，且处于 $state$ 状态下的最大利润。其中，

- $state = 0$：空仓
- $state = 1$：持有 “做多” 仓位
- $state = 2$：持有 “做空” 仓位

**状态转移**：对于每一天 $i$ 和每一个交易次数 $j$，

- 今天是空仓状态 $state = 0$，可能是以下几种情况转化而来：

1. 昨天就是空仓，今天休息，则 $dp[i-1][j][0]$
2. 昨天是多头，今天卖出平仓。平仓意味着一笔交易结束了，所以昨天只能是 $j-1$ 笔交易，所以是 $dp[i-1][j-1][1] + prices[i]$
3. 昨天是空头，今天买回平仓，同理平仓逻辑，有 $dp[i-1][j-1][2] - prices[i]$

- 今天是多头状态 $state = 1$，可能是：

1. 昨天就是多头，今天休息，则 $dp[i-1][j][1]$
2. 昨天是空仓，今天买入开仓。开仓并不增加 “已完成” 的交易计数，所以交易次数 $j$ 保持不变，所以是 $dp[i-1][j][0] - prices[i]$

- 今天是空头状态 $state = 2$，可能是：

1. 昨天就是空头，今天休息，则 $dp[i-1][j][2]$
2. 昨天是空仓，今天卖出开仓，同理逻辑，有 $dp[i-1][j][0] + prices[i]$

具体状态转移方程就不再列举，详情见代码。

**边界条件**：第 $0$ 天一定完成 $0$ 笔交易，三个状态的收益为 $0,-prices[0],prices[0]$。

**目标**：最终一定是平仓状态，但是交易多少笔不清楚，所以在 $dp[n-1][j][0]$ 中寻找最大值。

> 不是交易笔数越多，利润就越大。直接返回 $j=k$ 作为最大，会卡在 $652/776$ 样例。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        n = len(prices)
        # dp[i][j][state] 表示第 i 天已完成 j 笔交易，且处于 state 状态下的最大利润
        dp = [[[-float('inf')] * 3 for _ in range(k + 1)] for _ in range(n)]

        # 空仓
        dp[0][0][0] = 0
        # 第 0 天买入
        dp[0][0][1] = -prices[0]
        # 第 0 天做空
        dp[0][0][2] = prices[0]

        for i in range(1, n):
            for j in range(k + 1):
                
                # 空仓状态
                res_flat = dp[i-1][j][0]
                
                # 进行“平仓”操作来完成第 j 笔交易
                if j > 0:
                    # 昨天多头 -> 今天卖出平仓
                    sell_profit = dp[i-1][j-1][1] + prices[i]
                    # 昨天空头 -> 今天买回平仓
                    cover_profit = dp[i-1][j-1][2] - prices[i]
                    # 取最大值
                    res_flat = max(res_flat, sell_profit, cover_profit)
                
                dp[i][j][0] = res_flat

                # 多头状态
                # 昨天多头 OR 昨天空仓今天买入
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i])

                # 空头状态
                # 昨天空头 OR 昨天空仓今天做空
                dp[i][j][2] = max(dp[i-1][j][2], dp[i-1][j][0] + prices[i])

        # 最后一天必须是空仓
        return max(dp[n-1][j][0] for j in range(k + 1))
```

```Java
// java
class Solution {
    public long maximumProfit(int[] prices, int k) {
        int n = prices.length;

        // dp[i][j][state] 表示第 i 天已完成 j 笔交易，且处于 state 状态下的最大利润
        long[][][] dp = new long[n][k + 1][3];

        // 初始化，要防止溢出
        for (long[][] mat : dp) {
            for (long[] row : mat) {
                Arrays.fill(row, Long.MIN_VALUE / 2);
            }
        }

        // 空仓
        dp[0][0][0] = 0;
        // 第 0 天买入
        dp[0][0][1] = -prices[0];
        // 第 0 天做空
        dp[0][0][2] = prices[0];

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                
                // 空仓状态
                long res_flat = dp[i-1][j][0];
                
                // 进行“平仓”操作来完成第 j 笔交易
                if (j > 0) {
                    // 昨天多头 -> 今天卖出平仓
                    long sell_profit = dp[i-1][j-1][1] + prices[i];
                    // 昨天空头 -> 今天买回平仓
                    long cover_profit = dp[i-1][j-1][2] - prices[i];
                    // 取最大值
                    res_flat = Math.max(res_flat, Math.max(sell_profit, cover_profit));
                }
                
                dp[i][j][0] = res_flat;

                // 多头状态
                // 昨天多头 OR 昨天空仓今天买入
                dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j][0] - prices[i]);

                // 空头状态
                // 昨天空头 OR 昨天空仓今天做空
                dp[i][j][2] = Math.max(dp[i-1][j][2], dp[i-1][j][0] + prices[i]);
            }
        }

        // 最后一天必须是空仓
        long ans = Long.MIN_VALUE;
        for (int j = 0; j <= k; j++) {
            ans = Math.max(ans, dp[n-1][j][0]);
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n\times k)$，其中 $n$ 是数组 $prices$ 的长度
- 空间复杂度： $O(n\times k)$，表示数组 $dp$ 的大小

---

### 空间优化

可以发现，计算状态 $dp[i][j][s]$ 时，只会用到 $dp[i-1]$ 的值，不会用到比 $i-1$ 更早的状态。这里就采用滚动数组，优化掉第一维。

**重新定义**  $dp[j][state]$ 表示已完成 $j$ 笔交易，状态为 $state$ 的最大利润。

这个定义是第 $i$ 天的数据，如何保留第 $i-1$ 天的数据？滚动数组，旧的 $dp[i-1]$ 的值保存在 $dp$ 数组中；定义新的 $newDp$ 数组，新的状态更新在 $newDp[i]$ 中。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        n = len(prices)
        # dp[j][state] 表示已完成 j 笔交易，状态为 state 的最大利润
        dp = [[float('-inf')] * 3 for _ in range(k + 1)]

        # 空仓
        dp[0][0] = 0
        # 第 0 天买入
        dp[0][1] = -prices[0]
        # 第 0 天做空
        dp[0][2] = prices[0]

        for price in prices[1:]:
            # 新一天的状态表
            new_dp = [[float('-inf')] * 3 for _ in range(k + 1)]
            
            for j in range(k + 1):
                # 空仓状态
                # A: 昨天就是空仓
                max_flat = dp[j][0]
                # B/C: 昨天持有仓位，今天平仓
                if j > 0:
                    profit_sell = dp[j-1][1] + price
                    profit_cover = dp[j-1][2] - price
                    max_flat = max(max_flat, profit_sell, profit_cover)
                
                new_dp[j][0] = max_flat

                # 多头状态
                # A: 昨天就是多头
                # B: 昨天空仓，今天买入
                new_dp[j][1] = max(dp[j][1], dp[j][0] - price)

                # 空头状态
                # A: 昨天就是空头
                # B: 昨天空仓，今天做空
                new_dp[j][2] = max(dp[j][2], dp[j][0] + price)

            # 滚动更新
            dp = new_dp

        # 最终状态是空仓
        return max(dp[j][0] for j in range(k + 1))
```

```Java
// java
class Solution {
    public long maximumProfit(int[] prices, int k) {
        int n = prices.length;

        // dp[j][state] 表示已完成 j 笔交易，状态为 state 的最大利润
        long[][] dp = new long[k + 1][3];
        // 初始化
        for (long[] row : dp) Arrays.fill(row, Long.MIN_VALUE / 2);

        // 空仓
        dp[0][0] = 0;
        // 第 0 天买入
        dp[0][1] = -prices[0];
        // 第 0 天做空
        dp[0][2] = prices[0];

        for (int i = 1; i < n; i++) {
            long price = prices[i];
            // 新一天的状态表
            long[][] new_dp = new long[k + 1][3];
            for (long[] row : new_dp) Arrays.fill(row, Long.MIN_VALUE / 2);
            
            for (int j = 0; j <= k; j++) {
                // 空仓状态
                // A: 昨天就是空仓
                long max_flat = dp[j][0];
                // B/C: 昨天持有仓位，今天平仓
                if (j > 0) {
                    long profit_sell = dp[j-1][1] + price;
                    long profit_cover = dp[j-1][2] - price;
                    max_flat = Math.max(max_flat, Math.max(profit_sell, profit_cover));
                }
                
                new_dp[j][0] = max_flat;

                // 多头状态
                // A: 昨天就是多头
                // B: 昨天空仓，今天买入
                new_dp[j][1] = Math.max(dp[j][1], dp[j][0] - price);

                // 空头状态
                // A: 昨天就是空头
                // B: 昨天空仓，今天做空
                new_dp[j][2] = Math.max(dp[j][2], dp[j][0] + price);
            }

            // 滚动更新
            dp = new_dp;
        }

        // 最终状态是空仓
        long ans = Long.MIN_VALUE;
        for (int j = 0; j <= k; j++) {
            ans = Math.max(ans, dp[j][0]);
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n\times k)$
- 空间复杂度： $O(k)$，数组 $dp$ 是两维

---

### 一维 $DP$

既然第 $i$ 天的状态只依赖于第 $i-1$ 天，那就没必要将三个状态硬生生塞入一个 $dp$ 中。拆开第二维，变为 $flat/long/short$ 数组，分别表示 “空仓/多头/空头” 的状态。

同样使用临时数组，代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        # 完成 j 笔交易后，空仓/多头/空头的最大利润
        flat = [float('-inf')] * (k + 1)
        long_pos = [float('-inf')] * (k + 1)
        short_pos = [float('-inf')] * (k + 1)
        # 第0天之前，0笔交易，利润为0
        flat[0] = 0
        
        for price in prices:
            # 保存前一天状态
            new_flat = flat[:]
            new_long = long_pos[:]
            new_short = short_pos[:]
            
            for j in range(k + 1):
                # 更新多头状态
                # 保持原状 OR 从空仓买入
                if flat[j] != float('-inf'):
                    new_long[j] = max(long_pos[j], flat[j] - price)
                
                # 更新空头状态
                # 保持原状 OR 从空仓卖出做空
                if flat[j] != float('-inf'):
                    new_short[j] = max(short_pos[j], flat[j] + price)
                
                # 更新空仓状态
                # 保持原状 OR 卖出平多仓 OR 买入平空仓
                if j > 0:
                    profit_from_long = long_pos[j-1] + price
                    profit_from_short = short_pos[j-1] - price
                    new_flat[j] = max(new_flat[j], profit_from_long, profit_from_short)
            
            # 更新状态数组
            flat, long_pos, short_pos = new_flat, new_long, new_short
            
        # 必须是空仓状态
        return max(flat)
```

```Java
// java
class Solution {
    public long maximumProfit(int[] prices, int k) {
        // 完成 j 笔交易后，空仓/多头/空头的最大利润
        long[] flat = new long[k + 1];
        long[] long_pos = new long[k + 1];
        long[] short_pos = new long[k + 1];
        
        long INF = Long.MIN_VALUE / 2;
        Arrays.fill(flat, INF);
        Arrays.fill(long_pos, INF);
        Arrays.fill(short_pos, INF);

        // 第0天之前，0笔交易，利润为0
        flat[0] = 0;
        
        for (int price : prices) {
            // 保存前一天状态
            long[] new_flat = flat.clone();
            long[] new_long = long_pos.clone();
            long[] new_short = short_pos.clone();
            
            for (int j = 0; j <= k; j++) {
                // 更新多头状态
                // 保持原状 OR 从空仓买入
                if (flat[j] != INF) {
                    new_long[j] = Math.max(long_pos[j], flat[j] - price);
                }
                
                // 更新空头状态
                // 保持原状 OR 从空仓卖出做空
                if (flat[j] != INF) {
                    new_short[j] = Math.max(short_pos[j], flat[j] + price);
                }
                
                // 更新空仓状态
                // 保持原状 OR 卖出平多仓 OR 买入平空仓
                if (j > 0) {
                    long profit_from_long = long_pos[j-1] + price;
                    long profit_from_short = short_pos[j-1] - price;
                    new_flat[j] = Math.max(new_flat[j], Math.max(profit_from_long, profit_from_short));
                }
            }
            
            // 更新状态数组
            flat = new_flat;
            long_pos = new_long;
            short_pos = new_short;
        }
            
        // 必须是空仓状态
        long ans = INF;
        for (long val : flat) ans = Math.max(ans, val);
        return ans;
    }
}
```

- 时间复杂度： $O(n\times k)$
- 空间复杂度： $O(k)$

---

### 倒序

回想一下，为什么 $0-1$ 背包问题优化后是倒序枚举？为了避免 **数据污染**。

在 $0-1$ 背包的一维数组中，刚进入第 $i$ 个轮次时，这个 $dp$ 数组存储的是 $i-1$ 状态的值。如果选择正序枚举，即 $dp[i]+=dp[i-k]$，会造成重复计算！

举个例子，如果 $dp[3]+=dp[0],dp[6]+=dp[3]$，相当于 $nums[i]$ 重复选择了两次，违反了 $0-1$ 背包的约束！

本质 **原因**：用 $dp[i]$ 转移得到 $dp[j]$ 时， $dp[i]$ 可能已经被本次迭代中的计算修改过，所以导致错误计算。

上面的做法是用新的 $dp$ 数组作为 $i$ 状态，旧的 $dp$ 数组作为 $i-1$ 状态。如果我们不想开辟新数组，那就要倒序遍历第二维，并由于 $j-1$ 的存在，将 $j=0$ 单独处理。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        # 完成 j 笔交易后，空仓/多头/空头的最大利润
        flat = float('-inf') * (k + 1)
        long_pos = [float('-inf')] * (k + 1)
        short_pos = [float('-inf')] * (k + 1)
        
        # 第0天之前，0笔交易，利润为0
        flat = [0] * (k + 1)
        long_pos = [-prices[0]] * (k + 1)
        short_pos = [prices[0]] * (k + 1)

        for price in prices[1:]:
            # 必须倒序
            for j in range(k, 0, -1):
                # 更新持仓状态
                long_pos[j] = max(long_pos[j], flat[j] - price)
                short_pos[j] = max(short_pos[j], flat[j] + price)
                
                # 更新空仓状态
                flat[j] = max(flat[j], long_pos[j-1] + price, short_pos[j-1] - price)
            
            # j=0 的情况单独处理
            long_pos[0] = max(long_pos[0], -price) # 买入
            short_pos[0] = max(short_pos[0], price)  # 做空

        # 必须是空仓状态
        return flat[k]
```

```Java
// java
class Solution {
    public long maximumProfit(int[] prices, int k) {
        // 完成 j 笔交易后，空仓/多头/空头的最大利润
        long[] flat = new long[k + 1];
        long[] long_pos = new long[k + 1];
        long[] short_pos = new long[k + 1];
        
        // 初始化
        Arrays.fill(long_pos, -prices[0]);
        Arrays.fill(short_pos, prices[0]);

        for (int i = 1; i < prices.length; i++) {
            long price = prices[i];
            // 必须倒序
            for (int j = k; j > 0; j--) {
                // 更新持仓状态
                long_pos[j] = Math.max(long_pos[j], flat[j] - price);
                short_pos[j] = Math.max(short_pos[j], flat[j] + price);
                
                // 更新空仓状态
                flat[j] = Math.max(flat[j], Math.max(long_pos[j-1] + price, short_pos[j-1] - price));
            }
            
            // j=0 的情况单独处理
            long_pos[0] = Math.max(long_pos[0], -price); // 买入
            short_pos[0] = Math.max(short_pos[0], price);  // 做空
        }

        // 必须是空仓状态
        return flat[k];
    }
}
```

- 时间复杂度： $O(n\times k)$
- 空间复杂度： $O(k)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/solutions/3858997/si-jie-san-wei-dp-kong-jian-you-hua-er-w-pdhk/)
