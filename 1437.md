[Problem: 1437. 是否所有 1 都至少相隔 k 个元素](https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/description/)

### 方法：双/单指针

题目很简单，注意两点即可：

- 至少间隔 $k$，不是必须等于 $k$；
- $nums$ 中元素可能全为 $0$，自行检查一下。

**双指针** 思路：使用一个指针 $last$ 表示上一个遇到的 $1$ 的位置，以及指针 $cur$ 用来遍历数组 $nums$。当 $cur$ 指针碰到 $1$ 时，检查它与 $cur$ 之间的距离，

- 如果 $\geq k$，则说明符合要求，并更新 $last$ 指针；
- 如果小于 $k$，说明不符合，直接返回 $False$。

遍历正常结束，则符合要求。将 $last$ **初始化** 为一个超大负值，或者代码增加 $if$ 判断。

代码如下，已附加注释：

```Python
# python
class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        # 初始化上一个 1 的位置
        last_idx = -10000

        for i, num in enumerate(nums):
            if num == 1:
                # 计算当前 1 与上一个 1 之间的距离
                distance = i - last_idx - 1
                # 判断
                if distance < k:
                    return False
                # 更新
                last_idx = i
                
        # 走到这，说明都满足
        return True
```

```Java
// java
class Solution {
    public boolean kLengthApart(int[] nums, int k) {
        // 初始化上一个 1 的位置
        // 使用一个足够小的值，确保第一个 1 总是满足条件
        int lastIdx = -k - 1;

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                // 计算当前 1 与上一个 1 之间的距离
                int distance = i - lastIdx - 1;
                // 判断
                if (distance < k) {
                    return false;
                }
                // 更新
                lastIdx = i;
            }
        }
        
        // 走到这，说明都满足
        return true;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 计数

另外一种做法，和上面类似，只需要一个指针 $cur$，一个计数器 $cnt$，用于记录两个 $1$ 之间的距离。从前往后遍历，

- 当前数字是 $0$，说明还是连续的 $0$ 段，让 $cnt+1$；
- 否则，说明 $0$ 段终止，判断 $cnt$ 与 $k$ 的大小关系。

经实测，下面的 $Python$ 代码使用注释后，运行时间为 $11ms$，而去除注释简写的时间为 $6ms$。而在今年 $5$ 月提交该代码，运行时间为 $0ms$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        # 记录自上一个 '1' 以来遇到的 '0' 的数量
        cnt = inf  
        
        for i, x in enumerate(nums):
            if x == 0:
                # 计数器加一
                cnt += 1
            elif cnt < k:
                # 不满足条件
                return False
            else:
                # 满足条件，重置计数器
                cnt = 0
        
        return True
```

```Python
# python
class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        cnt = inf
        for i, x in enumerate(nums):
            if x == 0: cnt += 1
            elif cnt < k: return False
            else: cnt = 0
        return True
```

```Java
// java
class Solution {
    public boolean kLengthApart(int[] nums, int k) {
        int count = k;
        for (int num : nums) {
            if (num == 0) {
                count++;
            } else if (count < k) {
                return false;
            } else {
                count = 0;
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/solutions/3833848/shuang-jie-shuang-zhi-zhen-mo-ni-dan-zhi-rf3x/)
