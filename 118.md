[Problem: 118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/)

### 方法：模拟 & DP & 数学

填充杨辉三角时，如果你搞不清下标的递推关系，可以换成下面的形式来理解：

```Java
                    1                     1
                  1   1          -->      1   1
                1   2   1                 1   2   1
```

对于当前位置 $(i,j)$ 来说，它的值就是左上角元素 $(i-1,j-1)$ 和正上方元素 $(i-1,j)$ 相加而来。是不是比金字塔的形状更好理解？

强烈建议各位，做完本题后，顺手做完后一题 [三角 II](https://leetcode.cn/problems/pascals-triangle-ii/description/)。从全部构建，变为了单行构建。这样一来， $DP$ 才有空间优化的必要，[题解](https://leetcode.cn/problems/pascals-triangle-ii/solutions/3059070/di-tui-er-wei-dpgun-dong-you-hua-yu-chu-jz6xm/) 在这，四种方法，感谢支持。

如果我们直接 **模拟** 三角的变化流程，则代码如下，已附加注释：

```Python
# python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        triangle = []

        for i in range(numRows):
            row = [1] * (i + 1)  # 每一行的开头和结尾都是1，先初始化全为1
            # 中间部分
            for j in range(1, i):
                # 当前元素 = 上一行的左上方 + 右上方
                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]
            triangle.append(row)  # 添加当前行到三角形中

        return triangle
```

```Java
// java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> triangle = new ArrayList<>();

        for (int i = 0; i < numRows; i++) {
            // 每一行的开头和结尾都是1，先初始化全为1
            List<Integer> row = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                row.add(1);
            }

            // 中间部分
            for (int j = 1; j < i; j++) {
                // 当前元素 = 上一行的左上方 + 右上方
                int val = triangle.get(i - 1).get(j - 1) + triangle.get(i - 1).get(j);
                row.set(j, val);
            }

            triangle.add(row); // 添加当前行到三角形中
        }

        return triangle;
    }
}
```

为了方便，将变量 $numRows$ 记作 $n$。

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n^2)$，表示返回列表 $triangle$ 的大小，虽然一般不计入复杂度

---

### $DP$

杨辉三角的每一行的元素值是通过上一行的元素值推导出来。这意味着，当前行的计算依赖于上一行的计算结果，可以使用 **动态规划**。

**定义** $dp[i][j]$ 表示第 $i$ 行的第 $j$ 个元素的值。

当前元素是上一行的两个相邻元素之和，得到 **转移方程**：

$$
dp[i][j]=dp[i−1][j−1]+dp[i−1][j]
$$

其中， $1\leq j\leq i-1$。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # 每一行的所有元素先设为1
        dp = [[1 for j in range(i + 1)] for i in range(numRows)]

        # 从第2行开始更新
        for i in range(1, numRows):
            for j in range(1, i):  # 跳过首尾的1
                # 当前元素 = 上一行的左上 + 右上
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]

        return dp
```

```Java
// java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        // 每一行的所有元素先设为1
        List<List<Integer>> dp = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            List<Integer> row = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                row.add(1);
            }
            dp.add(row);
        }

        // 从第2行开始更新
        for (int i = 1; i < numRows; i++) {
            for (int j = 1; j < i; j++) {  // 跳过首尾的1
                // 当前元素 = 上一行的左上 + 右上
                int val = dp.get(i - 1).get(j - 1) + dp.get(i - 1).get(j);
                dp.get(i).set(j, val);
            }
        }

        return dp;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n^2)$

---

### 数学

从 $0$ 开始编号，杨辉三角的第 $n$ 行第 $k$ 个元素的值是 $C(n, k)$，也就是组合数：

$$
C(n, k) = \binom{n}{k} = \frac{n!}{k!(n-k)!}
$$

其中：

- $n!$ 表示 $n$ 的阶乘，等于 $1 \cdot 2 \cdot 3 \cdots n$
- $0 \leq k \leq n$

例如第 $4$ 行是 $\binom{4}{0}, \binom{4}{1}, \binom{4}{2}, \binom{4}{3}, \binom{4}{4}$，即 $1\ 4\ 6\ 4\ 1$

杨辉三角中的组合数满足以下递推关系：

$$
\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}
$$

这个公式也正是杨辉三角的“相邻两数之和得下一行”的由来。

具体公式的推导部分，请看上面给出的题解链接，万分感谢。代码如下：

```Python
# python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        triangle = []

        for i in range(numRows):
            row = [comb(i, j) for j in range(i + 1)]  # 第 i 行包含 i+1 个元素
            triangle.append(row)
        
        return triangle
```

```Java
// java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> triangle = new ArrayList<>();

        for (int i = 0; i < numRows; i++) {
            List<Integer> row = new ArrayList<>();

            for (int j = 0; j <= i; j++) {
                // 第 i 行包含 i+1 个元素，当前元素为组合数 C(i, j)
                row.add(combination(i, j));
            }

            triangle.add(row);
        }

        return triangle;
    }

    // 手动实现组合数 C(n, k) = n! / (k! * (n - k)!)
    private int combination(int n, int k) {
        // 这里最好使用long，本题数据范围小所以才敢用int
        int res = 1;
        // 使用对称性减少计算量，例如 C(n, k) == C(n, n-k)
        if (k > n - k) {
            k = n - k;
        }
        for (int i = 1; i <= k; i++) {
            res = res * (n - i + 1) / i;
        }
        return res;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n^2)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/pascals-triangle/solutions/3739378/san-jie-mo-ni-dp-shu-xue-geng-qing-xi-di-mtx0/)
