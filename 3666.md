[Problem: 3666. 使二进制字符串全为 1 的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-equalize-binary-string/description/)

### 方法：BFS & 数学

别被表象迷惑了！虽然题目要求翻转下标，但是如果我们真的去枚举下标，状态空间高达 $2^n$，这显然会超时。忽略下标，换个角度看问题。

观察翻转前后的变化，可以发现：**翻转操作与下标的具体位置无关**！

无论是翻转前三个还是后三个，只要翻转的 $0$ 和 $1$ 的 **数量** 一样，最终字符串中 $0$ 的总数变化就是一样的。终极目标是 **让 0 的数量变成** $0$，完全可以把 **“当前字符串中 $0$ 的个数”** 定义为 $BFS$ 的状态节点！

假设当前串 $s$ 有 $c$ 个 $0$，有 $n-c$ 个 $1$。在一次操作中，需要 **恰好** 翻转 $k$ 个不同位置。

假设在这 $k$ 个字符中，此时翻转了 $i$ 个 $0$，同时翻转其余 $k-i$ 个 $1$。

**翻转后的变化：**

1. 这 $i$ 个 $0$ 被翻转成了 $1$ $\implies$ $0$ 的数量减少 $i$。
2. 这 $k-i$ 个 $1$ 被翻转成了 $0$ $\implies$ $0$ 的数量增加 $k-i$。

因此，下一个状态 $c_{next}$ 变为：

$$
c_{next} = c - i + (k - i) = c + k - 2i
$$

我们不能凭空翻转，必须满足现实数量的限制：

1. 翻转的 $0$ 不能超过实际拥有的 $0$：对应 $i \le c$
2. 翻转的 $1$ 不能超过实际拥有的 $1$：对应 $k - i \le n - c \implies i \ge k - (n - c)$
3. 翻转的个数本身必须在 $[0, k]$ 范围内：对应 $0 \le i \le k$

综合起来，在当前状态 $c$ 下，合法的 $i$ 的范围是：

$$
\max(0, k - n + c) \le i \le \min(k, c)
$$

对于范围内的每一个 $i$，都可以走到新的状态 $c_{next} = c + k - 2i$。

**节点**：一个整数 $c$ 表示当前字符串里有 $c$ 个 $0$；**边**：一次操作导致 $c$ 发生的变化。枚举翻转数量 $i$，就可以写出标准的 $BFS$ 模板了。

为了防止重复访问形成死循环，使用 $visited$ **集合** 来记录已经到达过的状态。**队列** 中存放 `(当前 0 的个数, 已经走过的步数)`。

> 不好理解上面的思路？本质上，任意位置都可以翻转，那就相当于 **乱序**，字符串包含的信息只有 “0,1数量”！然后仿照 “单源最短路” 的思路，转化为图的问题。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minOperations(self, s: str, k: int) -> int:
        n = len(s)
        init_c = s.count('0')
        
        # 全是 1
        if init_c == 0:
            return 0
            
        # 队列中存储：(当前 0 的个数, 已经走过的步数)
        queue = deque([(init_c, 0)])
        visited = set([init_c])
        
        while queue:
            c, steps = queue.popleft()
            
            # 合法选择翻转 '0' 的个数
            min_i = max(0, k - n + c)
            max_i = min(k, c)
            
            # 遍历所有可能
            for i in range(min_i, max_i + 1):
                # 转移公式
                next_c = c + k - 2 * i
                
                # 完成目标
                if next_c == 0:
                    return steps + 1
                
                # 全新状态
                if next_c not in visited:
                    visited.add(next_c)
                    queue.append((next_c, steps + 1))
        
        # 无解
        return -1
```

在一个状态 $c$ 下，可以选择翻转 $i$ 个 $0$，而 $i$ 的合法范围可能长达 $O(n)$，所以总时间复杂度为 $O(n^2)$，会超时！经实测，卡在 $982/999$ 样例。

观察状态转移方程 $c_{next} = c + k - 2i$，随着 $i$ 从 $min_i$ 每次增加 $1$，对应 $c_{next}$ 每次减少 $2$。也就是说，所有一步能到达的状态，形成了一个 **奇偶性相同** 的连续区间。

利用这一点，不需要逐个遍历 $i$，而是维护 **“当前还有哪些节点尚未访问”**。使用两个有序集合 $SortedList$：一个存偶数，一个存奇数。

每次计算出下一步可以到达的区间 $[L, R]$ 时，只需要在 $SortedList$ 中利用 **二分** 找到第一个 $\ge L$ 的未访问状态，然后把区间内的有效状态全部加入队列，并从 $SortedList$ 中 **剔除** 即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minOperations(self, s: str, k: int) -> int:
        n = len(s)
        init_c = s.count('0')
        
        # 已经满足条件
        if init_c == 0:
            return 0
        
        # 分别存储【尚未被访问】的偶数状态和奇数状态
        unvisited =[SortedList(), SortedList()]
        for i in range(n + 1):
            if i != init_c:
                unvisited[i % 2].add(i)
        
        # 存储 (当前 0 的个数, 已经走过的步数)
        queue = deque([(init_c, 0)])
        
        while queue:
            c, steps = queue.popleft()
            
            # 翻转 0 的合法数量范围
            min_i = max(0, k - n + c)
            max_i = min(k, c)
            
            # 下一步到达的状态区间
            L = c + k - 2 * max_i
            R = c + k - 2 * min_i
            
            # 确定下一步状态的奇偶性，并选择对应的 SortedList
            parity = L % 2
            sl = unvisited[parity]
            
            # 二分查找第一个 >= L 的状态索引
            idx = sl.bisect_left(L)
            
            # 遍历区间 [L, R] 中所有【尚未访问过】的状态
            while idx < len(sl) and sl[idx] <= R:
                next_c = sl[idx]
                
                # 到达终点
                if next_c == 0:
                    return steps + 1
                
                # 否则入队
                queue.append((next_c, steps + 1))
                
                # 从 SortedList 中删除该状态
                del sl[idx]
        
        # 无解
        return -1
```

```Java
// java
class Solution {
    public int minOperations(String s, int k) {
        int n = s.length();
        int init_c = 0;
        for (char ch : s.toCharArray()) {
            if (ch == '0') init_c++;
        }

        // 已经满足条件
        if (init_c == 0) {
            return 0;
        }

        // 分别存储【尚未被访问】的偶数状态和奇数状态
        TreeSet<Integer>[] unvisited = new TreeSet[2];
        unvisited[0] = new TreeSet<>();
        unvisited[1] = new TreeSet<>();
        for (int i = 0; i <= n; i++) {
            if (i != init_c) {
                unvisited[i % 2].add(i);
            }
        }

        // 存储 (当前 0 的个数, 已经走过的步数)
        Deque<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{init_c, 0});

        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int c = curr[0];
            int steps = curr[1];

            // 翻转 0 的合法数量范围
            int min_i = Math.max(0, k - n + c);
            int max_i = Math.min(k, c);

            // 下一步到达的状态区间
            int L = c + k - 2 * max_i;
            int R = c + k - 2 * min_i;

            // 确定下一步状态的奇偶性，并选择对应的有序集合
            int parity = L % 2;
            TreeSet<Integer> sl = unvisited[parity];

            // 二分查找第一个 >= L 的状态索引
            Integer next = sl.ceiling(L);

            // 遍历区间 [L, R] 中所有【尚未访问过】的状态
            while (next != null && next <= R) {
                int next_c = next;

                // 到达终点
                if (next_c == 0) {
                    return steps + 1;
                }

                // 否则入队
                queue.offer(new int[]{next_c, steps + 1});

                // 从有序集合中删除该状态
                sl.remove(next);

                next = sl.ceiling(L);
            }
        }

        // 无解
        return -1;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是字符串 $s$ 的长度，有序集合的删除/二分查找时间均为 $O(logn)$，每个节点最多入/出队一次
- 空间复杂度： $O(n)$，维护了两个列表和 $BFS$ 队列

---

### 数学

假设经过 $m$ 次操作后，所有的字符都变成了 $1$。令 $X_i$ 为第 $i$ 个位置被翻转的次数。根据目标，易知：

- 如果 $s[i] = 0$，它需要被翻转 **奇数次** 才能变成 $1$
- 如果 $s[i] = 1$，它需要被翻转 **偶数次** 才能变成 $1$

每次操作恰好翻转 $k$ 个 **不同** 的下标，这等价于这 $m$ 次操作构成了总共 $m \times k$ 次翻转。因此所有下标翻转次数的总和必须为 $m \times k$：

$$
\sum X_i = m \times k
$$

并且由于每次操作不能选择重复下标，每个下标在 $m$ 次操作中最多被翻转 $m$ 次：

$$
0 \le X_i \le m
$$

$X_i$ 序列和的最小可能值是所有的 $0$ 都只翻转 $1$ 次，所有的 $1$ 都翻转 $0$ 次，也即：

$$
MinSum = c \times 1 + (n-c) \times 0 = c
$$

$X_i$ 序列和的最大可能值 $MaxSum$，取决于 $m$ 是奇数还是偶数：

- 如果 $m$ 是偶数：则 $0$ 最多被翻转 $m-1$ 次，且 $1$ 最多被翻转 $m$ 次。有
  $MaxSum = c(m-1) + (n-c)m = n \cdot m - c$
- 如果 $m$ 是奇数：则 $0$ 最多被翻转 $m$ 次，且 $1$ 最多被翻转 $m-1$ 次。有
  $MaxSum = cm + (n-c)(m-1) = n \cdot m - (n-c)$

由于在保持奇偶性不变的前提下，我们可以将任何 $X_i$ 增加 $2$。因此，只需 **目标和** $m \times k$ 的奇偶性与 $MinSum$（也就是 $c$）的奇偶性相同，且落在 $[MinSum, MaxSum]$ 区间内，那么就一定能构造出相应的序列！

总结： $m$ 必须满足的 $3$ 个条件：

1. **奇偶性匹配**： $(m \times k) \pmod 2 == c \pmod 2$
2. **总和下界**： $m \times k \ge c \implies m \ge \lceil c/k \rceil$
3. **总和上界**： $m \times k \le MaxSum$
   - 对于偶数 $m$： $mk \le nm - c\implies m \ge \lceil c / (n-k) \rceil$
   - 对于奇数 $m$： $mk \le nm - (n-c)\implies m \ge \lceil (n-c) / (n-k) \rceil$

这样问题就变成了 $O(1)$ 的数学公式检验。只需要分别计算符合不等式的 **最小合法偶数 $m$** 和 **最小合法奇数 $m$**，然后验证它们的奇偶性能否满足条件 $1$，取最小值即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minOperations(self, s: str, k: int) -> int:
        n = len(s)
        c = s.count('0')
        
        # 已经全部是 1
        if c == 0:
            return 0
            
        # 只能每次翻转整个字符串
        if n == k:
            if c == n:
                return 1
            else:
                return -1
                
        # 除法，向上取整
        def ceil_div(a, b):
            return (a + b - 1) // b
            
        m_min = float('inf')
        
        # 探寻最小合法的偶数 m
        # 不等式下界
        min_even = max(ceil_div(c, k), ceil_div(c, n - k))
        # 向上对齐到偶数
        if min_even % 2 != 0:
            min_even += 1
            
        # 检查能否匹配奇偶性
        if (min_even * k) % 2 == c % 2:
            m_min = min(m_min, min_even)
            
            
        # 探寻最小合法的奇数 m
        # 不等式下界
        min_odd = max(ceil_div(c, k), ceil_div(n - c, n - k))
        # 向上对齐到奇数
        if min_odd % 2 == 0:
            min_odd += 1
            
        # 检查能否匹配奇偶性
        if (min_odd * k) % 2 == c % 2:
            m_min = min(m_min, min_odd)
        
        # 无法达成
        return m_min if m_min != float('inf') else -1
```

```Java
// java
class Solution {
    public int minOperations(String s, int k) {
        int n = s.length();
        int c = 0;
        for (char ch : s.toCharArray()) {
            if (ch == '0') c++;
        }

        // 已经全部是 1
        if (c == 0) {
            return 0;
        }

        // 只能每次翻转整个字符串
        if (n == k) {
            if (c == n) {
                return 1;
            } else {
                return -1;
            }
        }

        // 除法，向上取整
        BiFunction<Integer, Integer, Integer> ceil_div = (a, b) -> (a + b - 1) / b;

        int m_min = Integer.MAX_VALUE;

        // 探寻最小合法的偶数 m
        // 不等式下界
        int min_even = Math.max(
                ceil_div.apply(c, k),
                ceil_div.apply(c, n - k)
        );
        // 向上对齐到偶数
        if (min_even % 2 != 0) {
            min_even += 1;
        }

        // 检查能否匹配奇偶性
        if ((min_even * k) % 2 == c % 2) {
            m_min = Math.min(m_min, min_even);
        }

        // 探寻最小合法的奇数 m
        // 不等式下界
        int min_odd = Math.max(
                ceil_div.apply(c, k),
                ceil_div.apply(n - c, n - k)
        );
        // 向上对齐到奇数
        if (min_odd % 2 == 0) {
            min_odd += 1;
        }

        // 检查能否匹配奇偶性
        if ((min_odd * k) % 2 == c % 2) {
            m_min = Math.min(m_min, min_odd);
        }

        // 无法达成
        return m_min != Integer.MAX_VALUE ? m_min : -1;
    }
}
```

- 时间复杂度： $O(n)$，初始时统计一次
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-operations-to-equalize-binary-string/solutions/3909550/shuang-jie-bfschao-shi-er-fen-you-hua-o1-n8vx/)
