[Problem: 36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/description/)

### 方法：模拟 & 位运算

**基础问题**：

- 如何判断一个数字是否重复出现？使用一个变量 $flag$ 作为标记位；
- 如何判断任意 $0$ ~ $9$ 数字重复出现？使用一维数组 $seen[10]$。

**进阶问题**：如何判断任意数字在任意一行/列出现？使用二维数组 $seen[m][10]$，其中 $seen[2][3]$ 的值表示数字 $3$ 在第 $2$ 行是否出现过。

九宫格比较特殊，每个 $3\times 3$ 的方格被划分到一个九宫格。这九个格子有什么 **共同点**？以第一个九宫格为例，它包含 $(0,0),(0,1),\dots,(2,2)$。

仿照一维特点，其实九宫格就是三行三列的 **交集**：如果横/纵坐标 “除以三” 的商相同，说明处在同样的三行/列。也就是说，

**横坐标 $/3$ 且纵坐标 $/3$ 的商相同，说明处于同一九宫格！**

那么，如何判断九宫格内数字重复出现？使用 **三维数组** $seen[i][j][10]$，其中 $seen[1][0][5]=True$ 表示数字 $5$ 在从左往右数的第 $1$ 且从上往下数的第 $0$ 块中。

回到数独问题：使用两个二维数组判断行/列，以及三维数组判断九宫格。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # row[i][d] 表示第 i 行是否有数字 d
        row = [[False] * 9 for _ in range(9)]
        # col[j][d] 表示第 j 列是否有数字 d
        col = [[False] * 9 for _ in range(9)]
        # box[i//3][j//3][d] 表示 3x3 宫是否有数字 d
        box = [[[False] * 9 for _ in range(3)] for _ in range(3)]

        for i, r in enumerate(board):
            for j, val in enumerate(r):
                if val == '.':
                    continue
                # 数值'1'~'9' -> 下标0~8
                d = int(val) - 1
                # 重复遇到该数字
                if row[i][d] or col[j][d] or box[i // 3][j // 3][d]:
                    return False
                # 标记行、列、宫包含数字 x
                row[i][d] = col[j][d] = box[i // 3][j // 3][d] = True
        
        return True
```

```Java
// java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // row[i][d] 表示第 i 行是否有数字 d
        boolean[][] row = new boolean[9][9];
        // col[j][d] 表示第 j 列是否有数字 d
        boolean[][] col = new boolean[9][9];
        // box[i//3][j//3][d] 表示 3x3 宫是否有数字 d
        boolean[][][] box = new boolean[3][3][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char val = board[i][j];
                if (val == '.') {
                    continue;
                }
                // 数值 '1'~'9' -> 下标 0~8
                int d = val - '1';
                // 重复遇到该数字
                if (row[i][d] || col[j][d] || box[i / 3][j / 3][d]) {
                    return false;
                }
                // 标记行、列、宫包含数字 d
                row[i][d] = true;
                col[j][d] = true;
                box[i / 3][j / 3][d] = true;
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(1)$，数独大小固定为 $9\times 9$，运算都是常数级别
- 空间复杂度： $O(1)$

---

### 位运算

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 对应的二进制数为 $10011$。

应用到数组中，数 $5=101$ 可以代表数组中的第 $0$ 个和第 $2$ 个元素存在，其余元素都不存在。上面的数组的第一维长度为 $9$，所以能进行状态压缩。

使用 `|` 运算将数字放到掩码中，以及 `&` 运算判断数字是否存在。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        row = [0] * 9  # 行
        col = [0] * 9  # 列
        group = [0] * 9  # 块

        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':  # 空格跳过
                    continue
                val = 1 << (ord(board[i][j]) - ord('1'))  # 映射到二进制位
                if row[i] & val:      # 行重复
                    return False
                if col[j] & val:      # 列重复
                    return False
                block = (i // 3) * 3 + j // 3  # 块编号 0~8
                if group[block] & val:  # 块重复
                    return False
                row[i] |= val         # 标记行
                col[j] |= val         # 标记列
                group[block] |= val   # 标记块
        
        return True
```

```Java
// java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[] row = new int[9];    // 行
        int[] col = new int[9];    // 列
        int[] group = new int[9];  // 块

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') { // 空格跳过
                    continue;
                }
                int val = 1 << (c - '1'); // 映射到二进制位
                if ((row[i] & val) != 0) { // 行重复
                    return false;
                }
                if ((col[j] & val) != 0) { // 列重复
                    return false;
                }
                int block = (i / 3) * 3 + j / 3; // 块编号 0~8
                if ((group[block] & val) != 0) { // 块重复
                    return false;
                }
                row[i] |= val;       // 标记行
                col[j] |= val;       // 标记列
                group[block] |= val; // 标记块
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/valid-sudoku/solutions/3767374/shuang-jie-shu-zu-biao-ji-wei-yun-suan-j-3g3c/)
