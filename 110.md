[Problem: 110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)

### DFS

左右子树高度不相差 $1$，所以左右子树高度是多少？

在树中求某棵子树的高度，使用 $DFS$。

**定义** $dfs(node)$ 表示节点 $node$ 所在子树的高度。在一棵树中，当前子树的高度 = 左右子树中的最大高度 $+1$，得出如下转移方程：

$$
dfs(node) = max(dfs(node.left),dfs(node.right))+1
$$

求出左右子树高度后，就可以判断当前节点是否平衡。

**流程**：如果任意子节点不平衡，不用继续判断；反之，就继续判断左右节点，直至遍历所有节点。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # 空树是平衡的
        if not root: 
            return True
        
        # 左右高度差不超过1，并判断左右子树
        return abs(self.depth(root.left) - self.depth(root.right)) <= 1 and \
               self.isBalanced(root.left) and \
               self.isBalanced(root.right)

    # 计算树的高度
    def depth(self, root):
        if not root: 
            return 0
        return max(self.depth(root.left), self.depth(root.right)) + 1
```

```Java
// java
class Solution {
    public boolean isBalanced(TreeNode root) {
        // 空树是平衡的
        if (root == null)
            return true;
        // 左右高度差不超过1，并判断左右子树
        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    // 计算树的高度
    private int depth(TreeNode root) {
        if (root == null)
            return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是树中节点个数，重复计算子树高度
- 空间复杂度： $O(n)$，表示递归栈的深度，树的高度为 $O(n)$

---

### 从底至顶

实际上，我们可以在计算高度的 **同时** 判断是否平衡，一旦发现不平衡直接返回 $-1$ 进行剪枝，避免重复计算。

具体来说，递归 $dfs$ 依旧返回子树高度。对于节点 $node$，

- 首先，计算左子树高度。如果左子树不平衡，直接返回 $-1$；
- 然后，计算右子树高度，同理不平衡返回 $-1$；
- 接着，用左右子树的高度差，判断当前节点是否平衡，不平衡返回 $-1$；
- 最后，所有子节点都平衡，才返回当前节点高度。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # 返回 -1 说明不平衡
        return self.dfs(root) != -1
    
    def dfs(self, root):
        if not root: 
            return 0
        
        # 计算左子树高度
        left = self.dfs(root.left)
        # 提前返回
        if left == -1:
            return -1
        
        # 计算右子树高度
        right = self.dfs(root.right)
        # 提前返回
        if right == -1:
            return -1
        
        # 如果左右高度差大于1，标记为不平衡
        if abs(left - right) > 1: 
            return -1
        
        # 返回当前节点高度
        return max(left, right) + 1
```

```Java
// java
class Solution {
    public boolean isBalanced(TreeNode root) {
        // 返回 -1 说明不平衡
        return dfs(root) != -1;
    }

    private int dfs(TreeNode root) {
        if (root == null)
            return 0;
        
        // 计算左子树高度
        int left = dfs(root.left);
        // 提前返回
        if(left == -1)
            return -1;
        
        // 计算右子树高度
        int right = dfs(root.right);
        // 提前返回
        if(right == -1)
            return -1;
        
        // 如果左右高度差大于1，标记为不平衡
        // 否则，返回当前节点高度
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
}
```

- 时间复杂度： $O(n)$，每个节点至多访问两次
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/balanced-binary-tree/solutions/3898665/shuang-jie-bao-li-cong-di-zhi-ding-dfs-y-5hfi/)
