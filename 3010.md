[Problem: 3010. 将数组分成最小总代价的子数组 I](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/)

### 排序 & 线性遍历

多读几遍题目，是把数组分成 $3$ 个连续 **子数组**，而不是子序列！

设这 $3$ 个子数组分别为 $A, B, C$。

- $A$ 的起点一定是原数组的第 1 个元素 $nums[0]$，因为子数组是连续且覆盖原数组头部的，必须从头开始。因此，第一个代价 $nums[0]$ **是固定且不可避免的**。
- 我们需要确定 $B$ 和 $C$ 的起点。假设 $B$ 从索引 $i$ 开始，$C$ 从索引 $j$ 开始，其中 $1 \le i < j < n$。
- 总代价 = $nums[0]$ + $nums[i]$ + $nums[j]$。

**贪心**：为了让总和最小，既然 $nums[0]$ 固定了，只需要让 $nums[i]$ 和 $nums[j]$ 尽可能小。换句话说，我们只需要在除了第一个元素 **以外的所有元素**中，找到 **最小的两个数**。

只要能找到这两个最小的数，不管它们在原数组中的位置先后如何，我们总能把它们作为第二和第三个子数组的起点。因为题目要求分成 $3$ 份，只要 **在它们俩之前** 切两刀即可。

最简单的解法就是排序，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        # 第一个元素 nums[0] 必选
        # 从剩下的元素 nums[1:] 中找到最小的两个
        rest = sorted(nums[1:])
        return nums[0] + rest[0] + rest[1]
```

```Java
// java
class Solution {
    public int minimumCost(int[] nums) {
        // 第一个元素 nums[0] 必选
        // 从剩下的元素 nums[1:] 中找到最小的两个
        int[] rest = Arrays.copyOfRange(nums, 1, nums.length);
        Arrays.sort(rest);
        return nums[0] + rest[0] + rest[1];
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度，快排
- 空间复杂度： $O(n)$，表示数组 $rest$ 的大小，忽略排序的 $O(logn)$ 栈开销

---

### 一次遍历

在数组中寻找最小元素，其实无需排序，使用辅助变量，然后线性遍历即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        # 找最小的两个元素
        min1 = float('inf')
        min2 = float('inf')
        
        for x in nums[1:]:
            if x < min1:
                # 原来的最小变成第二小，当前数变成最小
                min2 = min1
                min1 = x
            elif x < min2:
                # 当前数比最小的大，但比第二小的小
                min2 = x
           
        return nums[0] + min1 + min2
```

```Java
// java
class Solution {
    public int minimumCost(int[] nums) {
        // 找最小的两个元素
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        
        for (int i = 1; i < nums.length; i++) {
            int x = nums[i];
            if (x < min1) {
                // 原来的最小变成第二小，当前数变成最小
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                // 当前数比最小的大，但比第二小的小
                min2 = x;
            }
        }
        
        return nums[0] + min1 + min2;
    }
}
```

- 时间复杂度： $O(n)$，一次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/solutions/3893611/shuang-jie-jie-du-ti-yi-shuo-ming-tan-xi-2yd0/)
