[Problem: 868. 二进制间距](https://leetcode.cn/problems/binary-gap/description/)

### 方法：双指针 & 计数

题意很清晰，如果我们将二进制看作一个坐标系，每一个位都有一个索引。只需要记录每一个 $1$ 出现的索引，然后计算相邻两个 $1$ 的 **索引差**。

定义 $pre$ 表示上一个 $1$ 出现的位置索引，以及 $cnt$ 表示当前指针位置。

从后往前，线性扫描：

- 只要数字 $n$ 还没变成 $0$，就说明还有 $1$ 没处理完。
- 检查 $n$ 的二进制的最末位是否为 $1$。
- 如果是 $0$：说明仍处于两个 $1$ 之间的空隙，什么都不用做；
- 如果是 $1$，需要分情况讨论：
  - **情况一**：首次遇到。如果 $pre$ 还是 $-1$，说明这是从右往左遇到的第一个 $1$。没法计算距离，只记录它的位置 $pre = cnt$。
  - **情况二**：再次遇到。如果 $pre$ 不是 $-1$，说明之前已经有个 $1$ 了。两者距离为 `当前位置cnt - 上次位置pre`。一定记得 **重置锚点**，将 $pre$ 更新为当前位置 $cnt$。因为对于下一个未来的 $1$ 来说，当前的这个 $1$ 就是它的 “前一个”。
- 检查完成后，将 $cnt+1$，逻辑上索引向左移动一位。同时 `n >>= 1`，实际上数字向右移动一位，抛弃刚刚处理过的最低位。
- 当 $n$ 归零，说明全部遍历完成，返回 $res$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def binaryGap(self, n: int) -> int:
        res = 0  # 记录最大的间距
        pre = -1  # 上一次出现 1 的位置
        cnt = 0  # 当前位的位置
        
        while n > 0:
            if n & 1:  # 当前位是 1
                if pre == -1:  # 第一次遇到 1
                    pre = cnt
                else:
                    res = max(res, cnt - pre)  # 更新最大间距
                    pre = cnt
            cnt += 1
            n >>= 1  # 右移一位
        return res
```

```Java
// java
class Solution {
    public int binaryGap(int n) {
        int res = 0;  // 记录最大的间距
        int pre = -1;  // 上一次出现 1 的位置
        int cnt = 0;  // 当前位的位置
        
        while (n > 0) {
            if ((n & 1) == 1) {  // 当前位是 1
                if (pre == -1) {  // 第一次遇到 1
                    pre = cnt;
                } else {
                    res = Math.max(res, cnt - pre);  // 更新最大间距
                    pre = cnt;
                }
            }
            cnt++;
            n >>= 1;  // 右移一位
        }
        return res;
    }
}
```

- 时间复杂度： $O(log_2{n})$，一次遍历每个二进制位
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 计数

我们没必要记录具体的索引 $index$，而是直接 **数两个 $1$ 之间隔了多少个坑**。那么，两个相邻 $1$ 之间的距离 = 中间 $0$ 的个数 $+1$。

因为我们是从低位向高位处理，如果二进制末尾的 $0$ 后面并没有 $1$，比如 $5=100_2$，那么后面的 $0$ 不构成 “两个 $1$ 之间的距离”，需要去除它们。

找到末尾第一个 $1$ 后，也需要将其移出（或者跳过），因为距离是相对于它开始计算的。

此时，开始数数：

- 遇到 $0$，说明在两个 $1$ 之间，计数器 $cnt$ 加 $1$。
- 遇到 $1$，说明这段距离结束了。每走一步 $cnt$ 都会加 $1$，此时的 $cnt$ 就是答案，更新 $res$。切记 **重置计数器**，将 $cnt$ 归零，需要重新统计。

本质上，这两种方法殊途同归，第一种是 **全局坐标相减**，第二种是 **局部增量累加**。

代码如下，已附加注释：

```Python
# python
class Solution:
    def binaryGap(self, n: int) -> int:
        # 移除尾部的 0
        while n > 0 and (n & 1) == 0:
            n >>= 1
        
        # 把这个末尾的 1 移走，开始计算它之后的数据
        n >>= 1
        res = 0
        cnt = 0  # 记录当前两个 1 之间 0 的数量
        
        while n > 0:
            # 当前位是 0，说明还在两个 1 之间的缝隙里
            if (n & 1) == 0:
                cnt += 1
            else:
                # 缝隙结束了
                res = max(res, cnt + 1)
                cnt = 0
            
            # 处理下一位
            n >>= 1
        
        return res
```

```Java
// java
class Solution {
    public int binaryGap(int n) {
        // 移除尾部的 0
        while (n > 0 && (n & 1) == 0) {
            n >>= 1;
        }
        
        // 把这个末尾的 1 移走，开始计算它之后的数据
        n >>= 1;
        int res = 0;
        int cnt = 0;  // 记录当前两个 1 之间 0 的数量
        
        while (n > 0) {
            // 当前位是 0，说明还在两个 1 之间的缝隙里
            if ((n & 1) == 0) {
                cnt++;
            } else {
                // 缝隙结束了
                res = Math.max(res, cnt + 1);
                cnt = 0;
            }
            
            // 处理下一位
            n >>= 1;
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(logn)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/binary-gap/solutions/3906122/shuang-jie-shuang-zhi-zhen-mo-ni-tong-ji-3op5/)
