[Problem: 3446. 按对角线进行矩阵排序](https://leetcode.cn/problems/sort-matrix-by-diagonals/description/)

### 方法：模拟 & 展开

在本题中，要求将主对角线 $(45\degree)$ 上的元素值排序。

这些格子有什么特点？举个例子，主对角线上包含 $(0,0),(1,1)$，右侧的次对角线上有 $(0,1)$ 和 $(1,2)$，以此类推。

发现一个 **规律**：任意一条主对角线上，格子的下标都在直线 $y=x+k$ 上！对于任意坐标 $(i,j)$，只要 “横坐标-纵坐标” 的差相同，就说明在一条对角线上！

**做法**：总共 $2\times n-1$ 条对角线，将 “横坐标 $i$ - 纵坐标 $j$” 的和记作 $d$，根据该值，将一整条对角线上的元素全部取出，然后按照题目规则进行排序。

注意，非递减 = 递增+ 相同，这允许相邻元素相等，一般我们直接调库即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        # 遍历所有对角线，下标差 i - j = d
        for d in range(-(n - 1), n):
            # 收集该对角线元素
            diag = [grid[i][i - d] for i in range(n) if 0 <= i - d < n]
            # 按规则排序：左下降序，右上升序
            diag.sort(reverse = (d >= 0))
            # 排序结果放回原位置
            k = 0
            for i in range(n):
                j = i - d
                if 0 <= j < n:
                    grid[i][j] = diag[k]
                    k += 1
        return grid
```

```Java
// java
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;

        // 遍历所有对角线，下标差 i - j = d
        for (int d = -(n - 1); d < n; d++) {
            List<Integer> diag = new ArrayList<>();

            // 收集该对角线元素
            for (int i = 0; i < n; i++) {
                int j = i - d;
                if (0 <= j && j < n) {
                    diag.add(grid[i][j]);
                }
            }

            // 按规则排序：左下(含主对角线)非递增，右上非递减
            if (d >= 0) {
                diag.sort(Collections.reverseOrder()); // 非递增
            } else {
                Collections.sort(diag); // 非递减
            }

            // 排序结果放回原位置
            int k = 0;
            for (int i = 0; i < n; i++) {
                int j = i - d;
                if (0 <= j && j < n) {
                    grid[i][j] = diag.get(k++);
                }
            }
        }
        return grid;
    }
}
```

长度为 $l$ 的列表，快排时间为 $O(l\times logl)$。这里一共 $2\times n-1$ 条对角线，长度分别为 $1,2,\dots,n,n-1,\dots,1$。排序总成本就是 $2(\sum_{i=1}^{n}ilogi)-nlogn$，每一段列表的长度一定小于 $n$，所以能近似看作 $n^2logn$。具体的数学运算，可以看评论区大佬。

- 时间复杂度： $O(n^2\times logn)$，其中 $n$ 是 $grid$ 的边长
- 空间复杂度： $O(n)$，表示临时列表 $diag$ 的大小，忽略排序的 $O(logn)$ 栈开销

---

### 展开

总过程是 $「收集\to 排序\to 放回」$。经测试，分三段写的速度最慢，两段写的速度最快。代码如下，已附加注释：

```Python
# python
class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        diag_dct = {}

        # Step 1: 收集所有对角线元素
        for i in range(n):
            for j in range(n):
                diag_dct.setdefault(i - j, []).append(grid[i][j])

        # Step 2: 按规则排序
        for k in diag_dct:
            if k >= 0:  # 左下角 (含主对角线)
                diag_dct[k].sort(reverse=True)
            else:       # 右上角
                diag_dct[k].sort()

        # Step 3: 放回矩阵
        for i in range(n):
            for j in range(n):
                grid[i][j] = diag_dct[i - j].pop(0)

        return grid
```

```Java
// java
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;
        Map<Integer, List<Integer>> diagMap = new HashMap<>();

        // Step 1: 收集所有对角线元素
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int key = i - j;
                diagMap.computeIfAbsent(key, k -> new ArrayList<>()).add(grid[i][j]);
            }
        }

        // Step 2: 按规则排序
        for (Map.Entry<Integer, List<Integer>> entry : diagMap.entrySet()) {
            int key = entry.getKey();
            List<Integer> vals = entry.getValue();
            if (key >= 0) { // 左下角 (含主对角线)
                vals.sort(Collections.reverseOrder()); // 非递增
            } else {       // 右上角
                Collections.sort(vals); // 非递减
            }
        }

        // Step 3: 放回矩阵
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int key = i - j;
                List<Integer> vals = diagMap.get(key);
                grid[i][j] = vals.remove(0); // 取出并删除第一个元素
            }
        }

        return grid;
    }
}
```

- 时间复杂度： $O(n^2\times logn)$
- 空间复杂度： $O(n^2)$

---

```Python
# python
class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        # --- 左下角（含主对角线），非递增排序 ---
        for d in range(0, n):  # i - j = d >= 0
            diag = [grid[i][i - d] for i in range(d, n)]
            diag.sort(reverse=True)
            k = 0
            for i in range(d, n):
                grid[i][i - d] = diag[k]
                k += 1

        # --- 右上角，非递减排序 ---
        for d in range(-1, -n, -1):  # i - j = d < 0
            diag = [grid[i][i - d] for i in range(n + d)]
            diag.sort()
            k = 0
            for i in range(n + d):
                grid[i][i - d] = diag[k]
                k += 1

        return grid
```

```Java
// java
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;

        // --- 左下角（含主对角线），非递增排序 ---
        for (int d = 0; d < n; d++) { // i - j = d >= 0
            List<Integer> diag = new ArrayList<>();
            for (int i = d; i < n; i++) {
                diag.add(grid[i][i - d]);
            }

            diag.sort(Collections.reverseOrder()); // 非递增排序

            int k = 0;
            for (int i = d; i < n; i++) {
                grid[i][i - d] = diag.get(k++);
            }
        }

        // --- 右上角，非递减排序 ---
        for (int d = -1; d > -n; d--) { // i - j = d < 0
            List<Integer> diag = new ArrayList<>();
            for (int i = 0; i < n + d; i++) {
                diag.add(grid[i][i - d]);
            }

            Collections.sort(diag); // 非递减排序

            int k = 0;
            for (int i = 0; i < n + d; i++) {
                grid[i][i - d] = diag.get(k++);
            }
        }

        return grid;
    }
}
```

- 时间复杂度： $O(n^2\times logn)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/sort-matrix-by-diagonals/solutions/3765778/mo-ni-shou-ji-pai-xu-fang-hui-yi-duan-li-g5mv/)
