[Problem: 1536. 排布二进制网格的最少交换次数](https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/description/)

### 方法：贪心

首先，我们必须明确，只能交换行，不能交换列，同一行前面的 $0$ 无法换到末尾去。

目标是主对角线以上的格子全部都是 $0$，

- 第 $0$ 行：除了第 $0$ 个格子，后面的 $1$ 到 $n-1$ 格子必须全是 $0$。也就是说，至少要有 $n-1$ 个连续的 **后缀** $0$（从末尾往前数的连续 $0$ 的个数）。
- 第 $1$ 行：除了第 $0,1$ 个格子，后面的 $2$ 到 $n-1$ 必须全是 $0$。也就是至少要有 $n-2$ 个连续的后缀 $0$。
- 第 $i$ 行：同理类推，至少要有 $n - 1 - i$ 个连续的后缀 $0$。

**结论**：不管网格里面的 $1$ 和 $0$ 是怎么排列的，我们 **只关心每一行末尾连续 0 的个数**！

所以，可以把这个 $n\times n$ 的二维网格，**压缩成** 一个长度为 $n$ 的一维数组 $zeros$，其中 $zeros[i]$ 表示第 $i$ 行末尾连续 0 的个数。

**目标转化**：通过交换相邻数字，使得对于每一个 $i$，都满足 $zeros[i]\geq n - 1 - i$。

---

给定一个数组，只能交换相邻元素，求把它变成 “符合条件” 的数组的最少步数。

**暴力怎么做？**

1. 找出这个数组 $zeros$ 的所有可能的全排列（共有 $n!$ 种组合）。
2. 检查每一种排列是否满足要求（即 $arr[i] >= n - 1 - i$）。
3. 如果满足，计算从原数组变成这个排列需要多少次 “相邻交换”，也就是求两个排列之间的 **逆序对** 数量。
4. 在所有满足要求的排列中，找到交换次数最少的那个。

上面这个步骤里面，最难理解的可能是 “逆序对”。举个例子，如果要把初始数组 $[0, 1, 2]$ 仅通过相邻交换变成 $[2, 1, 0]$，最少需要几步？

这在数学上等价于求数组 $[2, 1, 0]$ 中的逆序对个数，答案是 $3$ 步。因为一次相邻交换，最多只能改变 $1$ 个逆序对！从 **冒泡排序** 的角度看，把一个乱序数组排好序，逆序对变成 $0$。每次遇到前大后小的相邻元素就交换，每次交换必定消灭 $1$ 个逆序对。当逆序对被消灭完时，数组就排好了。所以冒泡排序的交换次数，严格等于数组的逆序对数量。

当然，如果直接对包含 **相同元素** 的 $zeros$ 数组做全排列在计算交换次数时会比较麻烦，所以转为对原始数组的 “行索引”，即 $0$ 到 $n-1$ 进行全排列。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        n = len(grid)
        ans = float('inf')

        # 预处理每一行末尾连续 0 的个数
        zeros =[]
        for row in grid:
            count = 0
            for i in range(n - 1, -1, -1):
                if row[i] == 0:
                    count += 1
                else:
                    break
            zeros.append(count)
        
        # 生成所有行索引的全排列
        for p in itertools.permutations(range(n)):
            # 是否满足主对角线以上的格子全是 0
            valid = True
            for i in range(n):
                # p[i] 是当前排列在第 i 行的原始行号
                # zeros[p[i]] 就是这行所拥有的后缀 0 的个数
                if zeros[p[i]] < n - 1 - i:
                    valid = False
                    break
            
            # 计算达到这个排列需要的相邻交换次数
            if valid:
                swaps = 0
                # 计算排列 p 的逆序对数量
                for i in range(n):
                    for j in range(i + 1, n):
                        if p[i] > p[j]:
                            swaps += 1
                
                # 更新
                ans = min(ans, swaps)
        
        return ans if ans != float('inf') else -1
```

有 $n!$ 种全排列，对于每种排列，需要 $O(n)$ 来验证合法性，需要 $O(n^2)$ 来计算逆序对，因此总时间复杂度是 $O(n!\times n^2)$。一定超时！经实测，卡在 $34/129$ 样例。

---

既然不能把所有排列都找出来，能否 **从上到下，一行一行地去满足要求**？

假设为 **第 $0$ 行** 找一个符合条件的数，需要 $zeros[x]\geq n - 1$：此时，从上往下遍历 $zeros$ 数组。假设我们发现第 $j$ 行和第 $k(j < k)$ 行都满足要求。我们应该选哪一个换上来？

**贪心** 选择：选 **离得最近** 的那个，也就是第 $j$ 行！

为什么选最近的？为什么贪心正确？

1. 交换次数最少：把第 $j$ 行一路向上相邻交换到第 $0$ 行，需要 $j$ 次操作；而把第 $k$ 行换上来需要 $k$ 次操作。因为 $j < k$，所以选 $j$ 操作数更少。
2. 不影响其他行：把第 $j$ 行提上来时，原本在 $0$ 到 $j-1$ 的行会被 “挤” 下去一行。但是请注意，**越往下的行，对后缀 0 的要求越低**。所以把它们往下挤，不仅不会让它们更难满足条件，反而会让它们更容易满足条件。因此，选 $j$ 绝对是安全且最优的。

也就是说，这种思路局部最优，且全局最优。

总结一下贪心的具体流程：

- 统计每一行末尾连续 $0$ 的个数，生成数组 $zeros$。
- 遍历需要的行号 $i$ 从 $0$ 到 $n-1$：
- 当前行需要的最小 0 的个数为 $target = n - 1 - i$。
- 在 $zeros$ 数组中，从 $i$ 开始向后寻找，找到 **第一个** 满足 $zeros[j]\geq target$ 的位置 $j$。
- 如果 **找不到**：说明剩下的行里没有一个能满足当前的条件，直接返回 $-1$。
- 如果 **找到了**：把这个数字 $zeros[j]$ 通过相邻交换，一步步移动到位置 $i$，交换的次数就是 $j - i$。
- 更新 $zeros$ 数组：由于 $zeros[j]$ 提到了前面，原来 $i$ 到 $j-1$ 的元素都要往后退一格。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        n = len(grid)
        zeros = []
        ans = 0
        
        # 预处理每一行末尾连续 0 的个数
        for row in grid:
            count = 0
            # 从后往前遍历
            for i in range(n - 1, -1, -1):
                if row[i] == 0:
                    count += 1
                else:
                    break
            zeros.append(count)
        
        # 贪心寻找
        for i in range(n):
            # 当前行需要的后缀 0 的个数
            target = n - 1 - i
            
            # 找从 i 开始，第一个满足条件的行 j
            j = i
            while j < n and zeros[j] < target:
                j += 1

            # 没找到
            if j == n:
                return -1
                
            # 如果找到了，计算交换次数
            ans += (j - i)
            # 模拟交换
            val = zeros.pop(j)
            zeros.insert(i, val)
        
        return ans
```

```Java
// java
class Solution {
    public int minSwaps(int[][] grid) {
        int n = grid.length;
        List<Integer> zeros = new ArrayList<>();
        int ans = 0;
        
        // 预处理每一行末尾连续 0 的个数
        for (int[] row : grid) {
            int count = 0;
            // 从后往前遍历
            for (int i = n - 1; i >= 0; i--) {
                if (row[i] == 0) {
                    count += 1;
                } else {
                    break;
                }
            }
            zeros.add(count);
        }
        
        // 贪心寻找
        for (int i = 0; i < n; i++) {
            // 当前行需要的后缀 0 的个数
            int target = n - 1 - i;
            
            // 找从 i 开始，第一个满足条件的行 j
            int j = i;
            while (j < n && zeros.get(j) < target) {
                j += 1;
            }

            // 没找到
            if (j == n) {
                return -1;
            }
                
            // 如果找到了，计算交换次数
            ans += (j - i);
            // 模拟交换
            int val = zeros.remove(j);
            zeros.add(i, val);
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是矩阵 $grid$ 的行数，列表的 $pop$ 等操作是 $O(n)$
- 空间复杂度： $O(n)$，表示列表 $zeros$ 的长度

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/solutions/3911477/tan-xin-bao-li-chao-shi-tan-xin-jiao-hua-6y64/)
