[Problem: 840. 矩阵中的幻方](https://leetcode.cn/problems/magic-squares-in-grid/description/)

### 方法：数学 & 预处理

暴力模拟大家都会做，只是写法差异，这里不作介绍。

将题目的条件简化，在 $3 \times 3$ 且限定正整数的条件下：**“和为45 + 积为9! + 中心为5 + 边缘行列和为15”** 这个组合条件，在数学上已经将解的空间 **锁死** 在标准的幻方结构上了。

幻方的中心为 $5$ 好理解，下面是证明过程。假设有一个幻方，行、列、对角线和均为 $S=15$。考虑经过中心点的 $4$ 条线（中间行、中间列、两条对角线）：

$$
(行2) + (列2) + (对角1) + (对角2) = 15 \times 4 = 60
$$

这 $4$ 条线覆盖了网格中的所有 $9$ 个格子，**中心点被加了 4 次**，其余 $8$ 个点各被加了 $1$ 次。

将上式写成：

$$
\text{Sum(全网格)} + 3 \times \text{Center} = 60
$$

已知全网格和为 $45$，代入后，轻松得出中心 $Center=5$。

为什么不用判断对角线？可以从 “自由度” 的角度理解。

- 中间行列 **自动满足**：总和是 $45$。既然第一行和第三行各是 $15$，剩下的中间行必然是 $45 - 15 - 15 = 15$。同理中间列也是 $15$。
- 对角线 **被迫满足**：在 $1-9$ 的数字且中心为 $5$ 的前提下，如果要满足所有行列和都是奇数 $15$，数字的 **奇偶性排列** 是被固定的（四个角必须是偶数，中间边必须是奇数）。
- 在这种强约束下，**不存在** 一种排列方式使得 “行列和均为 $15$” 但 “对角线和不为 $15$”。数学上可以证明，当满足上述所有条件时，对角线和必然等于 $3 \times \text{Center} = 15$。

所以，检查对角线是冗余的计算，删掉它没有任何风险。

但是，难道不会有 **另一组** $9$ 个数字，它们的和也是 $45$，积也是 $9!=362880$ 吗？

肯定有。比如将 $\{3,6,8\}$ 变为 $\{4,4,9\}$，得到新集合 $\{1,2,4,4,4,5,7,9,9\}$。很容易验证，总和与乘积结果都满足要求，且包含 $5$。

虽然这个例子能通过 “代数和积” 的判定，但是无法通过 “几何约束”。在上述的条件下，集合里必须 **有两对** 数字，每对的和为 $10$，用来放在中心 $5$ 的上下左右。

因此，虽然 “和积判定法” 本身有哈希冲突，但是加上几何边长约束，可以证明，在整数范围内，能同时骗过这两层检查的 “伪幻方” 是不存在的。

**总结**：枚举矩阵中每个点作为幻方中心，满足 “和为$45$ + 积为 $9!$ + 中心为 $5$ + 边缘行列和为 $15$” 才算作一个幻方。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        # 幻方中心一定是5，边缘行列和为15
        rows, cols = len(grid), len(grid[0])
        dirs = ((0, 1), (1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1), (0, -1), (-1, 0))

        def check(x, y):
            # 中心为5
            if grid[x][y] != 5:
                return False
            # 判断3x3范围内是否有重复
            sum_square = 5
            for d in dirs:
                sum_square += grid[x + d[0]][y + d[1]]
            mult = 5
            for d in dirs:
                mult *= grid[x + d[0]][y + d[1]]
            if sum_square != 45 or mult != 1*2*3*4*5*6*7*8*9:
                return False
            # 判断4条边的和
            if grid[x - 1][y - 1] + grid[x - 1][y] + grid[x - 1][y + 1] != 15:
                return False
            if grid[x - 1][y - 1] + grid[x][y - 1] + grid[x + 1][y - 1] != 15:
                return False
            if grid[x + 1][y - 1] + grid[x + 1][y] + grid[x + 1][y + 1] != 15:
                return False
            if grid[x - 1][y + 1] + grid[x][y + 1] + grid[x + 1][y + 1] != 15:
                return False
            return True

        res = 0
        for r in range(1, rows - 1):
            for c in range(1, cols - 1):
                if check(r, c):
                    res += 1
        return res
```

```Java
// java
class Solution {
    public int numMagicSquaresInside(int[][] grid) {
        // 幻方中心一定是5，边缘行列和为15
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dirs = {{0, 1}, {1, 0}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}, {0, -1}, {-1, 0}};

        int res = 0;
        for (int r = 1; r < rows - 1; r++) {
            for (int c = 1; c < cols - 1; c++) {
                if (check(grid, r, c, dirs)) {
                    res++;
                }
            }
        }
        return res;
    }

    private boolean check(int[][] grid, int x, int y, int[][] dirs) {
        // 中心为5
        if (grid[x][y] != 5) {
            return false;
        }
        
        // 判断3x3范围内是否有重复
        int sumSuqare = 5;
        // 1*2*...*9 = 362880，int 范围内不会溢出
        int mult = 5; 
        
        for (int[] d : dirs) {
            int val = grid[x + d[0]][y + d[1]];
            sumSuqare += val;
            mult *= val;
        }
        
        if (sumSuqare != 45 || mult != 362880) {
            return false;
        }
        
        // 判断4条边的和
        if (grid[x - 1][y - 1] + grid[x - 1][y] + grid[x - 1][y + 1] != 15) {
            return false;
        }
        if (grid[x - 1][y - 1] + grid[x][y - 1] + grid[x + 1][y - 1] != 15) {
            return false;
        }
        if (grid[x + 1][y - 1] + grid[x + 1][y] + grid[x + 1][y + 1] != 15) {
            return false;
        }
        if (grid[x - 1][y + 1] + grid[x][y + 1] + grid[x + 1][y + 1] != 15) {
            return false;
        }
        
        return true;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n,m$ 为矩阵 $grid$ 的行数和列数，检查时间为 $O(1)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 预处理

实际上，满足上述四个条件的幻方，在正整数范围内，仅有 $8$ 个。

将这八个幻方放在静态代码块中，我们遍历网格进行匹配即可。经实测，下面 $Python$ 代码的时间与空间为 $0ms,16.95MB$，均超过 $100\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    # 预存所有可能的8种幻方
    MAGIC_SQUARES = {
        (8, 1, 6, 3, 5, 7, 4, 9, 2), (6, 1, 8, 7, 5, 3, 2, 9, 4),
        (4, 9, 2, 3, 5, 7, 8, 1, 6), (2, 9, 4, 7, 5, 3, 6, 1, 8),
        (6, 7, 2, 1, 5, 9, 8, 3, 4), (8, 3, 4, 1, 5, 9, 6, 7, 2),
        (2, 7, 6, 9, 5, 1, 4, 3, 8), (4, 3, 8, 9, 5, 1, 2, 7, 6)
    }

    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        if rows < 3 or cols < 3:
            return 0
        
        res = 0
        for i in range(rows - 2):
            for j in range(cols - 2):
                # 中心点必须是5
                if grid[i+1][j+1] != 5:
                    continue
                
                # 拼接当前 3x3 区域为一维元组
                current_square = tuple(
                    grid[i][j:j+3] + grid[i+1][j:j+3] + grid[i+2][j:j+3]
                )
                if current_square in self.MAGIC_SQUARES:
                    res += 1
                
        return res
```

```Java
// java
class Solution {
    // 预存所有可能的8种幻方
    private static final Set<String> MAGIC_SQUARES = new HashSet<>(Arrays.asList(
        "816357492", "618753294",
        "492357816", "294753618",
        "672159834", "834159672",
        "276951438", "438951276"
    ));

    public int numMagicSquaresInside(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        if (rows < 3 || cols < 3) {
            return 0;
        }

        int res = 0;
        for (int i = 0; i < rows - 2; i++) {
            for (int j = 0; j < cols - 2; j++) {
                // 中心点必须是5
                if (grid[i + 1][j + 1] != 5) {
                    continue;
                }

                // 拼接当前 3x3 区域为一维字符串
                StringBuilder sb = new StringBuilder();
                sb.append(grid[i][j]).append(grid[i][j + 1]).append(grid[i][j + 2]);
                sb.append(grid[i + 1][j]).append(grid[i + 1][j + 1]).append(grid[i + 1][j + 2]);
                sb.append(grid[i + 2][j]).append(grid[i + 2][j + 1]).append(grid[i + 2][j + 2]);

                if (MAGIC_SQUARES.contains(sb.toString())) {
                    res++;
                }
            }
        }
        return res;
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/magic-squares-in-grid/solutions/3869061/shuang-jie-shu-xue-fang-fa-jia-su-yu-chu-5uxa/)
