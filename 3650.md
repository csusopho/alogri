[Problem: 3650. 边反转的最小路径总成本](https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/description/)

### Dijkstra

题意很简单，所有边权均为正数 $w$ 和 $2w$。求从单源 $0$ 到任意节点的最短路径？非常自然地联想到 $Dijkstra$ 算法。朴素/堆优化版本的原理及模版，请查看这篇 [题解](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/solutions/2848394/po-su-dijkstradui-you-hua-mo-ban-zhao-lu-ve92/)。

虽然题目限制每个节点的开关只能使用一次，但在求解 **正权图的最短路径** 时，最优路径不会包含 **环路**。每个节点只会访问一次！因此，我们不需要在这个约束上做特殊的状态记录（比如位掩码），只需要将 “反向移动” 视为图中存在的 **另一条边** 即可。

用邻接表存图，其中 $graph[u]$ 存储所有从 $u$ 出发可以到达的 $(v, cost)$。对于每条输入边 $[u, v, w]$：

- 正向边：从 $u$ 到 $v$ 的代价为 $w$；
- 反向边：从 $v$ 到 $u$ 的代价为 $2 * w$。

这样就把 “是否反向走边” 的规则，编码进了图的边权里，后续只需在这张图上跑标准最短路。

接下来就是经典操作。

定义 $dist[x]$ 表示从起点 $0$ 到节点 $x$ 的当前已知最小代价。初始化 $dist[0] = 0$，其它节点为无穷大。

使用小根堆按 “当前总代价” 从小到大取出节点，始终保证每次扩展的是 **当前全局代价最小** 的那条路径前端。或者使用朴素版本，线性寻找当前最小代价的节点。

**流程**：

- 将代价为 $0$ 的起点 $(0, 0)$ 压入堆。
- 循环弹出堆顶 $(curCost, u)$：
- 如果 $curCost > dist[u]$，说明这是过期的状态，之前已经找到过更短的到达 $u$ 的路径，直接丢弃。
- 如果 $u = n - 1$，说明已经到达终点，直接返回 $curCost$，结束算法。
- 否则遍历 $u$ 的所有邻居 $(v, weight)$，尝试 “松弛”：
  - 新路径代价 $newCost = curCost + weight$。
  - 若 $newCost < dist[v]$，说明找到了到达 $v$ 的更优路径，更新 $dist[v]$ 并将 $(newCost, v)$ 压入堆中。

如果堆被弹空了仍然没有弹出终点 $n - 1$，说明从 $0$ 无法到达 $n - 1$，返回 $-1$。

注意，本题不能使用朴素版本的 $Dijkstra$，也就是下面这种形式。因为时间复杂度为 $O(n^2)$，题目限制 $n\leq 5\times 10^4$，所以会超时，经测试，卡在 $692/699$ 样例。

```Python
# python
class Solution:
    def minCost(self, n: int, edges: List[List[int]]) -> int:
        # 构建邻接表
        graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))       # 正向边
            graph[v].append((u, 2 * w))   # 开关反向边

        # dist[i] 表示从起点到节点 i 的最短距离
        dist = [float('inf')] * n
        dist[0] = 0
        
        # visited[i] 标记节点 i 是否访问过
        visited = [False] * n

        # 朴素 Dijkstra，每次确定一个节点
        for _ in range(n):
            
            # 寻找当前距离最小的未访问节点
            u = -1
            min_val = float('inf')
            
            for i in range(n):
                if not visited[i] and dist[i] < min_val:
                    min_val = dist[i]
                    u = i
            
            # 找不到可达节点，或者找到的节点距离是无穷大，说明剩下的节点都不可达
            if u == -1 or dist[u] == float('inf'):
                break
                
            # 找到了终点的最短路径
            if u == n - 1:
                return dist[u]
            
            # 标记该节点为已访问
            visited[u] = True
            
            # 松弛操作，更新邻居的距离
            for v, weight in graph[u]:
                if not visited[v]:
                    if dist[u] + weight < dist[v]:
                        dist[v] = dist[u] + weight

        return dist[n-1] if dist[n-1] != float('inf') else -1
```

使用堆优化版本，则不会超时，建议掌握如下写法：

```Python
# python
class Solution: 
    def minCost(self, n: int, edges: List[List[int]]) -> int: 
        # 邻接表 
        graph = [[] for _ in range(n)] 
        
        for u, v, w in edges: 
            # 正常的边 u -> v 
            graph[u].append((v, w)) 
            # 开关反转的边 v -> u 
            graph[v].append((u, 2 * w)) 
        
        # Dijkstra 算法初始化 
        dist = {i: float('inf') for i in range(n)} 
        dist[0] = 0 
        
        # 优先队列: (当前总成本, 当前节点) 
        pq = [(0, 0)] 
        
        while pq: 
            cur_cost, u = heapq.heappop(pq) 
            
            # u 之前出过堆 
            if cur_cost > dist[u]: 
                continue 
            # 到达终点 
            if u == n - 1: 
                return cur_cost 
            
            # 遍历邻居 
            for v, weight in graph[u]: 
                new_cost = cur_cost + weight 
                # 只有发现更短路径时才更新并入队 
                if new_cost < dist[v]: 
                    dist[v] = new_cost 
                    heapq.heappush(pq, (new_cost, v)) 
        
        # 无法到达 
        return -1
```

```Java
// java
class Solution {
    public int minCost(int n, int[][] edges) {
        // 邻接表
        List<int[]>[] graph = new ArrayList[n];
        // 初始化
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int[] e : edges) {
            int u = e[0], v = e[1], w = e[2];
            // 正常的边 u -> v
            graph[u].add(new int[]{v, w});
            // 开关反转的边 v -> u
            graph[v].add(new int[]{u, 2 * w});
        }

        // Dijkstra 算法初始化
        long[] dist = new long[n];
        Arrays.fill(dist, Long.MAX_VALUE / 2);
        dist[0] = 0;

        // 优先队列: (当前总成本, 当前节点)
        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));
        pq.offer(new long[]{0, 0});

        while (!pq.isEmpty()) {
            long[] cur = pq.poll();
            long curCost = cur[0];
            int u = (int) cur[1];

            // u 之前出过堆
            if (curCost > dist[u]) {
                continue;
            }
            // 到达终点
            if (u == n - 1) {
                return (int) curCost;
            }

            // 遍历邻居
            for (int[] e : graph[u]) {
                int v = e[0];
                int w = e[1];
                long newCost = curCost + w;
                // 只有发现更短路径时才更新并入队
                if (newCost < dist[v]) {
                    dist[v] = newCost;
                    pq.offer(new long[]{newCost, v});
                }
            }
        }

        // 无法到达
        return -1;
    }
}
```

- 时间复杂度： $O(m\times logn)$，其中 $m$ 是数组 $edges$ 的长度表示边数，而 $n$ 是节点数
- 空间复杂度： $O(n+m)$，表示邻接表 $graph$、数组 $dist$ 以及堆 $pq$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/solutions/3889966/zui-duan-lu-po-su-dijkstra-dui-you-hua-b-nlys/)
