[Problem: 66. 加一](https://leetcode.cn/problems/plus-one/description/)

### 方法：模拟 & 简化

数组第 $0$ 位是最高位，第 $n-1$ 位是个位。

对数字 $+1$，就是对个位 $+1$，然后判断是否进位，然后不断向高位 $+1$。

因此，我们使用标志位 $carry$ 表示是否向高位传递 $1$，**模拟** 整个流程即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        # 进位标志位
        carry = 1
        
        # 倒序遍历
        for i in range(len(digits) - 1, -1, -1):
            # 没有进位了
            if carry == 0:
                break
            
            # 当前数字加上进位
            digits[i] += carry
            
            if digits[i] == 10:
                digits[i] = 0   # 当前位归零
                carry = 1       # 进位标志保持为 1
            else:
                carry = 0       # 未满 10，消除进位标志
        
        # 最高位溢出
        if carry == 1:
            digits.insert(0, 1)
            
        return digits
```

```Java
// java
class Solution {
    public int[] plusOne(int[] digits) {
        // 进位标志位
        int carry = 1;
        
        // 倒序遍历
        for (int i = digits.length - 1; i >= 0; i--) {
            // 没有进位了
            if (carry == 0) {
                break;
            }
            
            // 当前数字加上进位
            digits[i] += carry;
            
            if (digits[i] == 10) {
                digits[i] = 0;   // 当前位归零
                carry = 1;       // 进位标志保持为 1
            } else {
                carry = 0;       // 未满 10，消除进位标志
            }
        }
        
        // 最高位溢出
        if (carry == 1) {
            int[] newDigits = new int[digits.length + 1];
            newDigits[0] = 1;
            return newDigits;
        }
            
        return digits;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $digits$ 的长度
- 空间复杂度： $O(n)$，平均情况为 $O(1)$，最坏情况下会增加最高位

---

### 简化

如果不进位到最高位，也就是说在循环内就停止进位，可以提前返回。

代码如下，已附加注释：

```Python
# python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)

        for i in range(n - 1, -1, -1):
            digits[i] += 1
            # 提前返回
            if digits[i] != 10:
                return digits
            # 当前位归 0
            digits[i] = 0
        
        # 走到这说明得增加一位
        return [1] + digits
```

```Java
// java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;

        for (int i = n - 1; i >= 0; i--) {
            digits[i]++;
            // 提前返回
            if (digits[i] != 10) {
                return digits;
            }
            // 当前位归 0
            digits[i] = 0;
        }
        
        // 走到这说明得增加一位
        int[] newDigits = new int[n + 1];
        newDigits[0] = 1;
        return newDigits;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/plus-one/solutions/3870400/mo-ni-biao-zhi-wei-ti-qian-tui-chu-2026x-k1ya/)
