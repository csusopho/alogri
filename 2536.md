[Problem: 2536. 子矩阵元素加 1](https://leetcode.cn/problems/increment-submatrices-by-one/description/)

### 方法：差分 & 优化

题意：每次对子矩阵内所有数字 $+1$，然后查询变化完成后的 $mat$。

本题虽然可以暴力解决，但是复杂度是 $O(q\times n^2)$，题目限制 $n\leq 500,q\leq 10^4$，极有可能超时，因此不推荐。

实际上，本题就是两个考察点：先二维差分，然后二维前缀和。

什么是二维前缀和？具体图解/原理/推导，可以看这篇 [题解](https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/2993541/tu-jie-er-wei-qian-zhui-he-tui-dao-ji-su-61oc/)。

什么是差分？差分是一种与前缀和相对的策略，可以当做是求和的逆运算，它能快速解决 **区间求和** 问题。具体原理/推导，可以看看这篇 [题解](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solutions/2899892/chai-fen-mei-ju-chai-fen-yuan-li-ying-yo-pbel/)。

为什么使用差分？假设我们对数组 $[1,2,3,4]$ 的所有数字 $+1$，暴力做法需要遍历 $4$ 个数字。如果要重复 $10000$ 次累加怎么办？因此，增加一个小技巧，在数组首位置 $+1$，在数组末尾 $-1$，表示这个范围的 **增量**。如此一来，重复一万次，就相当于在首位 $+-$ 一万。此时，从前往后遍历，

$$
真实数字=原数字+增量
$$

我们只需要 **一次** 遍历，就可以快速求出累加后的值。二维差分，则是同理逻辑，只不过是在二维数组上进行，具体原理图如下：

![pic](https://pic.leetcode.cn/1763050073-SojicJ-image-20240331114725714.png)

此时，想必你已经掌握了本题的解题 **流程**：根据 $queries$ 更新差分数组 $diff$，然后对差分数组累加，还原出真实的 $mat$ 数组。

代码如下，已附加注释：

```Python
# python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        # 二维差分数组
        diff = [[0] * (n + 2) for _ in range(n + 2)]
        
        # 处理每个查询
        for row1, col1, row2, col2 in queries:
            # 差分矩阵的四个关键点操作
            diff[row1 + 1][col1 + 1] += 1      # 左上角 +1
            diff[row1 + 1][col2 + 2] -= 1      # 右上角右侧 -1
            diff[row2 + 2][col1 + 1] -= 1      # 左下角下侧 -1
            diff[row2 + 2][col2 + 2] += 1      # 右下角右下侧 +1
        
        # 初始化结果矩阵
        mat = [[0] * n for _ in range(n)]
        
        # 通过差分矩阵还原原始矩阵
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                # 二维前缀和计算：当前值 = 上方值 + 左侧值 - 左上值 + 差分值
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]
                # 将结果填入原矩阵（注意下标转换）
                mat[i - 1][j - 1] = diff[i][j]
        
        return mat
```

```Java
// java
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        // 二维差分数组
        int[][] diff = new int[n + 2][n + 2];
        
        // 处理每个查询
        for (int[] query : queries) {
            int row1 = query[0];
            int col1 = query[1];
            int row2 = query[2];
            int col2 = query[3];
            
            // 差分矩阵的四个关键点操作
            diff[row1 + 1][col1 + 1]++;      // 左上角 +1
            diff[row1 + 1][col2 + 2]--;      // 右上角右侧 -1
            diff[row2 + 2][col1 + 1]--;      // 左下角下侧 -1
            diff[row2 + 2][col2 + 2]++;      // 右下角右下侧 +1
        }
        
        // 初始化结果矩阵
        int[][] mat = new int[n][n];
        
        // 通过差分矩阵还原原始矩阵
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 二维前缀和计算：当前值 = 上方值 + 左侧值 - 左上值 + 差分值
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
                // 将结果填入原矩阵（注意下标转换）
                mat[i - 1][j - 1] = diff[i][j];
            }
        }
        
        return mat;
    }
}
```

- 时间复杂度： $O(q+n^2)$，其中 $q$ 是数组 $queries$ 的长度
- 空间复杂度： $O(n^2)$，表示数组 $diff$ 的大小

---

### 原地

我们可以将 $mat$ 矩阵本身用作差分数组，在它上面进行差分&累加。

特别注意，记得下标 **不能越界**。如果将 $diff$ 数组设置为 $n^2$ 大小，那么就不能让 $i+1$ 或者 $j+1$ 超过 $n$。有小伙伴疑问，上面的流程不是会在边界 $-1$ 吗，这里边界超出怎么办？其实不用理会，因为 $-1$ 操作是防止影响子矩阵外面的数字，边界超出的话，更外层不会存在数字！

另一种方法是，将 $diff$ 数组变为 $(n+2)^2$ 大小，正常求解，然后截取中间的 $n^2$ 大小矩阵返回。不过这种方法实测速度较慢，这里不再展示。

代码如下，已附加注释：

```Python
# python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        diff = [[0] * n for _ in range(n)]

        # 计算差分
        for r1, c1, r2, c2 in queries:
            diff[r1][c1] += 1
            if c2 + 1 < n:
                diff[r1][c2 + 1] -= 1
            if r2 + 1 < n:
                diff[r2 + 1][c1] -= 1
            if r2 + 1 < n and c2 + 1 < n:
                diff[r2 + 1][c2 + 1] += 1

        # 计算前缀和
        for i in range(n):
            for j in range(n):
                if i > 0:
                    # 加上来自上方单元格的值
                    diff[i][j] += diff[i - 1][j]
                if j > 0:
                    # 加上来自左方单元格的值
                    diff[i][j] += diff[i][j - 1]
                if i > 0 and j > 0:
                    # 左上方的区域被加了两次，所以减去一次
                    diff[i][j] -= diff[i - 1][j - 1]
        
        return diff
```

```Java
// java
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        int[][] diff = new int[n][n];

        // 计算差分
        for (int[] query : queries) {
            int r1 = query[0];
            int c1 = query[1];
            int r2 = query[2];
            int c2 = query[3];

            diff[r1][c1]++;
            if (c2 + 1 < n) {
                diff[r1][c2 + 1]--;
            }
            if (r2 + 1 < n) {
                diff[r2 + 1][c1]--;
            }
            if (r2 + 1 < n && c2 + 1 < n) {
                diff[r2 + 1][c2 + 1]++;
            }
        }

        // 计算前缀和
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0) {
                    // 加上来自上方单元格的值
                    diff[i][j] += diff[i - 1][j];
                }
                if (j > 0) {
                    // 加上来自左方单元格的值
                    diff[i][j] += diff[i][j - 1];
                }
                if (i > 0 && j > 0) {
                    // 左上方的区域被加了两次，所以减去一次
                    diff[i][j] -= diff[i - 1][j - 1];
                }
            }
        }
        
        return diff;
    }
}
```

- 时间复杂度： $O(q+n^2)$
- 空间复杂度： $O(1)$，返回值一般不计入复杂度

---

### 优化

仔细想想，最终的目标 $mat[i][j]$ 是要求出差分矩阵 $diff$ 从 $(0, 0)$ 到 $(i, j)$ 这个矩形区域内所有值的总和。

在上面的步骤中，用的是 “上方+左方-左上+当前”，实际比较麻烦。如果我们能求出当前第 $i$ 行的 **一维前缀和**，再结合从 $(0, 0)$ 到 $(i-1, j)$ 这个 **上方大矩形**。

将这两个部分加起来，即 $mat[i-1][j]$ (上方大矩形) + $cnt$ (当前行小长条) = 从 $(0,0)$ 到 $(i, j)$ 的整个矩形区域的总和。这正是我们想要的 $mat[i][j]$ 的值！

因此，可以简化代码，大幅度提升代码速度：

```Python
# python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        diff = [[0] * (n + 1) for _ in range(n + 1)]

        # 计算差分
        for r1, c1, r2, c2 in queries:
            diff[r1][c1] += 1
            diff[r1][c2 + 1] -= 1
            diff[r2 + 1][c1] -= 1
            diff[r2 + 1][c2 + 1] += 1

        mat = [[0] * n for _ in range(n)]
        for i in range(n):
            cnt = 0  # 这一行的差分和
            for j in range(n):
                cnt += diff[i][j]
                # 累加上方单元格，原地更新
                mat[i][j] = cnt if i == 0 else mat[i - 1][j] + cnt
        
        return mat
```

```Java
// java
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        int[][] diff = new int[n + 1][n + 1];

        // 计算差分
        for (int[] query : queries) {
            int r1 = query[0];
            int c1 = query[1];
            int r2 = query[2];
            int c2 = query[3];

            diff[r1][c1]++;
            diff[r1][c2 + 1]--;
            diff[r2 + 1][c1]--;
            diff[r2 + 1][c2 + 1]++;
        }

        int[][] mat = new int[n][n];
        for (int i = 0; i < n; i++) {
            int cnt = 0; // 这一行的差分和
            for (int j = 0; j < n; j++) {
                cnt += diff[i][j];
                // 累加上方单元格，原地更新
                mat[i][j] = (i == 0) ? cnt : mat[i - 1][j] + cnt;
            }
        }
        
        return mat;
    }
}
```

- 时间复杂度： $O(q+n^2)$
- 空间复杂度： $O(n^2)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/increment-submatrices-by-one/solutions/3831552/tu-jie-er-wei-chai-fen-qian-zhui-he-mo-n-z8su/)
