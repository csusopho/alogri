[Problem: 961. 在长度 2N 的数组中找出重复 N 次的元素](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/description/)

### 方法：随机 & 鸽巢 & 摩尔

只有一个数字重复 $n$ 次，其他数字都只出现一次。

**最简单** 的思路：使用哈希表，记录所有元素的出现次数，然后找出最大次数的那个数。

或者说，对数组进行 **排序**，然后遍历一次，**相邻** 元素相同的就是目标。

这两种比较容易，下面给出三种比较巧妙的解法。

第一种，**随机法**。从数组中随机取两个不同位置的数字，如果它们相等，则说明找到；反之，继续寻找，直到相等为止。

目标元素占比 $1/2$，随便抓两个数，这两个数都是目标元素的概率约为 $1/4$。平均只需循环 **4次** 就能返回结果，速度极快。

代码如下，已附加注释：

```Python
# python
import random

class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        while True:
            # 随机选取两个不同的索引
            x, y = random.sample(nums, 2)
            # 相等，说明找到
            if x == y:
                return x
```

```Java
// java
class Solution {
    public int repeatedNTimes(int[] nums) {
        Random random = new Random();
        while (true) {
            // 随机选取两个不同的索引
            int i = random.nextInt(nums.length);
            int j = random.nextInt(nums.length);
            if (i == j) continue;
            
            int x = nums[i];
            int y = nums[j];

            // 相等，说明找到
            if (x == y) {
                return x;
            }
        }
    }
}
```

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

---

### 间隔检查

根据鸽巢原理可知，当一个元素占据数组一半位置时，它不可能被其他元素完全隔开，即不可能所有的 $x$ 之间都间隔 **两个或以上** 的非 $x$ 元素。

比如 $[1,2,1,3,1,4],[1,1,2,3,4,1],[1,2,3,1]$。

**总结**：要么所有相同数都不相邻，要么存在相邻且相等的情况。

如果遍历完未找到，仅在极少数特定排列的小 $n$ 情况（比如上述 $n=4$），答案就是头/尾元素。

代码如下，已附加注释：

```Python
# python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        # 要么所有相同数都不相邻，要么存在相邻且相等的情况
        for i in range(len(nums) - 2):
            if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:
                return nums[i]
        return nums[-1]
```

```Java
// java
class Solution {
    public int repeatedNTimes(int[] nums) {
        // 要么所有相同数都不相邻，要么存在相邻且相等的情况
        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2]) {
                return nums[i];
            }
        }
        return nums[nums.length - 1];
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 摩尔投票

摩尔投票，它是一种线性时间的算法，专门用来解决此类「众数」问题，具体 $Wiki$ 百科，链接：[OI](https://oi-wiki.org/misc/main-element/)，[peida](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95)。强烈推荐我写过的这篇 [讨论](https://leetcode.cn/discuss/post/3613283/fen-xiang-mo-er-tou-piao-jie-jue-suo-you-89r0/)，总结了通过情况。

众数问题是数量 **大于** 界限，本题是正好一半，也即 **等于** 界限。怎么办？

**删除一个** 元素后进行摩尔投票。

- 如果删除的不是目标，那么剩下的数组中，目标占据一半以上，正常摩尔投票即可；
- 如果删除的是目标，那么剩下的数组中，它一定会重复出现，增加一个 $if$ 判断。

这里选定初始候选元素为 $nums[0]$，以及去除元素为 $nums[n-1]$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        # 去除一个数后摩尔投票
        # 如果去除的是目标，它一定会重复出现；否则投票就能得出正确结果
        n = len(nums)
        last = nums[-1]  # 去除最后一个数
        ans = nums[0]  # 出现次数最多的数
        cnt = 0  # 对应的出现次数

        for i in range(n - 1):
            if nums[i] == last:  # 重复出现
                return last
            # 正常投票流程如下
            if cnt == 0:
                ans = nums[i]
            if nums[i] == ans:
                cnt += 1
            else:
                cnt -= 1
        
        return ans
```

```Java
// java
class Solution {
    public int repeatedNTimes(int[] nums) {
        // 去除一个数后摩尔投票
        // 如果去除的是目标，它一定会重复出现；否则投票就能得出正确结果
        int n = nums.length;
        int last = nums[n - 1];  // 去除最后一个数
        int ans = nums[0];  // 出现次数最多的数
        int cnt = 0;  // 对应的出现次数

        for (int i = 0; i < n - 1; i++) {
            if (nums[i] == last) {  // 重复出现
                return last;
            }
            // 正常投票流程如下
            if (cnt == 0) {
                ans = nums[i];
            }
            if (nums[i] == ans) {
                cnt++;
            } else {
                cnt--;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/solutions/3870981/wu-jie-ha-xi-pai-xu-sui-ji-zhua-qu-jian-oqyx5/)
