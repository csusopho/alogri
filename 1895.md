[Problem: 1895. 最大的幻方](https://leetcode.cn/problems/largest-magic-square/description/)

### 前缀和

为了高效计算子网格的行、列和对角线的和，使用 **前缀和**，具体原理看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

**暴力** 做法：枚举所有边长的正方向，检查它是否为幻方。

**优化**：答案是要求最大幻方，因此我们从大到小枚举边长，一旦成功找到，就能立刻返回。

定义 $rowSum[i][j]$ 表示第 $i$ 行前 $j$ 个元素的和，以及 $colSum[i][j]$ 表示第 $j$ 列前 $i$ 个元素的和。

**流程**：先填充前缀和，然后暴力枚举，验证所有行、列和两条对角线的和是否相同。

代码如下，已附加注释：

```Python
# python
class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        # row_sum[i][j] 表示第 i 行，前 j 个元素的和
        # col_sum[i][j] 表示第 j 列，前 i 个元素的和
        row_sum = [[0] * (n + 1) for _ in range(m)]
        col_sum = [[0] * n for _ in range(m + 1)]
        
        for i in range(m):
            for j in range(n):
                row_sum[i][j+1] = row_sum[i][j] + grid[i][j]
                col_sum[i+1][j] = col_sum[i][j] + grid[i][j]
                
        # 从大到小枚举边长 k
        max_k = min(m, n)
        
        for k in range(max_k, 1, -1):
            # 枚举左上角坐标 (r, c)
            for r in range(m - k + 1):
                for c in range(n - k + 1):
                    
                    # 检查是否为幻方
                    # 获取第一行的和
                    target = row_sum[r][c+k] - row_sum[r][c]
                    
                    is_magic = True
                    
                    # 检查每一行
                    for i in range(k):
                        # 当前行的区间和
                        curr_row = row_sum[r+i][c+k] - row_sum[r+i][c]
                        if curr_row != target:
                            is_magic = False
                            break
                    if not is_magic:
                        continue
                    
                    # 检查每一列
                    for j in range(k):
                        # 当前列的区间和
                        curr_col = col_sum[r+k][c+j] - col_sum[r][c+j]
                        if curr_col != target:
                            is_magic = False
                            break
                    if not is_magic:
                        continue
                    
                    # 检查两条对角线
                    d1, d2 = 0, 0
                    for i in range(k):
                        d1 += grid[r+i][c+i]           # 主对角线
                        d2 += grid[r+i][c+k-1-i]       # 副对角线
                    
                    # 找到最大的 k，直接返回
                    if d1 == target and d2 == target:
                        return k
        # 走不到这
        return 1
```

```Java
// java
class Solution {
    public int largestMagicSquare(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // rowSum[i][j] 表示第 i 行，前 j 个元素的和
        int[][] rowSum = new int[m][n + 1];
        // colSum[i][j] 表示第 j 列，前 i 个元素的和
        int[][] colSum = new int[m + 1][n];
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rowSum[i][j+1] = rowSum[i][j] + grid[i][j];
                colSum[i+1][j] = colSum[i][j] + grid[i][j];
            }
        }
        
        // 从大到小枚举边长 k
        int maxK = Math.min(m, n);
        
        for (int k = maxK; k >= 2; k--) {
            // 枚举左上角坐标 (r, c)
            for (int r = 0; r <= m - k; r++) {
                for (int c = 0; c <= n - k; c++) {
                    
                    // 检查是否为幻方
                    // 获取第一行的和
                    int target = rowSum[r][c+k] - rowSum[r][c];
                    
                    boolean isMagic = true;
                    
                    // 检查每一行
                    for (int i = 0; i < k; i++) {
                        // 当前行的区间和
                        int currRow = rowSum[r+i][c+k] - rowSum[r+i][c];
                        if (currRow != target) {
                            isMagic = false;
                            break;
                        }
                    }
                    if (!isMagic) {
                        continue;
                    }
                    
                    // 检查每一列
                    for (int j = 0; j < k; j++) {
                        // 当前列的区间和
                        int currCol = colSum[r+k][c+j] - colSum[r][c+j];
                        if (currCol != target) {
                            isMagic = false;
                            break;
                        }
                    }
                    if (!isMagic) {
                        continue;
                    }
                    
                    // 检查两条对角线
                    int d1 = 0, d2 = 0;
                    for (int i = 0; i < k; i++) {
                        d1 += grid[r+i][c+i];           // 主对角线
                        d2 += grid[r+i][c+k-1-i];       // 副对角线
                    }
                    
                    // 找到最大的 k，直接返回
                    if (d1 == target && d2 == target) {
                        return k;
                    }
                }
            }
        }
        // 走不到这
        return 1;
    }
}
```

- 时间复杂度： $O(mn\times min(m, n))$，其中 $m,n$ 分别是网格的行数和列数。预处理时间为 $O(mn)$，而枚举的 $k$ 最大为 $min(m, n)$
- 空间复杂度： $O(mn)$，表示两个前缀和数组的大小

---

### 优化

可以增加 **对角线前缀和** 数组来优化对角线和的计算，从而提高效率。

额外定义 $diagSum[i][j]$ 表示以 $grid[i-1][j-1]$ 结尾的主对角线（左上到右下）的前缀和，以及 $antiSum[i][j]$ 表示以 $grid[i-1][j]$ 结尾的副对角线（右上到左下）的前缀和。

总流程不变，从最大可能的边长 $k = min(m, n)$ 开始向下枚举，然后检验。

代码如下，已附加注释：

```Python
# python
class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        # 第 i 行，前 j 列的和
        row_sum = [[0] * (n + 1) for _ in range(m)]
        # 第 j 列，前 i 行的和
        col_sum = [[0] * n for _ in range(m + 1)]
        # 主对角线，以 grid[i-1][j-1] 结尾的前缀和
        diag_sum = [[0] * (n + 1) for _ in range(m + 1)]
        # 从右上到左下，行+1，列-1，以 grid[i-1][j] 结尾的前缀和
        anti_sum = [[0] * (n + 2) for _ in range(m + 1)]
        
        # 填充
        for i in range(m):
            for j in range(n):
                val = grid[i][j]
                row_sum[i][j+1] = row_sum[i][j] + val
                col_sum[i+1][j] = col_sum[i][j] + val
                diag_sum[i+1][j+1] = diag_sum[i][j] + val
                anti_sum[i+1][j] = anti_sum[i][j+1] + val
        
        # 从大到小枚举边长 k
        max_k = min(m, n)
        for k in range(max_k, 1, -1):
            # 枚举左上角 (r, c)
            for r in range(m - k + 1):
                for c in range(n - k + 1):
                    # 主对角线和
                    d1 = diag_sum[r+k][c+k] - diag_sum[r][c]
                    # 副对角线和
                    d2 = anti_sum[r+k][c] - anti_sum[r][c+k]
                    
                    if d1 != d2:
                        continue
                    
                    target = d1 # 目标和
                    match = True
                    
                    # 检查行
                    for i in range(r, r + k):
                        if row_sum[i][c+k] - row_sum[i][c] != target:
                            match = False
                            break
                    if not match: continue
                    
                    # 检查列
                    for j in range(c, c + k):
                        if col_sum[r+k][j] - col_sum[r][j] != target:
                            match = False
                            break
                    
                    # 如果所有检查都通过
                    if match:
                        return k
        # 走不到这
        return 1
```

```Java
// java
class Solution {
    public int largestMagicSquare(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        
        // 第 i 行，前 j 列的和
        int[][] rowSum = new int[m][n + 1];
        // 第 j 列，前 i 行的和
        int[][] colSum = new int[m + 1][n];
        // 主对角线，以 grid[i-1][j-1] 结尾的前缀和
        int[][] diagSum = new int[m + 1][n + 1];
        // 从右上到左下，行+1，列-1，以 grid[i-1][j] 结尾的前缀和
        int[][] antiSum = new int[m + 1][n + 2];
        
        // 填充
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int val = grid[i][j];
                rowSum[i][j+1] = rowSum[i][j] + val;
                colSum[i+1][j] = colSum[i][j] + val;
                diagSum[i+1][j+1] = diagSum[i][j] + val;
                antiSum[i+1][j] = antiSum[i][j+1] + val;
            }
        }
        
        // 从大到小枚举边长 k
        int maxK = Math.min(m, n);
        for (int k = maxK; k >= 2; k--) {
            // 枚举左上角 (r, c)
            for (int r = 0; r <= m - k; r++) {
                for (int c = 0; c <= n - k; c++) {
                    // 主对角线和
                    int d1 = diagSum[r + k][c + k] - diagSum[r][c];
                    // 副对角线和
                    int d2 = antiSum[r + k][c] - antiSum[r][c + k];
                    
                    if (d1 != d2) {
                        continue;
                    }
                    
                    int target = d1; // 目标和
                    boolean match = true;
                    
                    // 检查行
                    for (int i = r; i < r + k; i++) {
                        if (rowSum[i][c + k] - rowSum[i][c] != target) {
                            match = false;
                            break;
                        }
                    }
                    if (!match) continue;
                    
                    // 检查列
                    for (int j = c; j < c + k; j++) {
                        if (colSum[r + k][j] - colSum[r][j] != target) {
                            match = false;
                            break;
                        }
                    }
                    
                    // 如果所有检查都通过
                    if (match) {
                        return k;
                    }
                }
            }
        }
        // 走不到这
        return 1;
    }
}
```

- 时间复杂度： $O(mn\times min(m, n))$
- 空间复杂度： $O(mn)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/largest-magic-square/solutions/3883316/shuang-jie-bao-li-mei-ju-er-wei-qian-zhu-volw/)
