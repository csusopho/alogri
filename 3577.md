[Problem: 3577. 统计计算机解锁顺序排列数](https://leetcode.cn/problems/count-the-number-of-computer-unlocking-permutations/description/)

### 方法：全排列

最大大大难点：读懂题意。

解释一下，总共 $n$ 台计算机，初始时 $0$ 号计算机是解锁状态。想要用 $a$ 解锁 $b$，必须满足下标 $a<b$ 且复杂度 $complex[a]<complex[b]$。也即，下标小且值小 -> 解锁更大的。

最终目的是解锁所有计算机，求解锁顺序。~~不是排列中第一个位置的计算机密码已解锁。~~ 这句是人话？只是想误导你，用其他计算机作为第一个。根本不可能的。

那有小伙伴会想，正确顺序是用 $0 \to j \to \dots \to i$ 来解锁 $i$？根据不等式的传递性，链条上所有节点的复杂度必须严格递增？

注意：每台计算机可以使用 **无数次**，并不是一次性用品。

如果计算机 $i$ 不想用计算机 $0$ 来解锁，就必须走上面的链条形式。也即，**只有当 $complex[0] < complex[i]$ 时，计算机 $i$ 才有可能被解锁**。如果 $complex[0] \ge complex[i]$，无论中间经过多少个节点，最初的源头 $0$ 的复杂度都不小于 $i$，不存在有效的递增路径，因此计算机 $i$ 永远无法解锁。

**总结**：计算机 $0$ 万能。

只要 $complex[0]$ 比所有其他复杂度都小，计算机 $0$ 就能满足所有后续计算机的解锁条件。这种情况下，剩下的 $n-1$ 台计算机的 **任何排列顺序都是有效的**。

怎么想到全排列？节点 $0$ 是唯一入口。每个节点都满足 “至少有一个已解锁的前驱”，不要求所有前驱都必须出现，所以额外的依赖关系不会限制排列顺序，只剩下全排列。

用人话来说，就是开头固定为 $0$，后面 $[1,2,\dots,n-1]$ 的顺序任意。根据数学知识可知，有效的顺序总数为 $(n-1)!$，其中 $!$ 表示阶乘。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(complexity)
        # 基准
        root = complexity[0]
        
        # 检查
        for i in range(1, n):
            if complexity[i] <= root:
                return 0
        
        # 剩下的 n-1 个节点可以任意排列
        ans = 1
        for i in range(1, n):
            ans = (ans * i) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int countPermutations(int[] complexity) {
        int MOD = 1000000007;
        int n = complexity.length;
        // 基准
        int root = complexity[0];
        
        // 检查
        for (int i = 1; i < n; i++) {
            if (complexity[i] <= root) {
                return 0;
            }
        }
        
        // 剩下的 n-1 个节点可以任意排列
        long ans = 1;
        for (int i = 1; i < n; i++) {
            ans = (ans * i) % MOD;
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$，两次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 预处理

将 “计算阶乘” 的部分预处理，提到类外的静态代码块位置。力扣平台是多次调用 $count$ 方法跑所有样例，所以预处理中的内容只会计算一次。

代码如下，已附加注释：

```Python
# python
# 预处理
MOD = 10**9 + 7
MAX_N = 100002
fact = [1] * MAX_N

# 预计算阶乘表：fact[i] = i! % MOD
for i in range(2, MAX_N):
    fact[i] = (fact[i - 1] * i) % MOD

class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        n = len(complexity)
        root = complexity[0]
        
        # 检查
        for i in range(1, n):
            if complexity[i] <= root:
                return 0
        
        # 查表
        return fact[n - 1]
```

```Java
// java
class Solution {
    // 预处理
    private static final int MOD = 1000000007;
    private static final int MAX_N = 100002;
    private static final long[] fact = new long[MAX_N];

    static {
        fact[0] = 1;
        fact[1] = 1;
        // 预计算阶乘表：fact[i] = i! % MOD
        for (int i = 2; i < MAX_N; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
    }

    public int countPermutations(int[] complexity) {
        int n = complexity.length;
        // 基准
        int root = complexity[0];

        // 检查
        for (int i = 1; i < n; i++) {
            if (complexity[i] <= root) {
                return 0;
            }
        }

        // 查表
        return (int) fact[n - 1];
    }
}
```

- 时间复杂度： $O(n)$，预处理的时间与空间被均摊为 $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-the-number-of-computer-unlocking-permutations/solutions/3853548/shuang-jie-ju-jue-ji-fan-ren-hua-jie-du-hou4z/)
