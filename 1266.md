[Problem: 1266. 访问所有点的最小时间](https://leetcode.cn/problems/minimum-time-visiting-all-points/description/)

### 贪心

对角线移动允许我们在 $1$ 秒内 **同时缩短** 水平和竖直方向的距离。这是最高效的移动方式。

假设我们要从点 $A(x_1, y_1)$ 移动到 $B(x_2, y_2)$：

- 水平距离： $dx = |x_1 - x_2|$
- 竖直距离： $dy = |y_1 - y_2|$

**贪心策略：** 为了时间最短，应该尽可能多地使用 **对角线移动**。

- 对角线移动的次数取决于 $dx$ 和 $dy$ 中较小的那个值，即 $\min(dx, dy)$
- 进行 $\min(dx, dy)$ 次对角线移动后，在两个方向上都接近了目标 $\min(dx, dy)$ 个单位
- 此时，其中一个方向的距离变成了 $0$，另一个方向还剩下 $|dx - dy|$ 的距离。

剩余的距离只能通过 **直线移动**（水平或竖直）来完成，每一步消耗 $1$ 秒。

也就是说，总时间 = 对角线移动次数 + 剩余直线移动次数，即

$$
\text{Time} = \min(dx, dy) + |dx - dy|
$$

有一个数学恒等式： $\max(a, b) = \min(a, b) + |a - b|$，所以上式能化简为

$$
\text{Time} = \max(dx, dy)
$$

代码如下，已附加注释：

```Python
# python
class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
        ans = 0
        
        # 遍历相邻点
        for i in range(len(points) - 1):
            curr_point = points[i]
            next_point = points[i+1]
            
            # 计算 x 和 y 方向的绝对距离
            dx = abs(curr_point[0] - next_point[0])
            dy = abs(curr_point[1] - next_point[1])
            
            # 切比雪夫距离
            ans += max(dx, dy)
            
        return ans
```

```Java
// java
class Solution {
    public int minTimeToVisitAllPoints(int[][] points) {
        int ans = 0;
        
        // 遍历相邻点
        for (int i = 0; i < points.length - 1; i++) {
            int[] curr_point = points[i];
            int[] next_point = points[i+1];
            
            // 计算 x 和 y 方向的绝对距离
            int dx = Math.abs(curr_point[0] - next_point[0]);
            int dy = Math.abs(curr_point[1] - next_point[1]);
            
            // 切比雪夫距离
            ans += Math.max(dx, dy);
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $points$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-time-visiting-all-points/solutions/3878492/tan-xin-heng-zong-chai-zhi-de-zui-da-zhi-lowp/)
