[Problem: 3381. 长度可被 K 整除的子数组的最大元素和](https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/description/)

### 方法：前缀和&优化

子数组，必须连续。如果暴力枚举所有子数组，那就是 $O(n^2)$ 复杂度。题目限制 $n\leq 2\times 10^5$，所以铁定超时，需要想办法优化。

如何快速计算子数组的和？**前缀和**。具体原理/做法，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。此时，任意子数组 $nums[i:j]$ 的和可以表示为 $PrefixSum[j] - PrefixSum[i]$。

子数组 $nums[i:j)$ 的长度为 $j-i$。题目要求长度能被 $k$ 整除，即 $(j - i) \% k = 0$。有一个数学性质，叫做 **同余** 定理：上式可以转化为 $j \% k = i \% k$。

**结论**：找两个索引 $i,j$，如果两者对 $k$ 取模的余数相同，说明这个子数组符合要求。

因此，我们选择 **分组**，将 “对 $k$ 取模的余数” 相同的索引放在同一组，组内任选两个索引 $o,p$，它们构成的子数组 $nums[o:p]$ 长度一定整除 $k$。

有前缀和辅助，我们轻松求出子数组和。如何让子数组和最大？在遍历到当前索引 $j$ 时，我们需要在当前组中，找到一个之前的索引 $i$，使得 $PrefixSum[i]$ **最小**。用当前值减去最小，是局部最优；遍历一次后，得到全局最优。

**总结**：预处理，计算 $prefix$ 数组并将所有下标分组。主循环中，遍历每个分组，组内维护最小前缀和 $mn$，使用当前前缀和减去 $mn$，更新全局最大值。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = -math.inf

        # 前缀和 prefix[i] 表示前 i 个元素的和
        prefix = [0] * (n + 1)
        # groups[r] 存储所有满足 index % k == r 的前缀和下标
        groups = defaultdict(list)
        # 初始
        groups[0].append(0)

        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
            idx = i + 1
            groups[idx % k].append(idx)
        
        
        # 遍历每个分组
        for remainder, indices in groups.items():
            # 无法构成子数组
            if len(indices) < 2:
                continue
            # 组内维护出现的最小前缀和
            min_p = math.inf
            
            for idx in indices:
                # 对应的前缀和值
                cur_sum = prefix[idx]
                # 之前记录过 min_p
                if min_p != math.inf:
                    # 计算子数组和并更新最大值
                    ans = max(ans, cur_sum - min_p)
                # 更新最小前缀和
                min_p = min(min_p, cur_sum)
        
        return ans if ans != -math.inf else 0
```

```Java
// java
class Solution {
    public long maxSubarraySum(int[] nums, int k) {
        int n = nums.length;
        long ans = Long.MIN_VALUE;

        // 前缀和 prefix[i] 表示前 i 个元素的和
        long[] prefix = new long[n + 1];
        // groups[r] 存储所有满足 index % k == r 的前缀和下标
        Map<Integer, List<Integer>> groups = new HashMap<>();
        // 初始
        groups.computeIfAbsent(0, x -> new ArrayList<>()).add(0);

        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
            int idx = i + 1;
            groups.computeIfAbsent(idx % k, x -> new ArrayList<>()).add(idx);
        }

        // 遍历每个分组
        for (List<Integer> indices : groups.values()) {
            // 无法构成子数组
            if (indices.size() < 2) {
                continue;
            }
            // 组内维护出现的最小前缀和
            long min_p = Long.MAX_VALUE;

            for (int idx : indices) {
                // 对应的前缀和值
                long cur_sum = prefix[idx];
                // 之前记录过 min_p
                if (min_p != Long.MAX_VALUE) {
                    // 计算子数组和并更新最大值
                    ans = Math.max(ans, cur_sum - min_p);
                }
                // 更新最小前缀和
                min_p = Math.min(min_p, cur_sum);
            }
        }

        return ans != Long.MIN_VALUE ? ans : 0;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(n+k)$，表示列表 $groups$ 的大小

---

### 简化

我们可以换个思路，没必要真的进行分组，毕竟都是 $0$ ~ $n$ 顺序遍历。

使用 $MinPrefix[r]$ 存储当索引 $idx \%k=r$ 时，对应余数为 $0$ 到 $k-1$ 出现过的最小前缀和。如此一来，能将 “统计前缀和” 与 “更新最小前缀” 的过程合二为一。

**总结**：对于当前 $nums[i]$ 来说，如果它对 $k$ 的余数是 $r$，可能会与前面某个相同余数的索引，构成一个子数组。先计算当前子数组最大和，然后更新最小前缀。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        ans = -math.inf
        # 记录当前的前缀和
        cur_sum = 0
        # min_prefix_sum[r] 存储当 index % k == r 时，出现过的最小前缀和
        min_prefix_sum = [math.inf] * k
        # 初始
        min_prefix_sum[0] = 0
        
        for i, num in enumerate(nums):
            cur_sum += num
            # 前缀长度为 i + 1，余数
            remainder = (i + 1) % k
            
            # 两点间距离能被 k 整除
            if min_prefix_sum[remainder] != math.inf:
                # 更新最大子数组和
                ans = max(ans, cur_sum - min_prefix_sum[remainder])
            
            # 更新最小前缀和
            min_prefix_sum[remainder] = min(min_prefix_sum[remainder], cur_sum)
        
        return ans if ans != -math.inf else 0
```

```Java
// java
class Solution {
    public long maxSubarraySum(int[] nums, int k) {
        long ans = Long.MIN_VALUE;
        // 记录当前的前缀和
        long cur_sum = 0;
        // min_prefix_sum[r] 存储当 index % k == r 时，出现过的最小前缀和
        long[] min_prefix_sum = new long[k];
        Arrays.fill(min_prefix_sum, Long.MAX_VALUE);
        // 初始
        min_prefix_sum[0] = 0;

        for (int i = 0; i < nums.length; i++) {
            cur_sum += nums[i];
            // 前缀长度为 i + 1，余数
            int remainder = (i + 1) % k;

            // 两点间距离能被 k 整除
            if (min_prefix_sum[remainder] != Long.MAX_VALUE) {
                // 更新最大子数组和
                ans = Math.max(ans, cur_sum - min_prefix_sum[remainder]);
            }

            // 更新最小前缀和
            min_prefix_sum[remainder] = Math.min(min_prefix_sum[remainder], cur_sum);
        }

        return ans != Long.MIN_VALUE ? ans : 0;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(k)$

---

### 优化

我们可以仿照滑窗的思路，预先计算出前 $k$ 个数字，对应不同分组的起始位置。也即，将逻辑分为 “前 $k$ 个” 和 “后续元素”。

由于 $(-1) \% k$ 等价于 $k - 1$，在数组开始前，即 $index = -1$ 时的前缀和为 $0$。因此，我们必须将 $MinPrefix[k-1]$ 重置为 $0$，以便后续计算是减去 $0$。

这种提前预处理的思路，避免初始化 $+\infty$，且优化了整体逻辑，速度更快。实测 $Python$ 代码耗时 $117ms$，超过 $100\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        # min_prefix[r] 存储 index % k == r 时的最小前缀和
        min_prefix = [0] * k
        curr_sum = 0
        
        # 预处理前 k 个元素
        for i in range(k):
            curr_sum += nums[i]
            min_prefix[i] = curr_sum
        
        ans = min_prefix[-1]
        # 修正边界
        if min_prefix[-1] > 0:
            min_prefix[-1] = 0
            
        # 遍历剩余元素
        for i in range(k, len(nums)):
            curr_sum += nums[i]
            remainder = i % k
            
            # 尝试更新最大值：当前前缀和 - 同余数的最小历史前缀和
            sub_sum = curr_sum - min_prefix[remainder]
            if sub_sum > ans:
                ans = sub_sum
            
            # 记录该余数下出现的最小前缀和
            if curr_sum < min_prefix[remainder]:
                min_prefix[remainder] = curr_sum
                
        return ans
```

```Java
// java
class Solution {
    public long maxSubarraySum(int[] nums, int k) {
        // min_prefix[r] 存储 index % k == r 时的最小前缀和
        long[] min_prefix = new long[k];
        long curr_sum = 0;

        // 预处理前 k 个元素
        for (int i = 0; i < k; i++) {
            curr_sum += nums[i];
            min_prefix[i] = curr_sum;
        }

        long ans = min_prefix[k - 1];
        // 修正边界
        if (min_prefix[k - 1] > 0) {
            min_prefix[k - 1] = 0;
        }

        // 遍历剩余元素
        for (int i = k; i < nums.length; i++) {
            curr_sum += nums[i];
            int remainder = i % k;

            // 尝试更新最大值：当前前缀和 - 同余数的最小历史前缀和
            long sub_sum = curr_sum - min_prefix[remainder];
            if (sub_sum > ans) {
                ans = sub_sum;
            }

            // 记录该余数下出现的最小前缀和
            if (curr_sum < min_prefix[remainder]) {
                min_prefix[remainder] = curr_sum;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(k)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/solutions/3843338/san-jie-tong-yu-ding-li-qian-zhui-he-fen-0f59/)
