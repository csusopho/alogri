[Problem: 1611. 使整数变为 0 的最少操作次数](https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/description/)

### 方法：DFS&数学

操作 $1$：翻转第 $0$ 位，比如 $11\to 10$，或者 $10000\to 10001$；操作 $2$：如果当前 $i$ 的右侧全是 $0$，且第 $i$ 位是 $1$，则翻转第 $i+1$ 位，比如 $\dots 110\dots$ 变为 $\dots 010\dots$。

举几个例子：

```Java
数字 6 的二进制是 110
    执行操作 2，从 110 -> 010，其中 i=1
    执行操作 1，从 010 -> 011
    执行操作 2，从 011 -> 001，其中 i=0
    执行操作 1，从 001 -> 000

数字 8 的二进制是 1000
    执行操作 1，从 1000 -> 1001
    执行操作 2，从 1001 -> 1011，其中 i=0
    执行操作 1，从 1011 -> 1010
    执行操作 2，从 1010 -> 1110，其中 i=1
    执行操作 1，从 1110 -> 1111
    执行操作 2，从 1111 -> 1101，其中 i=0
    执行操作 1，从 1101 -> 1100
    执行操作 2，从 1100 -> 0100，其中 i=2
    -----------
    接下来，就是同理，让数字 4 变为 0
    100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000
```

可以发现，最关键的步骤是什么？**处理** $\mathbf{2^x}$！不管是什么数字，都是变为 $100\dots$ 的形式后，再一步步消减为 $0$。

现在就有两个问题：怎么将数字转为 $2^x$？怎么将 $2^x$ 转为 $0$？

因此，我们定义两个 **递归函数**，其中 $toZero(t)$ 计算 “将数字 $t$ 转换为 $0$ 所需的最小操作次数”，以及 $toPower(t,m)$ 计算 “将数字 $t$ 转换为 $2^m$ 所需的最小操作次数”。

---

如何让一个数字 $t$ 变为 $0$？

假设 $t$ 的最高有效位在第 $k$ 位。例如，如果 $t=6(2)=110$，则 $k=2$。函数 $toZero(t)$ 的核心任务是消除第 $k$ 位的这个 $1$。

根据题目的规则 $2$，要翻转第 $k$ 位，前提条件是第 $k-1$ 位必须是 $1$，且更低位都是 $0$。也就是说，我们必须先把数字变成形如 $...110...$ 的状态。

先将 $t$ 拆分为 $2^k + t'$，也即 $11?...=100...+01?...$。前者表示 $2^k$，后者表示 $t'$。那么，如果想要让 $t$ 变为 $0$，需要使用三个步骤：将 $t'\to 2^{k-1}$，这样才能调用规则 $2$ 去除第 $k$ 位（前者 $2^k\to 0$），最后再将 $2^{k-1}\to 0$。

**第一步**：将 $t'$ 变换到 $2^{k-1}$。

- 数字 $t$ 的最高位 $k$ 可以通过 `num.bit_length() - 1` 快速得到；
- 使用 `t ^ (1 << k)`，得到的 $t'$ 就是 $t$ 去掉最高位后的部分；
- 此时，再通过辅助函数 $toPower(t', k-1)$ 来计算翻转次数。

**第二步**：将 $2^k$ 变换到 $0$。直接使用规则 $2$，一次翻转次数足矣。

**第三步**：将 $2^{k-1}$ 变换到 $0$。这不就是 $toZero()$ 函数？！

总的来看，过程是 $t -> 2^{k-1} -> 0$，分为三步走，花费的总次数为 `toPower(t',k-1) + 1 + toZero(2^{k-1})`。

---

如何将数字 $t$ 变为 $2^m$？注意，由于 $t$ 是从上面传下来的，所以 $t$ 的最高位一定小于等于 $m$。我们考察 $t$ 的第 $m$ 位，分情况讨论。

**情况一**：数字 $t$ 的第 $m$ 位是 $1$，也即 $(t \& (1 << m)) \not= 0$。

此时 $t$ 也可以同理拆分为 $2^m + t'$，而目标是 $2^m$。这意味着，我们只需要把低位 $t'$ 变成 $0$ 就可以了，而最高位 $m$ 保持不动。所以 $toPower(t, m)$ 的步数就等于 $toZero(t')$，这就是总步数。

**情况二**：数字 $t$ 的第 $m$ 位是 $0$，也即 $(t \& (1 << m)) = 0$。

这意味着，我们必须在某个时刻，将第 $m$ 位从 $0$ 翻转成 $1$。要翻转第 $m$ 位，前提是数字状态必须先达到 $2^{m-1}$。路径分解为：

1. 将 $t$ 变换到 $2^{m-1}$，这个子问题的步数是 $toPower(t, m-1)$；
2. 现在数字是 $2^{m-1}$，根据规则 $2$ 翻转第 $m$ 位，需要一步。数字变为 $2^m + 2^{m-1}$；
3. 将 $2^m + 2^{m-1}$ 变换到我们的目标 $2^m$，根据情况一的逻辑，这个步数等于 $toZero(2^{m-1})$。

将三步相加，花费的总次数为 `toPower(t, m-1) + 1 + toZero(2^{m-1})`。

---

此时，对于任何数字 $n$，我们都可以通过 $toZero$ 以及 $toPower$ 函数相互调用求解。

不过，由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

为了方便理解，使用两个备忘录存储。在计算前判断，计算后存储。哈希的键是数字 $t$，值是翻转次数 $res$。其他细节不再阐述。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        # 备忘录，缓存两个函数的计算结果
        memo_zero = {0: 0, 1: 1}
        memo_power = {}

        # 将数字 num 转换为 0 的最小操作数
        def convert_to_zero(num):
            # 计算过
            if num in memo_zero:
                return memo_zero[num]
            
            # 找到 num 的最高有效位 (MSB) 的位置 k
            highest_bit_pos = num.bit_length() - 1
            # 去掉最高位
            num_prime = num ^ (1 << highest_bit_pos)
            
            # 将 num 的低位 num_prime 转换到 2^(k-1) 的状态
            # 翻转第 k 位
            # 将 2^(k-1) 转换到 0
            res = convert_to_2power(num_prime, highest_bit_pos - 1) + 1 +\
                convert_to_zero(1 << (highest_bit_pos - 1))
            # 记忆化
            memo_zero[num] = res
            return res

        # 将数字 num 转换为 2^m 的最小操作数
        def convert_to_2power(num, m):
            # 递归边界
            if m < 0:
                return 0
            # 目标是 2^0 = 1
            if m == 0:
                return (num & 1) ^ 1
            # 计算过
            key = (num, m)
            if key in memo_power:
                return memo_power[key]
            
            # num 的第 m 位是 1
            if (num >> m) & 1:
                # 目标是 2^m，只需将 num 的低位部分变为 0 即可
                num_prime = num ^ (1 << m)
                res = convert_to_zero(num_prime)
            else:
                # 第 m 位是 0，目标是 2^m，必须翻转第 m 位
                # 先达到 2^(m-1)，然后翻转第 m 位，再将低位部分变为0
                res = convert_to_2power(num, m - 1) + 1 +\
                    convert_to_zero(1 << (m - 1))
            # 记忆化
            memo_power[key] = res
            return res

        return convert_to_zero(n)
```

```Java
// java
class Solution {
    // 备忘录，缓存两个函数的计算结果
    private Map<Integer, Integer> memo_zero;
    private Map<Long, Integer> memo_power;

    public int minimumOneBitOperations(int n) {
        memo_zero = new HashMap<>();
        memo_power = new HashMap<>();
        
        // 初始化 base case
        memo_zero.put(0, 0);
        memo_zero.put(1, 1);
        
        return convert_to_zero(n);
    }

    // 将数字 num 转换为 0 的最小操作数
    private int convert_to_zero(int num) {
        // 计算过
        if (memo_zero.containsKey(num)) {
            return memo_zero.get(num);
        }

        // 找到 num 的最高有效位 (MSB) 的位置 k
        int highest_bit_pos = 31 - Integer.numberOfLeadingZeros(num);
        // 去掉最高位
        int num_prime = num ^ (1 << highest_bit_pos);
        
        // 将 num 的低位 num_prime 转换到 2^(k-1) 的状态
        // 翻转第 k 位
        // 将 2^(k-1) 转换到 0
        int res = convert_to_2power(num_prime, highest_bit_pos - 1) + 1 +
                  convert_to_zero(1 << (highest_bit_pos - 1));
        
        // 记忆化
        memo_zero.put(num, res);
        return res;
    }

    // 将数字 num 转换为 2^m 的最小操作数
    private int convert_to_2power(int num, int m) {
        // 递归边界
        if (m < 0) {
            return 0;
        }
        // 目标是 2^0 = 1
        if (m == 0) {
            return (num & 1) ^ 1;
        }
        // 计算过
        // 将两个 int 参数打包成一个 long 作为 key
        long key = ((long) num << 32) | m;
        if (memo_power.containsKey(key)) {
            return memo_power.get(key);
        }
        
        int res;
        // num 的第 m 位是 1
        if (((num >> m) & 1) == 1) {
            // 目标是 2^m，只需将 num 的低位部分变为 0 即可
            int num_prime = num ^ (1 << m);
            res = convert_to_zero(num_prime);
        } else {
            // 第 m 位是 0，目标是 2^m，必须翻转第 m 位
            // 先达到 2^(m-1)，然后翻转第 m 位，再将低位部分变为0
            res = convert_to_2power(num, m - 1) + 1 +
                  convert_to_zero(1 << (m - 1));
        }
        
        // 记忆化
        memo_power.put(key, res);
        return res;
    }
}
```

- 时间复杂度： $O(log^2n)$，状态的计算时间与递归深度都是 $O(logn)$
- 空间复杂度： $O(log^2n)$，主要由 $memoPower$ 的大小决定

---

### 数学

题目是 “将 $n$ 变成 $0$ 的步数”。由于所有操作都是可逆的，这等价于 “从 $0$ 开始，走多少步能到达 $n$”？拿数字 $4$ 举例。

```Java
步数    当前状态     操作      下一个状态
0       0 (000)      -           0
1       0 (000)   翻转第0位    1 (001)
2       1 (001)   翻转第1位    3 (011)
3       3 (011)   翻转第0位    2 (010)
4       2 (010)   翻转第2位    6 (110)
5       6 (110)   翻转第0位    7 (111)
6       7 (111)   翻转第1位    5 (101)
7       5 (101)   翻转第0位    4 (100)
```

这个 $n$ 的序列 $0, 1, 3, 2, 6, 7, 5, 4, ...$ 是一个非常著名且重要的序列，它就是 **二进制反射格雷码**。

题目给定的那两条看似奇怪的操作规则，本质上就是在生成格雷码序列！所以，原问题 “将格雷码 $n$ 变成 $0$ 需要多少步？” 被彻底转换成了一个等价的数学问题：“格雷码 $n$ 是由哪个整数 $i$ 生成的？”

格雷码 $g$ 和其对应的原始整数 $b$ 之间有如下数学关系，**编码** 公式：

$$
g = b \oplus (b >> 1)
$$

**解码** 的公式是：

$$
b_k = g_k \\
b_{k-1} = g_{k-1} \oplus b_k \\
b_{k-2} = g_{k-2} \oplus b_{k-1} \\
... \\
b_i = g_i \oplus b_{i+1}
$$

这个公式告诉我们，二进制数 $b$ 的每一位，是对应位格雷码 $g$ 和 $b$ 的更高一位的异或结果。将这个公式展开，可以得到一个累加异或的形式：

`b = g ^ (g >> 1) ^ (g >> 2) ^ (g >> 3) ^ ...`

直接套用公式，得到如下代码：

```Python
# python
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        # 将格雷码 n 解码为其对应的原始整数
        # 计算每一位的异或和
        ans = 0
        while n > 0:
            ans ^= n
            n >>= 1
        return ans
```

```Java
// java
class Solution {
    public int minimumOneBitOperations(int n) {
        // 将格雷码 n 解码为其对应的原始整数
        // 计算每一位的异或和
        int ans = 0;
        int temp_n = n;

        while (temp_n > 0) {
            ans ^= temp_n;
            temp_n >>= 1;
        }
        return ans;
    }
}
```

- 时间复杂度： $O(logn)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solutions/3826534/shuang-jie-wen-ti-chai-fen-shuang-di-gui-44ua/)
