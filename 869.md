[Problem: 869. 重新排序得到 2 的幂](https://leetcode.cn/problems/reordered-power-of-2/description/)

### 方法：DFS & 打表

重排数字顺序，判断新数字能否变为 $2^x$。如何判断一个数字是 $2$ 的幂呢？可以看一下 [前置题目](https://leetcode.cn/problems/power-of-two/description/)，题解为 [传送门]((https://leetcode.cn/problems/power-of-two/solutions/3747419/qi-jie-mo-ni-di-gui-diao-ku-wei-yun-suan-rotf/))。这里不再说明，统一使用 `n & (n - 1)` 来快速判断。

**暴力** 思路：将数字 $n$ 拆分后，进行重排列并组合，判断新数字是否符合要求。

从长度为 $lgn$ 的列表里面取出数位，拼接成为数字。在剩余所有数位里面，每次都是「选一个」，将父问题变为子问题，因此联想到 **递归**。

如果你之前没做过回溯的题，建议先去练一练经典例题 [N皇后](https://leetcode.cn/problems/n-queens/description/)，[题解链接](https://leetcode.cn/problems/n-queens/solutions/3006469/hui-su-po-su-jie-fa-yi-wei-you-hua-dfstu-gdhu/)。

回溯的核心思路是 “尝试 —— 撤销 —— 尝试其他路径”，在剩余数位中进行 $for$ 挑选，每个数位都尝试拼接在当前位置。其他细节不再阐述。

代码如下，已附加注释：

```Python
# python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        digits = list(str(n))
        visited = [False] * len(digits)
        path = []  # 全局路径变量

        def is_two(x):  # 是否为2的幂
            return x > 0 and x & (x - 1) == 0

        def dfs():
            if len(path) == len(digits):
                num = int(''.join(path))
                return is_two(num)
            
            for i in range(len(digits)):  # 枚举拼接哪一位
                if visited[i]:
                    continue
                if len(path) == 0 and digits[i] == '0':  # 首位不能是0
                    continue
                visited[i] = True  # 尝试
                path.append(digits[i])
                if dfs():   # 递归
                    return True
                path.pop()  # 撤销
                visited[i] = False
            return False

        return dfs()
```

```Java
// java
class Solution {
    private char[] digits;
    private boolean[] visited;
    private StringBuilder path; // 全局路径变量

    public boolean reorderedPowerOf2(int n) {
        digits = String.valueOf(n).toCharArray();  // 数字转字符数组
        visited = new boolean[digits.length];
        path = new StringBuilder();
        return dfs();
    }

    // 判断是否为 2 的幂
    private boolean isTwo(int x) {
        return x > 0 && (x & (x - 1)) == 0;
    }

    // DFS 构造排列
    private boolean dfs() {
        if (path.length() == digits.length) {
            int num = Integer.parseInt(path.toString());
            return isTwo(num);
        }

        for (int i = 0; i < digits.length; i++) { // 枚举拼接哪一位
            if (visited[i]) continue;
            if (path.length() == 0 && digits[i] == '0') continue; // 首位不能是0

            visited[i] = true; // 尝试
            path.append(digits[i]);
            if (dfs()) return true; // 递归
            path.deleteCharAt(path.length() - 1); // 撤销
            visited[i] = false;
        }
        return false;
    }
}
```

将 $lgn$ 记作 $m$，它表示 $n$ 的数位个数，且 $n\leq 10$。

每个数都可以选择其他数进行拼接，都会向下递归，也即，树中每个节点都会有 $O(m)$ 个孩子；而元素可以全部不同，也即，树的最大深度为 $m$，根据全排列公式，得出总方案数为 $m!$。每条路径都有可能加入答案，复制一份新列表的时间为 $O(m)$，相乘就是总复杂度。

- 时间复杂度： $O(m\times m!)$，其中 $m=lgn$
- 空间复杂度： $O(m)$，表示辅助列表 $path$ 和 $used$ 的大小，递归的栈开销为 $O(m)$

---

### 剪枝

数位可能会重复，比如 $65536$ 中就存在两个 $5,6$。那么，在搜索的过程中，会产生很多的重复分支，导致大量冗余搜索。

具体例题，可以看看 [47. 全排列II](https://leetcode.cn/problems/permutations-ii/description/)，解决方案就是使用 $\textbf{used}$ 数组，从而让 **同一层** 的重复分支不会被搜索，题解为 [传送门]((https://leetcode.cn/problems/permutations-ii/solutions/3065111/hui-su-bao-li-dfshui-su-er-jin-zhi-you-h-ctvu/))。

> $ps$：到底需不需要排序？本质上不需要，排序只是为了更快地触发去重，减少扫描次数。使用排序后，代码速度从 $1187ms$ 变为 $1038ms$，有些许提升。

本题效仿该方案，对树进行 **剪枝**，代码如下：

```Python
# python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        digits = list(str(n))
        visited = [False] * len(digits)
        path = []  # 全局路径变量

        def is_two(x):  # 是否为2的幂
            return x > 0 and x & (x - 1) == 0

        def dfs():
            if len(path) == len(digits):
                num = int(''.join(path))
                return is_two(num)
            
            used = set()  # 本层已使用过的数字
            for i in range(len(digits)):
                if visited[i]:
                    continue
                # 首位不能为 0
                if len(path) == 0 and digits[i] == '0':
                    continue
                # 去重：同一层已用过这个数字
                if digits[i] in used:
                    continue
                
                used.add(digits[i])
                visited[i] = True  # 尝试
                path.append(digits[i])

                if dfs():  # 递归
                    return True
                
                path.pop()  # 撤销
                visited[i] = False
            return False

        return dfs()
```

```Java
// java
class Solution {
    char[] digits;        // 数字字符数组
    boolean[] visited;    // 标记某位是否使用
    StringBuilder path;   // 当前构造的数字

    public boolean reorderedPowerOf2(int n) {
        digits = String.valueOf(n).toCharArray();
        visited = new boolean[digits.length];
        path = new StringBuilder();
        return dfs();
    }

    // 判断是否为 2 的幂
    private boolean isTwo(int x) {
        return x > 0 && (x & (x - 1)) == 0;
    }

    // DFS 构造排列
    private boolean dfs() {
        if (path.length() == digits.length) {
            int num = Integer.parseInt(path.toString());
            return isTwo(num);
        }

        Set<Character> used = new HashSet<>(); // 本层已使用过的数字
        for (int i = 0; i < digits.length; i++) {
            if (visited[i]) continue;
            // 首位不能为 0
            if (path.length() == 0 && digits[i] == '0') continue;
            // 去重：同一层已用过这个数字
            if (used.contains(digits[i])) continue;

            used.add(digits[i]);
            visited[i] = true; // 尝试
            path.append(digits[i]);

            if (dfs()) return true; // 递归

            path.deleteCharAt(path.length() - 1); // 撤销
            visited[i] = false;
        }
        return false;
    }
}
```

- 时间复杂度： $O(m\times m!)$，实际远比这小
- 空间复杂度： $O(m)$，忽略排序的 $O(logm)$ 栈开销

---

### 逆向思路

上面是通过数字 $n$ 找 $2^x$，**反向思考**：列举出所有 $2$ 的幂，判断当前 $n$ 的组成是否和其中的某一个完全相同。

如何判断数字组成相同与否？暴力方法，对 $10$ 个数位分别计数，然后一一判断；简单方法，转为字符串后排序，判断字符串是否相同。

代码如下，已附加注释：

```Python
# python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        # 计算数字的位数
        def count_length(num):
            length = 0
            while num:
                length += 1
                num //= 10
            return length

        # 获取 n 的位数
        target_length = count_length(n)

        # 遍历所有位数相同的 2 的幂次方
        i = 0
        while True:
            power = 2 ** i
            power_length = count_length(power)
            # 如果当前 2 的幂次方的位数超过 n 的位数，停止遍历
            if power_length > target_length:
                break
            # 如果位数相同，比较数字统计
            if power_length == target_length:
                if sorted(str(power)) == sorted(str(n)):
                    return True
            i += 1

        # 如果没有匹配的 2 的幂次方，返回 False
        return False
```

```Java
// java
class Solution {
    public boolean reorderedPowerOf2(int n) {
        // 获取 n 的位数
        int targetLength = countLength(n);

        int i = 0;
        while (true) {
            int power = 1 << i; // 2 的 i 次方
            int powerLength = countLength(power);

            // 如果当前 2 的幂次方的位数超过 n 的位数，停止遍历
            if (powerLength > targetLength) break;

            // 如果位数相同，比较数字统计
            if (powerLength == targetLength) {
                char[] arr1 = String.valueOf(power).toCharArray();
                char[] arr2 = String.valueOf(n).toCharArray();
                Arrays.sort(arr1);
                Arrays.sort(arr2);
                if (Arrays.equals(arr1, arr2)) {
                    return true;
                }
            }
            i++;
        }

        // 如果没有匹配的 2 的幂次方，返回 false
        return false;
    }
    
    // 计算数字的位数
    private int countLength(int num) {
        int length = 0;
        while (num > 0) {
            length++;
            num /= 10;
        }
        return length;
    }
}
```

- 时间复杂度： $O(m\times logm)$，性能瓶颈在于排序
- 空间复杂度： $O(m)$

---

上面的做法有些繁琐，直接一次性列举出所有 $2^x$，然后一一判断更加清晰易懂。

代码如下：

```Python
# python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        mapp = [sorted(list(str(2**i))) for i in range(30)]
        if sorted(list(str(n))) in mapp:
            return True
        else:
            return False
```

```Java
// java
class Solution {
    public boolean reorderedPowerOf2(int n) {
        List<String> mapp = new ArrayList<>();
        for (int i = 0; i < 30; i++) {
            int power = 1 << i;
            char[] arr = String.valueOf(power).toCharArray();
            Arrays.sort(arr);
            mapp.add(new String(arr));
        }

        char[] nArr = String.valueOf(n).toCharArray();
        Arrays.sort(nArr);
        String sortedN = new String(nArr);

        return mapp.contains(sortedN);
    }
}
```

- 时间复杂度： $O(m\times logm)$，同理
- 空间复杂度： $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/reordered-power-of-2/solutions/3748474/si-jie-bao-li-hui-su-jian-zhi-ni-xiang-d-eldj/)
