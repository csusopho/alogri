[Problem: 342. 4的幂](https://leetcode.cn/problems/power-of-four/description/)

### 方法：位运算 & 数学

基础题：[2 的幂](https://leetcode.cn/problems/power-of-two/description/)，题解为 [传送门](https://leetcode.cn/problems/power-of-two/solutions/3747419/qi-jie-mo-ni-di-gui-diao-ku-wei-yun-suan-rotf/)，里面介绍了七种解法，这里同理介绍。

题目不允许循环/递归，但是为了防止小白不太清楚，这里仅作展示，代码如下：

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 4 == 0:
            n //= 4
        return n == 1
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) return false;
        while (n % 4 == 0) {
            n /= 4;
        }
        return n == 1;
    }
}
```

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n == 1:
            return True
        if n <= 0 or n % 4 != 0:
            return False
        return self.isPowerOfFour(n // 4)
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n == 1)
            return true;
        if (n <= 0 || n % 4 != 0)
            return false;
        return isPowerOfFour(n / 4);
    }
}
```

根据计算机的精度问题，可以直接暴力将数字 **取对数**，判断结果是整数还是小数：

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        # log4(n) = log(n) / log(4)
        return (math.log(n, 4)).is_integer()
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0)
            return false;
        return (Math.log(n) / Math.log(4)) % 1 == 0;
    }
}
```

- 时间复杂度： $O(logn)$，其中 $n$ 为题目给定数字，位运算
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 位运算

什么是 $4$ 的幂？比如 $4,16,\dots$，它们的二进制的形式为 $100,10000,\dots$。也即，该数字在二进制的组成中，仅仅只有一个 $1$，后面全是 $0$ 且次数为 **偶数**。

先判断是否只有一个 $1$，也即是否为 $2$ 的幂，然后统计末尾 $0$ 的个数。代码如下：

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        # 判断 2 的幂
        if n & (n - 1) != 0:
            return False
        # 统计二进制尾随零的个数
        trailing_zeros = (n.bit_length() - 1)
        return trailing_zeros % 2 == 0
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0)
            return false;
        // 判断 2 的幂
        if ((n & (n - 1)) != 0)
            return false;
        // 统计尾随零的个数
        return Integer.numberOfTrailingZeros(n) % 2 == 0;
    }
}
```

---

基础问题：如何判断某一位存在 $1$？使用 `&` **与** 运算，规则：有 $0$ 则 $0$，全 $1$ 为 $1$。

比如，我想检验 $x$ 的二进制的第 $3$ 位是否存在 $1$，那就使用掩码 `0001000`。任意位存在 $1$，和掩码中的 $0$ 相与后都是 $0$；只有第三位存在 $1$，结果才能含有 $1$。也即，

- 结果为 $0$，说明第三位不是 $1$；
- 结果大于 $0$，说明第三位是 $1$。

在上面的问题中，能发现 $4$ 的幂中的 $1$ 总是出现在奇数位，如何检验？

**使用掩码 `...01010101`**。

因为 $4$ 的幂中只含奇数位一个 $1$，所以一旦结果为 $0$，说明答案不是 $4^x$，否则是。

不过，前提得是 $2^x$，也即仅含一个 $1$，否则会干扰答案判断。

二进制的 $0b0101$ 等价于十六进制的 $0x5$，所以能简写。代码如下：

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
}
```

一个惊人的发现：`4 % 3 = 1`，所以上面的与运算也可以用 `%` 运算替换。

```Python
# python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and n & (n - 1) == 0 and n % 3 == 1
```

```Java
// java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1;
    }
}
```

- 时间复杂度： $O(1)$，位运算
- 空间复杂度： $O(1)$

---

### 打表

题目限制 $n\le 2^{31}-1$，所以最大的数字为 $2^{30}$，对应 $4^{15}$，代码如下：

```Python
# python
POWERS =  [
    1, 4, 16, 64, 256, 1024, 4096, 16384,
    65536, 262144, 1048576, 4194304, 16777216,
    67108864, 268435456, 1073741824
    ]

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        for num in POWERS:
            if num == n:
                return True
        return False
```

```Java
// java
class Solution {
    private static final int[] POWERS = {
        1, 4, 16, 64, 256, 1024, 4096, 16384,
        65536, 262144, 1048576, 4194304, 16777216,
        67108864, 268435456, 1073741824
    };

    public boolean isPowerOfFour(int n) {
        for (int num : POWERS) {
            if (num == n) return true;
        }
        return false;
    }
}
```

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/power-of-four/solutions/3753629/qi-jie-mo-ni-di-gui-qu-dui-shu-wei-yun-s-8qau/)
