[Problem: 1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/)

### 方法：DFS & DP

如何将 $n$ 边形变为 $n-2$ 个三角形？使用 $n-3$ 条边。

怎么保证不交叉地添加边？如何保证正确划分？比如下面有一个八边形：

```Java
    A ------  B
     /      \
  H /        \ C
   |          |
   |          |
  G \        / D
     \      /
    F ------ E
```

如果我们选择连接 $A,C,F$ 三个顶点，则一定不能选择 $D,E,G$ 三个顶点，否则会产生交叉。所以，到底怎么连接？

仔细观察最终结果，多边形的边，一定是某个三角形的边！因此，我们考虑 **相邻** 的两个顶点，让这条边一定属于某个三角形。

例如顶点 $i$ 和顶点 $j$ 之间的边 $(i, j)$。这条边必然会与另一个顶点 $k$，其中 $k$ 在 $i$ 和 $j$ 之间，组成一个三角形 $(i, k, j)$。

注意，这里的 $k$ 是在 **顺时针** 方向上，在 $i$ ~ $j$ 中间的一个点！

当我们选择顶点 $k$ 与边 $(i, j)$ 形成一个三角形后，这个三角形的得分是 `values[i] * values[j] * values[k]`。同时，原来的多边形被这个三角形分成了两个更小的子多边形（如果 $k$ 不是 $i$ 或 $j$ 的邻居）。

- 一个子多边形由顶点 $i, i+1, ..., k$ 构成
- 另一个子多边形由顶点 $k, k+1, ..., j$ 构成

比如，上述的八边形能划分为：

```Java
    k -------
     /|\     \
    / | \     \
   |  |  \     |
   |  |   \    |
    \ |    \   /
     \|     \ /
    i ------- j
```

> 图画的比较丑，请见谅，这两天争取学习一下绘图工具。

此时，我们发现，原问题是 **求整个多边形的得分**，划分后，子问题是 **求子多边形的得分**。这意味着，在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

**定义** $dfs(i,j)$ 表示计算由顶点 $i$ 到顶点 $j$ **顺时针** 构成的子多边形的最低三角剖分分数。

**转移过程**：遍历所有可能的中间顶点 $k\in[i+1,j-1]$，并将 $(i, j)$ 这条边作为基准边，与 $k$ 组成三角形。从中选择最小方案，得到下面的状态转移方程：

$$
dfs(i,j) =\min_{i < k < j} \{ \text{values}[i] \cdot \text{values}[k] \cdot \text{values}[j] + dfs(i,k) + dfs(k,j) \}
$$

**递归入口**： $dfs(0,n-1)$，表示从顶点 $0$ 到顶点 $n-1$，覆盖整个多边形的最小方案。

**递归边界**： $j=i+1$，说明只有两个点，无法组成三角形，返回 $0$ 表示无效方案。

### 记忆化

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

> 只是单纯的 $DFS$，会超时！

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有两个，所以记忆化数组需要两维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

记忆化数组的初始值只要不等于某个 $dfs$ 的状态值即可，这里的顶点值都大于 $0$，所以可以不赋初值，默认为 $0$ 表示方案无效（赋值为 $-1$ 更规范）。

实现上面的过程，代码如下，已附加注释：

```Python
# python
class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        
        # 由顶点 i, i+1, ..., j 构成的子多边形的最低三角剖分分数
        @cache
        def dfs(i, j):
            # 如果只有两个顶点，无法形成三角形
            if j - i < 2:
                return 0
            
            min_score = float('inf')
            
            # 尝试所有可能的中间顶点 k 来与边 (i, j) 形成三角形
            for k in range(i + 1, j):
                # 当前剖分的分数 = 三角形(i, k, j)的分数 + 两个子问题的分数
                current_score = values[i] * values[k] * values[j] + dfs(i, k) + dfs(k, j)
                min_score = min(min_score, current_score)
            
            return min_score

        # 整个多边形
        return dfs(0, n - 1)
```

```Java
// java
class Solution {
    private int[] values;
    private int[][] memo;

    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        this.values = values;
        this.memo = new int[n][n];
        
        // 计算整个多边形（从顶点 0 到 n-1）的最低分数
        return dfs(0, n - 1);
    }

    // 由顶点 i, i+1, ..., j 构成的子多边形的最低三角剖分分数
    private int dfs(int i, int j) {
        // 如果只有两个顶点，无法形成三角形
        if (j - i < 2) {
            return 0;
        }
        
        // 如果结果已经计算过
        if (this.memo[i][j] != 0) {
            return this.memo[i][j];
        }
        
        int minScore = Integer.MAX_VALUE;
        
        // 尝试所有可能的中间顶点 k 来与边 (i, j) 形成三角形
        for (int k = i + 1; k < j; k++) {
            // 当前剖分的分数 = 三角形(i, k, j)的分数 + 两个子问题的分数
            int currentScore = this.values[i] * this.values[k] * this.values[j] 
                             + dfs(i, k) 
                             + dfs(k, j);
            minScore = Math.min(minScore, currentScore);
        }
        
        // 将计算结果存入记忆
        this.memo[i][j] = minScore;
        return minScore;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(n^2)$，单个状态的计算时间为 $O(n)$，所以总时间复杂度为 $O(n^3)$。

- 时间复杂度： $O(n^3)$，其中 $n$ 为数组 $values$ 的长度
- 空间复杂度： $O(n^2)$，保存多少状态，就需要多少空间

---

### 动态规划

将递归 $1:1$ 转化为递推。

同理，**定义** $dp[i][j]$ 表示由顶点 $i, i+1,\dots, j$ 构成的子多边形的最低三角剖分分数。

**状态转移方程**：

$$
dp[i][j] =\min_{i < k < j} \{ \text{values}[i] \cdot \text{values}[k] \cdot \text{values}[j] + dp[i][k] + dp[k][j] \}
$$

**初始化**：将 $dp[i][j]$ 置为 $0$ 表示没有更新过。

为了计算 $dp[i][j]$，我们需要提前知道所有 $dp[i][k]$ 和 $dp[k][j]$ 的值。在上述阐述中，我们已知 $k$ 是顺时针在 $(i,j)$ 中的点，

- 也即 $i<k$，所以第一维必须 **倒序** 枚举！确保更小的 $dp[k]$ 已知，才能推出未知的 $dp[i]$；
- 同理 $k<j$，所以第二维是 **正序**，通过 $dp[.][k]$ 推出 $dp[.][j]$。

由于三角形必须含有三个点，因此第一维的 $i$ 必须从 $n-2$ 开始，第二维的 $j$ 必须从 $i+2$ 开始，第三维 $k$ 则在两者的中间。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        
        # dp[i][j] 存储由顶点 i 到 j 构成的子多边形的最低剖分分数
        dp = [[0] * n for _ in range(n)]
        
        # 子多边形的左端点，必须倒序！
        for i in range(n - 3, -1, -1):
            # 子多边形的右端点，保证区间长度至少为3
            for j in range(i + 2, n):
                dp[i][j] = float('inf')
                # 枚举分割点
                for k in range(i + 1, j):
                    # 总分 = 左子多边形(i,k)最低分 + 右子多边形(k,j)最低分 + 新三角形(i,k,j)的分数
                    score = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]
                    dp[i][j] = min(dp[i][j], score)
                    
        # 覆盖整个多边形
        return dp[0][n - 1]
```

```Java
// java
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        
        // dp[i][j] 存储由顶点 i 到 j 构成的子多边形的最低剖分分数
        int[][] dp = new int[n][n];
        
        // 子多边形的左端点，必须倒序！
        for (int i = n - 3; i >= 0; i--) {
            // 子多边形的右端点
            for (int j = i + 2; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
                // 枚举分割点 k
                for (int k = i + 1; k < j; k++) {
                    // 总分 = 左子多边形(i,k)最低分 + 右子多边形(k,j)最低分 + 新三角形(i,k,j)的分数
                    int score = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j];
                    dp[i][j] = Math.min(dp[i][j], score);
                }
            }
        }
        
        // 覆盖整个多边形
        return dp[0][n - 1];
    }
}
```

---

我们也可以按照 $\textbf{区间 DP}$ 的思路解题。

区间 $DP$ 都是先枚举 **区间长度**，然后枚举 **左右端点**。对于求区间 $[l,r]$ 的值，我们需要先求出其子区间 $[l,k]$ 与 $[k,r]$ 的值。

那 $i,j$ 为什么正序枚举呢？这两个子区间的长度一定小于 $n$，且都是由更小的区间转移而来。所以第一维只需正序枚举区间大小即可，无需考虑左右端点的枚举！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        
        # dp[i][j] 表示由顶点 i, i+1, ..., j 构成的子多边形的最低剖分分数
        dp = [[0] * n for _ in range(n)]
        
        # 枚举子多边形的长度
        for L in range(3, n + 1):
            # 枚举子多边形的起始顶点
            for i in range(n - L + 1):
                # j 是子多边形的结束顶点
                j = i + L - 1
                dp[i][j] = float('inf')
                
                # 枚举分割点
                for k in range(i + 1, j):
                    score = values[i] * values[k] * values[j] + dp[i][k] + dp[k][j]
                    dp[i][j] = min(dp[i][j], score)
        
        # 覆盖整个多边形
        return dp[0][n - 1]
```

```Java
// java
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;

        // dp[i][j] 表示由顶点 i, i+1, ..., j 构成的子多边形的最低剖分分数
        int[][] dp = new int[n][n];

        // 枚举子多边形的长度 L
        for (int L = 3; L <= n; L++) {
            // 枚举子多边形的起始顶点 i
            for (int i = 0; i <= n - L; i++) {
                // j 是子多边形的结束顶点
                int j = i + L - 1;
                dp[i][j] = Integer.MAX_VALUE;

                // 枚举分割点 k
                for (int k = i + 1; k < j; k++) {
                    // 状态转移方程
                    int score = values[i] * values[k] * values[j] + dp[i][k] + dp[k][j];
                    dp[i][j] = Math.min(dp[i][j], score);
                }
            }
        }

        // 覆盖整个多边形
        return dp[0][n - 1];
    }
}
```

- 时间复杂度： $O(n^3)$
- 空间复杂度： $O(n^2)$，表示数组 $dp$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/solutions/3794932/tu-jie-xuan-ze-xiang-lin-ding-dian-ji-yi-8e2x/)
