[Problem: 3562. 折扣价交易股票的最大利润](https://leetcode.cn/problems/maximum-profit-from-trading-stocks-with-discounts/description/)

### 方法：树形DP

员工 $x$ 可以用 $present[x]$ 的价格买自己的股票，获得收益 $future[x]-present[x]$。员工之间有上下级关系，如果 $x$ 的 **直属上级** 是 $y$ 且 $y$ 买了 $y$ 自己的股票，则 $x$ 买 $x$ 自己的股票只需花费 $present[x]/2$。所有买股票的花费必须 $\le budget$，求获得的最大收益。

一会上级，一会下级，到底怎么做？

优惠政策是 **“上司买 -> 下属半价”**，那么当前节点 $u$ 非常重要，它起到了一个 **“承上启下”** 的作用：

1. 承上： $u$ 的 **父节点** 买没买，决定了 $u$ 是原价/半价。
2. 启下： $u$ 买没买，决定了 $u$ 的 **子节点** $v$ 是原价/半价。

为了处理这种依赖，我们需要分步走。

在决定 $u$ 怎么做之前，先看看它的子节点。因为 $u$ 有两个选择（买或不买），这会给下属创造两种不同的 “平行宇宙”：

- $aggNo$，假设 $u$ 决定 **不买**。所有子节点 $v$ 都没折扣，这种情况下，计算出所有子节点的最优解，也即 “u 不买” 这个分支下的子树收益底座。
- $aggYes$，假设 $u$ 决定 **购买**。所有子节点 $v$ 都有折扣，此时，计算出所有子节点的最优解，也即 “u 购买” 这个分支下的子树收益底座。

**注意**：此时 $aggNo$ 和 $aggYes$ 都 **不包含** $u$ 自己的花费和收益，它们纯粹是下属们的总和。

---

现在，节点 $u$ 的子节点已经计算完成。而 $u$ 是否半价，则取决于 $u$ 的上司。

假设 $u$ 的上司 **没买**，则 $u$ 可以选择买/不买。假如 $u$ 不买，则花费为 $0$，而下属无折扣，使用 $aggNo$。反之 $u$ 选择买，则花费为 $present[u]$。下属有折扣，使用的是 $aggYes$。

此时，定义 $dpNo$ 表示上司不买时，以 $u$ 为节点的子树的 `(价格, 最大收益)`。由于当前节点 $u$ 可能买/不买，所以 $dpNo$ 是上述两种情况的最大值。

假设 $u$ 的上司 **买了**，同理 $u$ 面临两个选择。假如 $u$ 不买，则花费为 $0$，而下属无折扣，使用 $aggNo$。反之 $u$ 选择买，注意花费为 $present[u] / 2$。下属有折扣，使用 $aggYes$。

此时，定义 $dpYes$ 表示上司购买时，以 $u$ 为节点的子树的 `(价格, 最大收益)`。同理是上述两种情况的最大值。

---

感觉很复杂啊，怎么写代码？

理清逻辑，注意两层状态依赖：

- 当前节点决策 -> 决定 -> 子节点可用状态池 $agg$
- 父节点状态 -> 决定 -> 当前节点成本 $dp$

因此，我们选择 **分两步走**。首先完成 “子树聚合”，再来 “决策当前节点”。

注意，对于树中的任意节点 $u$，我们需要计算出两个列表：

- $dpNo[w]$ 表示在以 $u$ 为根的子树中，父节点没买股票下，花费为 $w$ 时的最大利润。
- $dpYes[w]$ 表示在以 $u$ 为根的子树中，父节点买股票后，花费为 $w$ 时的最大利润。

总的来看，定义 $dfs(u)$ 表示根据 $u$ 的上司买/不买，返回 $dpYes$ 和 $dpNo$。其中，每个 $dp$ 都是一个哈希，存储 `{cost: profit}`。

要想计算 $dp$，首先需要计算 $agg$。因为子节点之间是独立的（兄弟节点互不影响，只受父节点 $u$ 影响），这相当于一个 **分组背包** 问题。

维护两个临时的聚合背包：

- $aggNo$：假设 $u$ 不购买，无折扣，需要合并所有子节点的 $child-dpNo$。
- $aggYes$: 假设 $u$ 购买，有折扣，需要合并所有子节点的 $child-dpYes$。

**合并过程**：`new_dp[w] = max(cur[w-k] + child[k])`。

其中，左侧的 $new$ 代表合并后的新状态，某个子节点的花费为 $k$，另外某个子节点的花费为 $w-k$，合起来就是选择 $2$ 个节点的花费。记得初始化 $(0,0)$，这样选择 $0/1/2$ 个节点的花费都会包含在其中。

当所有子节点合并完成后，我们再考虑节点 $u$ 本身的决策：

- 父节点没买，计算 $dpNo$。选择不买 $u$，子节点是 $aggNo$；选择买 $u$，子节点是 $aggYes$。花费分别是 $0$ 或者 $present[u]$，得出对应花费下的 $dpNo$。
- 父节点买了，计算 $dpYes$。选择不买 $u$，子节点是 $aggNo$；选择买 $u$，子节点是 $aggYes$。花费分别是 $0$ 或者 $present[u]/2$，得出对应花费下的 $dpYes$。

不好理解？从本质上来说，一定会从树中挑选 $0,1,\dots$ 个节点进行购买。在上面的过程中，子树计算出 $0,1,\dots$ 个节点的 `(花费, 最大价值)`，然后判断当前节点 $u$ 买/不买。从叶子开始，不断扩充 $0\to n$，就完成了对全部节点的选择。

这就叫做 **树形** $DP$。递归地处理子树，从叶节点向根节点，或从根节点向叶节点传播状态信息，最终合并子树的信息来得到问题的解。

**总结**：“递” 到叶子，累计叶子的选择情况，“归” 上来，计算出当前子树的选择情况。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProfit(self, n: int, present: List[int], future: List[int], hierarchy: List[List[int]], budget: int) -> int:
        # 构建邻接表
        adj = [[] for _ in range(n)]
        for u, v in hierarchy:
            adj[u - 1].append(v - 1)
        
        # 根据u的上司买/不买，返回以 u 为根的子树的 (花费,最大收益)
        # 每个 dp 都是一个字典 {cost: profit}
        def dfs(u):
            # 初始 u 不买 (agg_no) 和买 (agg_yes) 的情况
            agg_no = {0: 0}
            agg_yes = {0: 0}
            
            # 遍历所有子节点，进行背包合并
            for v in adj[u]:
                child_dp_no, child_dp_yes = dfs(v)
                
                # 合并到agg_no，上司 u 没买
                new_agg_no = {}
                for c1, p1 in agg_no.items():
                    for c2, p2 in child_dp_no.items():
                        if c1 + c2 <= budget:
                            # 如果同一 cost 有更高 profit，则更新
                            new_profit = p1 + p2
                            if new_profit > new_agg_no.get(c1 + c2, -123):
                                new_agg_no[c1 + c2] = new_profit
                agg_no = new_agg_no
                
                # 合并到agg_yes，上司 u 买了
                new_agg_yes = {}
                for c1, p1 in agg_yes.items():
                    for c2, p2 in child_dp_yes.items():
                        if c1 + c2 <= budget:
                            new_profit = p1 + p2
                            if new_profit > new_agg_yes.get(c1 + c2, -123):
                                new_agg_yes[c1 + c2] = new_profit
                agg_yes = new_agg_yes
            
            # 决策当前节点 u
            # 准备数据
            cost_full = present[u]
            profit_full = future[u] - cost_full
            
            cost_half = present[u] // 2
            profit_half = future[u] - cost_half
            
            # 假设 u 的上司没买，选择 u 不买，使用 agg_no
            dp_no = agg_no.copy()
            # 选择 u 买，但是必须全价，使用 agg_yes
            if cost_full <= budget:
                for c, p in agg_yes.items():
                    total_c = c + cost_full
                    if total_c <= budget:
                        total_p = p + profit_full
                        if total_p > dp_no.get(total_c, -123):
                            dp_no[total_c] = total_p
            
            # 假设 u 的上司买了，选择 u 不买，使用 agg_no
            dp_yes = agg_no.copy()
            # 选择 u 买，此时半价，使用 agg_yes
            if cost_half <= budget:
                for c, p in agg_yes.items():
                    total_c = c + cost_half
                    if total_c <= budget:
                        total_p = p + profit_half
                        if total_p > dp_yes.get(total_c, -123):
                            dp_yes[total_c] = total_p
            
            return dp_no, dp_yes

        # 根节点没有上司，也就是没买
        final_dp, _ = dfs(0)
        # 找出最大收益
        return max(final_dp.values())
```

```Java
// java
class Solution {
    private List<Integer>[] adj;
    private int[] present;
    private int[] future;
    private int budget;

    public int maxProfit(int n, int[] present, int[] future, int[][] hierarchy, int budget) {
        this.present = present;
        this.future = future;
        this.budget = budget;
        
        // 构建邻接表
        adj = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int[] relation : hierarchy) {
            adj[relation[0] - 1].add(relation[1] - 1);
        }

        // 根节点没有上司，也就是没买
        // dfs返回的是一个List，index 0 为 dpNo, index 1 为 dpYes
        List<Map<Integer, Integer>> result = dfs(0);
        Map<Integer, Integer> finalDp = result.get(0);
        
        // 找出最大收益
        int maxProfit = 0;
        for (int profit : finalDp.values()) {
            maxProfit = Math.max(maxProfit, profit);
        }
        return maxProfit;
    }

    // 根据u的上司买/不买，返回以 u 为根的子树的 (花费,最大收益)
    // 每个 dp 都是一个哈希 {cost: profit}
    private List<Map<Integer, Integer>> dfs(int u) {
        // 初始 u 不买 (agg_no) 和买 (agg_yes) 的情况
        Map<Integer, Integer> aggNo = new HashMap<>();
        aggNo.put(0, 0);
        Map<Integer, Integer> aggYes = new HashMap<>();
        aggYes.put(0, 0);

        // 遍历所有子节点，进行背包合并
        for (int v : adj[u]) {
            List<Map<Integer, Integer>> childRes = dfs(v);
            Map<Integer, Integer> childDpNo = childRes.get(0);
            Map<Integer, Integer> childDpYes = childRes.get(1);

            // 合并到agg_no，上司 u 没买
            Map<Integer, Integer> newAggNo = new HashMap<>();
            for (Map.Entry<Integer, Integer> e1 : aggNo.entrySet()) {
                for (Map.Entry<Integer, Integer> e2 : childDpNo.entrySet()) {
                    int c1 = e1.getKey();
                    int p1 = e1.getValue();
                    int c2 = e2.getKey();
                    int p2 = e2.getValue();

                    if (c1 + c2 <= budget) {
                        // 如果同一 cost 有更高 profit，则更新
                        int newProfit = p1 + p2;
                        newAggNo.merge(c1 + c2, newProfit, Integer::max);
                    }
                }
            }
            aggNo = newAggNo;

            // 合并到agg_yes，上司 u 买了
            Map<Integer, Integer> newAggYes = new HashMap<>();
            for (Map.Entry<Integer, Integer> e1 : aggYes.entrySet()) {
                for (Map.Entry<Integer, Integer> e2 : childDpYes.entrySet()) {
                    int c1 = e1.getKey();
                    int p1 = e1.getValue();
                    int c2 = e2.getKey();
                    int p2 = e2.getValue();

                    if (c1 + c2 <= budget) {
                        int newProfit = p1 + p2;
                        newAggYes.merge(c1 + c2, newProfit, Integer::max);
                    }
                }
            }
            aggYes = newAggYes;
        }

        // 决策当前节点 u
        // 准备数据
        int costFull = present[u];
        int profitFull = future[u] - costFull;

        int costHalf = present[u] / 2;
        int profitHalf = future[u] - costHalf;

        // 假设 u 的上司没买，选择 u 不买，使用 agg_no
        Map<Integer, Integer> dpNo = new HashMap<>(aggNo);
        // 选择 u 买，但是必须全价，使用 agg_yes
        if (costFull <= budget) {
            for (Map.Entry<Integer, Integer> entry : aggYes.entrySet()) {
                int c = entry.getKey();
                int p = entry.getValue();
                int totalC = c + costFull;
                
                if (totalC <= budget) {
                    int totalP = p + profitFull;
                    dpNo.merge(totalC, totalP, Integer::max);
                }
            }
        }

        // 假设 u 的上司买了，选择 u 不买，使用 agg_no
        Map<Integer, Integer> dpYes = new HashMap<>(aggNo);
        // 选择 u 买，此时半价，使用 agg_yes
        if (costHalf <= budget) {
            for (Map.Entry<Integer, Integer> entry : aggYes.entrySet()) {
                int c = entry.getKey();
                int p = entry.getValue();
                int totalC = c + costHalf;
                
                if (totalC <= budget) {
                    int totalP = p + profitHalf;
                    dpYes.merge(totalC, totalP, Integer::max);
                }
            }
        }

        return Arrays.asList(dpNo, dpYes);
    }
}
```

- 时间复杂度： $O(n\times budget^2)$，其中 $n$ 是数组 $present$ 的长度，而 $budget$ 是预算上界，哈希大小受限于 $budget$
- 空间复杂度： $O(n\times budget)$，表示递归过程中 $DP$ 哈希的大小

代码用的是哈希而非数组，实测 $Python$ 代码耗时 $435ms$，超过 $97.8\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-profit-from-trading-stocks-with-discounts/solutions/3858170/shu-xing-dp-fen-liang-bu-zou-shu-shang-b-docv/)
