[Problem: 498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/description/)

### 方法：模拟 & 简化

在本题中，要求出所有反对角线 $(135°)$ 上的格子值。

这些格子有什么特点？举个例子，第一条对角线上仅有一个 $(0,0)$，第二条对角线上有 $(0,1)$ 和 $(1,0)$，以此类推。

发现一个 **规律**：任意一条反对角线上，格子的下标都在直线 $y=-x+k$ 上！对于任意坐标 $(i,j)$，只要 “横坐标+纵坐标” 的和相同，就说明在一条对角线上！

将 “横坐标 $i$ + 纵坐标 $j$” 的和记作 $k$，根据该值，判断是第几条对角线，此时：

（1）在偶数编号 $0,2,\dots$ 的对角线上，我们是从下往上走，也即 $↗$ 的顺序，

- 在矩形的左上角区域，起点在第 $0$ 列，坐标为 $(k,0)$；
- 在矩形的右下角区域，起点在第 $m-1$ 行，坐标为 $(m-1,k-m+1)$。

（2）在奇数编号 $1,3,\dots$ 的对角线上，我们是从上往下走，也即 $↙$ 的顺序，

- 在矩形的左上角区域，起点在第 $0$ 行，坐标为 $(0,k)$；
- 在矩形的右下角区域，起点在第 $m-1$ 列，坐标为 $(k-n+1,n-1)$。

**做法**：总共 $m+n-1$ 条对角线，根据 $k$ 的奇偶性，一次性得出一整条对角线的元素。代码如下，已附加注释：

```Python
# python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        res = []

        for i in range(n + m - 1):
            if not i % 2:
                # 偶数编号对角线（从下往上走 ↗）
                x = i if i < m else m - 1   # 行起点
                y = 0 if i < m else i - m + 1  # 列起点
                while x >= 0 and y < n:
                    res.append(mat[x][y])
                    x -= 1
                    y += 1
            else:
                # 奇数编号对角线（从上往下走 ↙）
                x = 0 if i < n else i - n + 1  # 行起点
                y = i if i < n else n - 1      # 列起点
                while x < m and y >= 0:
                    res.append(mat[x][y])
                    x += 1
                    y -= 1
        
        return res
```

```Java
// java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        List<Integer> res = new ArrayList<>();

        // 总共有 m + n - 1 条对角线
        for (int i = 0; i < m + n - 1; i++) {
            if (i % 2 == 0) {
                // 偶数编号对角线（从下往上走 ↗）
                int x = (i < m) ? i : m - 1;      // 行起点
                int y = (i < m) ? 0 : i - m + 1;  // 列起点
                while (x >= 0 && y < n) {
                    res.add(mat[x][y]);
                    x--;
                    y++;
                }
            } else {
                // 奇数编号对角线（从上往下走 ↙）
                int x = (i < n) ? 0 : i - n + 1;  // 行起点
                int y = (i < n) ? i : n - 1;      // 列起点
                while (x < m && y >= 0) {
                    res.add(mat[x][y]);
                    x++;
                    y--;
                }
            }
        }

        // 转为 int[]
        int[] ans = new int[n * m];
        for (int i = 0; i < ans.length; i++) {
            ans[i] = res.get(i);
        }
        return ans;
    }
}
```

---

也可以先将一整条对角线的元素全部求出，然后根据奇偶性决定遍历顺序，从而翻转这些元素。代码更简洁，已附加注释：

```Python
# python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        res = []

        # 全部按照右上到左下 ↙ 的顺序
        for d in range(m + n - 1):
            diagonal = []
            # 计算对角线的起始行
            r = 0 if d < n else d - n + 1
            # 计算对角线的起始列
            c = d if d < n else n - 1

            # 收集该对角线上的元素
            while r < m and c > -1:
                diagonal.append(mat[r][c])
                r += 1
                c -= 1

            # 偶数对角线反转
            if d % 2 == 0:
                res.extend(diagonal[::-1])
            else:
                res.extend(diagonal)

        return res
```

```Java
// java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        List<Integer> res = new ArrayList<>();

        // 全部按照右上到左下 ↙ 的顺序
        for (int d = 0; d < m + n - 1; d++) {
            List<Integer> diagonal = new ArrayList<>();

            // 计算对角线的起始行
            int r = (d < n) ? 0 : d - n + 1;
            // 计算对角线的起始列
            int c = (d < n) ? d : n - 1;

            // 收集该对角线上的元素
            while (r < m && c >= 0) {
                diagonal.add(mat[r][c]);
                r++;
                c--;
            }

            // 偶数对角线反转
            if (d % 2 == 0) {
                Collections.reverse(diagonal);
            }
            res.addAll(diagonal);
        }

        // 转为 int[]
        int[] ans = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            ans[i] = res.get(i);
        }
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n)$，其中 $m,n$ 为矩阵 $mat$ 的行数和列数
- 空间复杂度： $O(min(m,n))$ 或者 $O(m\times n)$，表示列表 $diagonal$ 或者 $res$ 的大小，返回数组一般不计入复杂度

---

### 优化

仔细观察，能发现这些对角线 **首尾相接**，呈现 “蛇形/闪电形”，贯穿整个矩阵。

那么，我们没必要逐行遍历，而是 **逐个遍历**，根据 “横坐标+纵坐标” 的奇偶性决定遍历方向，以及每个维度的 $+-1$，达成精细化地一次移动一格。

代码如下，已附加注释：

```Python
# python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        r, c = 0, 0
        row, col = len(mat), len(mat[0])
        res = [0] * (row * col)
        
        for i in range(len(res)):
            res[i] = mat[r][c]
            
            # r + c 即为遍历的层数，偶数向上遍历，奇数向下遍历
            if (r + c) % 2 == 0:
                if c == col - 1:
                    # 往下移动一格准备向下遍历
                    r += 1
                elif r == 0:
                    # 往右移动一格准备向下遍历
                    c += 1
                else:
                    # 往上移动
                    r -= 1
                    c += 1
            else:
                if r == row - 1:
                    # 往右移动一格准备向上遍历
                    c += 1
                elif c == 0:
                    # 往下移动一格准备向上遍历
                    r += 1
                else:
                    # 往下移动
                    r += 1
                    c -= 1
        
        return res
```

```Java
// java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int r = 0, c = 0;
        int row = mat.length, col = mat[0].length;
        int[] res = new int[row * col];

        for (int i = 0; i < res.length; i++) {
            res[i] = mat[r][c];

            // r + c 即为遍历的层数，偶数向上遍历，奇数向下遍历
            if ((r + c) % 2 == 0) {
                if (c == col - 1) {
                    // 往下移动一格准备向下遍历
                    r++;
                } else if (r == 0) {
                    // 往右移动一格准备向下遍历
                    c++;
                } else {
                    // 往上移动
                    r--;
                    c++;
                }
            } else {
                if (r == row - 1) {
                    // 往右移动一格准备向上遍历
                    c++;
                } else if (c == 0) {
                    // 往下移动一格准备向上遍历
                    r++;
                } else {
                    // 往下移动
                    r++;
                    c--;
                }
            }
        }

        return res;
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/diagonal-traverse/solutions/3762981/mo-ni-zhu-xing-bian-li-jian-hua-she-xing-zgad/)
