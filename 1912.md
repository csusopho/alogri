[Problem: 1912. 设计电影租借系统](https://leetcode.cn/problems/design-movie-rental-system/description/)

### 方法：数据结构

题意比较清晰，这里不再赘述。

注意，每部电影 $movie$ 在每个商店 $shop$ 至多一部。但是，不同商店可以有相同 $movie$。因此，代码编写时小心 $set$ 结构。

我们到底该用什么数据结构？只用一个哈希存储吗？显然不行，每次检查或借出时，都需要线性遍历这个哈希，非常浪费时间。

- $search$ 操作：搜索指定电影，而价格+商店则是需要取最小。因此，使用一个 **哈希**，键为 “电影”，值为 “(价格,商店)” 的有序列表；
- $rent/drop$ 操作：对指定商店，指定电影进行借出/返还。因此，使用一个 **哈希**，键为 “商店+电影”，值为 “价格”。为啥不使用一个哈希 $set$？不存储这个 “价格” 行吗？**不行**。因为我们要根据 $(shop,movie,price)$ 三元组，唯一确定一部电影，从而正确地从哈希中移除/加入；
- $report$ 操作：已借出电影中，寻找最小。因此，使用一个 **有序列表**，题干中已指明排序规则：价格>商店>电影，且三者都是升序。

如何让列表 **有序**？排序肯定不行，每次加入一个新电影就排序，非常浪费时间。要么使用普通列表，手动维护有序性；要么使用有序的数据结构，自动维护。

最大难点在于寻找数据结构，具体实现则容易很多，详情见代码。首先，我们使用普通列表，然后二分查找元素，手动维护升序。

代码如下，已附加详细注释：

```Python
# python
class MovieRentingSystem:
    def __init__(self, n: int, entries: List[List[int]]):
        # 存储所有未借出电影的信息
        # 结构: {movie_id: sorted_list_of[(price, shop_id)]}
        self.available = defaultdict(list)

        # 存储每部电影在每个商店的价格
        # 结构: {(shop_id, movie_id): price}
        self.prices = {}

        # 存储所有已借出电影的信息
        # 结构: sorted_list_of[(price, shop_id, movie_id)]
        self.rented = []

        for shop, movie, price in entries:
            self.available[movie].append((price, shop))
            self.prices[(shop, movie)] = price

        for movie in self.available:
            self.available[movie].sort()

    def search(self, movie: int) -> List[int]:
        # 直接取出，shop_info 是 (price, shop)
        return [shop_info[1] for shop_info in self.available[movie][:5]]

    def rent(self, shop: int, movie: int) -> None:
        price = self.prices[(shop, movie)]
        # 从可用列表中移除
        self.available[movie].remove((price, shop))
        # 插入，并保持有序
        bisect.insort(self.rented, (price, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        price = self.prices[(shop, movie)]
        # 从租借列表中移除
        self.rented.remove((price, shop, movie))
        # 插入，并保持有序
        bisect.insort(self.available[movie], (price, shop))

    def report(self) -> List[List[int]]:
        # rent_info 是 (price, shop, movie)
        return [[rent_info[1], rent_info[2]] for rent_info in self.rented[:5]]
```

假设数组 $entries$ 的长度为 $n$，而 $rent/drop$ 操作的次数为 $m$。那么列表的长度为 $O(n)$ 级别，每次 $rent$ 插入时，先二分的时间为 $O(logn)$，再调整后续元素的时间为 $O(n)$。

题目指定 $n,m\leq 10^5$，所以会超时，卡在 $37/42$ 样例。

---

### 有序列表

手动维护不行，那就试试自动维护。数据结构有最小堆/有序集合。

为什么本题不能用 “最小堆+懒删除” 呢？我测试了一下，发现答案一直错误。究其本质，是因为本题允许归还！

举个例子，我从商店 $shop$ 中租借了电影 $x$，然后立刻归还。这条电影信息原本就 “可用”，但是经过这番操作后，又会加入一次 “可用” 堆中，那么堆中就会存储两个 “可用” 的 `相同电影`，且都是有效，导致答案错误！

一种解决方法是：两个堆共用一个标记 $set$。这样一来，即使 “可用” 堆中存储两个相同的电影，弹出一次后就会标记为 “借出”。但是，这样会留下隐患，导致样例 $37$ 也无法通过。评论区有无大佬可以使用最小堆解决？欢迎留言。

换成 **有序集合**，那逻辑只会更加容易。我们不再需要二分查找，然后手动插入维护，全部交给数据结构，让它自动处理！仅仅只需要定义排序规则！

代码如下，已附加详细注释：

```Python
# python
class MovieRentingSystem:
    def __init__(self, n: int, entries: list[list[int]]):
        # {movie_id: SortedList of (price, shop_id)}
        self.available = defaultdict(SortedList)
        # {(shop_id, movie_id): price}
        self.prices = {}
        # SortedList of (price, shop_id, movie_id)
        self.rented = SortedList()

        for shop, movie, price in entries:
            self.available[movie].add((price, shop))
            self.prices[(shop, movie)] = price

    def search(self, movie: int) -> list[int]:
        # shop_info 是 (price, shop)
        return [shop_info[1] for shop_info in self.available[movie][:5]]

    def rent(self, shop: int, movie: int) -> None:
        price = self.prices[(shop, movie)]
        # discard 比 remove 更安全，如果元素不存在不会报错
        self.available[movie].discard((price, shop))
        # 添加到列表中
        self.rented.add((price, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        price = self.prices[(shop, movie)]
        # 从列表中删除
        self.rented.discard((price, shop, movie))
        # 添加到列表中
        self.available[movie].add((price, shop))

    def report(self) -> list[list[int]]:
        # rent_info 是 (price, shop, movie)
        return [[rent_info[1], rent_info[2]] for rent_info in self.rented[:5]]
```

```Java
// java
class MovieRentingSystem {
    // {movie_id: TreeSet of (price, shop_id)}
    // 存储所有未借出电影，TreeSet自动按价格和商店ID排序
    private Map<Integer, TreeSet<int[]>> available;

    // {(shop_id, movie_id): price}，这里换成Map嵌套
    private Map<Integer, Map<Integer, Integer>> prices;

    // TreeSet of (price, shop_id, movie_id)
    // 存储所有已借出电影，自动排序
    private TreeSet<int[]> rented;

    public MovieRentingSystem(int n, int[][] entries) {
        // 初始化数据结构
        this.available = new HashMap<>();
        this.prices = new HashMap<>();

        // 自定义排序规则：
        // 1. 按价格升序
        // 2. 如果价格相同，按商店ID升序
        // 3. 如果商店ID也相同，按电影ID升序
        this.rented = new TreeSet<>((a, b) -> {
            if (a[0] != b[0]) return Integer.compare(a[0], b[0]); // price
            if (a[1] != b[1]) return Integer.compare(a[1], b[1]); // shop
            return Integer.compare(a[2], b[2]);                  // movie
        });

        for (int[] entry : entries) {
            int shop = entry[0];
            int movie = entry[1];
            int price = entry[2];

            this.prices.computeIfAbsent(shop, k -> new HashMap<>()).put(movie, price);

            // 排序规则：1. 按价格升序 2. 如果价格相同，按商店ID升序
            this.available.computeIfAbsent(movie, k -> new TreeSet<>((a, b) -> {
                if (a[0] != b[0]) return Integer.compare(a[0], b[0]); // price
                return Integer.compare(a[1], b[1]);                  // shop
            })).add(new int[]{price, shop});
        }
    }

    public List<Integer> search(int movie) {
        List<Integer> result = new ArrayList<>();
        // 获取指定电影的可用商店
        TreeSet<int[]> shopsForMovie = this.available.getOrDefault(movie, new TreeSet<>());

        // 遍历排好序的商店信息，shopInfo 是 [price, shop]
        for (int[] shopInfo : shopsForMovie) {
            if (result.size() >= 5) {
                break;
            }
            result.add(shopInfo[1]); // 添加商店ID到结果列表
        }
        return result;
    }

    public void rent(int shop, int movie) {
        int price = this.prices.get(shop).get(movie);
        // 从“可用”列表中移除
        this.available.get(movie).remove(new int[]{price, shop});
        // 添加到“已租借”列表中
        this.rented.add(new int[]{price, shop, movie});
    }

    public void drop(int shop, int movie) {
        int price = this.prices.get(shop).get(movie);
        // 从“已租借”列表中移除
        this.rented.remove(new int[]{price, shop, movie});
        // 添加回“可用”列表中
        this.available.get(movie).add(new int[]{price, shop});
    }

    public List<List<Integer>> report() {
        List<List<Integer>> result = new ArrayList<>();
        
        // 遍历排好序的已租借电影信息, rentInfo 是 [price, shop, movie]
        for (int[] rentInfo : this.rented) {
            if (result.size() >= 5) {
                break;
            }
            // 将 [shop, movie] 添加到结果列表
            result.add(List.of(rentInfo[1], rentInfo[2]));
        }
        return result;
    }
}
```

- 时间复杂度：
  - $init$ 函数： $O(n\times logn)$，其中 $n$ 是数组 $entries$ 的长度
  - $search$ 函数： $O(1)$
  - $rent$ 函数： $O(logS+logR)$，从列表 $S$ 中删除，向列表 $R$ 中加入
  - $drop$ 函数： $O(logS+logR)$，同理
  - $report$ 函数： $O(1)$
- 空间复杂度： $O(M)$，其中 $M$ 是操作 $rent/drop$ 的总次数+数组长度，表示不同列表的大小总和

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/design-movie-rental-system/solutions/3787841/jie-du-ti-yi-shou-dong-wei-hu-you-xu-lie-wpoc/)
