[Problem: 757. 设置交集大小至少为2](https://leetcode.cn/problems/set-intersection-size-at-least-two/description/)

### 方法：贪心+栈&优化

先理清题意：在示例 $1$ 中，有 $[1,3],[3,7],[8,9]$ 三个区间，

- 区间 $1$： $[1,3]$ 包含 $1,2,3$
- 区间 $2$： $[3,7]$ 包含 $3,4,5,6,7$
- 区间 $3$： $[8,9]$ 包含 $8,9$

此时，我们应该从每个区间中抽出两个数字，可能的解是 $[2,3,4,8,9]$，也即

- 区间 $1$： $2,3$ 属于原始区间和答案的交集，长度为 $2$，符合；
- 区间 $2$：包含 $3,4$，是交集，符合；
- 区间 $3$：包含 $8,9$，是交集，符合。

用人话概括题意：最终集合与每个区间的交集，至少有两个整数。

我们来 **寻找规律**：假设拥有区间 $[1,4]$ 与 $[3,6]$，怎么拼接答案？

最简单的情况，就是从 $[1,4]$ 中任选两个数字 $1,2$，从 $[3,6]$ 中任选两个数字 $5,6$，拼成答案 $[1,2,5,6]$，明显长度比较大。所以，一个想法就是找这两个区间的 **交集**，因为数字 $4$ 是两个区间共有的，答案就相当于 **独特数字+共有数字**，一旦都选择了 $4$，比如答案 $[1,4,6]$，那么独特的数字会 $-1$，导致总长度 $-1$。

在这个例子中，两个区间共同含有数字 $3,4,5$，从中选择两个数字 $[3,5]$ 作为答案，明显长度最小。将区间数增多，比如再加一个 $[5,8]$ 区间，我们应该怎么选择？

可以发现，前面两个区间的交集是 $[3,5]$，与当前 $[5,8]$ 区间还有交集 $[5]$，一旦答案选择了 $5$，那么最新区间只需要再添加一个独特数字即可！

因此，根据上面的做法，总结一个 **贪心** 的思路：选出所有区间的交集。具体做法上，就是挑选相邻两区间的交集，且尽可能让这个交集被覆盖在后面的区间内。

这个思路的 **前提** 是：相邻区间有交集，且从左往右遍历，区间的左右端点都在增大。

因此，对所有区间 **排序**，按照它们的 **结束点** 进行升序。如果结束点相同，则按 **起始点** 进行降序。如此一来，上面的区间才是按照 $[1,4],[3,6],[5,8]$ 的顺序处理。

为什么？按结束点 $end$ 排序，从而优先处理那些选择范围更小的区间。一个区间的结束点越早，留给我们放置点的余地就越小。先满足这些约束性强的区间是合理的。

对于当前区间 $[start, end]$，检查它是否已经被之前选择的点集 $ans$ 满足，即至少包含两个点。假设 $ans$ 中 **最大** 的两个点是 $p1$ 和 $p2$，且 $p1 < p2$。实际上，我们只需关心 **这两个点**，因为升序后，任何更小的点都不如它们更有可能覆盖当前及未来的区间。

如果当前区间未被满足（或只被满足了一部分），必须向集合中添加新的点。此时，**贪心** 的想法：为了让新添加的点能够尽可能地服务于 **未来** 的区间（那些结束点更晚的区间），我们应该选择 **当前区间内尽可能大的整数**。

- 如果当前区间 $[start, end]$ 与 $ans$ 完全没有交集，即 $start > p2$，此时必须添加两个点。最优的选择是 $end$ 和 $end - 1$。
- 只与 $p2$ 有交集，即 $start > p1$ 且 $start\leq p2$，此时只需再添加一个点。最优的选择是 $end$。
- 同时包含 $p1$ 和 $p2$，即 $start\leq p1$，那么它已经被满足，无需添加点。

通过这种方式，在满足当前区间需求的同时，最大化了所选点对后续区间的潜在价值，从而保证了每一步都是 “局部最优” 的。

为什么这种贪心是 **正确** 的？

假设正在处理区间 $I = [start, end]$，并且需要为它添加一个点。贪心策略是选择 $end$。现在假设存在一个最优解，它没有选择 $end$，而是选择了另外的某个点 $x$（其中 $start\leq x < end$）来满足区间 $I$。

我们可以构建一个新的解：将最优解中的 $x$ 替换为 $end$。

- 这个新解的总点数不变。
- 对于区间 $I$ 来说， $end$ 和 $x$ 的作用是等价的， $I$ 仍然被满足。
- 对于所有其他的区间 $I'$，如果 $I'$ 之前被 $x$ 覆盖，现在它是否被 $end$ 覆盖呢？
  - 区间按结束点升序，任何尚未处理的 $I' = [start', end']$ 都有 $end'\geq end$。
  - 如果一个区间 $I'$ 包含了 $x$（即 $start'\leq x\leq end'$），那么它也必然会包含 $end$，因为 $start'\leq x < end\leq end'$。
  - 因此，用 $end$ 替换 $x$ 不会破坏任何未来区间的满足条件。

也即，将点选在区间的末尾，其效果 **至少不差于** 选择区间内任何其他点。由于每一步都是局部最优，且不会导致更差全局结果的选择，最终累加起来就能得到全局最优解。

**做法**：先排序。使用一个单调递增的栈，存储我们已经选择的点集 $ans$，栈顶的两个数字 $p1,p2$ 最大，然后判断新区间与两者的关系，添加新的点。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # 按结束升序，起始点降序
        intervals.sort(key=lambda x: (x[1], -x[0]))
        # 存储我们最终选择的点集，升序
        # stack[-1] 是最大点，[-2] 是次大点
        stack = []

        for start, end in intervals:
            # p1 和 p2 这两个点都落在当前区间内
            if len(stack) >= 2 and start <= stack[-2]:
                continue
            # 当前区间只包含一个已选点 p2
            # 选择区间的终点 end 作为新点
            elif len(stack) >= 1 and start <= stack[-1]:
                stack.append(end)
            # 当前区间与已选点无交集
            # 选择区间的最后两个点 end 和 end-1
            else:
                stack.append(end - 1)
                stack.append(end)
        
        return len(stack)
```

```Java
// java
class Solution {
    public int intersectionSizeTwo(int[][] intervals) {
        // 按结束升序，起始点降序
        Arrays.sort(intervals, (a, b) -> {
            if (a[1] != b[1]) {
                return a[1] - b[1];
            }
            return b[0] - a[0];
        });
        
        // 存储我们最终选择的点集，升序
        // stack.get(stack.size()-1) 是最大点，.get(stack.size()-2) 是次大点
        List<Integer> stack = new ArrayList<>();

        for (int[] interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            
            // p1 和 p2 这两个点都落在当前区间内
            if (stack.size() >= 2 && start <= stack.get(stack.size() - 2)) {
                continue;
            }
            // 当前区间只包含一个已选点 p2
            // 选择区间的终点 end 作为新点
            else if (stack.size() >= 1 && start <= stack.get(stack.size() - 1)) {
                stack.add(end);
            }
            // 当前区间与已选点无交集
            // 选择区间的最后两个点 end 和 end-1
            else {
                stack.add(end - 1);
                stack.add(end);
            }
        }
        
        return stack.size();
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $intervals$ 的长度，主要时间开销在于排序，区间的处理都是 $O(1)$ 时间
- 空间复杂度： $O(n)$，表示栈 $stack$ 的大小

---

### 简化

可以发现，并不需要真的用 **栈/列表** 存储所有数字，我们只关心最大的两个数字，而且只会往里添加新的数字，并不会弹出数字。

因此，使用两个变量 $p1,p2$ 分别代指栈顶的最/次大值，然后动态更新即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[1], -x[0]))
        
        # 放入集合中的最大的两个数
        p1, p2 = -1, -1
        ans = 0
        
        for start, end in intervals:
            # p1 和 p2 这两个点都落在当前区间内
            if start <= p1:
                continue
            # 当前区间只包含一个已选点 p2
            # 选择区间的终点 end 作为新点
            elif start <= p2:
                ans += 1
                p1 = p2
                p2 = end
            # 当前区间与已选点无交集
            # 选择区间的最后两个点 end 和 end-1
            else:
                ans += 2
                p2 = end
                p1 = end - 1
        
        return ans
```

```Java
// java
class Solution {
    public int intersectionSizeTwo(int[][] intervals) {
        // 按结束升序，起始点降序
        Arrays.sort(intervals, (a, b) -> {
            if (a[1] != b[1]) {
                return a[1] - b[1];
            }
            return b[0] - a[0];
        });
        
        // 放入集合中的最大的两个数
        int p1 = -1, p2 = -1;
        int ans = 0;
        
        for (int[] interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            
            // p1 和 p2 这两个点都落在当前区间内
            if (start <= p1) {
                continue;
            }
            // 当前区间只包含一个已选点 p2
            // 选择区间的终点 end 作为新点
            else if (start <= p2) {
                ans += 1;
                p1 = p2;
                p2 = end;
            }
            // 当前区间与已选点无交集
            // 选择区间的最后两个点 end 和 end-1
            else {
                ans += 2;
                p2 = end;
                p1 = end - 1;
            }
        }
        
        return ans;
    }
}
```

这种写法较慢，换成下面的 $>$ 判断，速度有较大提升，实测 $Python$ 运行时间 $4ms$，超过 $92\%$。代码如下：

```Python
# python
class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # 按结束升序，起始点降序
        intervals.sort(key=lambda x: (x[1], -x[0]))
        
        # 选择的集合中最大的两个点
        p1, p2 = -1, -1
        ans = 0
        
        for start, end in intervals:
            # 当前区间与已选点无交集
            # 选择区间的最后两个点 end 和 end-1
            if start > p2:
                ans += 2
                p2 = end
                p1 = end - 1
            # 有一个交集
            # 选择区间的结束点 end
            elif start > p1:
                ans += 1
                p1 = p2
                p2 = end
            # 有两个或以上交集，无需添加
            
        return ans
```

```Java
// java
class Solution {
    public int intersectionSizeTwo(int[][] intervals) {
        // 按结束升序，起始点降序
        Arrays.sort(intervals, (a, b) -> {
            if (a[1] != b[1]) {
                return a[1] - b[1];
            }
            return b[0] - a[0];
        });
        
        // 选择的集合中最大的两个点
        int p1 = -1, p2 = -1;
        int ans = 0;
        
        for (int[] interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            
            // 当前区间与已选点无交集
            // 选择区间的最后两个点 end 和 end-1
            if (start > p2) {
                ans += 2;
                p2 = end;
                p1 = end - 1;
            } 
            // 有一个交集
            // 选择区间的结束点 end
            else if (start > p1) {
                ans += 1;
                p1 = p2;
                p2 = end;
            }
            // 有两个或以上交集，无需添加
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(nlogn)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/set-intersection-size-at-least-two/solutions/3837277/san-jie-yi-bu-bu-tui-dao-tan-xin-zheng-q-0ngv/)
