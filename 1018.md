[Problem: 1018. 可被 5 整除的二进制前缀](https://leetcode.cn/problems/binary-prefix-divisible-by-5/description/)

### 方法：数学&状态机

看示例 $1$，数组 $nums$ 从左到右，对应二进制的低位到高位。

如果我们直接 **模拟**，就是不断 $\times 2+nums[i]$ 去拼接，由于题目限定 $n\leq 10^5$，肯定会超出 $int$ 等数据类型的上限。

仔细想想，什么数字能被 $5$ 整除？比如 $5,10,15,20\dots$。可以发现，它们的 **个位数字** 一定是以 $0/5$ 结尾！

因此，依旧采用上述 “二进制 -> 十进制” 的流程，但每次都对 $10$ 取模，仅保留个位！

代码如下，已附加注释：

```Python
# python
class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        res = []
        last_digit = 0
        
        for bit in nums:
            # 个位数的推算
            last_digit = (last_digit * 2 + bit) % 10
            # 个位数是 0 或 5
            res.append(last_digit == 0 or last_digit == 5)
        
        return res
```

```Java
// java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] nums) {
        List<Boolean> res = new ArrayList<>();
        int last_digit = 0;
        
        for (int bit : nums) {
            // 个位数的推算
            last_digit = (last_digit * 2 + bit) % 10;
            // 个位数是 0 或 5
            res.add(last_digit == 0 || last_digit == 5);
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(1)$，返回值 $res$ 一般不计入复杂度

---

### 优化

上面的做法速度较慢，实际上，题目只关心是否被 $5$ 整除，根据模运算性质，

$$
(a * b + c) \% m = ((a \% m) * b + c) \% m
$$

因此，在计算过程中，我们只需要保留 **对 $5$ 取模后的余数** 即可。

修改点：将模 $10$ 变为模 $5$，然后判断余数是否为 $0$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        res = []
        remainder = 0
        
        for bit in nums:
            # 递推公式：新余数 = (旧余数 * 2 + 当前位) % 5
            # 模拟，并限制数值大小
            remainder = (remainder * 2 + bit) % 5
            # 是否能被5整除
            res.append(remainder == 0)
            
        return res
```

```Java
// java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] nums) {
        List<Boolean> res = new ArrayList<>();
        int remainder = 0;
        
        for (int bit : nums) {
            // 递推公式：新余数 = (旧余数 * 2 + 当前位) % 5
            // 模拟，并限制数值大小
            remainder = (remainder * 2 + bit) % 5;
            // 是否能被5整除
            res.add(remainder == 0);
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 有限状态机

我们可以把余数看作 “状态”。

因为模 $5$ 的余数只可能是 $0, 1, 2, 3, 4$，我们完全可以 **预先计算** 出所有状态在遇到输入 $0$ 或 $1$ 时会变成什么新状态（乘 $2$ 后对 $5$ 取模）。

- 状态 $0$ (余 $0$)：遇 $0\to 0$，遇 $1\to 1$；
- 状态 $1$ (余 $1$)：遇 $0\to 2$，遇 $1\to 3$；
- 状态 $2$ (余 $2$)：遇 $0\to 4$，遇 $1\to 0$；
- 状态 $3$ (余 $3$)：遇 $0\to 1$，遇 $1\to 2$；
- 状态 $4$ (余 $4$)：遇 $0\to 3$，遇 $1\to 4$。

**优点**：完全移除了乘法和模运算，只剩下数组索引查找（查表），在底层硬件或汇编层面非常快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        # 状态转移表: transition[当前余数][输入的位]
        # 行代表当前余数(0-4)，列代表输入的是0还是1
        transition = [
            [0, 1],  # 当前余数0: 遇0得0, 遇1得1
            [2, 3],  # 当前余数1: 遇0得2, 遇1得3
            [4, 0],  # 当前余数2: 遇0得4, 遇1得0 (2*2+1=5 -> 0)
            [1, 2],  # 当前余数3: 遇0得1 (3*2=6 -> 1), 遇1得2
            [3, 4]   # 当前余数4: 遇0得3, 遇1得4
        ]
        
        state = 0
        res = []
        
        for bit in nums:
            # 直接查表更新状态，没有乘法和取模
            state = transition[state][bit]
            res.append(state == 0)
        
        return res
```

```Java
// java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] nums) {
        // 状态转移表: transition[当前余数][输入的位]
        // 行代表当前余数(0-4)，列代表输入的是0还是1
        int[][] transition = {
            {0, 1},  // 当前余数0: 遇0得0, 遇1得1
            {2, 3},  // 当前余数1: 遇0得2, 遇1得3
            {4, 0},  // 当前余数2: 遇0得4, 遇1得0 (2*2+1=5 -> 0)
            {1, 2},  // 当前余数3: 遇0得1 (3*2=6 -> 1), 遇1得2
            {3, 4}   // 当前余数4: 遇0得3, 遇1得4
        };
        
        int state = 0;
        List<Boolean> res = new ArrayList<>();
        
        for (int bit : nums) {
            // 直接查表更新状态，没有乘法和取模
            state = transition[state][bit];
            res.add(state == 0);
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/binary-prefix-divisible-by-5/solutions/3840520/san-jie-zai-bao-li-shang-you-hua-dui-105-jork/)
