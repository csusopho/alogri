[Problem: 407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/description/)

### 方法：BFS

前置题目：[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)，本题在此基础上，从二维变成了三维。

我们先来看看二维，将 `x` 视作高度为 $1$ 的单元格：

```Java
x     x
x     x
x  x  x
```

显然，在上面的矩阵中，中间一列能装下 **两格** 的水。如果左右两侧高度不同，

```Java
x                                 x
x     x        或者       x       x
x  x  x                   x   x   x
```

那么中间一列只能装下 **一格** 的水。如果扩展到多列，

```Java
   x        x            x           x
x  x     x  x    或者    x  x     x  x
x  x  x  x  x            x  x  x  x  x
```

那么中间一列能装下 **两格** 的水。但是，如果左右两侧最大高度不同，

```Java
   x
x  x     x  x
x  x  x  x  x
```

此时，中间一列只能装下 **一格** 的水！你能发现什么规律？

$$
当前列能装下的水量 = min(左侧最大高度,右侧最大高度)
$$

因此，我们会写出下面的代码，作为前一题的解答：

```Python
# python
class Solution:
    def trap(self, height: List[int]) -> int:
        """
        对于位置 i，能接的雨水量取决于：
        min(左边最高的柱子, 右边最高的柱子) - 当前柱子高度
        因为水只能由两边的最矮柱子决定，柱子太高的话水会溢出
        """

        n = len(height)

        # 预处理数组 leftMax[i]，存储从左到 i 的最高柱子
        leftMax = [0] * n
        leftMax[0] = height[0]
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        # 预处理数组 rightMax[i]，存储从右到 i 的最高柱子
        rightMax = [0] * n
        rightMax[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        # 遍历每个位置 i，累加能接的雨水总量
        ans = 0
        for i in range(n):
            ans += min(leftMax[i], rightMax[i]) - height[i]

        return ans
```

---

现在，我们再来看看三维。当前这一列 $z$ 轴能装多少格子的水？取决于 **上下左右** 四个方向，比二维多了两个方向。

那能否直接预处理四个方向，然后同样解法？**不能！**

“绕流效应”：水不一定只从正上、正下、正左、正右流出去，它可以 **绕过** 一条低洼路径流走。也即，某一方向的最大值并不能保证水 **真的能留住**。如果你真的尝试了，会卡在 $19/42$ 样例，~~别问我怎么知道的。~~

正确做法是什么？核心思想：**从外向内，模拟** 水从矩阵的边界逐渐 “灌入” 的过程。我们可以把整个矩阵想象成一个洼地，雨水从外部流入，其水平面高度取决于包围洼地的 “堤坝” 的最低点（木桶效应）。

具体来说，使用 **最小堆** 和 $BFS$ 相结合。

**初始化**：

- 创建一个 $visited$ 矩阵，用于记录一个单元格是否已经被访问过，初始值均为 $False$。
- 创建一个最小堆，用于存放待处理的单元格。堆中存储的元素是 `(height, row, col)`，堆会根据 $height$ 进行排序，**堆顶** 是当前“堤坝”上高度最低的单元格。
- 将矩阵最外围一圈的所有单元格加入最小堆，并将它们在 $visited$ 矩阵中标记为 $True$。因为最外圈的单元格无法存水，它们是初始的 “堤坝”。

**处理过程**：

- 当最小堆不为空时，从堆中弹出高度最小的单元格 $(h, r, c)$。这个高度 $h$ 代表了当前能围住水的“堤坝”的有效高度；
- 遍历该单元格的上、下、左、右的四个相邻邻居 $(nr, nc)$；
- 对于每一个邻居，如果它在矩阵范围内且 **未被访问过**：
  - 标记该邻居为已访问 $True$。
  - 计算该邻居能接的雨水：如果当前堤坝高度 $h$ 大于邻居自身的高度 $heightMap[nr][nc]$，那么可以接的雨水量就是 `h - heightMap[nr][nc]`。将这部分水量累加到总结果中。如果 $h$ 不大于邻居的高度，则该邻居处接不到水。
  - 将该邻居加入最小堆。**关键点**：入堆的高度不是邻居自身的高度，而是 `max(h, heightMap[nr][nc])`。这是因为水流过 $(r, c)$ 到达 $(nr, nc)$ 后，新的堤坝高度取决于两者中的较大者。

为什么使用最小堆？因为我们总是从当前所有 “围墙” 单元格中，**最低的** 那个格子开始向内探索，它决定了当前的水面高度。如果水面再高，水就会从这个最低点流出。所以，当我们从堆中弹出一个高度为 $h$ 的单元格时，我们可以确定，任何从其内部邻居到外界的路径，都必须经过一个高度至少为 $h$ 的单元格。

为什么将邻居 $(nr, nc)$ 推入堆时，使用 $max$ 作为新的高度？这是因为，对于更内部的单元格来说，这个刚刚被访问的邻居 $(nr, nc)$ 也成为了 “堤坝” 的一部分。而这个新堤坝的有效高度，是由它自身高度和流过来的水面高度 $h$ **共同决定**。

这个过程就像是 $Dijkstra$ 算法的变体，我们寻找从内部单元格到边界的路径，路径的 “成本” 是路径上遇到的最大高度，而我们想找到这个 “成本” 的最小值。最小堆恰好能帮助我们实现这一目标。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        # 如果矩阵太小，无法形成“洼地”
        if m <= 2 or n <= 2:
            return 0

        visited = [[False for _ in range(n)] for _ in range(m)]
        min_heap = []  # 优先队列，存储 (height, row, col)

        # 将最外一圈的单元格加入最小堆
        for i in range(m):
            for j in range(n):
                if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                    heapq.heappush(min_heap, (heightMap[i][j], i, j))
                    visited[i][j] = True

        total = 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # 上、下、左、右四个方向

        # 从当前“堤坝”的最低点开始向内扩展
        while min_heap:
            height, r, c = heapq.heappop(min_heap)

            for dr, dc in directions:
                nr, nc = r + dr, c + dc

                # 确保邻居在界内且未被访问过
                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                    # 计算水量并更新
                    # 如果当前堤坝高度 > 邻居高度，则可以存水
                    water_trapped = max(0, height - heightMap[nr][nc])
                    total += water_trapped

                    visited[nr][nc] = True
                    # 新的堤坝高度是当前水面和邻居高度的较大者
                    new_height = max(height, heightMap[nr][nc])
                    heapq.heappush(min_heap, (new_height, nr, nc))

        return total
```

```Java
// java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        // 如果矩阵太小，无法形成“洼地”
        if (m <= 2 || n <= 2) {
            return 0;
        }

        boolean[][] visited = new boolean[m][n];
        // 最小堆（优先队列），用于存放待处理的单元格。
        // 存储的数组格式为 [height, row, col]，确保堆顶始终是高度最小的元素
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));

        // 初始化：将最外一圈的单元格加入最小堆
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    minHeap.offer(new int[]{heightMap[i][j], i, j});
                    visited[i][j] = true;
                }
            }
        }

        int total = 0;
        // 定义上、下、左、右四个方向
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        // 处理过程：从当前“堤坝”的最低点开始向内扩展
        while (!minHeap.isEmpty()) {
            int[] cell = minHeap.poll(); // 弹出高度最低的单元格
            int height = cell[0];
            int r = cell[1];
            int c = cell[2];

            // 遍历该单元格的四个相邻邻居
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // 确保邻居在界内且未被访问过
                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]) {
                    // 标记邻居为已访问
                    visited[nr][nc] = true;

                    // 计算水量
                    // 如果当前堤坝高度 > 邻居高度，则可以存水
                    int waterTrapped = Math.max(0, height - heightMap[nr][nc]);
                    total += waterTrapped;

                    // 将该邻居加入最小堆。
                    // 注意：入堆的高度是当前水面和邻居高度的较大者，这构成了新的堤坝高度。
                    int newHeight = Math.max(height, heightMap[nr][nc]);
                    minHeap.offer(new int[]{newHeight, nr, nc});
                }
            }
        }

        return total;
    }
}
```

- 时间复杂度： $O(m\times n\times log(mn))$，每个单元格最多出/入堆一次
- 空间复杂度： $O(m\times n)$，表示数组 $visited$ 以及堆 $minHeap$ 的大小

---

### 优化

如果不想一边出入堆一边累加，能否直接计算出每个点的 “最小可行水位”？也就是说，仿照二维的思路，求出每个点的 $z$ 轴最大容量，最后累加？

那么，我们不再需要 $visited$ 数组，换成 $waters$ 维护最小高度。

**做法**：依旧使用最小堆来向内扩展，但是逻辑更加清晰，容易调试与验证。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m = len(heightMap)
        n = len(heightMap[0])

        # 找到整个高度图中的最大高度，用于初始化水位数组 waters
        MAX_HEIGHT = reduce(lambda x, y: max(x, max(y)), heightMap, -1)

        # waters[x][y] 表示 (x,y) 处的“最终水位高度”
        # 之后会不断缩小，直到达到合理的“最小可行水位”
        waters = [[MAX_HEIGHT for _ in range(n)] for _ in range(m)]

        # walls 是最小堆，存放形式为 (高度, x, y)
        # 作用：每次从当前最矮的“墙”开始向内扩展
        walls = []
        heapify(walls)

        # 初始化：将四周边界上的格子放入堆中，并设定其水位 = 自身高度
        # 因为边界不可能积水，只能作为“容器的墙”
        for x, y in product(range(m), range(n)):
            if x == 0 or x == m - 1 or y == 0 or y == n - 1:
                heappush(walls, (heightMap[x][y], x, y))
                waters[x][y] = heightMap[x][y]

        # 从堆中不断取出当前最低的“墙”进行扩展
        while len(walls) > 0:
            h, x, y = heappop(walls)  # 当前最低墙（或水位）

            # 遍历四个方向（上下左右）
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                # 越界则跳过
                if not ((0 <= nx < m) and (0 <= ny < n)):
                    continue

                # waters[nx][ny] 是当前水位，heightMap[nx][ny] 是原始高度
                # 如果邻居格子的水位比当前墙高，说明可以被更新
                if waters[nx][ny] > waters[x][y] and waters[nx][ny] > heightMap[nx][ny]:
                    # 更新邻居格子的水位 = max(邻居原始高度, 当前墙高度)
                    # 逻辑：水位至少要“盖过原始地面”，并且不能低于当前墙
                    waters[nx][ny] = max(h, heightMap[nx][ny])

                    # 将更新后的邻居推入堆中，参与后续的扩展
                    heappush(walls, (waters[nx][ny], nx, ny))

        # 遍历所有格子，计算积水体积 = (最终水位 - 原始高度)
        ans = 0
        for x, y in product(range(m), range(n)):
            ans += waters[x][y] - heightMap[x][y]
        return ans
```

```Java
// java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;

        // 找到整个高度图中的最大高度，用于初始化水位数组 waters
        int MAX_HEIGHT = -1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                MAX_HEIGHT = Math.max(MAX_HEIGHT, heightMap[i][j]);
            }
        }

        // waters[x][y] 表示 (x,y) 处的“最终水位高度”
        // 之后会不断缩小，直到达到合理的“最小可行水位”
        int[][] waters = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(waters[i], MAX_HEIGHT);
        }

        // walls 是最小堆，存放形式为 (高度, x, y)
        // 作用：每次从当前最矮的“墙”开始向内扩展
        PriorityQueue<int[]> walls = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));

        // 初始化：将四周边界上的格子放入堆中，并设定其水位 = 自身高度
        // 因为边界不可能积水，只能作为“容器的墙”
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                    walls.offer(new int[]{heightMap[x][y], x, y});
                    waters[x][y] = heightMap[x][y];
                }
            }
        }

        // 四个方向（上下左右）
        int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

        // 从堆中不断取出当前最低的“墙”进行扩展
        while (!walls.isEmpty()) {
            int[] cur = walls.poll();
            int h = cur[0], x = cur[1], y = cur[2];

            for (int[] d : dirs) {
                int nx = x + d[0];
                int ny = y + d[1];

                // 越界则跳过
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;

                // waters[nx][ny] 是当前水位，heightMap[nx][ny] 是原始高度
                // 如果邻居格子的水位比当前墙高，说明可以被更新
                if (waters[nx][ny] > waters[x][y] && waters[nx][ny] > heightMap[nx][ny]) {
                    // 更新邻居格子的水位 = max(邻居原始高度, 当前墙高度)
                    // 逻辑：水位至少要“盖过原始地面”，并且不能低于当前墙
                    waters[nx][ny] = Math.max(h, heightMap[nx][ny]);

                    // 将更新后的邻居推入堆中，参与后续的扩展
                    walls.offer(new int[]{waters[nx][ny], nx, ny});
                }
            }
        }

        // 遍历所有格子，计算积水体积 = (最终水位 - 原始高度)
        int ans = 0;
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                ans += waters[x][y] - heightMap[x][y];
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n\times log(mn))$，同理
- 空间复杂度： $O(m\times n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/trapping-rain-water-ii/solutions/3797733/yi-bu-bu-tui-dao-yi-wei-kuo-zhan-bfszui-jl7kj/)
