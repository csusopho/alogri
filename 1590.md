[Problem: 1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/description/)

### 方法：前缀和+哈希

设数组总和为 $total$，如果 $total$ 能被 $p$ 整除，即 $total \% p = 0$，则不需要移除任何元素，直接返回 $0$。否则，令 $rem = total \% p$。

整体的余数是 $rem$，如果被移除的子数组余数也是 $rem$，那么剩余部分的余数就是 $0$。也即，问题转化为：寻找 **子数组的和** $subSum$ 满足 $subSum\% p= rem$。

如何快速求取任意子数组的和？**前缀和**。它是一种能将 $O(n)$ 的统计转化为 $O(1)$ 的快速方法。具体原理/做法，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

设 $presum[i]$ 为前 $i$ 个元素的和。子数组 $nums[j:i)$ 的和可以表示为 $presum[i] - presum[j]$。我们需要找到子数组，它满足：

$$
(presum[i] - presum[j]) \% p = rem
$$

移项变换后得到：

$$
presum[j] \% p = (presum[i] - rem) \% p
$$

等式左侧是之前出现过的前缀和，我们需要找到最短子数组 $[j:i]$。因此，使用一个 **哈希表** $modPos$ 记录 `(前缀和，最后出现的索引)`。

总结一下 **算法流程**，从前往后遍历：

- 当前前缀和余数为 $curMod$，需要的历史余数为 $targetMod = (curMod - rem) \% p$。
- 如果 $targetMod$ 存在于哈希表中，说明从之前位置 $j$ 到当前位置 $i$ 的子数组符合条件。计算长度并更新最小值。
- 将当前的 $curMod$ 和索引 $i$ 存入哈希。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        n = len(nums)
        # prefix[i] 表示 nums 前 i 个元素的和
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
            
        # 总和的余数
        rem = prefix[n] % p
        if rem == 0:
            return 0
        
        # 记录 {前缀和余数 : 该余数最后出现的索引}
        mod_pos = {}
        ans = n
        
        for i in range(n + 1):
            # 当前前缀和余数
            cur_mod = prefix[i] % p
            # 目标前缀和余数
            target = (cur_mod - rem) % p
            
            # 说明 prefix[j]...prefix[i] 中间的子数组符合条件
            if target in mod_pos:
                ans = min(ans, i - mod_pos[target])
            
            # 更新当前余数的索引
            mod_pos[cur_mod] = i
            
        return ans if ans < n else -1
```

```Java
// java
class Solution {
    public int minSubarray(int[] nums, int p) {
        int n = nums.length;
        // prefix[i] 表示 nums 前 i 个元素的和
        // 使用 long 防止整型溢出
        long[] prefix = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }
        
        // 总和的余数
        int rem = (int)(prefix[n] % p);
        if (rem == 0) {
            return 0;
        }
        
        // 记录 {前缀和余数 : 该余数最后出现的索引}
        Map<Integer, Integer> modPos = new HashMap<>();
        int ans = n;
        
        for (int i = 0; i < n + 1; i++) {
            // 当前前缀和余数
            int curMod = (int)(prefix[i] % p);
            // 目标前缀和余数
            // 负数取模结果为负，需 +p 修正
            int target = (curMod - rem + p) % p;
            
            // 说明 prefix[j]...prefix[i] 中间的子数组符合条件
            if (modPos.containsKey(target)) {
                ans = Math.min(ans, i - modPos.get(target));
            }
            
            // 更新当前余数的索引
            modPos.put(curMod, i);
        }
        
        return ans < n ? ans : -1;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示数组 $prefix$ 的大小

---

### 优化

将 “统计前缀和” 与 “计算答案” 的过程合二为一，毕竟两者都是从前往后遍历，本质是一维前缀和的空间优化，速度有小幅度提升。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        # 计算总和的余数
        rem = sum(nums) % p
        if rem == 0:
            return 0
        
        # 记录 {前缀和余数 : 该余数最后出现的索引}
        mod_pos = {0: -1}
        cur_mod = 0
        ans = len(nums)
        
        for i, num in enumerate(nums):
            # 计算当前前缀和余数
            cur_mod = (cur_mod + num) % p
            # 目标前缀和余数
            target = (cur_mod - rem) % p
            
            # 中间这段子数组的和 % p == rem
            if target in mod_pos:
                ans = min(ans, i - mod_pos[target])
            
            # 更新当前余数的索引
            mod_pos[cur_mod] = i

        return ans if ans < len(nums) else -1
```

```Java
// java
class Solution {
    public int minSubarray(int[] nums, int p) {
        // 计算总和的余数
        long sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int rem = (int)(sum % p);
        if (rem == 0) {
            return 0;
        }
        
        // 记录 {前缀和余数 : 该余数最后出现的索引}
        Map<Integer, Integer> modPos = new HashMap<>();
        modPos.put(0, -1);
        int curMod = 0;
        int ans = nums.length;
        
        for (int i = 0; i < nums.length; i++) {
            // 计算当前前缀和余数
            // 使用 long 防止加法溢出
            curMod = (int)((curMod + (long)nums[i]) % p);
            // 目标前缀和余数
            // 负数取模结果为负，需 +p 修正
            int target = (curMod - rem + p) % p;
            
            // 中间这段子数组的和 % p == rem
            if (modPos.containsKey(target)) {
                ans = Math.min(ans, i - modPos.get(target));
            }
            
            // 更新当前余数的索引
            modPos.put(curMod, i);
        }

        return ans < nums.length ? ans : -1;
    }
}
```

- 时间复杂度： $O(n)$，两次遍历
- 空间复杂度： $O(min(n,p))$，哈希表最多存储 $p$ 个余数或 $n$ 个索引

在计算 $ans$ 后附加一个 $if$ **剪枝**，如果 $ans=1$ 就立刻返回，可以提升代码速度，实测 $Python$ 代码运行时间为 $71ms$，超过 $98.6\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/3845419/shuang-jie-shu-xue-bian-xing-wen-ti-zhua-e1qd/)
