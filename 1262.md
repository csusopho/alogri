[Problem: 1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/)

### 方法：贪心&动规+优化

挑选元素，凑成 $3$ 的倍数，每个元素只能选一次。

一个 **自然** 的想法：如果所有元素的累加和是 $3$ 的倍数，那就全部都选上。如果不是 $3$ 的倍数，怎么办？

- 如果总和除以 $3$ 余 $1$，需要删去一个余数为 $1$ 的最小数，或者两个余数为 $2$ 的最小数（因为 $2+2=4$，它除 $3$ 余 $1$）。
- 如果总和除以 $3$ 余 $2$，需要删去一个余数为 $2$ 的最小数，或者两个余数为 $1$ 的最小数（因为 $1+1=2$，除 $3$ 余 $2$）。

**贪心**：为了让剩下的和最大，我们删去的数之和必须最小。

怎么得知哪个数最小？遍历所有数字，根据除 $3$ 的余数 **分组**，然后组内 **排序**。

**流程**：求出数组总和，计算除 $3$ 的余数，然后分类讨论，找出删除一个/两个的最小值。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        # 计算总和
        total = sum(nums)
        remainder = total % 3
        
        # 无需删除任何元素
        if remainder == 0:
            return total
            
        # 按余数1和余数2分类，并排序
        # 余数为0的不用管，因为它们不影响总和的余数
        r1 = sorted([x for x in nums if x % 3 == 1])
        r2 = sorted([x for x in nums if x % 3 == 2])
        
        # 要减去的值
        remove_val = float('inf')
        
        # 根据余数情况，尝试找出最小的删除代价
        if remainder == 1:
            # 方案A: 删掉一个最小的余1数
            if len(r1) >= 1:
                remove_val = min(remove_val, r1[0])
            # 方案B: 删掉两个最小的余2数
            if len(r2) >= 2:
                remove_val = min(remove_val, r2[0] + r2[1])
                
        elif remainder == 2:
            # 方案A: 删掉一个最小的余2数
            if len(r2) >= 1:
                remove_val = min(remove_val, r2[0])
            # 方案B: 删掉两个最小的余1数
            if len(r1) >= 2:
                remove_val = min(remove_val, r1[0] + r1[1])
        
        # 总和减去最小代价
        return total - remove_val if remove_val != float('inf') else 0
```

```Java
// java
class Solution {
    public int maxSumDivThree(int[] nums) {
        // 计算总和
        int total = 0;
        for (int x : nums) {
            total += x;
        }
        int remainder = total % 3;

        // 无需删除任何元素
        if (remainder == 0) {
            return total;
        }

        // 按余数1和余数2分类，并排序
        // 余数为0的不用管，因为它们不影响总和的余数
        List<Integer> r1 = new ArrayList<>();
        List<Integer> r2 = new ArrayList<>();
        for (int x : nums) {
            if (x % 3 == 1) r1.add(x);
            else if (x % 3 == 2) r2.add(x);
        }
        Collections.sort(r1);
        Collections.sort(r2);

        // 要减去的值
        int remove_val = Integer.MAX_VALUE;

        // 根据余数情况，尝试找出最小的删除代价
        if (remainder == 1) {
            // 方案A: 删掉一个最小的余1数
            if (r1.size() >= 1) {
                remove_val = Math.min(remove_val, r1.get(0));
            }
            // 方案B: 删掉两个最小的余2数
            if (r2.size() >= 2) {
                remove_val = Math.min(remove_val, r2.get(0) + r2.get(1));
            }
        } else if (remainder == 2) {
            // 方案A: 删掉一个最小的余2数
            if (r2.size() >= 1) {
                remove_val = Math.min(remove_val, r2.get(0));
            }
            // 方案B: 删掉两个最小的余1数
            if (r1.size() >= 2) {
                remove_val = Math.min(remove_val, r1.get(0) + r1.get(1));
            }
        }

        // 总和减去最小代价
        return remove_val != Integer.MAX_VALUE ? total - remove_val : 0;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度，瓶颈在于排序
- 空间复杂度： $O(n)$，表示列表 $r1,r2$ 的大小，忽略排序的 $O(logn)$ 栈开销

---

### 优化

我们只关心最/次小的两个数，因此没必要进行排序。

将 “计算总和” 与 “分组寻找最值” 的过程合二为一，简化为一次遍历。同时，省去排序步骤，改为动态更新最/小值。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        total = 0
        # 仅需记录最小的两个数
        # r1,r2 保存取模为 1,2 的最小两个数
        r1 = [float('inf')] * 2
        r2 = [float('inf')] * 2
        
        for x in nums:
            total += x
            if x % 3 == 1:
                # 更新 r1 中最小的两个数
                if x < r1[0]:
                    r1[1] = r1[0]
                    r1[0] = x
                elif x < r1[1]:
                    r1[1] = x
            elif x % 3 == 2:
                # 更新 r2 中最小的两个数
                if x < r2[0]:
                    r2[1] = r2[0]
                    r2[0] = x
                elif x < r2[1]:
                    r2[1] = x
        
        # 总余数
        remainder = total % 3
        # 要减去的值
        remove = float('inf')
        
        if remainder == 0:
            return total
        elif remainder == 1:
            # 删1个余1，或删2个余2
            remove = min(r1[0], r2[0] + r2[1])
        elif remainder == 2:
            # 删1个余2，或删2个余1
            remove = min(r2[0], r1[0] + r1[1])
            
        # 总和减去最小代价
        return total - remove
```

```Java
// java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int total = 0;
        // 仅需记录最小的两个数
        // r1,r2 保存取模为 1,2 的最小两个数
        int[] r1 = {Integer.MAX_VALUE, Integer.MAX_VALUE};
        int[] r2 = {Integer.MAX_VALUE, Integer.MAX_VALUE};

        for (int x : nums) {
            total += x;
            if (x % 3 == 1) {
                // 更新 r1 中最小的两个数
                if (x < r1[0]) {
                    r1[1] = r1[0];
                    r1[0] = x;
                } else if (x < r1[1]) {
                    r1[1] = x;
                }
            } else if (x % 3 == 2) {
                // 更新 r2 中最小的两个数
                if (x < r2[0]) {
                    r2[1] = r2[0];
                    r2[0] = x;
                } else if (x < r2[1]) {
                    r2[1] = x;
                }
            }
        }

        // 总余数
        int remainder = total % 3;
        // 要减去的值
        int remove = Integer.MAX_VALUE;

        if (remainder == 0) {
            return total;
        } else if (remainder == 1) {
            // 删1个余1，或删2个余2
            int case2 = (r2[0] != Integer.MAX_VALUE && r2[1] != Integer.MAX_VALUE) ? r2[0] + r2[1] : Integer.MAX_VALUE;
            remove = Math.min(r1[0], case2);
        } else if (remainder == 2) {
            // 删1个余2，或删2个余1
            int case2 = (r1[0] != Integer.MAX_VALUE && r1[1] != Integer.MAX_VALUE) ? r1[0] + r1[1] : Integer.MAX_VALUE;
            remove = Math.min(r2[0], case2);
        }

        // 总和减去最小代价
        return total - remove;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

这种方法速度最快， $Python$ 语言耗时 $11ms$，超过 $95\%$。

上面的流程都是反向贪心，从总和中删除数字。可以使用正向贪心，根据余数 $0,1,2$ 分组，然后从中选择尽量最多的数字。余数为 $0$ 的全选，余数为 $1$ 或 $2$ 的选择范围一定是组长减去 $2/1/0$，枚举最多 $3*3$ 种情况，找出最大可能。

如果是 “每一步” 贪心地维护当前能得到的 “余数为 $0、1、2$” 的最大和，本质是动规，下面再介绍。

---

### 动态规划

正规/推广的解法，则对应 **动规**，它是更加普遍的解法。

实际上，数字只能「选」或「不选」加入最终的答案，本质都是 “父问题 -> 子问题”。具体从 $DFS$ 推导至 $DP$ 的过程，这里不再介绍，递归代码放在评论区参考。

**定义** $dp[i][j]$ 表示从前面 $i$ 个数中选择后，能得到的模 $3$ 余 $j$ 的最大总和。

对于当前的 $nums[i-1]$ 来说，只有 “选” 或 “不选” 两种可能，**状态转移** 方程为：

$$
dp[i][j]=\max\left(dp[i-1][prev]+num,dp[i-1][j]\right)
$$

其中 `prev=(j-num)%3` 表示上一轮的余数，选择当前 $num$ 后得到当前余数 $j$。

将 $dp[i][j]$ 初始化为 $-\infty$ 表示未更新，以及 $dp[0][0]=0$ 作为初始状态。

观察状态转移方程，可知第一维正向枚举，第二维无所谓枚举方向。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        n = len(nums)
        # dp[i][j]: 前 i 个数中，和模 3 余 j 的最大和
        dp = [[float('-inf')] * 3 for _ in range(n + 1)]
        # 初始状态
        dp[0][0] = 0
        
        for i in range(1, n + 1):
            num = nums[i-1]  # 当前数字
            
            for j in range(3):
                # 不选当前数字
                not_pick = dp[i-1][j]
                
                # 选
                # 想要得到当前余数 j，上一轮的余数应该是 (j - num) % 3
                prev_rem = (j - num) % 3
                pick = dp[i-1][prev_rem] + num
                
                # 状态转移
                dp[i][j] = max(not_pick, pick)
                
        # 前 n 个数处理完后，余数为 0 的最大和
        return dp[n][0]
```

```Java
// java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int n = nums.length;
        // dp[i][j]: 前 i 个数中，和模 3 余 j 的最大和
        int[][] dp = new int[n + 1][3];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MIN_VALUE);
        }
        
        // 初始状态
        dp[0][0] = 0;

        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1]; // 当前数字

            for (int j = 0; j < 3; j++) {
                // 不选当前数字
                int not_pick = dp[i - 1][j];

                // 选
                // 想要得到当前余数 j，上一轮的余数应该是 (j - num) % 3
                int prev_rem = ((j - num) % 3 + 3) % 3;
                int pick = dp[i - 1][prev_rem];
                
                if (pick != Integer.MIN_VALUE) {
                    pick += num;
                }

                // 状态转移
                dp[i][j] = Math.max(not_pick, pick);
            }
        }

        // 前 n 个数处理完后，余数为 0 的最大和
        return dp[n][0];
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 空间优化

可以发现，计算状态 $dp[i]$ 时，只会用到 $dp[i-1]$ 的值，不会用到比 $i-1$ 更早的状态。所以能采用 **滚动数组**，优化掉第一维。

新的 $dp[j]$ 表示当前遍历过的数字选择后，得到的模 $3$ 余 $j$ 的最大和。

整体逻辑不变，具体细节见代码，已附加注释：

```Python
# python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        # dp[j]：当前遍历过的数字中，和模 3 余 j 的最大和
        dp = [0, float('-inf'), float('-inf')]
        
        for num in nums:
            # 必须使用新数组，不能直接修改 dp
            new_dp = dp[:]
            
            for j in range(3):
                # 不选 num，直接继承上一轮的同余数状态 (dp[j])
                # 选 num，需要上一轮余数为 (j - num) % 3 的状态加上 num
                prev_rem = (j - num) % 3
                # 状态转移
                new_dp[j] = max(dp[j], dp[prev_rem] + num)
            
            # 更新 dp 为最新状态
            dp = new_dp
        
        return dp[0]
```

```Java
// java
class Solution {
    public int maxSumDivThree(int[] nums) {
        // dp[j]：当前遍历过的数字中，和模 3 余 j 的最大和
        int[] dp = {0, Integer.MIN_VALUE, Integer.MIN_VALUE};

        for (int num : nums) {
            // 必须使用新数组，不能直接修改 dp
            int[] new_dp = dp.clone();

            for (int j = 0; j < 3; j++) {
                // 不选 num，直接继承上一轮的同余数状态 (dp[j])
                // 选 num，需要上一轮余数为 (j - num) % 3 的状态加上 num
                int prev_rem = ((j - num) % 3 + 3) % 3;
                
                // 状态转移
                if (dp[prev_rem] != Integer.MIN_VALUE) {
                    new_dp[j] = Math.max(dp[j], dp[prev_rem] + num);
                }
            }

            // 更新 dp 为最新状态
            dp = new_dp;
        }

        return dp[0];
    }
}
```

如果不想使用数组形式，可以只使用单独的三个状态，但是较难理解（有限状态机）：

```Python
# python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        # dp[i] 表示余数为 i 时的最大和
        dp = [0, 0, 0]
        
        for num in nums:
            # 读取了“上一轮”的状态，避免了直接修改 dp
            a = dp[0] + num
            b = dp[1] + num
            c = dp[2] + num
            
            # 更新到对应的余数位置
            dp[a % 3] = max(dp[a % 3], a)
            dp[b % 3] = max(dp[b % 3], b)
            dp[c % 3] = max(dp[c % 3], c)
            
        return dp[0]
```

```Java
// java
class Solution {
    public int maxSumDivThree(int[] nums) {
        // dp[i] 表示余数为 i 时的最大和
        int[] dp = {0, 0, 0};

        for (int num : nums) {
            // 读取了“上一轮”的状态，避免了直接修改 dp
            int a = dp[0] + num;
            int b = dp[1] + num;
            int c = dp[2] + num;

            // 更新到对应的余数位置
            dp[a % 3] = Math.max(dp[a % 3], a);
            dp[b % 3] = Math.max(dp[b % 3], b);
            dp[c % 3] = Math.max(dp[c % 3], c);
        }

        return dp[0];
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/greatest-sum-divisible-by-three/solutions/3839753/wu-jie-tan-xin-jian-hua-er-wei-dpkong-ji-otd3/)
