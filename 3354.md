[Problem: 3354. 使数组元素等于零](https://leetcode.cn/problems/make-array-elements-equal-to-zero/description/)

### 方法：模拟 & 前后缀

操作流程：从 $0$ 开始，根据值进行左右移动，直至出界。

**模拟**：记录所有数值为 $0$ 的下标，它们作为起点，分别进行移动，统计答案。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        n = len(nums)
        # 找出所有值为 0 的起点索引
        zero = [i for i, val in enumerate(nums) if val == 0]
        ans = 0

        for start in zero:
            # 尝试两种可能的初始方向
            for direction in [-1, 1]:
                # 创建一个副本
                nums_copy = list(nums)
                curr = start
                direction = direction

                # 直到超出数组边界
                while 0 <= curr < n:
                    if nums_copy[curr] > 0:
                        # 减1，反向移动
                        nums_copy[curr] -= 1
                        direction *= -1
                        curr += direction
                    else:
                        # 继续移动
                        curr += direction
                
                # 验证
                if sum(nums_copy) == 0:
                    ans += 1
        
        return ans
```

```Java
// java
class Solution {
    public int countValidSelections(int[] nums) {
        int n = nums.length;
        // 找出所有值为 0 的起点索引
        List<Integer> zeroIndices = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                zeroIndices.add(i);
            }
        }

        int ans = 0;
        int[] initialDirections = {-1, 1};

        // 遍历所有可能的起点
        for (int start : zeroIndices) {
            for (int initialDirection : initialDirections) {
                // 创建一个副本
                int[] numsCopy = nums.clone();
                int curr = start;
                int direction = initialDirection;

                // 直到超出数组边界
                while (curr >= 0 && curr < n) {
                    if (numsCopy[curr] > 0) {
                        // 减1，反向移动
                        numsCopy[curr]--;
                        direction *= -1;
                        curr += direction;
                    } else {
                        // 继续沿当前方向移动
                        curr += direction;
                    }
                }
                
                // 验证
                boolean flag = true;
                for (int val : numsCopy) {
                    if (val > 0) {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    ans++;
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^2\times S)$，其中 $n$ 是数组 $nums$ 的长度，而 $S$ 是所有元素总和
- 空间复杂度： $O(n)$，表示列表 $zero$ 以及数组 $copy$ 的大小

---

### 前后缀

实际上，我们可以转化思路，不再是分析数值，而是从 “左转” 和 “右转” 的角度下手。

**一个有效的路径必须在“左转次数”和“右转次数”之间达到一种平衡。**

我们可以将数组中每个正数 $nums[i]$，看作是需要 $nums[i]$ 次 “访问” 才能清零的 “任务”。每次访问一个正数，我们都会被迫 **反转方向**。

每个值为 $0$ 的位置视为一个潜在的 **起点**。

假设起点是 $x$，它将数组一分为二。数组左边所有正数之和 $l$，它可以被理解为在数组左半部分必须发生的 **转向总次数**。同理，右侧总和 $r$ 是右半部分必须发生的转向总次数。

当我们选择一个起点和初始方向时，我们为整个过程引入了一个初始的 “推力”，或者说 “不平衡”。

- 选择向 **右** 移动，相当于给系统增加了一次 “向右的力”。
- 选择向 **左** 移动，相当于给系统增加了一次 “向左的力”。

最终，我们需要不多不少正好清空所有数字。这要求左右两侧的转向力最终能相互抵消，或达到一个特定的平衡状态。只有在以下两种情况：

- 情况一： $l == r$
  - 这说明左右两侧需要相同次数的转向，也即左右任务 **完全对称**。
  - 如果我们初始向 **右** 移动，就引入了一个 “右推力”，使得右侧的 “总力” 比左侧多 $1$，则最终从右侧移出边界。
  - 同理，如果我们初始向 **左** 移动，引入的 “左推力” 使得结果从左侧移出。
  - 因此，当左右任务对称时，两个初始方向都有效，结果增加 $2$。

- 情况二： $abs(r - l) == 1$
  - 此时，一侧的转向任务比另一侧多 $1$，系统本身存在一个微小的 “不平衡”。
  - 比如 $r = l + 1$，说明右侧本身就比左侧多一次转向。为了抵消这种不平衡，我们必须选择一个能 “帮助” 弱势一方的初始方向，也就是向 **左** 移动。初始的 “左推力” 正好可以平衡掉右侧多出来的一个 “右推力”。反之，如果初始向右，则会加剧不平衡，导致路径无效。
  - 因此，当左右任务差 $1$ 时，只有一个初始方向是有效的，结果增加 $1$。

- 其他情况：如果 $abs(r - l) > 1$，说明左右任务的差距太大，一个初始的推力无法弥补这个差距，因此无法形成有效的路径。

如何快速计算左/右侧的子数组总和？**前/后缀和**。具体原理及推导，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

**做法**：预处理出前缀和数组 $prefix$，以及后缀和数组 $suffix$。然后遍历 $nums$ 数组，找出所有值为 $0$ 的索引，分别作为起点，一次性进行判断。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        n = len(nums)
        
        # 前缀和数组
        prefix = [0] * n
        prefix[0] = nums[0]
        for i in range(1, n):
            prefix[i] = prefix[i-1] + nums[i]
            
        # 后缀和数组
        suffix = [0] * n
        suffix[n-1] = nums[n-1]
        for i in range(n - 2, -1, -1):
            suffix[i] = suffix[i+1] + nums[i]
        
        ans = 0
        for i in range(n):
            if nums[i] == 0:
                # 左侧所有元素的和
                left_sum = prefix[i-1] if i > 0 else 0
                
                # 右侧所有元素的和
                right_sum = suffix[i+1] if i < n - 1 else 0
                
                # 左右两侧任务量完全相等
                # 向左或向右开始都能形成有效的路径
                if left_sum == right_sum:
                    ans += 2
                # 左右两侧任务量仅相差 1
                # 只有一个初始方向可以平衡掉这个微小的不对称性
                elif abs(right_sum - left_sum) == 1:
                    ans += 1
                    
        return ans
```

```Java
// java
class Solution {
    public int countValidSelections(int[] nums) {
        int n = nums.length;
        // 计算前缀和数组
        int[] prefixSum = new int[n];
        prefixSum[0] = nums[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i];
        }

        // 计算后缀和数组
        int[] suffixSum = new int[n];
        suffixSum[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffixSum[i] = suffixSum[i + 1] + nums[i];
        }

        int ans = 0;
        // 遍历数组，寻找所有值为 0 的潜在起点
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                // 左侧所有元素的和
                int leftSum = (i > 0) ? prefixSum[i - 1] : 0;

                // 右侧所有元素的和
                int rightSum = (i < n - 1) ? suffixSum[i + 1] : 0;

                // 左右两侧任务量完全相等
                // 向左或向右开始都能形成有效的路径
                if (leftSum == rightSum) {
                    ans += 2;
                // 左右两侧任务量仅相差 1
                // 只有一个初始方向可以平衡掉这个微小的不对称性
                } else if (Math.abs(rightSum - leftSum) == 1) {
                    ans += 1;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，三次线性遍历
- 空间复杂度： $O(n)$，表示前/后缀数组的大小

---

### 简化

对上面代码进行空间优化，无需长为 $n$ 的数组，只需要用一个滚动变量进行替换。

从左到右遍历时，左侧总和从 $0$ 开始不断累加 $nums[i]$，右侧总和从 $SUM$ 不断递减 $nums[i]$，因此分别只需要一个变量即可。

“前/后缀计算” 以及 “寻找起点” 两个过程合二为一，只需要两次遍历！

代码如下，已附加注释：

```Python
# python
class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        # 当前位置右侧的数字总和
        right_sum = sum(nums)
        # 当前位置左侧的数字总和
        left_sum = 0
        ans = 0
        
        for num in nums:
            if num > 0:
                left_sum += num
                right_sum -= num
            else:
                # 左右两侧任务量完全相等
                # 向左或向右开始都能形成有效的路径
                if left_sum == right_sum:
                    ans += 2
                # 左右两侧任务量仅相差 1
                # 只有一个初始方向可以平衡掉这个微小的不对称性
                elif abs(right_sum - left_sum) == 1:
                    ans += 1
                    
        return ans
```

```Java
// java
class Solution {
    public int countValidSelections(int[] nums) {
        // 当前处理元素右侧的数字总和
        int rightSum = 0;
        for (int num : nums) {
            rightSum += num;
        }
        // 当前处理元素左侧的数字总和
        int leftSum = 0;
        int ans = 0;
        
        for (int num : nums) {
            if (num > 0) {
                rightSum -= num;
                leftSum += num;
            } else {
                // 左右两侧任务量完全相等
                if (leftSum == rightSum) {
                    ans += 2;
                // 左右两侧任务量仅相差 1
                } else if (Math.abs(rightSum - leftSum) == 1) {
                    ans += 1;
                }
            }
        }
                    
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/make-array-elements-equal-to-zero/solutions/3817505/san-jie-mo-ni-qian-hou-zhui-fen-jie-jian-lg1u/)
