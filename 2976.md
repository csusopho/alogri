[Problem: 2976. 转换字符串的最小成本 I](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/description/)

### Dijkstra & Floyd

将字符 $x$ 转化为字符 $y$，可能需要多步完成！比如 $x\to a\to b\to\dots\to y$。因此，本题实际上是 **图论**，而不是简单的直接查询 $cost$。

将 $26$ 个小写英文字母看作图中的 **节点**。

- 给定的 $original$ 到 $changed$ 的转换可以看作图中的 **有向边**，边的权重就是转换成本 $cost$
- 从字符 $source[i]$ 变成 $target[i]$ 的最小成本，实际上就是在图中寻找从节点 $source[i]$ 到节点 $target[i]$ 的 **最短路径**

这里不是经典的单源最短路，但是可以看作 $26$ 个单独的源，每个节点分别寻找到其他节点的最短距离，这样我们就构建出了一个完整的 $26 \times 26$ 最短路径矩阵。

> 最短路问题，对应 $Dijkstra$ 算法。朴素/堆优化版本的原理及模版，请查看这篇 [题解](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/solutions/2848394/po-su-dijkstradui-you-hua-mo-ban-zhao-lu-ve92/)。

具体流程为：

- **建图**：遍历三个给定数组，构建邻接表 $graph[u] = [(v, w), ...]$
- **预计算**：遍历 $0$ 到 $25$（代表 $'a'$ 到 $'z'$）：
  - 以当前字符为起点 $start$ 运行 $Dijkstra$
  - 得到的 $minCosts$ 数组，即为从该字符变换到其他所有字符的最小成本
  - 将结果存入 $distMatrix$
- **计算总和**：遍历 $source$ 和 $target$，直接查 $distMatrix$ 累加成本

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        # 建图
        graph = defaultdict(list)
        for u, v, w in zip(original, changed, cost):
            # 将字符转换为 0-25 的整数索引
            graph[ord(u) - ord('a')].append((ord(v) - ord('a'), w))

        # 计算从 start_node 到所有其他节点的最小距离
        def dijkstra(start_node):
            # 初始化距离数组，默认为无穷大
            min_costs = [inf] * 26
            min_costs[start_node] = 0
            
            # 优先队列，存储 (当前累计成本, 当前节点)
            pq = [(0, start_node)]
            
            while pq:
                cur_cost, u = heapq.heappop(pq)
                
                # 已经计算过
                if cur_cost > min_costs[u]:
                    continue
                
                # 遍历邻居
                for v, weight in graph[u]:
                    new_cost = cur_cost + weight
                    # 如果找到了更短的路径，更新并入堆
                    if new_cost < min_costs[v]:
                        min_costs[v] = new_cost
                        heapq.heappush(pq, (new_cost, v))
            
            return min_costs

        # 预处理
        all_pairs_dist = []
        for i in range(26):
            all_pairs_dist.append(dijkstra(i))

        ans = 0
        n = len(source)
        
        for i in range(n):
            s_char = source[i]
            t_char = target[i]
            
            if s_char == t_char:
                continue
            
            u = ord(s_char) - ord('a')
            v = ord(t_char) - ord('a')
            
            # 直接取出
            cost_val = all_pairs_dist[u][v]
            # 无穷大，说明不可达
            if cost_val == inf:
                return -1
            # 累加
            ans += cost_val
            
        return ans
```

```Java
// java
class Solution {
    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {
        // 建图
        List<int[]>[] graph = new ArrayList[26];
        for (int i = 0; i < 26; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int i = 0; i < original.length; i++) {
            // 将字符转换为 0-25 的整数索引
            graph[original[i] - 'a'].add(new int[]{changed[i] - 'a', cost[i]});
        }

        // 预处理
        long[][] all_pairs_dist = new long[26][];
        for (int i = 0; i < 26; i++) {
            all_pairs_dist[i] = dijkstra(i, graph);
        }

        long ans = 0;
        int n = source.length();
        
        for (int i = 0; i < n; i++) {
            char s_char = source.charAt(i);
            char t_char = target.charAt(i);
            
            if (s_char == t_char) {
                continue;
            }
            
            int u = s_char - 'a';
            int v = t_char - 'a';
            
            // 直接取出
            long cost_val = all_pairs_dist[u][v];
            // 无穷大，说明不可达
            if (cost_val == Long.MAX_VALUE / 2) {
                return -1;
            }
            // 累加
            ans += cost_val;
        }
            
        return ans;
    }

    // 计算从 start_node 到所有其他节点的最小距离
    private long[] dijkstra(int start_node, List<int[]>[] graph) {
        long inf = Long.MAX_VALUE / 2;
        // 初始化距离数组，默认为无穷大
        long[] min_costs = new long[26];
        Arrays.fill(min_costs, inf);
        min_costs[start_node] = 0;
        
        // 优先队列，存储 (当前累计成本, 当前节点)
        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));
        pq.offer(new long[]{0, start_node});
        
        while (!pq.isEmpty()) {
            long[] pair = pq.poll();
            long cur_cost = pair[0];
            int u = (int) pair[1];
            
            // 已经计算过
            if (cur_cost > min_costs[u]) {
                continue;
            }
            
            // 遍历邻居
            for (int[] edge : graph[u]) {
                int v = edge[0];
                int weight = edge[1];
                long new_cost = cur_cost + weight;
                // 如果找到了更短的路径，更新并入堆
                if (new_cost < min_costs[v]) {
                    min_costs[v] = new_cost;
                    pq.offer(new long[]{new_cost, v});
                }
            }
        }
        
        return min_costs;
    }
}
```

- 时间复杂度： $O(n+ C\times m\times logm)$，其中 $n$ 是串 $source$ 的长度，而 $m$ 是数组 $original$ 的长度，且 $C=26$ 表示字符集大小，单次 $Dijkstra$ 接近 $O(mlogm)$
- 空间复杂度： $O(C^2+m)$，表示矩阵 $allDist$、邻接表 $graph$ 以及堆 $heapq$ 的大小

---

### $Floyd$

由于节点数量非常少，且是稠密图，我们可以使用 $Floyd$ 算法，具体原理看这篇 [题解](https://leetcode.cn/problems/network-delay-time/solutions/2999961/tu-lun-bfs-liang-chong-dijkstra-floyd-be-cfdv/)。

首先，建立一个 $26 \times 26$ 的距离矩阵 $dist$，其中 $dist[i][j]$ 表示从字符 $i$ 变到字符 $j$ 的最小成本。初始化 $dist[i][i] = 0$（自己到自己），而其他初始值为无穷大（表示不可达）。

遍历题目给出的三个数组，更新 $dist$ 矩阵。**注意**，输入可能包含多条相同的转换规则（例如 $a\to b$ 成本 $5$，且 $a\to b$ 成本 $2$），我们需要取最小值。

然后，使用 $Floyd$（本质是动规）计算最短路径：三层循环遍历所有中间节点 $k$，尝试通过 $k$ 来缩短 $i$ 到 $j$ 的距离，也即

$$
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
$$

最后，遍历字符串 $source$ 和 $target$ 的每一个位置，查表 $dist$，累加总成本。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        # dist[i][j] 表示从字符 i 转换到 j 的最小成本
        dist = [[inf] * 26 for _ in range(26)]
        
        # 自身转化
        for i in range(26):
            dist[i][i] = 0
        # 初始化
        for o, c, w in zip(original, changed, cost):
            u = ord(o) - ord('a')
            v = ord(c) - ord('a')
            # 存在多条相同的边，取成本最小的那条
            dist[u][v] = min(dist[u][v], w)
            
        # 计算所有字符对之间的最短路径
        # k 是中间节点，i 是起点，j 是终点
        for k in range(26):
            for i in range(26):
                # 没必要继续更新
                if dist[i][k] == inf:
                    continue
                for j in range(26):
                    # 通过中间点 k 能使路径更短，则更新
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
                    
        ans = 0
        n = len(source)
        
        for i in range(n):
            s_char = source[i]
            t_char = target[i]
            
            if s_char == t_char:
                continue
            
            u = ord(s_char) - ord('a')
            v = ord(t_char) - ord('a')

            # 直接取出
            cur_cost = dist[u][v]
            # 无穷大，说明不可达
            if cur_cost == inf:
                return -1
            # 累加
            ans += cur_cost
        
        return ans
```

```Java
// java
class Solution {
    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {
        long inf = Long.MAX_VALUE / 2;
        // dist[i][j] 表示从字符 i 转换到 j 的最小成本
        long[][] dist = new long[26][26];
        for (long[] row : dist) {
            Arrays.fill(row, inf);
        }
        
        // 自身转化
        for (int i = 0; i < 26; i++) {
            dist[i][i] = 0;
        }
        // 初始化
        for (int i = 0; i < original.length; i++) {
            int u = original[i] - 'a';
            int v = changed[i] - 'a';
            int w = cost[i];
            // 存在多条相同的边，取成本最小的那条
            dist[u][v] = Math.min(dist[u][v], (long) w);
        }
            
        // 计算所有字符对之间的最短路径
        // k 是中间节点，i 是起点，j 是终点
        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                // 没必要继续更新
                if (dist[i][k] == inf) {
                    continue;
                }
                for (int j = 0; j < 26; j++) {
                    // 通过中间点 k 能使路径更短，则更新
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
                    
        long ans = 0;
        int n = source.length();
        
        for (int i = 0; i < n; i++) {
            char s_char = source.charAt(i);
            char t_char = target.charAt(i);
            
            if (s_char == t_char) {
                continue;
            }
            
            int u = s_char - 'a';
            int v = t_char - 'a';

            // 直接取出
            long cur_cost = dist[u][v];
            // 无穷大，说明不可达
            if (cur_cost == inf) {
                return -1;
            }
            // 累加
            ans += cur_cost;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n+m+C^3)$，三重 $for$ 计算所有字符间的距离
- 空间复杂度： $O(C^2)$，表示矩阵 $dist$ 的大小

经实测，第一种 $Dijkstra$ 居然还更快，两种 $Python$ 代码耗时分别为 $355/363ms$，超过 $92\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/solutions/3891418/shuang-jie-zui-duan-lu-wen-ti-dijkstra-f-jqbv/)
