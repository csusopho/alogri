[Problem: 3408. 设计任务管理器](https://leetcode.cn/problems/design-task-manager/description/)

### 方法：模拟 & 二分 & 堆

题意比较清晰，这里不再赘述。可以发现，最重要的一个信息就是 $taskId$，它不会重复，永远唯一，因此将它作为解题的关键。

简单的 **思路**：使用哈希表 `(任务ID，用户ID&优先级)` 存储所有任务，然后按照题目要求，模拟整个操作流程。

代码如下，已附加详细注释：

```Python
# python
class TaskManager:
    def __init__(self, tasks):
        self.tasks = {}  # 使用字典来存储任务
        for userId, taskId, priority in tasks:
            self.tasks[taskId] = (userId, priority)
    
    def add(self, userId, taskId, priority):
        self.tasks[taskId] = (userId, priority)
    
    def edit(self, taskId, newPriority):
        if taskId in self.tasks:
            # 元组是不可变的
            # 所以我们需要获取旧的 userId 并创建一个新的元组
            userId = self.tasks[taskId][0]
            self.tasks[taskId] = (userId, newPriority)
    
    def rmv(self, taskId):
        if taskId in self.tasks:
            del self.tasks[taskId]
    
    def execTop(self):
        if not self.tasks:
            return -1

        # 寻找优先级最高且 taskId 最大的任务
        top_task_id = -1
        max_prior = -1
        
        # 遍历所有任务来找到目标任务
        for taskId, (userId, priority) in self.tasks.items():
            if priority > max_prior:
                max_prior = priority
                top_task_id = taskId
            elif priority == max_prior:
                if taskId > top_task_id:
                    top_task_id = taskId

        # 获取用户信息并删除任务
        target_id = self.tasks[top_task_id][0]
        del self.tasks[top_task_id]
        return target_id
```

假设向哈希中插入了 $n$ 个任务，最终要执行 $m$ 个任务。题目限定 $n,m$ 均在 $O(10^5)$ 量级，一次执行需要扫描所有 $O(n)$ 任务。因此超时，卡在 $660/663$ 样例。

---

### 手动维护

在一次执行 $exec$ 中，需要从头扫描所有任务，非常浪费时间！如果该 $tasks$ 已经排好序，那么第一个任务就是答案！

想让列表有序，要么手动维护这种降序关系，要么使用自动维护的数据结构。

手动维护的 **做法**：对于新插入/删除的元素，先查找它在列表中的正确位置，然后进行插入/修改，保证修改后列表依旧维持有序。

代码如下，已附加详细注释：

```Python
# python
class TaskManager:
    def __init__(self, tasks: list[list[int]]):
        # 首先按 priority 降序, 然后按 taskId 降序
        self.tasks = []
        for userId, taskId, priority in tasks:
            self.tasks.append([priority, taskId, userId])
        
        # 初始排序
        self.tasks.sort(reverse=True)

    def add(self, userId: int, taskId: int, priority: int) -> None:
        new_task = [priority, taskId, userId]
        # 线性查找第一个比 new_task 小的元素的位置
        idx = 0
        while idx < len(self.tasks) and self.tasks[idx] >= new_task:
            idx += 1
        # 插入
        self.tasks.insert(idx, new_task)

    def edit(self, taskId: int, newPriority: int) -> None:
        found_idx = -1
        userId = -1
        # 线性查找
        for i, task in enumerate(self.tasks):
            if task[1] == taskId:
                userId = task[2]
                found_idx = i
                break
        # 删除旧任务，加入新任务
        if found_idx != -1:
            self.tasks.pop(found_idx)
            self.add(userId, taskId, newPriority)

    def rmv(self, taskId: int) -> None:
        found_idx = -1
        # 线性查找
        for i, task in enumerate(self.tasks):
            if task[1] == taskId:
                found_idx = i
                break
        
        if found_idx != -1:  # 删除
            self.tasks.pop(found_idx)

    def execTop(self) -> int:
        if not self.tasks:
            return -1
        # 找到优先级最高的任务，然后删除
        top_task = self.tasks.pop(0)
        return top_task[2]
```

为了保证这种有序性，插入/删除前，我们会对 $tasks$ 进行线性扫描。与之前做法同理，仍然是 $O(n^2)$ 的量级，导致超时，卡在 $658/663$ 样例。

---

### 二分

在有序列表中寻找位置？联想到 **二分查找**。

具体原理不再阐述，这里直接调库进行二分。代码如下，已附加注释：

```Python
# python
class TaskManager:
    def __init__(self, tasks: list[list[int]]):
        self.task_map = {}
        # 这等价于按 [priority, taskId] 降序排序
        temp_list = []
        for userId, taskId, priority in tasks:
            task_item = [-priority, -taskId, userId]
            self.task_map[taskId] = task_item
            temp_list.append(task_item)

        temp_list.sort()  # 初始化排序
        self.tasks = temp_list

    def add(self, userId: int, taskId: int, priority: int) -> None:
        new_task = [-priority, -taskId, userId]
        # 二分找到位置并插入
        idx = bisect.bisect_left(self.tasks, new_task)
        self.tasks.insert(idx, new_task)
        # 更新哈希
        self.task_map[taskId] = new_task

    def edit(self, taskId: int, newPriority: int) -> None:
        # 删除旧任务
        old_task = self.task_map.pop(taskId)
        userId = old_task[2]
        # 在列表中的位置
        idx = bisect.bisect_left(self.tasks, old_task)
        # 从列表中移除
        self.tasks.pop(idx)
        # 添加新任务
        self.add(userId, taskId, newPriority)


    def rmv(self, taskId: int) -> None:
        # 找到任务
        task_to_remove = self.task_map.pop(taskId)
        # 二分查找在 tasks 中定位
        idx = bisect.bisect_left(self.tasks, task_to_remove)
        # 从列表中移除该元素
        if idx < len(self.tasks) and self.tasks[idx][1] == -taskId:
            self.tasks.pop(idx)


    def execTop(self) -> int:
        if not self.tasks:
            return -1
        
        # 优先级最高的任务
        top_task = self.tasks.pop(0)
        priority, taskId, userId = -top_task[0], -top_task[1], top_task[2]
        # 从哈希中移除
        del self.task_map[taskId]
        return userId
```

```Java
// java
// 为了更好地组织数据，我们创建一个 Task 类
class Task implements Comparable<Task> {
    int priority;
    int taskId;
    int userId;

    public Task(int priority, int taskId, int userId) {
        this.priority = priority;
        this.taskId = taskId;
        this.userId = userId;
    }

    // 自定义排序逻辑
    @Override
    public int compareTo(Task other) {
        if (this.priority != other.priority) {
            // 优先级降序
            return Integer.compare(other.priority, this.priority);
        } else {
            // taskId 降序
            return Integer.compare(other.taskId, this.taskId);
        }
    }

    // 重写 equals 和 hashCode 以便在集合中正确操作
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return priority == task.priority &&
               taskId == task.taskId &&
               userId == task.userId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(priority, taskId, userId);
    }
}

public class TaskManager {
    private Map<Integer, Task> taskMap;
    private List<Task> tasks;

    public TaskManager(List<List<Integer>> initialTasks) {
        taskMap = new HashMap<>();
        tasks = new ArrayList<>();

        for (List<Integer> taskInfo : initialTasks) {
            int userId = taskInfo.get(0);
            int taskId = taskInfo.get(1);
            int priority = taskInfo.get(2);
            Task taskItem = new Task(priority, taskId, userId);
            taskMap.put(taskId, taskItem);
            tasks.add(taskItem);
        }

        // 初始化排序
        Collections.sort(tasks);
    }

    public void add(int userId, int taskId, int priority) {
        Task newTask = new Task(priority, taskId, userId);
        // 二分找到位置并插入
        int idx = Collections.binarySearch(tasks, newTask);
        if (idx < 0) {
            idx = -(idx + 1);
        }
        tasks.add(idx, newTask);
        // 更新哈希
        taskMap.put(taskId, newTask);
    }

    public void edit(int taskId, int newPriority) {
        // 删除旧任务
        if (taskMap.containsKey(taskId)) {
            Task oldTask = taskMap.remove(taskId);
            int userId = oldTask.userId;
            // 从列表中移除
            tasks.remove(oldTask);
            // 添加新任务
            add(userId, taskId, newPriority);
        }
    }

    public void rmv(int taskId) {
        if (taskMap.containsKey(taskId)) {
            // 找到任务
            Task taskToRemove = taskMap.remove(taskId);
            // 从列表中移除该元素
            tasks.remove(taskToRemove);
        }
    }

    public int execTop() {
        if (tasks.isEmpty()) {
            return -1;
        }

        // 优先级最高的任务
        Task topTask = tasks.remove(0);
        // 从哈希中移除
        taskMap.remove(topTask.taskId);
        return topTask.userId;
    }
}
```

假设 $n$ 是列表 $tasks$ 的最大长度，它在 $O(10^5)$ 量级。

- 时间复杂度：
  - $init$ 函数： $O(T\times logT)$，其中 $T$ 为初始列表长度
  - $add$ 函数： $O(n)$，虽然查找时间为 $O(logn)$，但是插入会导致后续元素移动，最坏为 $O(n)$
  - $edit$ 函数： $O(n)$，同理
  - $rmv$ 函数： $O(n)$
  - $execTop$ 函数： $O(n)$
- 空间复杂度： $O(n)$，表示列表 $tasks$ 以及哈希 $taskMap$ 的大小

虽然时间很慢，但是空间消耗只有 $96.27M$，超过 $100\%$。

---

### 堆

我们也可以使用有序的数据结构（队列/堆）进行维护，从而快速寻找最大值。

不过，本题有个 **麻烦点**：函数 $edit$ 会修改下标处的值，会导致之前已经放在堆中的数据变为无效（错误）！

因此，我们使用 **懒删除** 的策略：

1. 在 $edit$ 以及 $rmv$ 操作时，不直接从堆中删除，而是用哈希标记
2. 在 $exec$ 时，检查任务是否还存在于哈希表中，对应 $rmv$ 删除操作
3. 检查哈希表中的优先级，是否与从堆中取出的优先级一致，对应 $edit$ 操作

**做法**：依旧使用一个哈希维护 “任务ID-用户ID&优先级”，使用一个最大堆存储 “任务-优先级”。在 $edit/rev$ 时不删除，在 $exec$ 时才真正删除。

代码如下，已附加详细注释：

```Python
# python
class TaskManager:
    def __init__(self, tasks):
        # 存储元组 (-priority, -taskId)，模拟最大堆
        self.heap = []
        # 哈希表，存储 taskId -> (userId, priority)
        self.task_map = {}

        for userId, taskId, priority in tasks:
            self.task_map[taskId] = (userId, priority)
            heapq.heappush(self.heap, (-priority, -taskId))
    
    def add(self, userId, taskId, priority):
        # 哈希中记录
        self.task_map[taskId] = (userId, priority)
        # 推入堆中
        heapq.heappush(self.heap, (-priority, -taskId))
    
    def edit(self, taskId, newPriority):
        if taskId in self.task_map:
            userId, _ = self.task_map[taskId]
            # 更新哈希表中的优先级
            self.task_map[taskId] = (userId, newPriority)
            # 将更新后的任务作为一个新条目推入堆
            # 旧的任务条目仍然留在堆中
            heapq.heappush(self.heap, (-newPriority, -taskId))
    
    def rmv(self, taskId):
        if taskId in self.task_map:
            # 懒删除：仅从哈希表中移除任务记录
            # 堆中对应的条目会保留
            del self.task_map[taskId]
    
    def execTop(self):
        while self.heap:
            # 弹出当前堆中优先级最高的任务
            priority, taskId = heapq.heappop(self.heap)
            # 恢复原始的 taskId 和 priority
            priority = -priority
            taskId = -taskId
            
            # --- 懒删除的核心检查 ---
            # 1. 检查任务是否还存在于哈希表中
            # 2. 检查优先级是否与一致
            if taskId in self.task_map and self.task_map[taskId][1] == priority:
                # 如果任务有效，则从哈希表中彻底删除
                userId, _ = self.task_map.pop(taskId)
                return userId
        
        # 如果堆为空，或者堆中全是无效任务，则返回 -1
        return -1
```

```Java
// java
public class TaskManager {
    // 存储最大堆，格式为：{priority, taskId}
    private PriorityQueue<int[]> heap;
    // 哈希表存储 taskId -> {userId, priority}
    private Map<Integer, int[]> taskMap;

    public TaskManager(List<List<Integer>> tasks) {
        // 1. 按 priority 降序
        // 2. 如果 priority 相同，则按 taskId 降序
        this.heap = new PriorityQueue<>((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(b[0], a[0]); // 比较 priority
            }
            return Integer.compare(b[1], a[1]);   // 比较 taskId
        });

        this.taskMap = new HashMap<>();

        for (List<Integer> task : tasks) {
            int userId = task.get(0);
            int taskId = task.get(1);
            int priority = task.get(2);
            
            this.taskMap.put(taskId, new int[]{userId, priority});
            this.heap.add(new int[]{priority, taskId});
        }
    }

    public void add(int userId, int taskId, int priority) {
        // 哈希中记录
        this.taskMap.put(taskId, new int[]{userId, priority});
        // 推入堆中
        this.heap.add(new int[]{priority, taskId});
    }

    public void edit(int taskId, int newPriority) {
        if (this.taskMap.containsKey(taskId)) {
            // 从哈希表中获取 userId
            int userId = this.taskMap.get(taskId)[0];
            // 更新哈希表中的优先级
            this.taskMap.put(taskId, new int[]{userId, newPriority});
            // 将更新后的任务作为一个新条目推入堆
            // 旧的任务条目仍然留在堆中（懒删除）
            this.heap.add(new int[]{newPriority, taskId});
        }
    }

    public void rmv(int taskId) {
        if (this.taskMap.containsKey(taskId)) {
            // 懒删除：仅从哈希表中移除任务记录
            // 堆中对应的条目会保留
            this.taskMap.remove(taskId);
        }
    }

    public int execTop() {
        while (!this.heap.isEmpty()) {
            // 弹出当前堆中优先级最高的任务
            int[] topTask = this.heap.poll();
            int priority = topTask[0];
            int taskId = topTask[1];

            // --- 懒删除的核心检查 ---
            // 1. 检查任务是否还存在于哈希表中
            if (!this.taskMap.containsKey(taskId)) {
                continue; // 任务已被 rmv 删除，跳过
            }
            
            // 2. 检查优先级是否与哈希表中的一致
            int[] currentInfo = this.taskMap.get(taskId);
            int currentPriority = currentInfo[1];

            if (currentPriority == priority) {
                // 如果任务有效，则从哈希表中彻底删除
                this.taskMap.remove(taskId);
                return currentInfo[0]; // 返回 userId
            }
            // 如果优先级不匹配，说明这是个旧的、已被 edit 修改过的任务，跳过
        }

        // 如果堆为空，或者堆中全是无效任务，则返回 -1
        return -1;
    }
}
```

- 时间复杂度：
  - $init$ 函数： $O(T\times logT)$，其中 $T$ 为初始列表长度
  - $add$ 函数： $O(logn)$，堆的调整为 $log$ 时间
  - $edit$ 函数： $O(logn)$
  - $rmv$ 函数： $O(1)$，只更新哈希
  - $execTop$ 函数：均摊后为 $O(logn)$，每个任务最多压入/弹出一次
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/design-task-manager/solutions/3785496/yi-bu-bu-tui-dao-mo-ni-shou-dong-wei-hu-6xcpw/)
