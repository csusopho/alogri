[Problem: 762. 二进制表示中质数个计算置位](https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/description/)

### 方法：模拟 & 位运算

题意很清晰，只需直观地分三步走：

1. 遍历 $[left, right]$ 区间
2. 计算每个数的二进制中 $1$ 的个数 $cnt$
3. 判断 $cnt$ 是否为质数

输入范围指定 $right \le 10^6$，由于 $10^6<2^{20}$，所以二进制位数最多只有 $20$ 位左右，所以质数集合非常小，可以直接列举。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        # 小范围内的质数集合
        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}
        
        res = 0
        for i in range(left, right + 1):
            # 计算当前数字 i 的二进制中 1 的个数
            count = bin(i).count('1')
            # 判断
            if count in primes:
                res += 1
        
        return res
```

```Java
// java
class Solution {
    public int countPrimeSetBits(int left, int right) {
        // 小范围内的质数集合
        java.util.Set<Integer> primes = java.util.Set.of(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
        
        int res = 0;
        for (int i = left; i <= right; i++) {
            // 计算当前数字 i 的二进制中 1 的个数
            int count = Integer.bitCount(i);
            // 判断
            if (primes.contains(count)) {
                res += 1;
            }
        }
        
        return res;
    }
}
```

将 $right-left$ 这个区间的长度记作 $D$，表示需要检查的数字个数。

- 时间复杂度： $O(D)$，主要时间用在 $for$ 循环上
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 位运算

因为 $2^{19} \approx 5.2 \times 10^5$ 且 $2^{20} \approx 1.04 \times 10^6$，所以 $1$ 的个数最多也就 $20$ 个，也即 $[0,19]$。这个范围内，质数一共有： $2, 3, 5, 7, 11, 13, 17, 19$。

在使用位运算前，我们先了解一些小技巧。

1）在计算机中，一个整数 $mask$ 可以被看作是一个由 $0$ 和 $1$ 组成的布尔数组。

- 如果想知道数字 $k$ 是否满足某些条件（比如是否为奇数），可以检查整数 $mask$ 的 **第 $k$ 位**（从右往左数，从 $0$ 开始）是否为 $1$。
- 比如数字 $4=100_{2}$，它的第 $0$ 位是 $0$，第 $2$ 位是 $1$，不是奇数。

2）如何提取第 $k$ 位的值呢？分为两步：

- $mask >> k$：将 $mask$ 向右移动 $k$ 位，这样原本在第 $k$ 位的数据就跑到了最低位（第 $0$ 位）。
- `& 1`：与 $1$ 进行 “按位与” 操作，只保留最低位的值，屏蔽掉其他高位。
- 如果第 $k$ 位是 $1$，那么运算结果结果为 $1$；否则为 $0$。

此时，构造一个整数 $mask$，使得它的第 $2、3、5、7\dots$ 位是 $1$，其他位是 $0$。

将所有质数位置代表的数值 **相加**，也即：

$$
mask = 2^2 + 2^3 + 2^5 + 2^7 + 2^{11} + 2^{13} + 2^{17} + 2^{19}
$$

求和后可知，这个数字为 $665772$，对应的二进制形式为：

$$
10100010100010101100
$$

从左往右看，第 $19$ 位是 $1$，第 $17$ 位是 $1$ ... 第 $2$ 位是 $1$，第 $0$ 和 $1$ 位是 $0$。

构造这个数字 **有什么用**？结合我们上面得知的位运算技巧，写出下面的代码：

$$
(665772 >> bin(x).count('1')) \& 1
$$

将它翻译成人话就是：

1. 算出 $x$ 有多少个 $1$，记为 $k$
2. 判断 $665772$ 的第 $k$ 位是否为 $1$
3. 因为 $665772$ 在质数位上全是 $1$，所以如果取出来是 $1$，说明 $k$ 是质数

总的来看，这种解法仅仅只是将 “是否在集合中” 变为 “是否相与为1”。

> 通常比 $Set$ 集合法 更快，因为位运算直接在 $CPU$ 寄存器层面完成，没有哈希计算、对象封装、函数调用栈进出等开销。

代码如下：

```Python
# python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        res = 0
        # 使用位操作和掩码判断
        for i in range(left, right + 1):
            res += (665772 >> bin(i).count('1')) & 1
        return res
```

```Java
// java
class Solution {
    public int countPrimeSetBits(int left, int right) {
        int res = 0;
        // 使用位操作和掩码判断
        for (int i = left; i <= right; i++) {
            res += (665772 >> Integer.bitCount(i)) & 1;
        }
        return res;
    }
}
```

- 时间复杂度： $O(D)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/solutions/3905801/shuang-jie-ji-shu-mo-ni-wei-yun-suan-jia-ke0m/)
