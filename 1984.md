[Problem: 1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/)

### 贪心

题目要求从 $n$ 个数中选 $k$ 个数，使得 $\text{max} - \text{min}$ 最小。
在数轴上，这意味着我们需要找到 $k$ 个点，这 $k$ 个点覆盖的区间长度（即跨度）最小。

为了让 $k$ 个数的差值最小，那这 $k$ 个数在数值上必须尽可能 **接近**。
在乱序数组中，数值接近的数可能分布在不同的位置。通过 **排序**，将数值接近的数在物理位置上聚拢在一起。

**结论**：最小差值一定是排序后数组中 “连续” $k$ 个元素的最大值与最小值的差。

即：将数组 $nums$ 从小到大排序，然后计算所有长度为 $k$ 的连续子数组中，首尾元素的差值，取其中的最小值即可。

$$
\text{result} = \min_{0 \le i \le n-k} ( \text{nums}[i+k-1] - \text{nums}[i] )
$$

---

为什么一定连续？

假设数组排序为 $A[0], A[1], ..., A[n-1]$，单调递增。

我们需要选择 $k$ 个下标 $i_1, i_2, ..., i_k$，对应的数值为 $A[i_1], A[i_2], ..., A[i_k]$。因为数组已排序，所以这组数的最小值为 $A[i_1]$，最大值为 $A[i_k]$（假设 $i_1 < i_2 < ... < i_k$）。此时差值为：

$$
\text{Diff} = A[i_k] - A[i_1]
$$

目标是让这个 $Diff$ 最小。

**反证法：** 假设我们选取的这 $k$ 个数在排序后的数组中 **不是连续** 的。也就是说，在下标 $i_1$ 和 $i_k$ 之间，存在某个下标 $j$ 没有被选中，且 $i_1 < j < i_k$。

为了满足选满 $k$ 个数的要求，必须去 $i_k$ 的右边或者 $i_1$ 的左边找其他的数来凑齐 $k$ 个。

- 如果往右找（选更大的数），最大值会变大（或不变），最小值不变，差值变大。
- 如果往左找（选更小的数），最小值会变小（或不变），最大值不变，差值变大。

**正面推导：** 如果我们确定了这 $k$ 个数中的最小值为 $A[i]$。为了让差值最小，希望最大值尽可能小。在数组递增的前提下，比 $A[i]$ 大且最小的 $k-1$ 个数，就是紧挨着 $A[i]$ 后面的那 $k-1$ 个数。

即： $A[i+1], A[i+2], ..., A[i+k-1]$。

此时最大值是 $A[i+k-1]$。如果跳过中间任何一个数去选 $A[i+k]$，那么最大值变成了 $A[i+k]$，显然 $A[i+k] \ge A[i+k-1]$，差值只会变大。

**结论：** 最优解一定是在排序后的数组中选取 **连续的** $k$ 个元素。

流程：排序，然后遍历每个长度为 $k$ 的窗口，计算最大-最小。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:  
        # 排序
        nums.sort()
        n = len(nums)
        # 初始化最小差值
        min_diff = nums[k-1] - nums[0]
        
        # 遍历所有连续 k 个数的窗口
        for i in range(1, n - k + 1):
            cur_diff = nums[i + k - 1] - nums[i]
            if cur_diff < min_diff:
                min_diff = cur_diff
        
        return min_diff
```

```Java
// java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        // 排序
        Arrays.sort(nums);
        int n = nums.length;
        // 初始化最小差值
        int minDiff = nums[k - 1] - nums[0];
        
        // 遍历所有连续 k 个数的窗口
        for (int i = 1; i <= n - k; i++) {
            int curDiff = nums[i + k - 1] - nums[i];
            if (curDiff < minDiff) {
                minDiff = curDiff;
            }
        }
        
        return minDiff;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度，快速排序
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solutions/3888441/tan-xin-pai-xu-zai-chang-du-wei-k-de-hua-o1x7/)
