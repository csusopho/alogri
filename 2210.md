[Problem: 2210. 统计数组中峰和谷的数量](https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/description/)

### 方法：暴力 & 去重 & 优化

注意，必须有上升和下降才叫峰/谷，比如 $[1,4,2]$；同时，相同数字不要重复计数，比如 $[1,4,4,4,2]$ 只有一个峰。

**暴力**：检查当前数字的左右两边，判断上升/下降，并跳过重复段。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n = len(nums)
        i = 1
        ans = 0

        while i < n - 1:
            # 找到当前连续段的右边界
            j = i
            while j + 1 < n and nums[j] == nums[j + 1]:
                j += 1

            # 找左侧最近不相等的元素
            left = i - 1
            while left >= 0 and nums[left] == nums[i]:
                left -= 1

            # 找右侧最近不相等的元素
            right = j + 1
            while right < n and nums[right] == nums[i]:
                right += 1

            # 判断是否为峰或谷
            if left >= 0 and right < n:
                if nums[i] > nums[left] and nums[i] > nums[right]:
                    ans += 1
                elif nums[i] < nums[left] and nums[i] < nums[right]:
                    ans += 1

            # 跳到当前连续段的后面一个位置
            i = j + 1

        return ans
```

```Java
// java
class Solution {
    public int countHillValley(int[] nums) {
        int n = nums.length;
        int i = 1;
        int ans = 0;

        while (i < n - 1) {
            // 找到当前连续段的右边界
            int j = i;
            while (j + 1 < n && nums[j] == nums[j + 1]) {
                j++;
            }

            // 找左侧最近不相等的元素
            int left = i - 1;
            while (left >= 0 && nums[left] == nums[i]) {
                left--;
            }

            // 找右侧最近不相等的元素
            int right = j + 1;
            while (right < n && nums[right] == nums[i]) {
                right++;
            }

            // 判断是否为峰或谷
            if (left >= 0 && right < n) {
                if (nums[i] > nums[left] && nums[i] > nums[right]) {
                    ans++;
                } else if (nums[i] < nums[left] && nums[i] < nums[right]) {
                    ans++;
                }
            }

            // 跳到当前连续段的后面一个位置
            i = j + 1;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $nums$ 的长度，最坏情况下每个元素都需要向左/右搜索 $O(n)$ 的距离
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 去重

左右指针去搜索，就是为了找到第一个不同的元素；当前元素也需要跳过相同位置。

萌生一个 **想法**：对 $nums$ 去重后，再进行统计，就只需要判断 `nums[i-1], nums[i], nums[i+1]` 这三者的关系即可！

开辟一个新数组存储去重后的数组，做法比较简单，这里不再展示。有没有原地达到去重的方法？有的兄弟，使用 **双指针** 就能做到。

指针 $i$ 在左边，将不重复的元素重新写入 $nums$；指针 $j$ 在右边，跳过重复的元素，只将不重复的元素传给 $i$。一前一后，就达成原地修改的目的。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n = len(nums)
        # 原地去除连续重复元素（双指针）
        write = 1  # write 指针指向下一个要写入的位置
        for read in range(1, n):
            if nums[read] != nums[read - 1]:
                nums[write] = nums[read]
                write += 1
        # 此时 nums[:write] 是去重后的有效部分

        # 统计峰谷
        ans = 0
        for i in range(1, write - 1):
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                ans += 1  # 峰
            elif nums[i] < nums[i - 1] and nums[i] < nums[i + 1]:
                ans += 1  # 谷

        return ans
```

```Java
// java
class Solution {
    public int countHillValley(int[] nums) {
        int n = nums.length;

        // 原地去除连续重复元素（双指针）
        int write = 1;  // write 指针指向下一个要写入的位置
        for (int read = 1; read < n; read++) {
            if (nums[read] != nums[read - 1]) {
                nums[write] = nums[read];
                write++;
            }
        }
        // 此时 nums[0...write-1] 是去重后的有效部分

        // 统计峰谷
        int ans = 0;
        for (int i = 1; i < write - 1; i++) {
            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {
                ans++;  // 峰
            } else if (nums[i] < nums[i - 1] && nums[i] < nums[i + 1]) {
                ans++;  // 谷
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，两次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

不去重，能不能做到 $O(n)$ 逻辑？当然可以。

对于当前 $nums[i]$ 来说，我们本质上只关心 “前一个不同元素”、“后一个不同元素” 两者，也即三元组 `(前，中，后)`。

不去重的情况下，前一个不同元素很容易得知，毕竟我们是从前往后遍历，只需要使用变量 $prev$ 记录不同元素即可。

后一个不同元素怎么找？不用指针/提前去重就没办法？那就不找了！我们 **转化思路**，只考虑三元组 `(前前，前，自己)`。

题目已经指明，边界元素 $nums[n-1]$ 不能作为峰/谷，因为两边没有元素了，所以这种 **延迟判断** 无需担忧缺漏方案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        prev_prev = -1  # 上上个不同的元素
        prev = nums[0]

        for i in range(1, n):
            curr = nums[i]
            if curr == prev:
                continue  # 跳过重复元素

            if prev_prev > 0:
                if prev > prev_prev and prev > curr:
                    ans += 1  # 峰
                elif prev < prev_prev and prev < curr:
                    ans += 1  # 谷

            prev_prev = prev   # 更新
            prev = curr

        return ans
```

```Java
// java
class Solution {
    public int countHillValley(int[] nums) {
        int n = nums.length;
        int ans = 0;
        int prevPrev = -1;  // 上上个不同的元素
        int prev = nums[0];

        for (int i = 1; i < n; i++) {
            int curr = nums[i];
            if (curr == prev) {
                continue;  // 跳过重复元素
            }

            if (prevPrev != -1) {
                if (prev > prevPrev && prev > curr) {
                    ans++;  // 峰
                } else if (prev < prevPrev && prev < curr) {
                    ans++;  // 谷
                }
            }

            // 更新
            prevPrev = prev;
            prev = curr;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，一次遍历
- 空间复杂度： $O(1)$

---

难道真的不能判断 `(前，中，后)` 吗？可以利用上面 **去重** 的逻辑，将 “上一个不同元素” 永远放在 $i-1$ 位置。

那么，当前的重复段跳过，则 $nums[i+1]$ 与 $nums[i]$ 不重复，是不同元素；且 $nums[i-1]$ 一直被前面不同元素覆盖，三元组 $(i-1,i,i+1)$ 就互不相同。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0

        for i in range(1, n - 1):
            # 峰
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                ans += 1
            # 谷
            elif nums[i] < nums[i - 1] and nums[i] < nums[i + 1]:
                ans += 1
            # 把当前值设为左边不同的值，并跳过一次重复
            elif nums[i] == nums[i + 1]:
                nums[i] = nums[i - 1]

        return ans
```

```Java
// java
class Solution {
    public int countHillValley(int[] nums) {
        int n = nums.length;
        int ans = 0;

        for (int i = 1; i < n - 1; i++) {
            // 峰
            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {
                ans++;
            }
            // 谷
            else if (nums[i] < nums[i - 1] && nums[i] < nums[i + 1]) {
                ans++;
            }
            // 把当前值设为左边不同的值，并跳过一次重复
            else if (nums[i] == nums[i + 1]) {
                nums[i] = nums[i - 1];
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，同理
- 空间复杂度： $O(1)$

---

### 差值

这种方法还是 `(前前，前，自己)` 的逻辑，只不过将峰/谷的判断，换为了 **差值的乘积**：如果上升，则相邻的差值 $>0$；反之下降，则相邻的差值 $<0$。

这种方法比较巧妙，所以单独写出来。代码如下，已附加注释：

```Python
# python
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        prev_diff = 0  # 上一个非零差值

        for i in range(1, n):
            diff = nums[i] - nums[i - 1]
            if diff == 0:
                continue  # 跳过平地，不改变方向
            if prev_diff * diff < 0:
                ans += 1  # 出现方向转折，即是峰或谷
            prev_diff = diff  # 更新方向

        return ans
```

```Java
// java
class Solution {
    public int countHillValley(int[] nums) {
        int n = nums.length;
        int ans = 0;
        int prevDiff = 0;  // 上一个非零差值

        for (int i = 1; i < n; i++) {
            int diff = nums[i] - nums[i - 1];
            if (diff == 0) {
                continue;  // 跳过平地，不改变方向
            }
            if (prevDiff * diff < 0) {
                ans++;  // 出现方向转折，即是峰或谷
            }
            prevDiff = diff;  // 更新方向
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solutions/3734806/wu-jie-bao-li-yuan-di-qu-zhong-yi-ci-bia-gct6/)
