[Problem: 3542. 将所有元素变为 0 的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/description/)

### 方法：贪心+单调栈

每次操作，都是将数组的最小元素变为 $0$，比如子数组 $[1,2,1]$ 变化后是 $[0,2,0]$。也即，子数组中不能存在 $0$，否则相当于没有变化。

将 $0$ 看作 **分隔符**，可以写出如下的 **暴力** 代码：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        if all(x == 0 for x in nums):
            return 0

        while True:
            # 寻找第一个非零块的开始
            i = 0
            while i < n and nums[i] == 0:
                i += 1
            
            # 找不到非零元素
            if i == n:
                break
            
            # 记录本次操作
            ans += 1
            
            # 寻找这个非零块的结束
            j = i
            while j + 1 < n and nums[j + 1] != 0:
                j += 1
            
            # 在这个块 nums[i...j] 中找到最小值
            min_val = float('inf')
            for k in range(i, j + 1):
                if nums[k] < min_val:
                    min_val = nums[k]
            
            # 执行操作：将块中所有等于最小值的地方设为 0
            for k in range(i, j + 1):
                if nums[k] == min_val:
                    nums[k] = 0
                    
        return ans
```

最坏情况下，每个位置都需要搜索一整轮 $nums$，复杂度为 $O(n^2)$。题目限定 $n\leq 10^5$，所以 **会超时**。至于分治递归的写法，是同样复杂度，这里不再展示。

如何优化？

想要消除一个数字 $k$，它必须在某个操作中成为子数组的 **最小值**。之后，再处理所有比 $k$ 大的数，这天然地形成了一种从小数到大数逐层消除的依赖关系。

因此，我们得出一个贪心策略：**总是先处理局部范围内最小的数字**。

那么，当前数字 $x$ 是哪个块内的最小数字？可以用树状数组求子数组最小，但是本题最好利用贪心结论，所以使用 **单调栈**。具体的原理/模版，请看这篇 [题解](https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/solutions/2875204/chi-xian-cha-xun-zui-xiao-dui-dan-diao-z-pbsq/)。

本题的 **核心思路**：识别出 “**必须开启新操作的那个点**”。

首先，使用单调栈预处理，得到每个数字 $nums[i]$ 左侧第一个比它小的元素索引 $j$。那么，子数组 $[j+1,i]$ 内的最小值就是 $nums[i]$，能看作一块。

如何构建这个索引数组 $indices$？单调递增栈，从右往左遍历。一旦当前元素 $nums[i]$ 比栈顶元素更小，就说明它是栈顶元素的左侧 “第一个” 更小元素。

然后，在主循环内，从左到右遍历，使用一个哈希表 $lookup$，它用来记录每个值上一次出现的位置。且 $indices[i]$ 是当前 $num$ 的 “左侧屏障” 的位置。

1. 如果当前数字 $num$ 没有记录过：说明第一次遇到 $num$ 这个值。任何一个数值第一次出现，都必然需要一次新的操作来消除它，因为它必须在某个时刻成为某个子数组的最小值。
2. 如果 $lookup[num] < indices[i]$，说明上一个 $num$ 和当前的 $num$ 被一个更小的数（位于 $indices[i]$）**隔开了**。那么，能够消除上一个 $num$ 的那次操作，由于被 $indices[i]$ 切断，它无法接触到当前的 $num$。所以，当前的 $num$ 必须由一次新的操作来负责。

反之，如果 $lookup[num] >= indices[i]$，说明从上一个 $num$ 到当前这个 $num$ 的路径上，没有出现比 $num$ 更小的数。这意味着它们处在同一个 “山谷” 或 “平台” 上，可以被同一次操作（即以 $num$ 为最小值的操作）一并消除，不需要额外操作。

**总结**：两次遍历，识别出因数值大小关系而产生的 “必须独立处理” 的块。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        # 找到左边第一个比当前元素小的元素
        st = []
        # 表示 nums[i] 左边第一个比它小的元素的索引
        indices = [-1] * n

        # 从右向左扫描，用单调递增栈构造每个元素的“左侧边界”
        for i in range(n - 1, -1, -1):
            # 当前元素比栈顶元素小，说明它是栈顶元素的“左边第一个更小的数”
            while st and nums[i] < nums[st[-1]]:
                index = st.pop()
                indices[index] = i
            st.append(i)  # 压入栈，等待处理

        ans = 0
        lookup = {}  # 存储每个值上一次出现的位置

        # 判断是否需要一个“新的操作”将其归零
        for i, num in enumerate(nums):
            if num != 0:
                # 出现 “上坡” 或 “下坡”，不能被同步消除，需要新操作
                if num not in lookup or lookup[num] < indices[i]:
                    ans += 1
            lookup[num] = i  # 最后出现位置

        return ans
```

```Java
// java
class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        // 找到左边第一个比当前元素小的元素
        Deque<Integer> st = new ArrayDeque<>();
        // 表示 nums[i] 左边第一个比它小的元素的索引
        int[] indices = new int[n];
        Arrays.fill(indices, -1);

        // 从右向左扫描，用单调递增栈构造每个元素的“左侧边界”
        for (int i = n - 1; i >= 0; i--) {
            // 当前元素比栈顶元素小，说明它是栈顶元素的“左边第一个更小的数”
            while (!st.isEmpty() && nums[i] < nums[(st.peek())]) {
                int index = st.pop();
                indices[index] = i;
            }
            st.push(i); // 压入栈，等待处理
        }

        int ans = 0;
        Map<Integer, Integer> lookup = new HashMap<>(); // 存储每个值上一次出现的位置

        // 判断是否需要一个“新的操作”将其归零
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num != 0) {
                // 出现 “上坡” 或 “下坡”，不能被同步消除，需要新操作
                if (!lookup.containsKey(num) || lookup.get(num) < indices[i]) {
                    ans++;
                }
            }
            lookup.put(num, i); // 最后出现位置
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示栈 $st$ 以及数组 $indices$ 的大小

---

### 整合

实际上，我们可以在出/入栈的同时，判断是否需要新增操作次数。

同理，还是维护一个单调 **递增** 栈，且从左到右遍历：

- 当前 $x$ 比栈顶更大时，说明出现一个 “上坡”。在消除栈顶元素后，这个更大的数 $x$ 才能被处理，因此它需要一次新的操作。将 $x$ 入栈，并计入一次操作。
- 当前 $x$ 比栈顶更小时，说明出现一个 “下坡”。这破坏了原来的递增序列。这个更小的数 $x$ 必须在栈内所有比它大的数之前被消除。这标志着之前 “上坡” 过程的终结，和一个必须优先处理的新过程的开始。将栈中所有大于 $x$ 的元素弹出，因为它们所在的 “上坡” 已经被 $x$ 从中间 “截断” 了，这同样需要一次新的操作。
- 当前数 $x$ 和栈顶相等时，说明它可以和栈顶元素在同一次操作中被消除，不需要额外增加操作次数。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        st = []

        for x in nums:
            # 之前的非零块已经结束
            if x == 0:
                st = []
                continue

            # 栈不空，且小于栈顶元素，遇到了“下坡”
            # 栈顶那些更大的元素所代表的操作序列被中断，必须先处理 x
            while st and st[-1] > x:
                st.pop()
            
            # 如果栈为空，说明这是一个新块的开始
            # 大于栈顶元素，说明是一个“上坡”的新台阶
            if not st or st[-1] < x:
                ans += 1
                st.append(x)
                
        return ans
```

```Java
// java
class Solution {
    public int minOperations(int[] nums) {
        int ans = 0;
        Deque<Integer> st = new ArrayDeque<>();

        for (int x : nums) {
            // 之前的非零块已经结束
            if (x == 0) {
                st.clear();
                continue;
            }

            // 栈不空，且小于栈顶元素，遇到了“下坡”
            // 栈顶那些更大的元素所代表的操作序列被中断，必须先处理 x
            while (!st.isEmpty() && st.peek() > x) {
                st.pop();
            }

            // 如果栈为空，说明这是一个新块的开始
            // 大于栈顶元素，说明是一个“上坡”的新台阶
            if (st.isEmpty() || st.peek() < x) {
                ans++;
                st.push(x);
            }
        }
        return ans;
    }
}
```

如果我们预先将 $-1$ 压入栈，则栈永不为空。同时，压栈时不再累计操作次数，遇到 $0$ 不予理会，最后累加一次即可。

```Python
# python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        # 单调递增栈，栈底元素是 -1，便于比较
        st = [-1]
        ans = 0

        for num in nums:
            # 当前数字小于栈顶，遇到了 “下坡”，破坏递增序列
            while st[-1] > num:
                ans += 1
                st.pop()

            # 不为0，且不同于栈顶，才压栈（避免重复）
            # 比栈顶大的新值，是 “上坡” 的新台阶，压入等待处理
            if num != 0 and st[-1] != num:
                st.append(num)

        # 栈内每个不同值需要一次操作
        return ans + len(st) - 1
```

```Java
// java
class Solution {
    public int minOperations(int[] nums) {
        // 单调递增栈，栈底元素是 -1，便于比较
        Deque<Integer> st = new ArrayDeque<>();
        st.push(-1);
        int ans = 0;

        for (int num : nums) {
            // 当前数字小于栈顶，遇到了 “下坡”，破坏递增序列
            while (st.peek() > num) {
                ans++;
                st.pop();
            }

            // 不为0，且不同于栈顶，才压栈（避免重复）
            // 比栈顶大的新值，是 “上坡” 的新台阶，压入等待处理
            if (num != 0 && st.peek() != num) {
                st.push(num);
            }
        }
        
        // 栈内每个不同值需要一次操作
        return ans + st.size() - 1;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/solutions/3827831/shuang-jie-tan-xin-dan-diao-zhan-liang-y-1xn7/)
