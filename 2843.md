[Problem: 2843. 统计对称整数的数目](https://leetcode.cn/problems/count-symmetric-integers/description/)

### 方法：暴力 & 预处理 & 打表

对称整数：前半的 $n$ 位数字和 = 后半的 $n$ 位数字和。

那么，如何判断一个数字是对称整数呢？

- 将它变为字符串，然后截取前半与后半，判断它们的数位和是否相同；
- 将整除 $/$ 与取余 % 结合，从而遍历每个数位，累加判断。

~~我比较懒~~，前一种方法放在 $Python$ 代码中，后一种放在 $Java$ 代码中。

**暴力** 想法：遍历区间 $[low,high]$ 内的所有整数，判断是否“对称”后进行计数。

代码如下，勉强能够通过：

```Python
# python
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        ans = 0
        for num in range(low, high + 1):
            s = str(num)
            n = len(s)
            # 数字的位数必须是偶数
            if n % 2 != 0:
                continue
            n = n // 2
            first_half = s[:n]
            second_half = s[n:]
            sum_first = sum(int(d) for d in first_half)
            sum_second = sum(int(d) for d in second_half)
            if sum_first == sum_second:
                ans += 1
        return ans
```

```Java
// java
class Solution {
    public int countSymmetricIntegers(int low, int high) {
        int count = 0;
        for (int num = low; num <= high; num++) {
            int temp = num, digits = 0;
            // 计算数字的位数
            while (temp > 0) {
                temp /= 10;
                digits++;
            }
            // 位数不是偶数则跳过
            if (digits % 2 != 0) continue;
            int half = digits / 2;
            int firstHalfSum = 0, secondHalfSum = 0;
            temp = num;
            // 计算后半部分的数字和
            for (int i = 0; i < half; i++) {
                secondHalfSum += temp % 10;
                temp /= 10;
            }
            // 计算前半部分的数字和
            for (int i = 0; i < half; i++) {
                firstHalfSum += temp % 10;
                temp /= 10;
            }
            // 比较前后半部分的数字和
            if (firstHalfSum == secondHalfSum) count++;
        }
        return count;
    }
}
```

- 时间复杂度： $O(d)$，其中 $d$ 表示整数个数，即 $d=high-low+1$
- 空间复杂度： $O(1)$，仅用常数个额外变量

---

### 预处理

本题给的数字范围是 $[1,10^4]$，在这个范围内，对称整数的数量有限，才 $624$ 个。所以，完全没必要实时计算，可以提前进行 **预处理**。

也即，在类外提前计算出所有对称整数，然后判断 $[low,high]$ 内有几个。如何计数？

- 简单思考，就是遍历这 $d$ 个数，判断它们是否在预处理的列表中；
- 转化思维，分别搜索小于 $low$ 和小于等于 $high$ 的对称整数有几个，相减即可。

后面这种思路，用符号表示为 $[low,high]=[0,high]-[0,low)$。为了统一函数，后者可以变为 $[0,low-1]$，这样 **二分** 搜索的就是“小于等于目标”的值。

为什么可以二分？有序。如何二分？调库或者手写。

代码如下，已附加注释：

```Python
# python
# 预生成1~10000的所有对称整数
SYMMETRIC_NUMS = []
for num in range(1, 10001):
    s = str(num)
    length = len(s)
    if length % 2 == 0:  # 偶数位
        n = length // 2
        first_half = s[:n]
        second_half = s[n:]
        if sum(int(d) for d in first_half) == sum(int(d) for d in second_half):
            SYMMETRIC_NUMS.append(num)

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        # 使用二分查找确定 low 和 high 的边界
        left = bisect_left(SYMMETRIC_NUMS, low)
        right = bisect_right(SYMMETRIC_NUMS, high)
        return right - left
```

```Java
// java
class Solution {
    // 预生成1~10000的所有对称整数
    private static final List<Integer> SYMMETRIC_NUMS = new ArrayList<>();
    
    static {
        for (int num = 1; num <= 10000; num++) {
            int temp = num, digits = 0;
            // 计算数字的位数
            while (temp > 0) {
                temp /= 10;
                digits++;
            }
            // 位数不是偶数则跳过
            if (digits % 2 != 0) continue;
            
            int half = digits / 2;
            int firstHalfSum = 0, secondHalfSum = 0;
            temp = num;
            // 计算后半部分的数字和
            for (int i = 0; i < half; i++) {
                secondHalfSum += temp % 10;
                temp /= 10;
            }
            // 计算前半部分的数字和
            for (int i = 0; i < half; i++) {
                firstHalfSum += temp % 10;
                temp /= 10;
            }
            // 如果是对称整数则加入列表
            if (firstHalfSum == secondHalfSum) {
                SYMMETRIC_NUMS.add(num);
            }
        }
    }
    
    public int countSymmetricIntegers(int low, int high) {
        // 使用二分查找确定边界
        int left = Collections.binarySearch(SYMMETRIC_NUMS, low);
        if (left < 0) left = -left - 1;
        
        int right = Collections.binarySearch(SYMMETRIC_NUMS, high);
        if (right < 0) right = -right - 2;
        
        return right - left + 1;
    }
}
```

一种比较优雅，且不使用二分的写法：

```Python
# python
SYMMETRIC_NUMS = [False] * 10001
for i in range(11, 100, 11):
    SYMMETRIC_NUMS[i] = True
for i in range(1000, 10000):
    if i % 10 + (i // 10 % 10) == i // 1000 + (i // 100 % 10):
        SYMMETRIC_NUMS[i] = True

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        return sum(SYMMETRIC_NUMS[low:high + 1])
```

```Java
// java
class Solution {
    // 预生成1~10000的对称数标记数组
    private static final boolean[] SYMMETRIC_FLAGS = new boolean[10001];
    
    static {
        // 标记11~99的对称数（11的倍数）
        for (int i = 11; i < 100; i += 11) {
            SYMMETRIC_FLAGS[i] = true;
        }
        // 标记1000~9999的对称数
        for (int i = 1000; i < 10000; i++) {
            int firstTwo = i / 100;
            int lastTwo = i % 100;
            if (firstTwo / 10 + firstTwo % 10 == lastTwo / 10 + lastTwo % 10) {
                SYMMETRIC_FLAGS[i] = true;
            }
        }
    }
    
    public int countSymmetricIntegers(int low, int high) {
        int count = 0;
        for (int i = low; i <= high; i++) {
            if (SYMMETRIC_FLAGS[i]) {
                count++;
            }
        }
        return count;
    }
}
```

注意，这种方法比较慢，因为主体函数还需要遍历求和，时间是 $O(d)$，而二分的时间是 $O(logU)$，其中 $U$ 是预处理列表的长度。

实际测试下来，前者的 $Python$ 代码耗时 $11ms$，后者耗时 $0ms$。

当然，我们可以重温一下二分的写法，本题只需要使用 **闭区间** 二分，去寻找 “小于等于目标” 的个数：

```Python
# python
def search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid - 1
    return right
```

如果你想寻找 “小于目标” 的个数，那就是左闭右开写法：

```Python
# python
def search(arr, target):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left
```

将这段代码替换库函数的部分，这里我不再展示，感兴趣的小伙伴自行尝试。

- 时间复杂度：遍历的是 $O(d)$，求和的是 $O(logU)$，预处理时间被均摊
- 空间复杂度： $O(1)$，预处理空间被均摊

---

### 打表

上面是在运行时自动打表，我们也可以自行手动打表，数据量并不大。

为什么我们要在类外进行打表，而不是函数内？因为力扣平台是多次调用 $count$ 方法跑所有样例，所以预处理中的内容只会计算一次。

如果放在函数内， $Python$ 代码耗时 $12ms$，放在类外 $0ms$。代码如下：

```Python
# python
symmetric_nums = [
    11, 22, 33, 44, 55, 66, 77, 88, 99, 1001, 1010, 1102, 1111, 1120, 1203, 1212, 1221, 1230, 
    1304, 1313, 1322, 1331, 1340, 1405, 1414, 1423, 1432, 1441, 1450, 1506, 1515, 1524, 1533, 
    1542, 1551, 1560, 1607, 1616, 1625, 1634, 1643, 1652, 1661, 1670, 1708, 1717, 1726, 1735, 
    1744, 1753, 1762, 1771, 1780, 1809, 1818, 1827, 1836, 1845, 1854, 1863, 1872, 1881, 1890, 
    1919, 1928, 1937, 1946, 1955, 1964, 1973, 1982, 1991, 2002, 2011, 2020, 2103, 2112, 2121, 
    2130, 2204, 2213, 2222, 2231, 2240, 2305, 2314, 2323, 2332, 2341, 2350, 2406, 2415, 2424, 
    2433, 2442, 2451, 2460, 2507, 2516, 2525, 2534, 2543, 2552, 2561, 2570, 2608, 2617, 2626, 
    2635, 2644, 2653, 2662, 2671, 2680, 2709, 2718, 2727, 2736, 2745, 2754, 2763, 2772, 2781, 
    2790, 2819, 2828, 2837, 2846, 2855, 2864, 2873, 2882, 2891, 2929, 2938, 2947, 2956, 2965, 
    2974, 2983, 2992, 3003, 3012, 3021, 3030, 3104, 3113, 3122, 3131, 3140, 3205, 3214, 3223, 
    3232, 3241, 3250, 3306, 3315, 3324, 3333, 3342, 3351, 3360, 3407, 3416, 3425, 3434, 3443, 
    3452, 3461, 3470, 3508, 3517, 3526, 3535, 3544, 3553, 3562, 3571, 3580, 3609, 3618, 3627, 
    3636, 3645, 3654, 3663, 3672, 3681, 3690, 3719, 3728, 3737, 3746, 3755, 3764, 3773, 3782, 
    3791, 3829, 3838, 3847, 3856, 3865, 3874, 3883, 3892, 3939, 3948, 3957, 3966, 3975, 3984, 
    3993, 4004, 4013, 4022, 4031, 4040, 4105, 4114, 4123, 4132, 4141, 4150, 4206, 4215, 4224, 
    4233, 4242, 4251, 4260, 4307, 4316, 4325, 4334, 4343, 4352, 4361, 4370, 4408, 4417, 4426, 
    4435, 4444, 4453, 4462, 4471, 4480, 4509, 4518, 4527, 4536, 4545, 4554, 4563, 4572, 4581, 
    4590, 4619, 4628, 4637, 4646, 4655, 4664, 4673, 4682, 4691, 4729, 4738, 4747, 4756, 4765, 
    4774, 4783, 4792, 4839, 4848, 4857, 4866, 4875, 4884, 4893, 4949, 4958, 4967, 4976, 4985, 
    4994, 5005, 5014, 5023, 5032, 5041, 5050, 5106, 5115, 5124, 5133, 5142, 5151, 5160, 5207, 
    5216, 5225, 5234, 5243, 5252, 5261, 5270, 5308, 5317, 5326, 5335, 5344, 5353, 5362, 5371, 
    5380, 5409, 5418, 5427, 5436, 5445, 5454, 5463, 5472, 5481, 5490, 5519, 5528, 5537, 5546, 
    5555, 5564, 5573, 5582, 5591, 5629, 5638, 5647, 5656, 5665, 5674, 5683, 5692, 5739, 5748, 
    5757, 5766, 5775, 5784, 5793, 5849, 5858, 5867, 5876, 5885, 5894, 5959, 5968, 5977, 5986, 
    5995, 6006, 6015, 6024, 6033, 6042, 6051, 6060, 6107, 6116, 6125, 6134, 6143, 6152, 6161, 
    6170, 6208, 6217, 6226, 6235, 6244, 6253, 6262, 6271, 6280, 6309, 6318, 6327, 6336, 6345, 
    6354, 6363, 6372, 6381, 6390, 6419, 6428, 6437, 6446, 6455, 6464, 6473, 6482, 6491, 6529, 
    6538, 6547, 6556, 6565, 6574, 6583, 6592, 6639, 6648, 6657, 6666, 6675, 6684, 6693, 6749, 
    6758, 6767, 6776, 6785, 6794, 6859, 6868, 6877, 6886, 6895, 6969, 6978, 6987, 6996, 7007, 
    7016, 7025, 7034, 7043, 7052, 7061, 7070, 7108, 7117, 7126, 7135, 7144, 7153, 7162, 7171, 
    7180, 7209, 7218, 7227, 7236, 7245, 7254, 7263, 7272, 7281, 7290, 7319, 7328, 7337, 7346, 
    7355, 7364, 7373, 7382, 7391, 7429, 7438, 7447, 7456, 7465, 7474, 7483, 7492, 7539, 7548, 
    7557, 7566, 7575, 7584, 7593, 7649, 7658, 7667, 7676, 7685, 7694, 7759, 7768, 7777, 7786, 
    7795, 7869, 7878, 7887, 7896, 7979, 7988, 7997, 8008, 8017, 8026, 8035, 8044, 8053, 8062, 
    8071, 8080, 8109, 8118, 8127, 8136, 8145, 8154, 8163, 8172, 8181, 8190, 8219, 8228, 8237, 
    8246, 8255, 8264, 8273, 8282, 8291, 8329, 8338, 8347, 8356, 8365, 8374, 8383, 8392, 8439, 
    8448, 8457, 8466, 8475, 8484, 8493, 8549, 8558, 8567, 8576, 8585, 8594, 8659, 8668, 8677, 
    8686, 8695, 8769, 8778, 8787, 8796, 8879, 8888, 8897, 8989, 8998, 9009, 9018, 9027, 9036, 
    9045, 9054, 9063, 9072, 9081, 9090, 9119, 9128, 9137, 9146, 9155, 9164, 9173, 9182, 9191, 
    9229, 9238, 9247, 9256, 9265, 9274, 9283, 9292, 9339, 9348, 9357, 9366, 9375, 9384, 9393, 
    9449, 9458, 9467, 9476, 9485, 9494, 9559, 9568, 9577, 9586, 9595, 9669, 9678, 9687, 9696, 
    9779, 9788, 9797, 9889, 9898, 9999
]

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        left = bisect_left(symmetric_nums, low)
        right = bisect_right(symmetric_nums, high)
        return right - left
```

```Java
// java
class Solution {
    // 预生成1~10000的对称数标记数组
    private static final List<Integer> SYMMETRIC_NUMS = Arrays.asList(
        11, 22, 33, 44, 55, 66, 77, 88, 99, 1001, 1010, 1102, 1111, 1120, 1203, 1212, 1221, 1230, 
        1304, 1313, 1322, 1331, 1340, 1405, 1414, 1423, 1432, 1441, 1450, 1506, 1515, 1524, 1533, 
        1542, 1551, 1560, 1607, 1616, 1625, 1634, 1643, 1652, 1661, 1670, 1708, 1717, 1726, 1735, 
        1744, 1753, 1762, 1771, 1780, 1809, 1818, 1827, 1836, 1845, 1854, 1863, 1872, 1881, 1890, 
        1919, 1928, 1937, 1946, 1955, 1964, 1973, 1982, 1991, 2002, 2011, 2020, 2103, 2112, 2121, 
        2130, 2204, 2213, 2222, 2231, 2240, 2305, 2314, 2323, 2332, 2341, 2350, 2406, 2415, 2424, 
        2433, 2442, 2451, 2460, 2507, 2516, 2525, 2534, 2543, 2552, 2561, 2570, 2608, 2617, 2626, 
        2635, 2644, 2653, 2662, 2671, 2680, 2709, 2718, 2727, 2736, 2745, 2754, 2763, 2772, 2781, 
        2790, 2819, 2828, 2837, 2846, 2855, 2864, 2873, 2882, 2891, 2929, 2938, 2947, 2956, 2965, 
        2974, 2983, 2992, 3003, 3012, 3021, 3030, 3104, 3113, 3122, 3131, 3140, 3205, 3214, 3223, 
        3232, 3241, 3250, 3306, 3315, 3324, 3333, 3342, 3351, 3360, 3407, 3416, 3425, 3434, 3443, 
        3452, 3461, 3470, 3508, 3517, 3526, 3535, 3544, 3553, 3562, 3571, 3580, 3609, 3618, 3627, 
        3636, 3645, 3654, 3663, 3672, 3681, 3690, 3719, 3728, 3737, 3746, 3755, 3764, 3773, 3782, 
        3791, 3829, 3838, 3847, 3856, 3865, 3874, 3883, 3892, 3939, 3948, 3957, 3966, 3975, 3984, 
        3993, 4004, 4013, 4022, 4031, 4040, 4105, 4114, 4123, 4132, 4141, 4150, 4206, 4215, 4224, 
        4233, 4242, 4251, 4260, 4307, 4316, 4325, 4334, 4343, 4352, 4361, 4370, 4408, 4417, 4426, 
        4435, 4444, 4453, 4462, 4471, 4480, 4509, 4518, 4527, 4536, 4545, 4554, 4563, 4572, 4581, 
        4590, 4619, 4628, 4637, 4646, 4655, 4664, 4673, 4682, 4691, 4729, 4738, 4747, 4756, 4765, 
        4774, 4783, 4792, 4839, 4848, 4857, 4866, 4875, 4884, 4893, 4949, 4958, 4967, 4976, 4985, 
        4994, 5005, 5014, 5023, 5032, 5041, 5050, 5106, 5115, 5124, 5133, 5142, 5151, 5160, 5207, 
        5216, 5225, 5234, 5243, 5252, 5261, 5270, 5308, 5317, 5326, 5335, 5344, 5353, 5362, 5371, 
        5380, 5409, 5418, 5427, 5436, 5445, 5454, 5463, 5472, 5481, 5490, 5519, 5528, 5537, 5546, 
        5555, 5564, 5573, 5582, 5591, 5629, 5638, 5647, 5656, 5665, 5674, 5683, 5692, 5739, 5748, 
        5757, 5766, 5775, 5784, 5793, 5849, 5858, 5867, 5876, 5885, 5894, 5959, 5968, 5977, 5986, 
        5995, 6006, 6015, 6024, 6033, 6042, 6051, 6060, 6107, 6116, 6125, 6134, 6143, 6152, 6161, 
        6170, 6208, 6217, 6226, 6235, 6244, 6253, 6262, 6271, 6280, 6309, 6318, 6327, 6336, 6345, 
        6354, 6363, 6372, 6381, 6390, 6419, 6428, 6437, 6446, 6455, 6464, 6473, 6482, 6491, 6529, 
        6538, 6547, 6556, 6565, 6574, 6583, 6592, 6639, 6648, 6657, 6666, 6675, 6684, 6693, 6749, 
        6758, 6767, 6776, 6785, 6794, 6859, 6868, 6877, 6886, 6895, 6969, 6978, 6987, 6996, 7007, 
        7016, 7025, 7034, 7043, 7052, 7061, 7070, 7108, 7117, 7126, 7135, 7144, 7153, 7162, 7171, 
        7180, 7209, 7218, 7227, 7236, 7245, 7254, 7263, 7272, 7281, 7290, 7319, 7328, 7337, 7346, 
        7355, 7364, 7373, 7382, 7391, 7429, 7438, 7447, 7456, 7465, 7474, 7483, 7492, 7539, 7548, 
        7557, 7566, 7575, 7584, 7593, 7649, 7658, 7667, 7676, 7685, 7694, 7759, 7768, 7777, 7786, 
        7795, 7869, 7878, 7887, 7896, 7979, 7988, 7997, 8008, 8017, 8026, 8035, 8044, 8053, 8062, 
        8071, 8080, 8109, 8118, 8127, 8136, 8145, 8154, 8163, 8172, 8181, 8190, 8219, 8228, 8237, 
        8246, 8255, 8264, 8273, 8282, 8291, 8329, 8338, 8347, 8356, 8365, 8374, 8383, 8392, 8439, 
        8448, 8457, 8466, 8475, 8484, 8493, 8549, 8558, 8567, 8576, 8585, 8594, 8659, 8668, 8677, 
        8686, 8695, 8769, 8778, 8787, 8796, 8879, 8888, 8897, 8989, 8998, 9009, 9018, 9027, 9036, 
        9045, 9054, 9063, 9072, 9081, 9090, 9119, 9128, 9137, 9146, 9155, 9164, 9173, 9182, 9191, 
        9229, 9238, 9247, 9256, 9265, 9274, 9283, 9292, 9339, 9348, 9357, 9366, 9375, 9384, 9393, 
        9449, 9458, 9467, 9476, 9485, 9494, 9559, 9568, 9577, 9586, 9595, 9669, 9678, 9687, 9696, 
        9779, 9788, 9797, 9889, 9898, 9999
    );
    
    public int countSymmetricIntegers(int low, int high) {
        // 使用二分查找确定边界
        int left = Collections.binarySearch(SYMMETRIC_NUMS, low);
        if (left < 0) left = -left - 1;
        
        int right = Collections.binarySearch(SYMMETRIC_NUMS, high);
        if (right < 0) right = -right - 2;
        
        return right - left + 1;
    }
}
```

- 时间复杂度： $O(logU)$，预处理时间被均摊，而 $U=624$ 是列表长度
- 空间复杂度： $O(1)$，预处理空间被均摊

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-symmetric-integers/solutions/3647746/si-jie-bao-li-yu-chu-li-er-fen-mei-ju-da-bw3i/)
