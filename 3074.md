[Problem: 3074. 重新分装苹果](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/)

### 方法：贪心+排序

同一个包裹中的苹果可以分装到不同的箱子中 -> 不关心苹果怎么装。

我们只需要将苹果全部装完，因此计算出苹果总数 $total = sum(apple)$。

贪心策略：为了使用 **最少** 数量的箱子，我们应该优先选择 **容量最大** 的箱子。

将箱子容量数组 $capacity$ 按 **从大到小** 排序。

- 依次使用这些容量最大的箱子，并从总苹果数 $total$ 中减去当前箱子的容量 $cap$。
- 每用一个箱子，计数器 $ans$ 加 $1$。
- 当总苹果数被减到 $\le 0$ 时，说明所有苹果已全部装下。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        # 苹果总数
        total = sum(apple)
        # 箱子容量从大到小排序
        capacity.sort(reverse=True)
        ans = 0

        # 依次取最大的箱子
        for cap in capacity:
            total -= cap
            ans += 1
            # 装完了
            if total <= 0:
                break
                
        return ans
```

```Java
// java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        // 苹果总数
        int total = 0;
        for (int a : apple) total += a;
        // 箱子容量从大到小排序
        Arrays.sort(capacity);
        int ans = 0;

        // 依次取最大的箱子
        for (int i = capacity.length - 1; i >= 0; i--) {
            total -= capacity[i];
            ans++;
            // 装完了
            if (total <= 0) {
                break;
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n+mlogm)$，其中 $n,m$ 分别是数组 $apple,capacity$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量，忽略排序的 $O(logm)$ 栈开销

---

### 计数

注意到，箱子容量 $capacity[i]\in[0,50]$，数值非常小。

因此，我们使用计数排序（一种线性时间的排序），统计每个值的出现次数。

实测性能差不多，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total = sum(apple)
    
        # 统计每个容量出现的次数
        counts = [0] * 51
        for cap in capacity:
            counts[cap] += 1
        
        ans = 0
        # 依次取最大的箱子
        for cap in range(50, 0, -1):
            while counts[cap] > 0:
                total -= cap
                ans += 1
                counts[cap] -= 1
                if total <= 0:  # 装完
                    return ans
        
        return ans
```

```Java
// java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int total = 0;
        for (int a : apple) total += a;

        // 统计每个容量出现的次数
        int[] counts = new int[51];
        for (int cap : capacity) {
            counts[cap]++;
        }

        int ans = 0;
        // 依次取最大的箱子
        for (int cap = 50; cap > 0; cap--) {
            while (counts[cap] > 0) {
                total -= cap;
                ans++;
                counts[cap]--;
                if (total <= 0) {  // 装完
                    return ans;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n+m+V)$，其中 $V$ 是数组 $capacity$ 中的最大值
- 空间复杂度： $O(V)$，表示数组 $counts$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/apple-redistribution-into-boxes/solutions/3864416/tan-xin-kuai-pai-ji-shu-pai-xu-jian-ji-x-uqsw/)
