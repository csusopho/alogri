[Problem: 1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/description/)

### 中序遍历 & DSW

什么是二叉搜索树？对于任意节点，

- 左节点的值都比当前节点的小；
- 右节点的值都比当前节点的大。

二叉搜索树 $BST$ 的中序遍历结果是一个 **严格递增的有序数组**。

得到有序数组后，我们可以选取 **中间位置** 的元素作为根节点，确保左右子树节点数量大致相等。然后，**递归地** 对左右子数组进行同样的操作，构建左右子树。

这就是有序数组转为平衡 $BST$ 的本质原理，具体可以练练这道题 [108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)。

代码如下，已附加注释：

```Python
# python
class Solution:
    def balanceBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 中序遍历，收集节点值
        vals = []

        def inorder(node):
            if not node:
                return
            inorder(node.left)
            vals.append(node.val)
            inorder(node.right)
        
        inorder(root)
        
        # 构建平衡BST
        def build(left, right):
            if left > right:
                return None
            
            # 选择中间位置作为根
            mid = (left + right) // 2
            node = TreeNode(vals[mid])
            # 二分，左/右侧构建左/右子树
            node.left = build(left, mid - 1)
            node.right = build(mid + 1, right)
            # 返回构造完成的节点
            return node
        
        return build(0, len(vals) - 1)
```

```Java
// java
class Solution {
    // 存储节点值
    private List<Integer> vals = new ArrayList<>();

    public TreeNode balanceBST(TreeNode root) {
        // 清空
        vals.clear();
        // 中序遍历，收集节点值
        inorder(root);
        // 构建平衡BST
        return build(0, vals.size() - 1);
    }

    private void inorder(TreeNode node) {
        if (node == null) {
            return;
        }
        inorder(node.left);
        vals.add(node.val);
        inorder(node.right);
    }

    private TreeNode build(int left, int right) {
        if (left > right) {
            return null;
        }
        
        // 选择中间位置作为根
        int mid = (left + right) / 2;
        TreeNode node = new TreeNode(vals.get(mid));
        
        // 二分，左/右侧构建左/右子树
        node.left = build(left, mid - 1);
        node.right = build(mid + 1, right);
        
        // 返回构造完成的节点
        return node;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是树中节点个数
- 空间复杂度： $O(n)$，用数组 $vals$ 存储所有节点

---

### $DSW$

本题是将一棵树全局重构，逐个节点判断高度差+旋转，效率实在太低。可以考虑使用 $O(n)$ 的平衡算法 $DSW$，我参考了 [知乎](https://zhuanlan.zhihu.com/p/53783149) 上的这篇解答。

一共两个阶段：

1. 造藤：通过 **右旋**，将整棵树 “拉直” 变成一个只有右孩子的链表。
2. 压缩：通过多次 **左旋**，将链表折叠回一棵完美的平衡二叉树。

具体来说，

- 首先，创建一个伪根节点 $dummy$ 指向 $root$，因为 $root$ 可能也会移动；
- 接着，遍历右链，如果节点有左孩子，就右旋，直到所有左孩子消失；
- 接着，计算最接近 $n$ 的完全二叉树节点数 $m = 2^{\lfloor \log_2(n+1) \rfloor} - 1$
- 第一次压缩时，对链表末尾多出的 $n - m$ 个节点进行左旋；
- 后续压缩时，每次对 $m$ 个节点的一半进行左旋，直到 $m=0$。

“压缩” 本质上就是有规律的批量左旋，每次将链表长度减半，直到变平衡。

旋转逻辑非常繁琐，极易写错指针连接，不推荐这种解法，但最好有所了解。

代码如下，已附加注释：

```Python
# python
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:   
        # 辅助节点，方便处理根节点的旋转
        dummy = TreeNode(0)
        dummy.right = root
        
        # 将树拉直成一个只有右子节点的链表
        cnt = 0
        tmp = dummy
        while tmp.right:
            if tmp.right.left:
                # 右旋操作，将左孩子提上来
                old_root = tmp.right
                new_root = old_root.left
                
                # 重连指针
                tmp.right = new_root
                old_root.left = new_root.right
                new_root.right = old_root
                # 旋转后，tmp 的右孩子变了，需要再次检查新的右孩子是否有左子树
            else:
                # 没有左孩子，才继续向下移动
                cnt += 1
                tmp = tmp.right
        
        # 压缩，将链表折叠回平衡树
        # 这一轮“完美”层级能容纳的节点数
        m = 2 ** (cnt.bit_length() - 1) - 1
        
        # 对 node 右侧的链表执行 times 次左旋
        def compress(node, times):
            tmp = node
            for _ in range(times):
                # 确保有足够的节点进行旋转
                if not tmp.right or not tmp.right.right:
                    break
                
                # 左旋
                child = tmp.right
                pivot = child.right
                
                child.right = pivot.left
                pivot.left = child
                tmp.right = pivot
                
                # 移动到下一个旋转位
                tmp = pivot
        
        # 处理多余的节点，将非完全二叉树底层的多余叶子折叠上去
        compress(dummy, cnt - m)
        
        # 循环压缩，每次对剩下节点的一半进行左旋
        while m > 1:
            m //= 2
            compress(dummy, m)
        
        return dummy.right
```

```Java
// java
class Solution {
    public TreeNode balanceBST(TreeNode root) {
        // 辅助节点，方便处理根节点的旋转
        TreeNode dummy = new TreeNode(0);
        dummy.right = root;
        
        // 将树拉直成一个只有右子节点的链表
        int cnt = 0;
        TreeNode tmp = dummy;
        while (tmp.right != null) {
            if (tmp.right.left != null) {
                // 右旋操作，将左孩子提上来
                TreeNode old_root = tmp.right;
                TreeNode new_root = old_root.left;
                
                // 重连指针
                tmp.right = new_root;
                old_root.left = new_root.right;
                new_root.right = old_root;
                // 旋转后，tmp 的右孩子变了，需要再次检查新的右孩子是否有左子树
            } else {
                // 没有左孩子，才继续向下移动
                cnt++;
                tmp = tmp.right;
            }
        }
        
        // 压缩，将链表折叠回平衡树
        // 这一轮“完美”层级能容纳的节点数
        int m = Integer.highestOneBit(cnt) - 1;
        
        // 处理多余的节点，将非完全二叉树底层的多余叶子折叠上去
        compress(dummy, cnt - m);
        
        // 循环压缩，每次对剩下节点的一半进行左旋
        while (m > 1) {
            m /= 2;
            compress(dummy, m);
        }
        
        return dummy.right;
    }

    // 对 node 右侧的链表执行 times 次左旋
    private void compress(TreeNode node, int times) {
        TreeNode tmp = node;
        for (int i = 0; i < times; i++) {
            // 确保有足够的节点进行旋转
            if (tmp.right == null || tmp.right.right == null) {
                break;
            }
            
            // 左旋
            TreeNode child = tmp.right;
            TreeNode pivot = child.right;
            
            child.right = pivot.left;
            pivot.left = child;
            tmp.right = pivot;
            
            // 移动到下一个旋转位
            tmp = pivot;
        }
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，原地操作

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/3899414/shuang-jie-zhong-xu-bian-li-gou-zao-bstl-2tsl/)
