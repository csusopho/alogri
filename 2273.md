[Problem: 2273. 移除字母异位词后的结果数组](https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/description/)

### 方法：栈 & 双指针

什么叫做字母异位词？单词组成 **完全相同**，只是排列不同，比如 $abc$ 与 $cba$。

如何检查两个单词是异位词？

- 使用哈希/数组统计字母出现次数，然后逐个字母比较；
- 排序后，使用双指针检查每个位置的字母是否相同。

如果 $words[i-1],words[i]$ 是异位词，且 $words[i],words[i+1]$ 也是异位词，则它们三者都互为异位词，将它们看作一个组，只需要保留 **第一个**！

因此，我们可以使用 **双指针/栈** 来判断当前单词与前面的单词，是否属于同一个组。

首先，我们选择比较容易想到的做法：哈希判断两个单词的关系，栈判断是否连续。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        # 初始化一个栈，并将第一个单词放进去
        stack = [words[0]]

        for i in range(1, len(words)):
            # 检查与前一个单词，是否组成相同
            if Counter(words[i]) != Counter(stack[-1]):
                stack.append(words[i])
        
        return stack
```

```Java
// java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        // 初始化一个列表，并将第一个单词放进去
        List<String> res = new ArrayList<>();
        res.add(words[0]);

        for (int i = 1; i < words.length; i++) {
            // 检查当前单词与前一个单词，是否组成相同
            if (!areAnagrams(words[i], res.get(res.size() - 1))) {
                res.add(words[i]);
            }
        }
        
        return res;
    }

    // 使用哈希表检查两个字符串是否为字母异位词
    private boolean areAnagrams(String s1, String s2) {
        // 如果长度不同，肯定不是
        if (s1.length() != s2.length()) {
            return false;
        }

        // 使用一个大小为 26 的数组作为哈希表
        int[] charCount = new int[26];

        // 遍历第一个字符串
        for (char c : s1.toCharArray()) {
            charCount[c - 'a']++;
        }

        // 遍历第二个字符串
        for (char c : s2.toCharArray()) {
            charCount[c - 'a']--;
            // 如果某个字符的计数变为负数
            // 说明第二个字符串中该字符的数量比第一个字符串多
            if (charCount[c - 'a'] < 0) {
                return false;
            }
        }

        // 如果所有计数最终都归零，则它们是字母异位词
        return true;
    }
}
```

- 时间复杂度： $O(n\times L)$，其中 $n$ 是数组 $words$ 的长度，每个单词的平均长度为 $L$
- 空间复杂度： $O(L)$，表示哈希表的空间，返回值 $res$ 一般不计入复杂度

---

### 原地

使用一个指针 $write$，它指向下一个非字母异位词应该被放置的位置。也即，**每个组** 需要保留的第一个单词，都放在 $write$ 位置。

具体来说，流程为：

- 如果相邻两个单词不是字母异位词，则说明两者都需要保留，前者已存储过，所以将第二个单词放在 $write$ 位置；
- 否则，说明两者可能都需要删除，不进行记录，继续遍历下一对相邻单词。

**做法**：检查的是「相邻」单词，且换成「排序后调库」比较两个单词。遍历完成后，所有合法单词都放在 $[0:write)$ 内，删除列表末尾的无效单词。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        # write 指向下一个非字母异位词应该被放置的位置
        write = 1 
        
        # 相邻元素的元组
        for prev, cur in pairwise(words):
            # 检查两个相邻的单词是否为字母异位词
            if sorted(prev) != sorted(cur):
                # 如果不是字母异位词，则保留 cur
                # 将它移动到 write 指示的位置
                words[write] = cur
                # 将指针后移，为下一个非字母异位词做准备
                write += 1
        
        # 删除列表末尾所有不再需要的元素
        del words[write:]
        
        return words
```

```Java
// java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        // write 指向下一个非字母异位词应该被放置的位置
        int write = 1;
        
        // 遍历相邻的元素
        for (int i = 1; i < words.length; i++) {
            String prev = words[i - 1];
            String cur = words[i];

            // 检查两个相邻的单词是否为字母异位词
            if (!areAnagrams(prev, cur)) {
                // 如果不是字母异位词，则保留 cur
                // 将它移动到 write 指示的位置
                words[write] = cur;
                // 将指针后移，为下一个非字母异位词做准备
                write++;
            }
        }
        
        // words 数组的前 write 个元素就是我们想要的结果
        List<String> res = new ArrayList<>();
        for (int i = 0; i < write; i++) {
            res.add(words[i]);
        }
        return res;
    }

    // 通过排序来检查两个字符串是否为字母异位词
    private boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return Arrays.equals(arr1, arr2);
    }
}
```

- 时间复杂度： $O(nLlogL)$，每个单词使用快排再比较
- 空间复杂度： $O(1)$，而 $Java$ 代码由于辅助方法会创建 $O(L)$ 空间

---

### 双指针

**核心**：使用两个指针，找出 **一组** 异位词的首尾，从而只需保留第一个。

使用指针 $start$ 指向当前一组连续字母异位词的第一个单词，以及指针 $end$ 指向末尾的最后一个单词。

**流程**：让 $end$ 指针后移，找到所有与 $start$ 处单词是字母异位词的连续单词，直到找到一个非字母异位词，或到达列表末尾。

这种方法速度最快， $Python$ 代码耗时 $0ms$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        res = []
        n = len(words)
        
        # start 指向当前一组连续字母异位词的第一个单词
        start = 0

        while start < n:
            # end 用于向后查找，找到所有与 start 处单词是字母异位词的连续单词
            end = start + 1
            
            # 直到找到一个非字母异位词或到达列表末尾
            while (end < n and 
                   sorted(words[start]) == sorted(words[end])):
                end += 1
            
            # 只添加第一个
            res.append(words[start])
            # 移动到下一组不同单词的起始位置
            start = end
            
        return res
```

```Java
// java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        List<String> res = new ArrayList<>();
        int n = words.length;

        // start 指向当前一组连续字母异位词的第一个单词
        int start = 0;

        while (start < n) {
            // end 用于向后查找，找到所有与 start 处单词是字母异位词的连续单词
            int end = start + 1;
            
            // 直到找到一个非字母异位词或到达列表末尾
            while (end < n && areAnagrams(words[start], words[end])) {
                end++;
            }
            
            // 只添加这组连续字母异位词中的第一个单词
            res.add(words[start]);
            
            // 移动到下一组不同单词的起始位置
            start = end;
        }
            
        return res;
    }

    // 通过排序来检查两个字符串是否为字母异位词
    private boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return Arrays.equals(arr1, arr2);
    }
}
```

- 时间复杂度： $O(nLlogL)$
- 空间复杂度： $O(L)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/solutions/3804666/san-jie-zhan-yuan-di-xiu-gai-shuang-zhi-fkarg/)
