[Problem: 3459. 最长 V 形对角线段的长度](https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/description/)

### 方法：DFS & BFS+剪枝

题意：从元素 $1$ 出发，斜着移动，必须 $2,0$ 交替，也即路径是 $12020\dots$ 的形式。最多顺时针转一次方向，求路径的最大长度。

如果换成二维坐标的 **增量** 表示方向，那就是：

- $(1, 1)$ 表示右下方向，即 $↘$
- $(1, -1)$ 表示左下方向，即 $↙$
- $(-1, -1)$ 表示左上方向，即 $↖$
- $(-1, 1)$ 表示右上方向，即 $↗$

相邻方向之间是 $90\degree$ 夹角，比如 $↘$ 顺时针旋转 $90\degree$ 得到 $↙$。使用 $+1$ 就能表示方向转动一次，不过需要 `%4` 或者 `&3` 防止越界。

起点是 $1$，在网格中搜索路径，这不就是 **递归** 的经典应用场景？！

我们知道，一个格子能否继续向某个方向移动，必须确保 $0/2$ 交替，所以使用参数 $exp$ 表示目标值，以及 $d$ 表示方向；同时，还需要确定是否转过向。

**定义** $dfs(i,j,d,exp,turn)$ 表示当前坐标是 $(i,j)$，移动方向为 $d$，当前格子值必须是 $exp=2/0$，是否转过一次方向 $turn$ 下，能得到的最大路径长度。

**状态转移**：当前路径要么直走，要么转向一次，

- 如果直走，则新状态变为 $\text{straight} = f(x',y',d,e',t)$，其中 $e'$ 表示下一个格子的目标值，在 $0/2$ 之前交替，而 $x',y'$ 表示新坐标。
- 如果之前没转过弯，也即 $t=false$，当前位置尝试转一次，方向会更新为 $d'$，新状态变为 $\text{turn}=f(x',y',d',e',true)$。

两种路径都是可行的，所以选择答案较大者，用公式表示：

$$
f(x, y, d, e, t) =\max(\text{straight}, \text{turn})+1
$$

**递归起点**：网格中任意一个值为 $1$ 的格子都可能是起点，都需要递归。

两个不同位置的起点，转向一次后，可能共用一段路径。此时两者的递归参数相同，所以会产生大量重复递归调用。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此使用记忆化搜索来优化。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        # 四个对角方向 (↘, ↙, ↖, ↗)
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]

        # 当前坐标、方向、预期值、是否转向一次
        @cache
        def dfs(x, y, di, expect, turned):
            if x < 0 or x >= n or y < 0 or y >= m:
                return 0
            if grid[x][y] != expect:
                return 0
            length = 1
            dx, dy = dirs[di]
            # 继续直行
            length = max(length, 1 + dfs(x + dx, y + dy, di, 2 if expect == 0 else 0, turned))
            # 如果还没转向，尝试顺时针 90° 转向
            if not turned:
                ndir = (di + 1) % 4
                ndx, ndy = dirs[ndir]
                length = max(length, 1 + dfs(x + ndx, y + ndy, ndir, 2 if expect == 0 else 0, True))
            return length

        res = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:  # 起点是 1，下一个期望 2
                    for d in range(4):  # 枚举四个方向
                        dx, dy = dirs[d]
                        ni, nj = i + dx, j + dy
                        res = max(res, 1 + dfs(ni, nj, d, 2, False))
        return res
```

```Python
# python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        m, n = len(grid), len(grid[0])

        @cache
        def dfs(i, j, di, turned, target):
            # 新位置
            i += dirs[di][0]
            j += dirs[di][1]
            # 递归边界
            if (not (0 <= i < m and 0 <= j < n)) or grid[i][j] != target:
                return 0
            # 直走
            res = dfs(i, j, di, turned, 2 - target) + 1
            # 转向一次
            if turned:
                res = max(res, dfs(i, j, (di + 1) % 4, False, 2 - target) + 1)
            return res
        
        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 1:
                    for k in range(4):
                        ans = max(ans, dfs(i, j, k, True, 2) + 1)
        return ans
```

```Java
// java
class Solution {
    int[][] dirs = {{1,1},{1,-1},{-1,-1},{-1,1}};
    int m, n;
    int[][][][][] memo; // i,j,方向,turned(0/1),target(0/2)

    public int lenOfVDiagonal(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        memo = new int[m][n][4][2][3];

        int ans = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == 1){ // 起点是 1
                    for(int k=0;k<4;k++){
                        // dfs(i,j,方向,turned,target) + 1 表示起点计入长度
                        ans = Math.max(ans, dfs(grid,i,j,k,1,2) + 1);
                    }
                }
            }
        }
        return ans;
    }

    // i,j 当前坐标, di 方向, turned 是否还可以转(1=可以,0=不可以), target 期望值
    private int dfs(int[][] grid, int i, int j, int di, int turned, int target){
        // 新位置
        int ni = i + dirs[di][0];
        int nj = j + dirs[di][1];
        // 越界或值不匹配，返回 0
        if(ni<0 || ni>=m || nj<0 || nj>=n || grid[ni][nj] != target)
            return 0;
        // 已记忆过，直接返回
        if(memo[ni][nj][di][turned][target] != 0)
            return memo[ni][nj][di][turned][target];

        // 直走
        int res = dfs(grid, ni, nj, di, turned, 2 - target) + 1;
        // 转向一次（如果还可以转向 turned==1）
        if(turned == 1){
            res = Math.max(res, dfs(grid, ni, nj, (di+1)%4, 0, 2 - target) + 1);
        }

        memo[ni][nj][di][turned][target] = res;
        return res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共五个，状态个数等于 $O(m\times n)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(m\times n)$。

- 时间复杂度： $O(m\times n)$，其中 $m,n$ 为矩阵 $grid$ 的行数和列数，系数 $16$ 省略
- 空间复杂度： $O(m\times n)$，保存多少状态，就需要多少空间

---

### 剪枝

这里我参考了灵神的题解，可以增加最优性剪枝！

**原理**：之前的路径遍历后，假设最大长度为 $5$，而本条路径就算走到底也只可能长度为 $4$，那就没必要计算！

“走到底” 的最大值怎么算？假设当前方向是 $↘$，最多转一次变为 $↙$，这两段路径的 **共同点**：纵坐标 $j$ 不断 $+1$，这条路径最大长度就是纵坐标的最大增量！

> $ps$：如果不好理解，就将曲线 “拉平”，总长度是一样的。

也就是说，如果起点是 $(x,y)$，方向是 $↘$，那么这条路径最长也只能是 $n-j$！同理其他方向，都是边界值 - 起始横/纵坐标。

**注意**：两次剪枝，一次是起点，一次是递归过程中。第一种是减少源头的树枝，第二种是减少递归过程中的树枝，两者概念不同！

代码如下，已附加注释：

```Python
# python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        m, n = len(grid), len(grid[0])

        @cache
        def dfs(i, j, di, turned, target):
            # 新位置
            i += dirs[di][0]
            j += dirs[di][1]
            # 递归边界
            if (not (0 <= i < m and 0 <= j < n)) or grid[i][j] != target:
                return 0
            # 直走
            res = dfs(i, j, di, turned, 2 - target)
            # 转向一次
            if turned:
                maxs = (m - i - 1, j, i, n - j - 1)  # 理论最大值（走到底）
                di = (di + 1) % 4
                # 优化二：如果理论最大值没有超过 res，那么不递归
                if maxs[di] > res:
                    res = max(res, dfs(i, j, di, False, 2 - target))
            return res + 1
        
        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 1:
                    maxs = (m - i, j + 1, i + 1, n - j)  # 理论最大值（走到底）
                    for k, mx in enumerate(maxs):  # k是起始方向
                        # 优化一：如果理论最大值没有超过 ans，那么不递归
                        if mx > ans:
                            ans = max(ans, dfs(i, j, k, True, 2) + 1)
        return ans
```

```Java
// java
class Solution {
    int[][] dirs = {{1,1},{1,-1},{-1,-1},{-1,1}};
    int m, n;
    int[][][][][] memo; // i,j,方向,turned(0/1),target(0/2)

    public int lenOfVDiagonal(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        memo = new int[m][n][4][2][3];

        int ans = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == 1){ // 起点是 1
                    // 理论最大长度（走到底）优化
                    int[] maxs = {m - i, j + 1, i + 1, n - j};
                    for(int k=0;k<4;k++){
                        if(maxs[k] > ans){ // 优化一：剪枝
                            ans = Math.max(ans, dfs(grid,i,j,k,1,2) + 1);
                        }
                    }
                }
            }
        }
        return ans;
    }

    // i,j 当前坐标, di 方向, turned 是否还可以转(1=可以,0=不可以), target 期望值
    private int dfs(int[][] grid, int i, int j, int di, int turned, int target){
        // 新位置
        int ni = i + dirs[di][0];
        int nj = j + dirs[di][1];
        // 越界或值不匹配，返回 0
        if(ni<0 || ni>=m || nj<0 || nj>=n || grid[ni][nj] != target)
            return 0;
        // 已记忆过，直接返回
        if(memo[ni][nj][di][turned][target] != 0)
            return memo[ni][nj][di][turned][target];

        // 直走
        int res = dfs(grid, ni, nj, di, turned, 2 - target);
        // 转向一次（如果还可以转向 turned==1）
        if(turned == 1){
            // 理论最大值：走到底
            int[] maxs = {m - ni - 1, nj, ni, n - nj - 1};
            int ndi = (di + 1) % 4;
            if(maxs[ndi] > res){ // 优化二：剪枝
                res = Math.max(res, dfs(grid, ni, nj, ndi, 0, 2 - target));
            }
        }

        return memo[ni][nj][di][turned][target] = res + 1; // 加上当前格子
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(m\times n)$

---

### $BFS$

如果将剪枝前的 $DFS$ 转为 $BFS$，就会超时，卡在 $556/561$ 样例，代码如下：

```Python
# python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        m, n = len(grid), len(grid[0])
        ans = 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] != 1:
                    continue
                # 四个起始方向
                for di in range(4):
                    queue = deque()
                    # 队列元素：i, j, 当前方向, 是否还能转向, 下一个目标, 当前长度
                    queue.append((i, j, di, True, 2, 1))
                    
                    while queue:
                        x, y, d, turned, target, length = queue.popleft()
                        nx, ny = x + dirs[d][0], y + dirs[d][1]
                        if not (0 <= nx < m and 0 <= ny < n) or grid[nx][ny] != target:
                            # 当前长度无法继续走，更新答案
                            ans = max(ans, length)
                            continue
                        # 直走
                        queue.append((nx, ny, d, turned, 2 - target, length + 1))
                        # 转向一次
                        if turned:
                            nd = (d + 1) % 4
                            queue.append((nx, ny, nd, False, 2 - target, length + 1))
        return ans
```

所以，将递归中的剪枝同理应用，得到下面的代码（空间超过 $100\%$）：

```Python
# python
class Solution:
    def lenOfVDiagonal(self, grid: list[list[int]]) -> int:
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        m, n = len(grid), len(grid[0])
        ans = 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] != 1:
                    continue
                
                # 四个起始方向
                maxs = (m - i, j + 1, i + 1, n - j)  # 当前方向理论最大长度
                for di in range(4):
                    # 起点方向剪枝
                    if maxs[di] <= ans:
                        continue
                    
                    queue = deque()
                    queue.append((i, j, di, True, 2, 1))
                    
                    while queue:
                        x, y, d, turned, target, length = queue.popleft()
                        nx, ny = x + dirs[d][0], y + dirs[d][1]
                        
                        if not (0 <= nx < m and 0 <= ny < n) or grid[nx][ny] != target:
                            ans = max(ans, length)
                            continue
                        
                        # 计算剩余理论最大长度
                        remain = 0
                        if d == 0: remain = m - nx
                        elif d == 1: remain = ny + 1
                        elif d == 2: remain = nx + 1
                        elif d == 3: remain = n - ny
                        
                        # 如果还能转向，考虑转向后的理论长度
                        if turned:
                            nd = (d + 1) % 4
                            if nd == 0: remain = max(remain, m - nx)
                            elif nd == 1: remain = max(remain, ny + 1)
                            elif nd == 2: remain = max(remain, nx + 1)
                            elif nd == 3: remain = max(remain, n - ny)
                        
                        # 剪枝：剩余理论长度 + 当前长度 <= ans
                        if length + remain <= ans:
                            continue
                        
                        # 直走
                        queue.append((nx, ny, d, turned, 2 - target, length + 1))
                        # 转向一次
                        if turned:
                            nd = (d + 1) % 4
                            queue.append((nx, ny, nd, False, 2 - target, length + 1))
        return ans
```

```Java
// java
class Solution {
    public int lenOfVDiagonal(int[][] grid) {
        int[][] dirs = {{1,1},{1,-1},{-1,-1},{-1,1}};
        int m = grid.length;
        int n = grid[0].length;
        int ans = 0;
        
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] != 1) continue; // 起点不是1，跳过
                
                // 四个起始方向，理论最大长度
                int[] maxs = {m - i, j + 1, i + 1, n - j};
                
                for(int di=0; di<4; di++){
                    // 起点方向剪枝
                    if(maxs[di] <= ans) continue;
                    
                    Queue<int[]> queue = new LinkedList<>();
                    // 队列元素：[x, y, direction, turned(1/0), target, length]
                    queue.offer(new int[]{i, j, di, 1, 2, 1});
                    
                    while(!queue.isEmpty()){
                        int[] cur = queue.poll();
                        int x = cur[0], y = cur[1], d = cur[2];
                        int turned = cur[3], target = cur[4], length = cur[5];
                        
                        int nx = x + dirs[d][0];
                        int ny = y + dirs[d][1];
                        
                        // 越界或值不匹配
                        if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny] != target){
                            ans = Math.max(ans, length);
                            continue;
                        }
                        
                        // 剩余理论最大长度
                        int remain = 0;
                        switch(d){
                            case 0: remain = m - nx; break;
                            case 1: remain = ny + 1; break;
                            case 2: remain = nx + 1; break;
                            case 3: remain = n - ny; break;
                        }
                        
                        // 如果还能转向，考虑转向后的理论长度
                        if(turned == 1){
                            int nd = (d + 1) % 4;
                            switch(nd){
                                case 0: remain = Math.max(remain, m - nx); break;
                                case 1: remain = Math.max(remain, ny + 1); break;
                                case 2: remain = Math.max(remain, nx + 1); break;
                                case 3: remain = Math.max(remain, n - ny); break;
                            }
                        }
                        
                        // 剪枝：剩余理论长度 + 当前长度 <= ans
                        if(length + remain <= ans) continue;
                        
                        // 直走
                        queue.offer(new int[]{nx, ny, d, turned, 2 - target, length + 1});
                        // 转向一次
                        if(turned == 1){
                            int nd = (d + 1) % 4;
                            queue.offer(new int[]{nx, ny, nd, 0, 2 - target, length + 1});
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(m\times n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/solutions/3764971/san-jie-dfs-jian-zhi-bfsxiang-xi-tui-dao-l87n/)
