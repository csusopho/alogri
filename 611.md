[Problem: 611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/description/)

### 方法：二分 & 双指针

三角形必须满足什么条件？**两边之和大于第三边**。

**暴力** 思路：枚举所有三元组，判断 $(a,b,c)$ 三条边能否组成三角形。

代码如下，已附加注释：

```Python
# python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)

        # 如果数组元素少于3个，则不可能组成三角形
        if n < 3:
            return 0

        # 遍历所有可能的三元组 (i, j, k)
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    # 获取三条边的长度
                    a, b, c = nums[i], nums[j], nums[k]

                    # 检查是否满足三角形不等式定理
                    if a + b > c and a + c > b and b + c > a:
                        ans += 1
        
        return ans
```

假设数组 $nums$ 的长度为 $n$，题目限定 $n\leq 10^3$。上述复杂度为 $O(n^3)$，因此超时，会卡在 $223/241$ 样例。

---

### 二分

在 “两边之和 > 第三边” 这条定理中，对于边 $(a,b,c)$ 来说，如果我们已知边 $c$ 最长，那么只需要比较 $a+b$ 与 $c$ 的关系，而无需判断三个不等式！

因此，我们想到利用 **排序**，让整个数组有序，从而轻松地找出最长边。假设排序后，三条边在数组中的顺序为 $a,b,c$，则有 $a\leq b\leq c$。

如何优化三重循环？**思路**：我们固定最短边为 $a$，中间长度的边为 $b$，统计有几个符合要求的 $c$？也即，在数值范围 $[b,a+b)$ 内寻找有几个 $c$？

有序数组中寻找数 —— 联想到 **二分查找**。

假设值 $b$ 的下标为 $j$，则搜索范围是 $(j,n)$。二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~

给出最容易理解的 **闭区间写法**，代码如下，已附加注释：

```Python
# python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                target = nums[i] + nums[j]
                
                # 在 nums[j+1:] 中二分查找
                low, high = j + 1, n - 1
                k = j
                while low <= high:
                    mid = low + (high - low) // 2
                    if nums[mid] < target:
                        # 这个元素是有效的，但可能还有更大的有效元素
                        k = mid
                        low = mid + 1
                    else:
                        # 这个元素太大了，需要向左边找
                        high = mid - 1
                
                # 满足条件的元素是从 j+1 到 k
                ans += k - j
                
        return ans
```

```Java
// java
class Solution {
    public int triangleNumber(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        int ans = 0;
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                int target = nums[i] + nums[j];
                
                // 在 nums[j+1:] 中二分查找
                int low = j + 1, high = n - 1;
                int k = j;
                while (low <= high) {
                    int mid = low + (high - low) / 2;
                    if (nums[mid] < target) {
                        // 这个元素是有效的，但可能还有更大的有效元素
                        k = mid;
                        low = mid + 1;
                    } else {
                        // 这个元素太大了，需要向左边找
                        high = mid - 1;
                    }
                }
                
                // 满足条件的元素是从 j+1 到 k
                ans += k - j;
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n^2\times logn)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

---

### 双指针

我们应该利用 **单调性** 这个条件，想到 **滑动窗口**。

上面解法的速度较慢，是因为没有利用之前的计算结果。如果 $a+b>c$，那么 $a+1+b>c$ 也一定成立！也就是说，如果 `(nums[i], nums[j], nums[k])` 已经成立，那么 `nums[i...j-1], nums[j], nums[k]` 也会成立。

滑窗的本质就是让一个数从一端进来，让其他数从另一端退出。这样的过程使得暴力双 $for$ 枚举变为了一次遍历，从而降低时间复杂度。具体的原理推导，以及实现过程，可以看看这篇题解 [双指针&哈希](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solutions/2901292/yi-ti-shuang-jie-shuang-zhi-zhen-ha-xi-e-cods/)。

**思路**：我们固定最长边为 $c$，然后使用滑窗/双指针在前面的段中寻找，从而快速地找出所有 $(i,j)$ 组合的数量。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()  # 升序
        ans = 0
        n = len(nums)

        # 固定最长的一条边 c
        # k 从 2 开始，因为三角形至少需要三条边
        for k in range(2, n):
            c = nums[k]
            i = 0  # 左指针，指向可能的 a
            j = k - 1  # 右指针，指向可能的 b

            # 使用双指针法寻找满足 a + b > c 的组合
            while i < j:
                if nums[i] + nums[j] > c:
                    # 在 i 和 j 之间的所有元素与 c 组合都能满足条件
                    ans += j - i
                    # 将右指针向左移动，尝试一个更小的 b
                    j -= 1
                else:
                    # 如果 nums[i] + nums[j] <= c，说明 a 太小了
                    i += 1
                    
        return ans
```

```Java
// java
class Solution {
    public int triangleNumber(int[] nums) {
        Arrays.sort(nums); // 升序
        int ans = 0;
        int n = nums.length;

        // 固定最长的一条边 c
        // k 从 2 开始，因为三角形至少需要三条边
        for (int k = 2; k < n; k++) {
            int c = nums[k];
            int i = 0;      // 左指针，指向可能的 a
            int j = k - 1;  // 右指针，指向可能的 b

            // 使用双指针法寻找满足 a + b > c 的组合
            while (i < j) {
                if (nums[i] + nums[j] > c) {
                    // 在 i 和 j 之间的所有元素与 c 组合都能满足条件
                    ans += j - i;
                    // 将右指针向左移动，尝试一个更小的 b
                    j--;
                } else {
                    // 如果 nums[i] + nums[j] <= c，说明 a 太小了
                    i++;
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，内部进行滑窗时，每个指针最多各自移动一趟，时间为 $O(n)$
- 空间复杂度： $O(1)$

---

能否固定最短边 $a$ 来同理求解呢？当然可以！

代码如下，已附加注释：

```Python
# python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return 0
        
        nums.sort()  # 升序
        ans = 0

        # 固定最短的一条边 a
        for i in range(n - 2):
            # 如果最短边为0，则无法构成三角形
            if nums[i] == 0:
                continue

            k = i + 2  # k 指针，指向可能的 c
            # 固定第二条边 b
            for j in range(i + 1, n - 1):
                target = nums[i] + nums[j]
                
                # 移动 k 指针，找到第一个不满足 a + b > c 的位置
                while k < n and nums[k] < target:
                    k += 1
                
                # 在 j 和 k 之间的所有元素都可以作为第三条边 c
                ans += (k - j - 1)
                    
        return ans
```

```Java
// java
class Solution {
    public int triangleNumber(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0;
        }
        
        Arrays.sort(nums);  // 升序
        int ans = 0;

        // 固定最短的一条边 a
        for (int i = 0; i < n - 2; i++) {
            // 如果最短边为0，则无法构成三角形
            if (nums[i] == 0) {
                continue;
            }

            int k = i + 2;  // k 指针，指向可能的 c
            // 固定第二条边 b
            for (int j = i + 1; j < n - 1; j++) {
                int target = nums[i] + nums[j];
                
                // 移动 k 指针，找到第一个不满足 a + b > c 的位置
                while (k < n && nums[k] < target) {
                    k++;
                }
                
                // 在 j 和 k 之间的所有元素都可以作为第三条边 c
                // (j+1) 到 (k-1) 的所有索引都满足条件
                ans += (k - j - 1);
            }
        }
                    
        return ans;
    }
}
```

---

能否固定中间边 $b$ 来求解呢？同样可以！

```Python
# python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return 0
        
        nums.sort()
        ans = 0

        # 固定中间的边 b
        for j in range(1, n - 1):
            if nums[j] == 0:
                continue
            
            i = 0      # 左指针，指向 a
            k = j + 1  # 右指针，指向 c
            b = nums[j]

            while i < j and k < n:
                a, c = nums[i], nums[k]
                
                if a + b > c:
                    # 这些有效的 a 的数量是 j - i
                    ans += (j - i)
                    # 尝试一个更大的 c
                    k += 1
                else:
                    # 反之，说明 a 太小了
                    i += 1
        
        return ans
```

```Java
// java
class Solution {
    public int triangleNumber(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0;
        }
        
        Arrays.sort(nums);
        int ans = 0;

        // 固定中间的边 b
        for (int j = 1; j < n - 1; j++) {
            if (nums[j] == 0) {
                continue;
            }
            
            int i = 0;      // 左指针，指向 a
            int k = j + 1;  // 右指针，指向 c
            int b = nums[j];

            while (i < j && k < n) {
                int a = nums[i];
                int c = nums[k];
                
                if (a + b > c) {
                    // 从 i 到 j-1，这些有效的 a 的数量是 j - i
                    ans += (j - i);
                    // 尝试一个更大的 c
                    k++;
                } else {
                    // 反之，说明 a 太小了
                    i++;
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/valid-triangle-number/solutions/3792606/si-jie-bao-li-pai-xu-er-fen-shuang-zhi-z-favz/)
