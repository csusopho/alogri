[Problem: 3314. 构造最小位运算数组 I](https://leetcode.cn/problems/construct-the-minimum-bitwise-array-i/description/)

### 暴力 & 位运算

必须明确一点，题目中的 $OR$ 指的是位运算 “或”，不是中文 “或者” 的意思。

如果满足 $x \text{ OR } (x + 1)= n$，则一定有 $x\le n$。比如 $1|2=3$，两个正数进行或运算，结果只会 **不变或变大**。

因此，对于 $nums$ 中的每一个 $val$，我们都可以暴力枚举 $x\in [0,val]$，判断等式 $x|(x+1) = val$ 是否成立。从小到大枚举，第一个成立的 $x$ 就是最小的 $x$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        
        for p in nums:
            found_x = -1
            # 从 0 尝试到 p
            for x in range(p + 1):
                if (x | (x + 1)) == p:
                    found_x = x
                    break  # 找到第一个就退出
            ans.append(found_x)
        
        return ans
```

```Java
// java
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            int found_x = -1;
            // 从 0 尝试到 p
            for (int x = 0; x <= p; x++) {
                if ((x | (x + 1)) == p) {
                    found_x = x;
                    break;  // 找到第一个就退出
                }
            }
            ans[i] = found_x;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n$ 是数组 $nums$ 的长度，而 $m$ 是质数最大值
- 空间复杂度： $O(1)$，返回值 $ans$ 不计入复杂度

---

### 位运算

我们先看看 `x | (x + 1)` 这个操作的本质：

假设 $x$ 的二进制表示中，**最低位的 0** 在第 $k$ 位。例如 $x = 1001\mathbf{0}111_2$，这里的最低位 $0$ 在第 $3$ 位。

那么 $x + 1$ 会将第 $0$ 到 $k-1$ 位的所有 $1$ 变成 $0$，并将第 $k$ 位的 $0$ 变成 $1$，也即 $x + 1 = 1001\mathbf{1}000_2$。

两者进行或运算，高位保持不变。

- 第 $k$ 位变成了 $1$，因为 $x+1$ 这一位是 $1$
- 第 $0$ 到 $k-1$ 位保持为 $1$，因为 $x$ 这些位是 $1$

**结论**：`x | (x + 1)` 的作用是把 $x$ 二进制表示中 **最低位** 的那个 $0$ 变成 $1$。

题目给出 $n = x \mid (x + 1)$，则 $n$ 就是把 $x$ 的最低位 $0$ 变 $1$ 后的结果。反过来说，$x$ 就是把 $n$ 中的 **某一个** $1$ 变回 $0$。

因为填补的是 $x$ 的最低位 $0$，这意味着在 $x$ 中，被变回 $0$ 的那一位的 **右边所有位** 必须原本就是 $1$。对应到 $n$ 上，这意味着我们只能改变 $n$ **末尾连续的那一串 1** 中的某一位。

我们只能在末尾连续的 $1$ 中选择一位变为 $0$，为了让结果 $x$ 最小，显然应该选择这一串连续 $1$ 中 **最高位** 的那一个。

---

如何快速找到 “末尾连续 $1$ 的最高位”？

如果 $n$ 末尾有连续的 $k$ 个 1，那么 $n + 1$ 会导致进位，使得第 $k$ 位变成 $1$，而第 $0$ 到 $k-1$ 位变成 $0$。例如 $n = 10111_2 (23)$，则 $n + 1 = 11000_2 (24)$。

而已知 `lowbit(y) = y & -y` 可以取出 $y$ 二进制中最低位的 $1$，则 `lowbit(n + 1)` 就能取出 $n+1$ 中末尾的第一个 $1$ 的位置。比如，`lowbit(24)` 是 $8 (1000_2)$。

观察后可知，我们需要消除的那个 $1$，就在 `lowbit(n + 1)` 的 **右边一位**。总结得到

$$
x = n \text{ XOR } (\text{lowbit}(n + 1) >> 1)
$$

这里的 $XOR$ 代表异或，性质为 $1$ ^ $1=0$，这里表示将 $n$ 中的那一位变为 $0$。

当 $n=2$ 时 $n+1=3$，`lowbit(3) >> 1` = $1 >> 1 = 0$，则 $x = 2 \text{ XOR } 0 = 2$。但是 $2 | 3 = 3 \neq 2$。所以 $n=2$ 时无解，返回 $-1$。这也是唯一的偶质数，其他质数都是奇数，末尾至少有一个 $1$，公式成立。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                # 取出 n+1 的最低位 1
                # 右移一位得到 n 末尾连续 1 序列的最高位
                mask = ((n + 1) & -(n + 1)) >> 1
                # 异或运算将其变为 0
                ans.append(n ^ mask)
        return ans
```

```Java
// java
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int size = nums.size();
        int[] ans = new int[size];
        for (int i = 0; i < size; i++) {
            int n = nums.get(i);
            if (n == 2) {
                ans[i] = -1;
            } else {
                // 取出 n+1 的最低位 1
                // 右移一位得到 n 末尾连续 1 序列的最高位
                int mask = ((n + 1) & -(n + 1)) >> 1;
                // 异或运算将其变为 0
                ans[i] = n ^ mask;
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，位运算时间为 $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/construct-the-minimum-bitwise-array-i/solutions/3884779/shuang-jie-bao-li-mei-ju-wei-yun-suan-yo-djz3/)
