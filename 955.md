[Problem: 955. 删列造序 II](https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/description/)

### 方法：模拟 & 剪枝

最大难点：读懂题意。

什么叫做 **字典序**？就是英文单词在字典中的先后顺序，即 $a,b,c,d\dots$

利用这种先后顺序可以去比较两个字符串的大小，举例：

- $aw$ 小于 $bb$
- $abc$ 小于 $abcd$
- $axxxxxx$ 小于 $ba$

总结：从前往后比较时， **第一个** 不同的字母谁更小，对应的那个字符串就更小。

本题的核心是删除列，但是比较的是 **相邻** $str$。比如

- 示例 $1$ 中 $ca$ 字典序大于 $bb$，所以删除第零列，删完后是 $a,b,c$ 符合要求；
- 示例 $2$ 中 $xc<yb<za$，已经满足字典序递增，不用删；
- 示例 $3$ 中 $zyx>wvu$，不满足，删除第零列后剩下  $yx,wu,sr$；但是依旧有 $yx>wu$，所以删除第一列，剩下 $x,u,r$；此时依旧不满足字典序递增，所以再删除第二列。

总的来看，如果在一列中，上元素 $x$ 大于下元素 $y$，则出现逆序对，一定要删除这一列；如果 $x=y$，则还需要比较 $x,y$ 所在两行后续元素；如果 $x<y$，则这两行无需再比较。

因此，使用数组 $sorted$ 来记录 **相邻字符串** 的状态。如果 $sorted[i] = True$，说明 $strs[i]$ 已经严格小于 $strs[i+1]$ 了，无需理会这两行后面列的元素。

> 不好理解？比如 $ax$ 与 $cb$，已经确定 $a<c$，前者字典序一定小于后者，无需比较 $x$ 与 $b$。同理 $ab$ 与 $ad$，只比较两个 $a$ 无法确定字典序。

如果某一列可以保留（没有逆序对），就需要更新 $sorted$ 数组，标记出那些 “明确小于” 的相邻对，后续不用再比较这两行。

**贪心证明**：每一列的选择「只」受前面列 “是否已分胜负” 的影响，且删除当前列是为了修正逆序，这是最小化删除次数的唯一途径。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        m = len(strs[0])
        # 判断 strs[i] 是否小于 strs[i+1]
        is_sorted = [False] * (n - 1)
        ans = 0

        # 逐列遍历
        for j in range(m):
            # 检查当前列
            can_keep = True
            for i in range(n - 1):
                # 左右还没分出大小，需要检查当前列的字符
                if not is_sorted[i]:
                    if strs[i][j] > strs[i+1][j]:
                        can_keep = False
                        break
            
            # 出现逆序，必须删除这一列
            if not can_keep:
                ans += 1
                continue
            
            # 保留这一列，更新已经严格小于的相邻对
            for i in range(n - 1):
                if strs[i][j] < strs[i+1][j]:
                    is_sorted[i] = True
        
        return ans
```

```Java
// java
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs.length;
        int m = strs[0].length();
        // 判断 strs[i] 是否小于 strs[i+1]
        boolean[] is_sorted = new boolean[n - 1];
        int ans = 0;

        // 逐列遍历
        for (int j = 0; j < m; j++) {
            // 检查当前列
            boolean can_keep = true;
            for (int i = 0; i < n - 1; i++) {
                // 左右还没分出大小，需要检查当前列的字符
                if (!is_sorted[i]) {
                    if (strs[i].charAt(j) > strs[i + 1].charAt(j)) {
                        can_keep = false;
                        break;
                    }
                }
            }

            // 出现逆序，必须删除这一列
            if (!can_keep) {
                ans++;
                continue;
            }

            // 保留这一列，更新已经严格小于的相邻对
            for (int i = 0; i < n - 1; i++) {
                if (strs[i].charAt(j) < strs[i + 1].charAt(j)) {
                    is_sorted[i] = true;
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n$ 是数组 $strs$ 的长度，每个串长为 $m$
- 空间复杂度： $O(n)$，表示数组 $sorted$ 的大小

---

### 剪枝

如果我们发现所有的相邻字符串都已经满足了 “严格小于” 的关系，即 $sorted$ 全部为 $True$，那么不再需要检查，直接跳出循环即可。

因此，使用一个存储 “尚未分出胜负的索引” 的 **集合** $Set$ 来代替布尔数组。每次只需遍历这个集合。当集合为空时，说明整体已经有序。

剪枝后，部分样例会提前终止，并减少重复计算。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        m = len(strs[0])
        
        # 存储尚未确定字典序顺序的相邻索引对 (i, i+1)
        remain_pairs = set(range(n - 1))
        ans = 0
        
        for j in range(m):
            # 检查当前列
            can_keep = False
            for i in remain_pairs:
                if strs[i][j] > strs[i+1][j]:
                    can_keep = True
                    break
            
            # 出现逆序，必须删除这一列
            if can_keep:
                ans += 1
                continue
                
            # 找出已经严格小于的相邻对
            # 不能在遍历 set 时删除元素，所以用列表记录需要移除的
            to_remove = [i for i in remain_pairs if strs[i][j] < strs[i+1][j]]
            for i in to_remove:
                remain_pairs.remove(i)
                
            # 剪枝：如果所有字符串都已经分出胜负，直接返回
            if not remain_pairs:
                return ans
        
        return ans
```

```Java
// java
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs.length;
        int m = strs[0].length();
        
        // 存储尚未确定字典序顺序的相邻索引对 (i, i+1)
        Set<Integer> remain_pairs = new HashSet<>();
        for (int i = 0; i < n - 1; i++) {
            remain_pairs.add(i);
        }
        int ans = 0;
        
        for (int j = 0; j < m; j++) {
            // 检查当前列
            boolean can_keep = false;
            for (int i : remain_pairs) {
                if (strs[i].charAt(j) > strs[i + 1].charAt(j)) {
                    can_keep = true;
                    break;
                }
            }
            
            // 出现逆序，必须删除这一列
            if (can_keep) {
                ans++;
                continue;
            }
            
            // 找出已经严格小于的相邻对
            // 不能在遍历 set 时删除元素，所以用列表记录需要移除的
            List<Integer> to_remove = new ArrayList<>();
            for (int i : remain_pairs) {
                if (strs[i].charAt(j) < strs[i + 1].charAt(j)) {
                    to_remove.add(i);
                }
            }
            for (int i : to_remove) {
                remain_pairs.remove(i);
            }
            
            // 剪枝：如果所有字符串都已经分出胜负，直接返回
            if (remain_pairs.isEmpty()) {
                return ans;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(n)$，存储索引集合

经 $Python$ 代码实测，前者空间超过 $100\%$，后者时间 $100\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/solutions/3862037/shuang-jie-jie-du-ti-yi-li-qing-xing-lie-lvx8/)
