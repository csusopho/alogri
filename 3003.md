[Problem: 3003. 执行操作后的最大分割数量](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/description/)

### 方法：记忆化搜索

分割操作是指，从 $s$ 中截取 **最长** 前缀，其中包含的不同字母数 $\leq k$。这里的 “最长”，意味着刚好不能包含 $k+1$ 个不同字符。分割一直进行，直至到达串 $s$ 末尾。

比如串 $s=ccddeef,k=2$，此时的最长前缀是 $ccdd$，截取后变为 $eef$；而 $eef$ 中恰好包含 $k$ 个不同字母，因此 $s$ 会被切分为 $2$ 段。

题目加了一项 **操作**：将串 $s$ 中某个字符修改为任意字符，这个步骤最多进行一次。我们可以选择修改/不修改，求串 $s$ 能分割为几段。

- 假设不进行修改，串 $s$ 的分割方式唯一！比如，串 $s=abccd$ 且 $k=2$，则原串会被分成 $ab,ccd$ 两段；
- 假设进行修改，串 $s$ 的分割方式依旧唯一！比如，上面的串改为 $abced$，则它会被分为 $ab,ce,d$ 三段。

也即，本题的 **难点** 在于：是否进行修改？修改哪个位置？变成什么字母？

**暴力** 想法：枚举 $[0,n-1]$ 中所有字母，每个都尝试修改为 $a$ ~ $z$ 的任意可能。找出所有修改方案中，能得到的最大答案。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)

        # 计算给定字符串的分割数
        def cal(ss):
            partitions = 0
            i = 0
            while i < len(ss):
                partitions += 1
                distinct_chars = set()
                # 从 i 开始寻找最长有效前缀
                j = i
                while j < len(ss):
                    distinct_chars.add(ss[j])
                    if len(distinct_chars) > k:
                        # 在 j 处，不同字符数首次超过 k
                        # 因此，最长有效前缀是 s[i:j]
                        # 下一次分割从 j 开始
                        i = j
                        break
                    j += 1
                
                if j == len(ss):
                    # 已经到达字符串末尾，循环结束
                    i = j
            return partitions

        # 计算原始字符串的分割数
        ans = cal(s)

        # 遍历所有可能的单字符修改
        for i in range(n):
            original_char = s[i]
            # 尝试将 s[i] 替换为 'a' 到 'z' 中的每一个字符
            for char_code in range(ord('a'), ord('z') + 1):
                new_char = chr(char_code)
                if new_char == original_char:
                    continue

                # 构建修改后的字符串
                modified_s = s[:i] + new_char + s[i+1:]
                
                # 计算新字符串的分割数
                ans = max(ans, cal(modified_s))
        
        return ans
```

枚举串 $s$ 中所有字母，每个都对应 $|\Sigma|=26$ 种修改结果，计算分割数的时间为 $O(n)$，因此总时间为 $O(n^2\times |\Sigma|)$。题目指定 $n\leq 10^4$，因此会超时，卡在 $270/277$ 样例。

---

### $DFS$

仔细想想，如果串 $s=abbdef,k=3$，对于中间的字母来说，它修改为 $ab(c/e/\dots z)def$ 任意一种，都是分成 $2$ 段。

也即，只要前面 $ab?$ 的部分计算完成，后面的结果永远不变！

上面超时的本质，也就是因为这种重复的计算，所以联想到 **备忘录/DP** 进行存储。如果将形式变为 $DFS$，那就很容易想到 **记忆化**！

- 修改是哪一个字母？
- 当前这一段已经包含多少不同字母？
- 之前是否用过 “修改” 的机会？

因此，我们 **定义** $dfs(i,mask,flag)$ 表示从前往后遍历，当前处理到第 $i$ 个位置，已经包含 $mask$ 个不同字母， $flag$ 标记是否用过，所能得到的最大分割数。

一般情况下，将 $mask$ 定义为哈希 $Set$，表示这一个段内存储了哪几种不同的字符。不过，由于要记忆化，为了方便放入 $memo$ 数组，特此采用 **位运算** 小知识。

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 或者说 $\{a,b,e\}$ 对应的二进制数为 $10011$。

使用 `|` 运算将数字放到掩码中，以及 `&` 运算判断数字是否存在。

对于当前字母 $s[i]$，

- 如果不修改它：
  - 直接加入 $mask$，导致不同字符数 $>k$，则必须重新开始一个分割段，且 $s[i]$ 是新段的起始字母，新的状态变为 $dfs(i+1,\{s[i]\},flag)$；
  - 直接加入 $mask$，不同字符数依旧 $\geq k$，则还处于同一个段内，新状态变为 $dfs(i+1,mask\bigcup \{s[i]\},flag)$。
- 如果选择修改，假设改为字符 $t$：
  - 同理，尝试加入 $mask$，如果导致不同字符数 $>k$，则必须重新开始分割段，新的状态变为 $dfs(i+1,\{t\},True)$；
  - 加入 $mask$，不同字符数 $\geq k$，则依旧同一个段，新状态是 $dfs(i+1,mask\bigcup \{j\},True)$。

注意，在上面的状态中，不修改依旧是 $flag$。因为可能修改，也可能没修改，所以保持这个状态。而尝试加入同一段，则是因为题目的贪心要求。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数有三个，所以记忆化数组需要三维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)

        # 计算 s[index:] 的最大分割数
        # 当前索引，当前分割块中不同字符的位掩码，是否修改过
        @cache
        def dfs(index, cur_mask, has_changed):
            # 边界，最后一个分割块计为1
            if index == n:
                return 1

            # 不修改 s[index]
            char_ord = ord(s[index]) - ord('a')
            no_mask = cur_mask | (1 << char_ord)

            res = 0
            # 检查将 s[index] 加入当前块后，不同字符数是否超过 k
            if bin(no_mask).count('1') > k:
                # 超过 k，必须开启一个新的分割
                # 新分割从 s[index] 开始，所以新的掩码只包含 s[index]
                res = 1 + dfs(index + 1, (1 << char_ord), has_changed)
            else:
                # 未超过 k，可以继续当前分割
                res = dfs(index + 1, no_mask, has_changed)

            # 修改 s[index]
            if not has_changed:
                # 遍历所有可能的字符 'a' 到 'z'
                for new_ord in range(26):
                    new_mask = cur_mask | (1 << new_ord)
                    
                    # 检查将修改后的字符加入当前块后，不同字符数是否超过 k
                    if bin(new_mask).count('1') > k:
                        # 超过 k，必须开启新分割
                        res = max(res, 1 + dfs(index + 1, (1 << new_ord), True))
                    else:
                        # 未超过 k，可以继续当前分割
                        res = max(res, dfs(index + 1, new_mask, True))
            return res

        return dfs(0, 0, False)
```

```Java
// java
class Solution {
    private String s;
    private int k;
    private int n;
    private Map<Integer, Integer[]>[] memo;

    public int maxPartitionsAfterOperations(String s, int k) {
        this.s = s;
        this.k = k;
        this.n = s.length();
        this.memo = new HashMap[n + 1];
        for (int i = 0; i <= n; i++) {
            memo[i] = new HashMap<>();
        }
        return dfs(0, 0, false);
    }

    // 计算 s[index:] 的最大分割数
    // 当前索引，当前分割块中不同字符的位掩码，是否修改过
    private int dfs(int index, int curMask, boolean hasChanged) {
        // 边界，最后一个分割块计为1
        if (index == n) {
            return 1;
        }

        // 检查备忘录
        int changedIndex = hasChanged ? 1 : 0;
        if (memo[index].containsKey(curMask) && memo[index].get(curMask)[changedIndex] != null) {
            return memo[index].get(curMask)[changedIndex];
        }

        // 不修改 s[index]
        int charOrd = s.charAt(index) - 'a';
        int noMask = curMask | (1 << charOrd);

        int res = 0;
        // 检查将 s[index] 加入当前块后，不同字符数是否超过 k
        if (Integer.bitCount(noMask) > k) {
            // 超过 k，必须开启一个新的分割
            // 新分割从 s[index] 开始，所以新的掩码只包含 s[index]
            res = 1 + dfs(index + 1, (1 << charOrd), hasChanged);
        } else {
            // 未超过 k，可以继续当前分割
            res = dfs(index + 1, noMask, hasChanged);
        }

        // 修改 s[index]
        if (!hasChanged) {
            // 遍历所有可能的字符 'a' 到 'z'
            for (int newOrd = 0; newOrd < 26; newOrd++) {
                int newMask = curMask | (1 << newOrd);
                
                // 检查将修改后的字符加入当前块后，不同字符数是否超过 k
                if (Integer.bitCount(newMask) > k) {
                    // 超过 k，必须开启新分割
                    res = Math.max(res, 1 + dfs(index + 1, (1 << newOrd), true));
                } else {
                    // 未超过 k，可以继续当前分割
                    res = Math.max(res, dfs(index + 1, newMask, true));
                }
            }
        }

        // 将结果存入备忘录
        memo[index].putIfAbsent(curMask, new Integer[2]);
        memo[index].get(curMask)[changedIndex] = res;

        return res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。这个 $mask$ 范围很大，难道是 $2^{26}$ 次方？并非。

没修改过字母，则直接加入，分割方式唯一，状态只有 $O(n)$ 个，单个状态的计算时间为 $O(|\Sigma|)$。

反之，如果修改过，因为集合中最多 $k$ 个不同字符，加入 $mask$ 后，至多会产生 $O(k)$ 个不同的 $mask$。选择任意位置修改，由于记忆化，只有 $O(k)$ 个本质不同的修改位置，每个位置至多有 $|\Sigma|$ 种不同的修改方式。从小到大进行枚举，所以每个 $i$ 都对应 $O(k|\Sigma|)$ 个 $mask$。不能再次修改，单个状态的计算时间为 $O(1)$。

- 时间复杂度： $O(nk|\Sigma|)$
- 空间复杂度： $O(nk|\Sigma|)$，保存多少状态，就需要多少空间

由于 $1<<26$ 的存在，直接改写为 $DP$ 非常困难。本题的其他解法，同理逻辑，将 $DP$ 定义为后缀/前缀的分割结果，然后采用二分/枚举。这次的官解很通人性，灵神的题解依旧完美，可以去查看这些。有其他问题，欢迎评论区留言。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/solutions/3808727/dfs-bao-li-ji-yi-hua-sou-suo-wei-yun-sua-7fg4/)
