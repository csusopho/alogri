[Problem: 2975. 移除栅栏得到的正方形田地的最大面积](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/description/)

### 暴力 & 优化

到底移走哪一条？别想复杂，只需要考虑剩下的正方形边长！

要形成正方形，需要找到相同的 **水平间距** 和 **垂直间距**。

因此，我们收集所有可能的分割线：

- 水平方向：包括边界 $1$ 和 $m$，以及所有 $hFences$；
- 垂直方向：包括边界 $1$ 和 $n$，以及所有 $vFences$。

然后，计算所有可能的间距：

- 水平间距：任意两个水平分割线之间的距离
- 垂直间距：任意两个垂直分割线之间的距离

正方形的边长必须同时出现在水平间距和垂直间距中，那么找到最大的 **公共间距**，其平方就是最大正方形面积。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
        MOD = 10**9 + 7
        
        # 添加边界栅栏并排序
        hFences = [1, m] + hFences
        vFences = [1, n] + vFences
        hFences.sort()
        vFences.sort()
        
        # 计算所有可能的水平间距
        horizontal_gaps = set()
        for i in range(len(hFences)):
            for j in range(i + 1, len(hFences)):
                gap = hFences[j] - hFences[i]
                horizontal_gaps.add(gap)
        
        # 计算所有可能的垂直间距
        vertical_gaps = set()
        for i in range(len(vFences)):
            for j in range(i + 1, len(vFences)):
                gap = vFences[j] - vFences[i]
                vertical_gaps.add(gap)
        
        # 找到最大的公共间距
        common_gaps = horizontal_gaps & vertical_gaps  # 集合交集
        
        if not common_gaps:
            return -1
        
        max_side = max(common_gaps)
        return (max_side * max_side) % MOD
```

```Java
// java
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        final int MOD = (int) 1e9 + 7;
        
        // 添加边界栅栏并排序
        List<Integer> hFencesList = new ArrayList<>();
        hFencesList.add(1);
        hFencesList.add(m);
        for (int fence : hFences) {
            hFencesList.add(fence);
        }
        Collections.sort(hFencesList);
        
        List<Integer> vFencesList = new ArrayList<>();
        vFencesList.add(1);
        vFencesList.add(n);
        for (int fence : vFences) {
            vFencesList.add(fence);
        }
        Collections.sort(vFencesList);
        
        // 计算所有可能的水平间距
        Set<Integer> horizontal_gaps = new HashSet<>();
        for (int i = 0; i < hFencesList.size(); i++) {
            for (int j = i + 1; j < hFencesList.size(); j++) {
                int gap = hFencesList.get(j) - hFencesList.get(i);
                horizontal_gaps.add(gap);
            }
        }
        
        // 计算所有可能的垂直间距
        Set<Integer> vertical_gaps = new HashSet<>();
        for (int i = 0; i < vFencesList.size(); i++) {
            for (int j = i + 1; j < vFencesList.size(); j++) {
                int gap = vFencesList.get(j) - vFencesList.get(i);
                vertical_gaps.add(gap);
            }
        }
        
        // 找到最大的公共间距
        Set<Integer> common_gaps = new HashSet<>(horizontal_gaps);
        common_gaps.retainAll(vertical_gaps);  // 求交集
        
        if (common_gaps.isEmpty()) {
            return -1;
        }
        
        int max_side = Collections.max(common_gaps);
        return (int) ((long) max_side * max_side % MOD);
    }
}
```

- 时间复杂度： $O(h^2+v^2)$，其中 $v,h$ 分别表示数组 $hFences,vFences$ 的长度
- 空间复杂度： $O(h^2+v^2)$，表示两个哈希集合 $set$ 的大小

---

### 优化

上面是正统的 “三步走”，其实可以将最后两步融合，一边寻找垂直间距，一边更新最大公共间距，从而节省时间。经实测，两段 $Python$ 耗时从 $1674ms\to 1011ms$，超过 $96\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
        MOD = 10**9 + 7
        # 处理水平方向的栅栏
        hFences.extend([1, m])
        hFences.sort()

        # 存储所有可能的水平方向间距
        horizontal_gaps = set()
        for i in range(len(hFences)):
            for j in range(i + 1, len(hFences)):
                gap = hFences[j] - hFences[i]
                horizontal_gaps.add(gap)
        
        # 处理垂直方向的栅栏
        vFences.extend([1, n])
        vFences.sort()
        max_side = -1
        
        # 寻找最大公共边长
        for i, start in enumerate(vFences):
            for j in range(i + 1, len(vFences)):
                gap = vFences[j] - start
                # 该间距在水平方向也存在，并且比当前记录的最大边长更大
                if gap > max_side and gap in horizontal_gaps:
                    max_side = gap
        
        return (max_side * max_side) % MOD if max_side > 0 else -1
```

```Java
// java
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        final int MOD = (int) 1e9 + 7;
        
        // 处理水平方向的栅栏
        List<Integer> hFencesList = new ArrayList<>();
        hFencesList.add(1);
        hFencesList.add(m);
        for (int fence : hFences) {
            hFencesList.add(fence);
        }
        Collections.sort(hFencesList);
        
        // 存储所有可能的水平方向间距
        Set<Integer> horizontal_gaps = new HashSet<>();
        for (int i = 0; i < hFencesList.size(); i++) {
            for (int j = i + 1; j < hFencesList.size(); j++) {
                int gap = hFencesList.get(j) - hFencesList.get(i);
                horizontal_gaps.add(gap);
            }
        }
        
        // 处理垂直方向的栅栏
        List<Integer> vFencesList = new ArrayList<>();
        vFencesList.add(1);
        vFencesList.add(n);
        for (int fence : vFences) {
            vFencesList.add(fence);
        }
        Collections.sort(vFencesList);
        int max_side = -1;
        
        // 寻找最大公共边长
        for (int i = 0; i < vFencesList.size(); i++) {
            for (int j = i + 1; j < vFencesList.size(); j++) {
                int gap = vFencesList.get(j) - vFencesList.get(i);
                // 该间距在水平方向也存在，并且比当前记录的最大边长更大
                if (gap > max_side && horizontal_gaps.contains(gap)) {
                    max_side = gap;
                }
            }
        }
        
        return max_side > 0 ? (int) ((long) max_side * max_side % MOD) : -1;
    }
}
```

- 时间复杂度： $O(h^2+v^2)$
- 空间复杂度： $O(h^2+v)$，省去一个哈希

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/solutions/3881923/bao-li-mei-ju-zheng-fang-xiang-bian-chan-zzco/)
