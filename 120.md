[Problem: 120. 三角形最小路径和](https://leetcode.cn/problems/triangle/description/)

### 方法：记忆化搜索 & 动规 & 空间优化

这样看，不好理解？

```Java
   2
  3 4
 6 5 7
4 1 8 3
```

把它拉直，再看看呢？

```Java
值                对应下标
2                 (0,0)
3 4               (1,0), (1,1)
6 5 7             (2,0), (2,1), (2,2)
4 1 8 3           (3,0), (3,1), (3,2), (3,3)
```

如果当前坐标位于 $(i,j)$，向下一步就能移动到 $(i+1,j)$ 以及 $(i+1,j+1)$ 中任意节点。

如果三角形总共 $n$ 行，每一步都是向下移动一行，那么 **总步数** 为 $n-1$。假设当前的位置在 $(i,j)$ 处，还需要移动 $k$ 次。向下移动一次后，离底部更近，只剩下 $k-1$ 次移动。

这意味着，在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

**定义** $dfs(i,j)$ 表示从 $(i,j)$ 位置开始移动，到达最终行后，得到的最小路径和。

**转移过程**：对于当前位置 $(i,j)$ 来说，它可能向下跳到 $(i+1,j)$，也可能向右下跳到 $(i+1,j+1)$。父路径 = 子路径 + 当前格子。得到下面的状态转移方程：

$$
dfs(i,j) = min\left(dfs(i+1,j),dfs(i+1,j+1)\right)+triangle[i][j]
$$

**递归入口**： $dfs(0,0)$，表示从起点开始，跳到终点的总路径和。

**递归边界**： $i=n$ 说明已经走完 $[0,n-1]$ 的所有行，返回 $0$ 表示方案结束。

> 注意，这里直接 $DFS$ 会超时。

### 记忆化

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有两个，所以记忆化数组需要两维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

题目指定总方案数 $n\leq 200$，所以可以用 $int$ 进行记录。

记忆化数组的初始值只要不等于某个 $dfs$ 的状态值即可，这里不能直接赋值为 $0$ 或 $-1$！因为数组中的值可能为负数，所以用 $+-\infty$ 更合适。

实现上面的过程，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)

        # 计算从 (row, col) 到达底部的最小路径和
        @cache
        def dfs(row, col):
            # 全部走完
            if row == n - 1:
                return triangle[row][col]

            # 递归计算下一层两个节点的最小路径和
            path_down = dfs(row + 1, col)
            path_right = dfs(row + 1, col + 1)

            # 返回当前节点值与下一行较小的路径和之和
            return triangle[row][col] + min(path_down, path_right)

        # 从三角形顶部 (0, 0) 开始搜索
        return dfs(0, 0)
```

```Java
// java
class Solution {
    private int[][] memo; // 记忆化数组

    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        memo = new int[n][n];

        // 将 memo 数组初始化为正无穷
        for (int i = 0; i < n; i++) {
            Arrays.fill(memo[i], Integer.MAX_VALUE);
        }

        // 从三角形顶部 (0, 0) 开始搜索
        return dfs(0, 0, triangle);
    }

    // 计算从 (row, col) 到达底部的最小路径和
    private int dfs(int row, int col, List<List<Integer>> triangle) {
        // 全部走完
        if (row == triangle.size() - 1) {
            return triangle.get(row).get(col);
        }

        // 已经记录，避免重复计算
        if (memo[row][col] != Integer.MAX_VALUE) {
            return memo[row][col];
        }

        // 递归计算下一层两个节点的最小路径和
        int path_down = dfs(row + 1, col, triangle);
        int path_right = dfs(row + 1, col + 1, triangle);

        // 返回当前节点值与下一行较小的路径和之和，并存入 memo
        memo[row][col] = triangle.get(row).get(col) + Math.min(path_down, path_right);
        return memo[row][col];
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(n^2)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n^2)$。

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $triangle$ 的长度
- 空间复杂度： $O(n^2)$，保存多少状态，就需要多少空间

---

### 动态规划

将递归 $1:1$ 转化为递推。

同理，**定义** $dp[i][j]$ 表示从点 $(i,j)$ 出发，到达三角形底部的最小路径和。

**状态转移方程**：

$$
dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])
$$

**方向**：注意， $dp[i]$ 的值需要状态 $dp[i+1]$ 的值，所以第一维要倒序枚举！

有的小伙伴可能难以理解？！将记忆化搜索（自顶向下）改成动态规划的迭代写法（自底向上）时，之所以要 “倒序”（即从三角形的底部开始向上计算），根本原因在于 **状态的依赖关系** 和 **初始状态的确定性**。

递归的逻辑是：**一个父问题的解，依赖于其子问题的解**。 $dfs(0,0)$ 依赖 $dfs(1,0)$ 和 $dfs(1,1)$，以此类推，直到最底层的基本情况。

动态规划的迭代思想是反过来的。我们不再从未知的大问题开始，而是从 **最简单、已知的子问题** 开始，然后利用这些解来构建出更大问题的解，直到最终解决我们关心的大问题。

在这个三角形问题中，最简单的、解是确定的子问题是什么？

答案是：**最后一行的所有节点**。

如果我们问：“从最后一行的某个节点 $(n-1, j)$ 出发，到达底部的最小路径和是多少？”
答案非常明确：就是节点 $(n-1, j)$ 本身的值，因为你已经到底部了，没有其他路径了。

这就是我们 **确定的初始状态**。

为什么必须“倒序”？核心：**为了在计算当前状态时，它所依赖的状态已经被计算出来了。**

上面的转移方程告诉我们：想要求出第 $i$ 行某个状态的解，你 **必须** 先知道第 $i+1$ 行相关状态的解。

- 要计算 $dp[倒数第二行]$，你需要 $dp[最后一行]$ 的值。
- 要计算 $dp[倒数第三行]$，你需要 $dp[倒数第二行]$ 的值。
- ...
- 要计算 $dp[第一行]$ (也就是 $dp[0][0]$)，你需要 $dp[第二行]$ 的值。

这就形成了一个清晰的计算顺序：**必须从最后一行开始，逐层向上计算，直到第一行。** 这就是 “倒序” 的原因。

这里不再举例证明。那么，如果我不想 “倒序” 怎么办？正序迭代怎么做？

如果我们尝试从上到下迭代，状态定义就必须改变。比如，我们定义 $dp[i][j]$ 为 **从顶部 $(0, 0)$ 到达点 $(i, j)$ 的最小路径和**。

状态转移方程会变成：

$$
dp[i][j] = triangle[i][j] + min(dp[i-1][j-1], dp[i-1][j])
$$

这个方法也是可行的！但需要处理一些边界条件。比如 $j=0$ 时，$dp[i-1][j-1]$ 导致的越界问题。

总结：“倒序” 是为了保证在计算任何一个状态 $dp[i][j]$ 时，它所依赖的 **后继状态** $dp[i+1][\dots]$ 都已经是 **已知的、计算完毕的**。这是动态规划迭代解法的基本要求。

使用 “倒序” 解题更加方便，无需处理边界问题。并且直接从 $DFS$ 转化，更容易想到转移方程，因此这里使用 “倒序” 解法。“正序” 解法也比较简单，欢迎评论区留言。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        # dp[i][j] 表示从点 (i,j) 出发，到达三角形底部的最小路径和
        n = len(triangle)
        dp = [[0] * (n + 1) for _ in range(n + 1)]

        for i in range(len(triangle) - 1, -1, -1):  # 倒序遍历！
            cur_row = triangle[i]
            for j in range(len(cur_row)):  # 正向遍历这一行
                dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + cur_row[j]
        
        return dp[0][0]
```

```Java
// java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        // dp[i][j] 表示从点 (i,j) 出发，到达三角形底部的最小路径和
        int n = triangle.size();
        int[][] dp = new int[n + 1][n + 1];

        for (int i = n - 1; i >= 0; i--) {  // 倒序遍历！
            List<Integer> cur_row = triangle.get(i);
            for (int j = 0; j < cur_row.size(); j++) {  // 正向遍历这一行
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + cur_row.get(j);
            }
        }
        
        return dp[0][0];
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $triangle$ 的长度
- 空间复杂度： $O(n^2)$，表示数组 $dp$ 的空间

---

### 空间优化

可以发现，计算状态 $dp[i][j]$ 时，只会用到 $dp[i+1][j]$ 以及 $dp[i+1][j+1]$ 的值，不会用到比 $i+1$ 更早的状态。可以使用滚动数组，优化掉第一维。

使用 $prev$ 数组存储 **上一轮** 的 $dp[i+1]$ 状态，以及 $curr$ 数组存储 **当前轮** 的 $dp[i]$ 状态。

**状态转移方程**：

$$
curr[j] = triangle[i][j] + min(prev[j], prev[j+1])
$$

递推完一轮后，交换 $prev$ 与 $curr$ 就能达到 **滚动** 的效果。**本质**：将一个 $dp$ 矩阵进行缩减，只保留需要的两行。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)

        # prev_row 数组用于存储 dp[i+1] 的状态（即下一行的最小路径和）
        # curr_row 数组用于存储 dp[i] 的状态（即当前行的最小路径和）
        prev_row = [0] * (n + 1)
        curr_row = [0] * (n + 1)

        for i in range(n - 1, -1, -1):  # 倒序
            for j in range(i + 1):  # 正序
                curr_row[j] = min(prev_row[j], prev_row[j + 1]) + triangle[i][j]
            
            # 将 curr_row 数组的状态复制给 prev_row 数组
            prev_row = curr_row[:]
        
        # 循环结束后，i=0 时 curr_row 的计算结果被复制给了 prev_row
        return prev_row[0]
```

```Java
// java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();

        // prev 数组用于存储 dp[i+1] 的状态（即下一行的最小路径和）
        // curr 数组用于存储 dp[i] 的状态（即当前行的最小路径和）
        int[] prev = new int[n + 1]; 
        int[] curr = new int[n + 1];

        for (int i = n - 1; i >= 0; i--) {  // 倒序
            for (int j = 0; j <= i; j++) {  // 正序
                curr[j] = Math.min(prev[j], prev[j + 1]) + triangle.get(i).get(j);
            }
            
            // 将 curr 数组的状态复制给 prev 数组
            // 在下一轮迭代中，当前的 curr 数组就变成了 "下一行" 的 prev 数组
            System.arraycopy(curr, 0, prev, 0, n + 1);
        }
        
        // curr[0] 转移给了 prev[0]
        return prev[0];
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$，表示数组 $prev,curr$ 的空间

---

$prev$ 数组表示没更新的 $dp[i+1]$， $curr$ 数组表示已更新的 $dp[i]$。仔细对比两个方程的差别，完全可以看作 **第一维省略** 而已。因此，方程可以变为：

$$
dp[j] = triangle[i][j] + min(dp[j], dp[j+1])
$$

其中，左边的新 $dp$ 代表第 $i$ 行的值，而右边的旧 $dp$ 表示第 $i+1$ 行的值。本质还是上一轮 -> 下一轮，只不过换成在 $dp$ 上进行，无需额外定义数组。

**本质**：俩数组更新前后的值存储到 $dp[j+1]$ 以及 $dp[j]$ 中。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        dp = [0] * (n + 1)  # 去掉第一维空间

        for i in range(n - 1, -1, -1):  # 倒序
            for j in range(i + 1):  # 正序
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
        
        return dp[0]
```

```Java
// java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[] dp = new int[n + 1]; // 去掉第一维空间

        for (int i = n - 1; i >= 0; i--) { // 倒序
            for (int j = 0; j <= i; j++) { // 正序
                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
            }
        }
        
        return dp[0];
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$

---

### 原地修改

发现一个现象，使用完 $triangle[i][j]$ 后，不会再次使用它。

因此，我们可以将 $triangle$ 数组当作 $dp$ 数组！这样一来，更新前格子是原本值，更新后就变为 $dp$ 值，非常方便。

一般不推荐这种写法，因为实际工程中不缺这点空间，反而会污染数据。如果在笔试中写出这种解法，面试官可能还会询问原因。

代码如下：

```Python
# python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])
        return triangle[0][0]
```

```Java
// java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        for (int i = triangle.size() - 2; i >= 0; i--) {
            for (int j = 0; j < triangle.get(i).size(); j++) {
                int minSum = triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1));
                triangle.get(i).set(j, minSum);
            }
        }
        return triangle.get(0).get(0);
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/triangle/solutions/3791747/wu-jie-ji-yi-hua-dfser-wei-dpkong-jian-y-19gq/)
