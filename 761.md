[Problem: 761. 特殊的二进制字符串](https://leetcode.cn/problems/special-binary-string/description/)

### 方法：递归

为了方便理解，我们可以利用 **“括号匹配”** 的模型来解释这个问题。

先来看看前缀码。对于串 $1100$，它的前缀码有 $1,11,110,1100$。那么，什么叫做 “特殊的二进制字符串”？前缀 $1$ 更多，总 $0,1$ 数量相同，这完全等价于 **有效的括号序列**：

- 将 $1$ 看作左括号 $($
- 将 $0$ 看作右括号 $)$

例如：

- $10 \rightarrow ()$
- $1100 \rightarrow (())$
- $1010 \rightarrow ()()$

题目允许交换两个 **连续的** 特殊子串。这意味着，如果有一串连续的平衡括号块，例如 $A$ 和 $B$ 是相邻的，即 $AB$，我们可以把它们交换成 $BA$。

既然可以 **任意** 交换相邻的块，这就意味着对于同一层级的多个特殊子串，例如 $ABCD$，我们可以通过 **冒泡排序** 的方式，将它们排列成任意顺序。

为了得到字典序最大的字符串，需要让 $1$ 尽可能靠前。因此，得到一个 **贪心** 策略：将这些子串按照字典序从大到小排序。

---

任何一个非空的 “特殊” 二进制字符串，一定是以 $1$ 开头，以 $0$ 结尾的。也即 $1$ + 中间部分 + $0$，对应的括号形态是：

$$
( + 内部 + )
$$

例如 $11011000$ 可以看作 $1$ + $101100$ + $0$。

> 反之，如果以 $0$ 开头，或者以 $1$ 结尾。比如 $01$，那一定不是特殊字符串！

为了使整体的字典序最大，我们需要以 **两种角度** 看待本题：

- 小范围：对于 “特殊子串” 内部，可以优化为更大的字典序，比如 $1010$ 变为 $1100$。让特殊子串字典序最大？那就是本题这个函数！
- 大范围：整体是多个 “特殊子串” 比如 $ABCD$ 拼接的形式。为了让整体最大，那就按照字典序排序，变为 $BADC$ 等形式。

这就是 **递归** 的核心思想，大问题拆解为小问题，处理好小问题，大问题也迎刃而解。

总的来看，本题一共分为四步：

1. **拆分**：找出当前串的所有不可拆分的特殊子串，例如 $S = A + B + C$。
2. **递归**：对于每一个子串，剥去首尾的 $1$ 和 $0$，对其内部进行同样的 $DFS$ 操作，然后再把 $1$ 和 $0$ 加到返回结果上。
3. **排序**：将处理好的子串列表 $[A, B, C]$ 按字典序降序排列。
4. **合并**：将排序后的子串，拼接成一个新的字符串返回。

代码如下，已附加注释：

```Python
# python
class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        # 递归边界
        if not s:
            return ""
        
        # 存储当前层级拆分出的所有特殊子串
        substrings = []
        
        count = 0  # 计数，遇到1就+1，遇到0就-1
        start = 0  # 当前子串的起始索引
        
        # 枚举拆分位置
        for i, char in enumerate(s):
            count += 1 if char == '1' else -1
            
            # 此时，找到了一个完整的特殊子串
            if count == 0:
                # 当前子串必定是 "1" + "内部" + "0" 的形式
                inner = s[start+1 : i]
                # 递归处理中间，让中间字典序最大
                optimized_inner = self.makeLargestSpecial(inner)
                # 重新包上 1 和 0
                substrings.append("1" + optimized_inner + "0")
                # 下一个子串的起始位置
                start = i + 1
        
        # 所有子串按字典序降序排列
        substrings.sort(reverse=True)
        # 合并
        return "".join(substrings)
```

```Java
// java
class Solution {
    public String makeLargestSpecial(String s) {
        // 递归边界
        if (s.length() == 0) {
            return "";
        }
        
        // 存储当前层级拆分出的所有特殊子串
        List<String> substrings = new ArrayList<>();
        
        int count = 0;  // 计数，遇到1就+1，遇到0就-1
        int start = 0;  // 当前子串的起始索引
        
        // 枚举拆分位置
        for (int i = 0; i < s.length(); i++) {
            count += (s.charAt(i) == '1') ? 1 : -1;
            
            // 此时，找到了一个完整的特殊子串
            if (count == 0) {
                // 当前子串必定是 "1" + "内部" + "0" 的形式
                String inner = s.substring(start + 1, i);
                // 递归处理中间，让中间字典序最大
                String optimizedInner = makeLargestSpecial(inner);
                // 重新包上 1 和 0
                substrings.add("1" + optimizedInner + "0");
                // 下一个子串的起始位置
                start = i + 1;
            }
        }
        
        // 所有子串按字典序降序排列
        Collections.sort(substrings, Collections.reverseOrder());
        // 合并
        return String.join("", substrings);
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为字符串 $s$ 的长度，每一层处理 $O(n)$ 级别的子串，总运算量相当于等差数列求和
- 空间复杂度： $O(n^2)$，递归深度为 $O(n)$，最坏情况下递归嵌套，内存中同时存在 $n,n-2,\dots$ 的字符串对象等待递归返回

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/special-binary-string/solutions/3905113/di-gui-gua-hao-pi-pei-zhu-ceng-chu-li-ch-gn56/)
