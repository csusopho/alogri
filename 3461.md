[Problem: 3461. 判断操作后字符串中的数字是否相等 I](https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/description/)

### 方法：模拟 & 数学

题意比较清晰，就是相邻的两个数字相加，直接看示例 $1$ 就能明白。

直接模拟，代码如下，已附加注释：

```Python
# python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2:
            # 下一轮迭代的新字符串
            next_s = []
            # 每一对相邻数字
            for i in range(len(s) - 1):
                num1 = int(s[i])
                num2 = int(s[i+1])
                sum_mod = (num1 + num2) % 10
                # 拼接
                next_s.append(sum_mod)
            
            # 替换
            s = "".join(map(str, next_s))
        
        # 检查
        return s[0] == s[1]
```

```Java
// java
class Solution {
    public boolean hasSameDigits(String s) {
        while (s.length() > 2) {
            // 下一轮迭代的新字符串
            StringBuilder nextSBuilder = new StringBuilder();
            
            // 每一对相邻数字
            for (int i = 0; i < s.length() - 1; i++) {
                int num1 = s.charAt(i) - '0';
                int num2 = s.charAt(i + 1) - '0';
                int sumMod = (num1 + num2) % 10;
                // 拼接
                nextSBuilder.append(sumMod);
            }
            
            // 替换旧串
            s = nextSBuilder.toString();
        }
        
        // 检查
        return s.charAt(0) == s.charAt(1);
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是字符串 $s$ 的长度
- 空间复杂度： $O(n)$，表示中间列表 $nextS$ 的长度

---

### 优化

每一轮计算完成后，都重新拼接回字符串，其实完全没必要。可以一直放在列表中，从头到尾只与数字相关，省去这个 $O(n)$ 的转化时间。

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        s_list = [int(char) for char in s]

        while len(s_list) > 2:
            # 下一轮
            next_list = []
            
            for i in range(len(s_list) - 1):
                new_digit = (s_list[i] + s_list[i+1]) % 10
                next_list.append(new_digit)
            
            # 替换
            s_list = next_list
            
        # 比较
        return s_list[0] == s_list[1]
```

```Java
// java
class Solution {
    public boolean hasSameDigits(String s) {
        // 转为整数列表
        List<Integer> sList = new ArrayList<>();
        for (char c : s.toCharArray()) {
            sList.add(c - '0');
        }

        while (sList.size() > 2) {
            // 下一轮
            List<Integer> nextList = new ArrayList<>();

            for (int i = 0; i < sList.size() - 1; i++) {
                int newDigit = (sList.get(i) + sList.get(i + 1)) % 10;
                nextList.add(newDigit);
            }
            
            // 替换
            sList = nextList;
        }
            
        // 比较
        return sList.get(0) == sList.get(1);
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$

---

### 数学

**观察规律**：假设初始字符串是 $s = [a, b, c, d]$，

- 第 $1$ 轮后，得到 $[(a+b), (b+c), (c+d)]$
- 第 $2$ 轮后，得到 $[(a+b) + (b+c), (b+c) + (c+d)]$，也即 $[a + 2b + c,  b + 2c + d]$

观察这两个最终数字的构成：

- 第一个数字 $a + 2b + c$ 是由 $s$ 的前三个数字 $a, b, c$ 构成的，系数是 $1, 2, 1$
- 第二个数字 $b + 2c + d$ 是由 $s$ 的后三个数字 $b, c, d$ 构成的，系数也是 $1, 2, 1$。

系数 $1, 2, 1$ 正是二项式 $(x+y)^2$ 展开后的系数，即 **二项式系数** $C(2,0), C(2,1), C(2,2)$。

将这个规律进行 **推广**：对于一个长度为 $L$ 的初始字符串，经过 $L-2$ 轮操作后，会剩下两个数字。令 $n = L - 1$。

- 最终的 **第一个数字**，是原始数字 $s[0], s[1], ..., s[n-1]$ 的加权和，权重为二项式系数 $C(n-1, 0), C(n-1, 1), ..., C(n-1, n-1)$。也即

$$
Final1 = (s[0] * C(n-1, 0) + s[1] * C(n-1, 1) + ... + s[n-1] * C(n-1, n-1))\mod 10
$$

- 最终的 **第二个数字**，是原始数字 $s[1], s[2], ..., s[n]$ 的加权和，权重也是相同的二项式系数。也即

$$
Final2 = (s[1] * C(n-1, 0) + s[2] * C(n-1, 1) + ... + s[n] * C(n-1, n-1))\mod 10
$$

其中，我们可以利用 $C(n, k+1) = C(n, k) * (n-k) / (k+1)$ 这个递推性质，**高效地** 计算这些二项式系数 $C(n-1, i)$，从而避免了每次都从头计算阶乘。

**总结**：重复的相邻求和过程，在数学上等价于用 **二项式系数**（帕斯卡三角中的数字）作为权重，对原始数字进行加权求和。

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        n = len(s) - 1 
        # 存储当前的二项式系数 C(n-1, i)
        cur = 1
        sum1, sum2 = 0, 0 

        # 循环计算加权和
        for i in range(n):
            # 权重是当前的二项式系数 cur
            sum1 = (sum1 + int(s[i]) * cur) % 10
            sum2 = (sum2 + int(s[i+1]) * cur) % 10

            # 高效更新二项式系数
            if i < n - 1:
                cur = cur * (n - (i + 1)) // (i + 1)
        
        # 比较
        return sum1 == sum2
```

```Java
// java
class Solution {
    public boolean hasSameDigits(String s) {
        int n = s.length() - 1;
        // 存储当前的二项式系数 C(n-1, i)，用 long 防止溢出
        long cur = 1;
        int sum1 = 0, sum2 = 0;

        // 循环计算加权和
        for (int i = 0; i < n; i++) {
            // 权重是当前的二项式系数 cur
            sum1 = (int)((sum1 + (s.charAt(i) - '0') * cur) % 10);
            sum2 = (int)((sum2 + (s.charAt(i + 1) - '0') * cur) % 10);

            // 高效更新二项式系数
            if (i < n - 1) {
                cur = cur * (n - (i + 1)) / (i + 1);
            }
        }
        
        // 比较
        return sum1 == sum2;
    }
}
```

- 时间复杂度： $O(n)$，计算系数的时间为 $O(1)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/solutions/3813683/san-jie-mo-ni-you-hua-er-xiang-shi-ding-2gg5m/)
