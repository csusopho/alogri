[Problem: 3025. 人员站位的方案数 I](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/description/)

### 方法：暴力 & 排序

长度为 $n$ 的数组中，一共有 $n\times(n-1)/2$ 个点对。假设点对为 $(a,b)$，必须确保点 $a$ 在坐标系中处于点 $b$ 的左上角。

下面看一个正确示例：

```Java
↑
|
|    x(2,7)
|
|
|        x(4,4)
|
|
|
O — — — — — — — — — — — —→
```

如果点 $a$ 的坐标为 $(x1,y1)$，点 $b$ 的坐标为 $(x2,y2)$。处于左上角，则有

$$
x1\leq x2,y1\geq y2
$$

同时，我们还要确保中间不能有其他点，下面看一个错误示例：

```Java
↑
|
|    a(2,7)
|
|
|        c(4,4)
|
|
|            b(6,1)
O — — — — — — — — — — — —→
```

那么，如果中间夹杂一个其余的点 $c(x3,y3)$，则有

$$
x1\leq x3\leq x2,y1\geq y3\geq y2
$$

所以，我们必须增加一个 $for$ 循环，确保其他点不在这两者之间。

**暴力** 做法：检查所有点对，然后判断两两之间是否符合上述要求。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        n = len(points)
        ans = 0
        for i in range(n):
            for j in range(n):
                if i == j:  # 跳过相同的点
                    continue
                x1, y1 = points[i]
                x2, y2 = points[j]
                # 检查点i是否在点j的右上方
                if y1 >= y2 and x1 <= x2:
                    flag = 1  # 标记位
                    for k in range(n):
                        if k != i and k != j:  # 跳过当前比较的两个点
                            x, y = points[k]
                            # 检查是否存在其他点在这个矩形区域内
                            if (y1 >= y >= y2) and (x1 <= x <= x2):
                                flag = 0  # 存在其他点，标记为无效
                                break
                    ans += flag  # 如果没有其他点，则计数+1
        return ans
```

```Java
// java
class Solution {
    public int numberOfPairs(int[][] points) {
        int n = points.length;
        int ans = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {  
                    // 跳过相同的点
                    continue;
                }

                int x1 = points[i][0], y1 = points[i][1];
                int x2 = points[j][0], y2 = points[j][1];

                // 检查点 i 是否在点 j 的右上方
                if (y1 >= y2 && x1 <= x2) {
                    int flag = 1;  // 标记位

                    for (int k = 0; k < n; k++) {
                        if (k != i && k != j) {  
                            // 跳过当前比较的两个点
                            int x = points[k][0], y = points[k][1];

                            // 检查是否存在其他点在这个矩形区域内
                            if ((y1 >= y && y >= y2) && (x1 <= x && x <= x2)) {
                                flag = 0;  // 存在其他点，标记为无效
                                break;
                            }
                        }
                    }

                    ans += flag;  // 如果没有其他点，则计数 +1
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^3)$，其中 $n$ 为数组 $points$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

所有点没有顺序，所以需要检查所有 **三元组**。有什么办法，只检查 **两元组** 呢？因此使用 **排序**，强制让这些点具有顺序。规则是：

$\textbf{让第一维 x 坐标递增，且第二维 y 坐标递减。}$

如此一来，双 $for$ 遍历就能确保点 $a$ 一定在点 $b$ 的左上角。那么，如何不让点 $c$ 进来骚扰呢？

由于我们是从前往后遍历，且排过序，所以新的点一定比旧的点 *横坐标* $x$ 更大。看看前面的示例，在 $x$ 值已经更大的情况下，如果不想包裹其他点，必须让点 $b$ 的纵坐标比点 $c$ 的 **更大**！也即

```Java
↑
|
|    a(2,7)
|
|
|            c(6,4)
|
|
|        b(4,1)
O — — — — — — — — — — — —→
```

此时，才能保证 $a,b$ 中间不包含其他点。具体来说，就是让新的点 $b$ 的总坐标 $y2$ 永远大于之前遍历过的 $maxY2$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        # 按照 x 升序排序，若 x 相同则按照 y 降序排序
        points.sort(key=lambda p: (p[0], -p[1]))

        n = len(points)
        ans = 0  # 结果统计

        for i in range(n):
            x1, y1 = points[i]
            max_y2 = -1  # 用于记录当前能配对的最大 y2

            for j in range(i + 1, n):
                x2, y2 = points[j]

                # 条件：y1 >= y2，同时 y2 必须比之前记录的 max_y2 大
                if y1 >= y2 > max_y2:
                    ans += 1
                    max_y2 = y2  # 更新最大 y2，避免后续重复

        return ans
```

```Java
// java
class Solution {
    public int numberOfPairs(int[][] points) {
        // 按照 x 升序排序，若 x 相同则按照 y 降序排序
        Arrays.sort(points, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1]; // x 相同，按 y 降序
            }
            return a[0] - b[0]; // 按 x 升序
        });

        int n = points.length;
        int ans = 0;  // 结果统计

        for (int i = 0; i < n; i++) {
            int x1 = points[i][0], y1 = points[i][1];
            int maxY2 = -1;  // 用于记录当前能配对的最大 y2

            for (int j = i + 1; j < n; j++) {
                int x2 = points[j][0], y2 = points[j][1];

                // 条件：y1 >= y2，同时 y2 必须比之前记录的 maxY2 大
                if (y1 >= y2 && y2 > maxY2) {
                    ans++;
                    maxY2 = y2;  // 更新最大 y2，避免后续重复
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2+nlogn)$，快排
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/solutions/3769982/tu-jie-bao-li-pai-xu-xiang-xi-tui-dao-sh-7a01/)
