[Problem: 3454. 分割正方形 II](https://leetcode.cn/problems/separate-squares-ii/description/)

### 离散化+线段树

本题与前一题几乎相同，但这里的 **重叠区域** 只计算一次，且数据量扩大。

前一题的题解为 [双解](https://leetcode.cn/problems/separate-squares-i/solutions/3879291/shuang-jie-bi-qu-jian-er-fen-chi-san-hua-ikbm/)，采用其中第二种的离散方法继续尝试。

**第一步：离散化 Y 坐标，构建水平条带**。

正方形的边平行于坐标轴。正方形并集的截面宽度，即该高度下所有正方形在 $x$ 轴投影的并集长度）只有在遇到正方形的 **下边缘** 或 **上边缘** 时才会发生改变。

因此，将所有正方形的下边缘 $y_i$ 和上边缘 $y_i + l_i$ 收集起来，去重并排序。设排序后的 $y$ 坐标为 $h_0, h_1, ..., h_m$。这些坐标将平面在垂直方向上切分成了若干个水平条带。

**第二步：计算每个条带的面积**。

对于任意一个条带 $[h_j, h_{j+1}]$ 来说，它的高度是 $\Delta h = h_{j+1} - h_j$。

在这个高度区间内，有哪些正方形是 “存在” 的？若一个正方形 $[x_i, y_i, l_i]$ 覆盖了这个条带，必须满足 $y_i \le h_j$ 且 $y_i + l_i \ge h_{j+1}$。

找出所有覆盖该条带的正方形，取它们在 $x$ 轴上的区间 $[x_i, x_i + l_i]$。计算这些 $x$ 区间的并集总长度，也就是 **区间合并** 问题，记为 $W_j$。那么，该条带的 **面积** 就是 $W_j \times \Delta h$。

**第三步：计算总面积，寻找分割线**。

累加所有条带的面积，得到总面积 $\sum A_j$，目标就是总和的一半。**再次遍历** 这些条带，不断累加遇到的面积 $Area$。

如果加上当前条带的面积后 $\ge S_{target}$，说明分割线 $Y$ 就在当前条带 $[h_j, h_{j+1}]$ 内部。**线性插值**：设进入该条带前累加的面积为 $S_{pre}$，当前条带的宽度为 $W_j$。为了让总和达到一半，则需要在当前条带中补充的面积为 $S_{needed} = S_{target} - S_{pre}$。

条带内宽度恒定，所以所需的高度增量 $\Delta y = S_{needed} / W_j$，则最终答案 $Y = h_j + \Delta y$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        # 计算并集总长度，区间合并问题
        def get_union_len(intervals):
            if not intervals:
                return 0
            
            # 按起点排序
            intervals.sort(key=lambda x: x[0])
            union_length = 0
            # 取第一个区间作为当前合并的基准
            cur_start, cur_end = intervals[0]
            
            for i in range(1, len(intervals)):
                next_start, next_end = intervals[i]
                
                if next_start < cur_end:
                    # 有重叠，更新当前区间的终点
                    cur_end = max(cur_end, next_end)
                else:
                    # 无重叠，结算当前区间长度，开启新区间
                    union_length += cur_end - cur_start
                    cur_start, cur_end = next_start, next_end
                    
            # 加上最后一个区间的长度
            union_length += cur_end - cur_start
            return union_length
        
        # 获取所有唯一的 Y 坐标边界
        y_coords = set()
        for x, y, l in squares:
            y_coords.add(y)
            y_coords.add(y + l)
        # 排序
        sorted_y = sorted(list(y_coords))
        
        # 存储条带信息：(y_bottom, height, width, area)
        strips = []
        total_area = 0
        
        # 遍历每一个条带
        for i in range(len(sorted_y) - 1):
            y1 = sorted_y[i]
            y2 = sorted_y[i+1]
            height = y2 - y1
            
            if height == 0:
                continue
                
            # 找出在这个高度区间内有效的正方形的 x 区间
            # 一个正方形覆盖 [y1, y2] 当且仅当 sq_y <= y1 且 sq_y + l >= y2
            active_x_intervals = []
            for x, y, l in squares:
                if y <= y1 and y + l >= y2:
                    active_x_intervals.append([x, x + l])
            
            # 计算这些 x 区间的并集宽度
            width = get_union_len(active_x_intervals)
            
            # 计算当前条带面积
            area = width * height
            
            strips.append((y1, height, width, area))
            total_area += area
            
        # 寻找分割线
        target = total_area / 2.0
        cur_sum = 0
        
        for y1, height, width, area in strips:
            # 超过目标
            if cur_sum + area >= target:
                # 需要在当前条带中补充的面积
                needed = target - cur_sum
                
                # 计算在这个条带内的高度增量
                delta_y = needed / width
                return y1 + delta_y
                
            cur_sum += area
            
        # 走不到这
        return sorted_y[-1]
```

最多 $2n-1$ 个条带，则上述代码的时间复杂度为 $O(n^2\times logn)$，题目限定 $n\le 5\times 10^4$，所以会超时，卡在 $694/763$ 样例。

---

### 线段树

假如你想全面了解线段树，可以去看看 [维基百科](https://oi-wiki.org/ds/seg/)，有详细阐释，不过稍微有点难理解，对新手不太友好。推荐一篇我写过的 [题解](https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/2933254/xian-duan-shu-yuan-li-mo-ban-xiang-xi-tu-dlmy/)，里面介绍了链表形式和数组形式的线段树，以及 **动态开点** 做法，包含 *原理*、*模版代码*、*经典例题*。

在扫描线从下往上扫的过程中，我们需要快速计算 **当前水平线上被正方形覆盖的总宽度**，也即并集长度。上述解法中，每次计算宽度都需要 $O(nlogn)$ 的区间合并。
通过线段树，可以将 “区间修改” 和 “查询全集长度” 的操作优化到 $O(logn)$。

**第一步：离散化 X 坐标**。

正方形的垂直边，即左边界 $x_i$ 和 右边界 $x_i + l_i$，将 $x$ 轴切分成了若干个基础区间。

收集所有 $x$ 和 $x+l$，排序去重得到数组 $sortX$。线段树的每一个叶子节点对应 $sortX$ 数组中的一个区间 $[sortX_i, sortX_{i+1})$，切记这里是左闭右开。

**第二步：构建事件**。

扫描线不仅记录 $y$，还记录在这个高度发生了什么变化。

从差分的角度看，**入边** 是正方形下边缘 $y_i$，对应 $x$ 区间为 $[x_i, x_i+l_i]$。加入，并且计数 $+1$。**出边** 是正方形上边缘 $y_i+l_i$，对应 $x$ 区间为 $[x_i, x_i+l_i]$。移除，并且计数 $-1$。

按 $y$ 坐标从小到大排序所有事件。

**第三步：线段树节点维护**。

使用 $tree\_cnt$ 表示当前区间被多少个正方形完全覆盖，以及 $tree\_len$ 表示当前区间内被覆盖的 **有效长度**。

- 如果 $tree\_cnt > 0$，说明该节点代表的区间被完全覆盖，那么 $tree\_len$ 等于该节点的物理宽度 $X_{right} - X_{left}$。
- 反之，如果 $tree\_cnt = 0$，说明区间还未被覆盖。
  - 若是叶子节点，则令 $tree\_len = 0$
  - 若是非叶子节点，则有 $tree\_len = 左子树.tree\_len + 右子树.tree\_len$

这一段 $pushup$  **更新** 的逻辑比较难懂。用一个例子来看：

- **叶子**：Node 1 区间 $[0,5]$，Node 2 区间 $[5,10]$，Node 3 区间 $[10,15]$。
- **根节点**：代表 $[0, 15]$。

首先，正方形 $A$ 进场，它的范围是 $[0, 10]$。要给 $[0, 10]$ 区域 $cnt + 1$。

- 线段树会找到 Node 1 $[0,5]$ 和 Node 2 $[5,10]$ 这两个节点。
- Node 1 $0-5$：它的 $cnt$ 变为 $1$。因为 $cnt > 0$，所以 $len$ = 物理宽度 $5$。
- Node 2 $5-10$：它的 $cnt$ 变为 $1$。因为 $cnt > 0$，所以 $len$ = 物理宽度 $5$。
- Node 3 $10-15$：它没被覆盖，所以 $cnt$ 是 $0$，则 $len$ 是 $0$。
- 根节点 $0-15$: 它没有被整体覆盖，则 $cnt$ 保持 $0$。不是叶子，则它的 $len$ = 左孩子 $len$ + 右孩子 $len$ = $0+10$。
- **结论**：总长度为 $10$。

接着，正方形 $B$ 进场，它的范围是 $[5, 15]$。要给 $[5, 15]$ 区域 $cnt + 1$。

- 线段树会找到 Node 2 $[5,10]$ 和 Node 3 $[10,15]$ 这两个节点。
- Node 2 $5-10$：之前 $cnt$ 是 $1$，现在再加 $1$ 变为 $2$。因为 $cnt > 0$，所以 $len$ 还是物理宽度 $5$，覆盖两次算一个面积。
- Node 3 $10-15$：之前 $cnt$ 是 $0$，现在加 $1$ 变为 $1$。因为 $cnt > 0$，所以 $len$ = 物理宽度 $5$。
- 根节点 $0-15$：依旧 $cnt$ 保持 $0$，而 $len$ = 左孩子 $len$ + 右孩子 $len$ = $10+5$。
- **结论**：总长度为 $15$。

总的来看，变量 $tree\_cnt$ 记录 “有几个正方形叠在这个区间上”。只要它不为 $0$，这个区间就是满的。而 $tree\_len$ 是根据 $tree\_cnt$ 算出来的结果。要么全满，取自身宽度；要么不满，问孩子要长度。

这种机制避免了复杂的 “懒标记下传”。这里总是成对地操作 $+1$ 和 $-1$，当 $cnt$ 减回 $0$ 时，自然地去查子节点的长度，就能知道里面是不是还有别的正方形残留。

**第四步：计算**。

遍历事件 $events$，更新线段树。

在处理每个 $y$ 坐标的事件之前，累加 $(当前y - 上次y)\times 上次的总宽度$ 到总面积中。记录 $(当前y, 当前累计面积, 当前总宽度)$ 到一个列表 $history$ 中。

遍历结束后，得到总面积 $S$。目标是 $S/2$，然后在 $history$ 遍历，找到目标面积所在的水平条带，利用线性插值算出精确 $Y$。

这里采用离散化+数组形式+ $2^{\left\lceil\log{n}\right\rceil +1}$ 空间线段树，代码如下，已附加注释：

```Python
# python
class SegmentTree:
    def __init__(self, x_coords):
        # 排序去重后的 x 坐标数组
        self.X = x_coords
        self.n = len(x_coords) - 1
        # 记录每个节点被覆盖的次数
        self.tree_cnt = [0] * (2 << self.n.bit_length())
        # 记录每个节点覆盖的实际长度
        self.tree_len = [0.0] * (2 << self.n.bit_length())

    # 当前节点管理的区间范围 [start, end]；需要更新的区间范围 [l, r]
    def update(self, node, start, end, l, r, val):
        if l > end or r < start:
            return
        
        # 如果当前节点区间被完全包含在更新区间内
        if l <= start and end <= r:
            self.tree_cnt[node] += val
            self.push_up(node, start, end)
            return

        mid = (start + end) // 2
        self.update(node * 2, start, mid, l, r, val)
        self.update(node * 2 + 1, mid + 1, end, l, r, val)
        self.push_up(node, start, end)

    def push_up(self, node, start, end):
        # 如果当前节点被覆盖次数 > 0，则长度为该区间的物理总长度
        if self.tree_cnt[node] > 0:
            self.tree_len[node] = self.X[end + 1] - self.X[start]
        else:
            # 如果是叶子节点，且 cnt 为 0，长度为 0
            if start == end:
                self.tree_len[node] = 0
            else:
                # 否则长度等于左右子节点长度之和
                self.tree_len[node] = self.tree_len[node * 2] + self.tree_len[node * 2 + 1]

    def query_len(self):
        return self.tree_len[1]

class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        # 离散化 X 坐标
        x_set = set()
        for x, y, l in squares:
            x_set.add(x)
            x_set.add(x + l)
        # 排序后的唯一 X 坐标
        sorted_x = sorted(list(x_set))
        # 建立 X 坐标到 索引 的映射
        x_map = {val: i for i, val in enumerate(sorted_x)}
        
        # 构建扫描线事件
        # events: (y, type, x_start_idx, x_end_idx)
        # type: 1 (入边), -1 (出边)
        events = []
        for x, y, l in squares:
            # 左闭右开区间 [x, x+l) 在 sorted_x 中的索引范围
            l_idx = x_map[x]
            r_idx = x_map[x + l] - 1  # 注意减1
            
            events.append((y, 1, l_idx, r_idx))
            events.append((y + l, -1, l_idx, r_idx))
        
        # 按 y 坐标排序
        events.sort(key=lambda x: x[0])
        
        # 处理
        st = SegmentTree(sorted_x)
        total_area = 0.0
        
        # 记录(当前y, 这一步之前的总面积, 这一步开始时的有效宽度)
        history = []
        prev_y = events[0][0]
        
        # 遍历所有事件,每次 y 变化时结算面积
        for y, type_, l_idx, r_idx in events:
            # 结算上一段高度的面积
            cur_width = st.query_len()
            dy = y - prev_y
            
            if dy > 0:
                area_segment = cur_width * dy
                total_area += area_segment
                # 记录这段条带结束时的状态：(条带顶y, 累计面积, 条带宽度)
                history.append((y, total_area, cur_width))
            
            # 更新线段树，如果宽度为 0 不处理
            if l_idx <= r_idx:
                st.update(1, 0, st.n - 1, l_idx, r_idx, type_)
            # 更新上一个 y 值
            prev_y = y
            
        # 寻找分割线
        target = total_area / 2.0
        last_area = 0
        last_y = events[0][0]
        
        for y_end, curr_accum_area, width in history:
            # 超过目标
            if curr_accum_area >= target:
                # 需要补足的面积
                needed = target - last_area
                # 计算在这个条带内的高度增量
                delta_y = needed / width
                return last_y + delta_y
            
            last_area = curr_accum_area
            last_y = y_end
        
        # 走不到这
        return last_y
```

```Java
// java
class SegmentTree {
    double[] X;
    int n;
    // 记录每个节点被覆盖的次数
    int[] tree_cnt;
    // 记录每个节点覆盖的实际长度
    double[] tree_len;

    public SegmentTree(double[] x_coords) {
        // 排序去重后的 x 坐标数组
        this.X = x_coords;
        this.n = x_coords.length - 1;
        int size = 2 << (32 - Integer.numberOfLeadingZeros(this.n)); // 比 4n 空间更小
        this.tree_cnt = new int[size];
        this.tree_len = new double[size];
    }

    // 当前节点管理的区间范围 [start, end]；需要更新的区间范围 [l, r]
    public void update(int node, int start, int end, int l, int r, int val) {
        if (l > end || r < start) {
            return;
        }

        // 如果当前节点区间被完全包含在更新区间内
        if (l <= start && end <= r) {
            this.tree_cnt[node] += val;
            push_up(node, start, end);
            return;
        }

        int mid = (start + end) / 2;
        update(node * 2, start, mid, l, r, val);
        update(node * 2 + 1, mid + 1, end, l, r, val);
        push_up(node, start, end);
    }

    public void push_up(int node, int start, int end) {
        // 如果当前节点被覆盖次数 > 0，则长度为该区间的物理总长度
        if (this.tree_cnt[node] > 0) {
            this.tree_len[node] = this.X[end + 1] - this.X[start];
        } else {
            // 如果是叶子节点，且 cnt 为 0，长度为 0
            if (start == end) {
                this.tree_len[node] = 0;
            } else {
                // 否则长度等于左右子节点长度之和
                this.tree_len[node] = this.tree_len[node * 2] + this.tree_len[node * 2 + 1];
            }
        }
    }

    public double query_len() {
        return this.tree_len[1];
    }
}

class Solution {
    // 辅助类：事件
    private static class Event implements Comparable<Event> {
        double y;
        int type;
        int l_idx;
        int r_idx;

        public Event(double y, int type, int l_idx, int r_idx) {
            this.y = y;
            this.type = type;
            this.l_idx = l_idx;
            this.r_idx = r_idx;
        }

        @Override
        public int compareTo(Event other) {
            return Double.compare(this.y, other.y);
        }
    }

    // 辅助类：历史记录
    private static class History {
        double y_end;
        double accum_area;
        double width;

        public History(double y_end, double accum_area, double width) {
            this.y_end = y_end;
            this.accum_area = accum_area;
            this.width = width;
        }
    }

    public double separateSquares(int[][] squares) {
        // 离散化 X 坐标
        Set<Integer> x_set = new HashSet<>();
        for (int[] sq : squares) {
            x_set.add(sq[0]);
            x_set.add(sq[0] + sq[2]);
        }
        
        // 排序后的唯一 X 坐标
        List<Integer> sorted_x_list = new ArrayList<>(x_set);
        Collections.sort(sorted_x_list);
        
        // 转换为 double 数组供线段树使用
        double[] sorted_x = new double[sorted_x_list.size()];
        // 建立 X 坐标到 索引 的映射
        Map<Integer, Integer> x_map = new HashMap<>();
        for (int i = 0; i < sorted_x_list.size(); i++) {
            sorted_x[i] = sorted_x_list.get(i);
            x_map.put(sorted_x_list.get(i), i);
        }

        // 构建扫描线事件
        // type: 1 (入边), -1 (出边)
        List<Event> events = new ArrayList<>();
        for (int[] sq : squares) {
            int x = sq[0];
            int y = sq[1];
            int l = sq[2];

            // 左闭右开区间 [x, x+l) 在 sorted_x 中的索引范围
            int l_idx = x_map.get(x);
            int r_idx = x_map.get(x + l) - 1; // 注意减1

            events.add(new Event(y, 1, l_idx, r_idx));
            events.add(new Event(y + l, -1, l_idx, r_idx));
        }

        // 按 y 坐标排序
        Collections.sort(events);

        // 处理
        SegmentTree st = new SegmentTree(sorted_x);
        double total_area = 0.0;

        // 记录(当前y, 这一步之前的总面积, 这一步开始时的有效宽度)
        List<History> history = new ArrayList<>();
        double prev_y = events.get(0).y;

        // 遍历所有事件,每次 y 变化时结算面积
        for (Event e : events) {
            // 结算上一段高度的面积
            double cur_width = st.query_len();
            double dy = e.y - prev_y;

            if (dy > 0) {
                double area_segment = cur_width * dy;
                total_area += area_segment;
                // 记录这段条带结束时的状态：(条带顶y, 累计面积, 条带宽度)
                history.add(new History(e.y, total_area, cur_width));
            }

            // 更新线段树，如果宽度为 0 不处理
            if (e.l_idx <= e.r_idx) {
                st.update(1, 0, st.n - 1, e.l_idx, e.r_idx, e.type);
            }
            // 更新上一个 y 值
            prev_y = e.y;
        }

        // 寻找分割线
        double target = total_area / 2.0;
        double last_area = 0;
        double last_y = events.get(0).y;

        for (History h : history) {
            // 超过目标
            if (h.accum_area >= target) {
                // 需要补足的面积
                double needed = target - last_area;
                // 计算在这个条带内的高度增量
                double delta_y = needed / h.width;
                return last_y + delta_y;
            }
            
            last_area = h.accum_area;
            last_y = h.y_end;
        }

        // 走不到这
        return last_y;
    }
}
```

- 时间复杂度： $O(n\times logn)$，表示离散化排序时间，每个事件的更新时间为 $logn$
- 空间复杂度： $O(2^{\left\lceil\log{n}\right\rceil +1})$，表述线段树数组 $tree$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/separate-squares-ii/solutions/3880333/sao-miao-xian-pai-xu-chai-fen-chi-san-hu-bp82/)
