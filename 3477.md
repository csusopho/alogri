[Problem: 3477. 水果成篮 II](https://leetcode.cn/problems/fruits-into-baskets-ii/description/)

### 方法：模拟

难点在于 **读题**：必须从左往右处理 $fruits$，且从左往右第一个能放的篮子就放入。

也即，本题没有复杂的 *田忌赛马* 等贪心问题，只需要模拟整体的流程。这里为了方便判断 $bastets[i]$ 是否被使用过，定义 $used$ 数组。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        n = len(fruits)
        m = len(baskets)
        used = [False] * m  # 标记篮子是否已被使用
        unplaced = 0

        for fruit in fruits:
            placed = False
            for i in range(m):  # 暴力从前往后
                if not used[i] and baskets[i] >= fruit:
                    used[i] = True
                    placed = True
                    break
            if not placed:
                unplaced += 1

        return unplaced
```

```Java
// java
class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        int n = fruits.length;
        int m = baskets.length;
        boolean[] used = new boolean[m];  // 标记篮子是否已被使用
        int unplaced = 0;

        for (int fruit : fruits) {
            boolean placed = false;
            for (int i = 0; i < m; i++) {  // 暴力从前往后查找
                if (!used[i] && baskets[i] >= fruit) {
                    used[i] = true;  // 标记篮子已使用
                    placed = true;  // 成功放置
                    break;
                }
            }
            if (!placed) {
                unplaced++;  // 无法放置
            }
        }

        return unplaced;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n,m$ 分别为为数组 $fruits,baskets$ 的长度
- 空间复杂度： $O(m)$，表示数组 $used$ 的大小

---

### 优化

代码速度有点慢？不想使用额外空间？那就跳过第二次 $for$ 中的无用搜索，将已经 **完成放置** 的 $basket$ 从数组中删除不就行了！

$Python$ 语言可以直接在原地删除，但是 $Java$ 语言不能直接对数组操作，所以必须复制一份 $List$ 用来存储。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        ans = 0

        for fruit in fruits:
            placed = False  # 当前水果是否已成功放置
            for basket in baskets:
                if basket >= fruit:
                    # 将该篮子从列表中移除，表示已使用
                    baskets.remove(basket)
                    placed = True  # 成功放置
                    break
            if not placed:
                ans += 1  # 无法放置
        
        return ans
```

```Java
// java
class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        int ans = 0;

        // 将固定数组转换为可变列表，便于移除元素
        List<Integer> basketList = new ArrayList<>();
        for (int b : baskets) {
            basketList.add(b);
        }

        for (int fruit : fruits) {
            boolean placed = false; // 当前水果是否已成功放置

            for (int i = 0; i < basketList.size(); i++) {
                if (basketList.get(i) >= fruit) {
                    // 移除该篮子，表示已使用
                    basketList.remove(i);
                    placed = true;
                    break;
                }
            }

            if (!placed) {
                ans++; // 无法放置
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$，在线性列表中的前半部分进行查找，后半部分移除，合并起来是 $O(m)$ 时间
- 空间复杂度： $O(1)$，在 $Java$ 中是 $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/fruits-into-baskets-ii/solutions/3742920/shuang-jie-bao-li-mo-ni-shan-chu-you-hua-jp5u/)
