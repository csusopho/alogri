[Problem: 3005. 最大频率元素计数](https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/)

### 方法：模拟 & 优化

答案 = 最大出现次数 * 该类数字个数。

因此，最简单的想法就是直接 **模拟**：统计每个数字的出现次数，找出最大的次数，然后统计这样的数字有几个。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        # 统计每个元素出现的次数
        freq = Counter(nums)
        # 找到最大频率
        max_freq = max(freq.values())
        # 累加总频率
        total = sum(count for count in freq.values() if count == max_freq)
        return total
```

```Java
// java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        // 统计每个元素出现的次数
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }

        // 找到最大频率
        int maxFreq = 0;
        for (int count : freq.values()) {
            maxFreq = Math.max(maxFreq, count);
        }

        // 累加总频率
        int total = 0;
        for (int count : freq.values()) {
            if (count == maxFreq) {
                total += count;
            }
        }

        return total;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，三次遍历
- 空间复杂度： $O(n)$，表示哈希表 $freq$ 的大小

---

### 两次遍历

将上述的后两个过程 “找最大次数” 以及 “累加” 合二为一。

定义一个变量 $mx$ 表示 **当前** 的最大次数。从前往后不断遍历，那么这个 $mx$ 最终会变为 **全局** 的最大次数。

- 当前数字的次数为 $mx$，说明这个次数可能是答案，进行累加；
- 当前数字的出现次数大于 $mx$，说明旧答案不靠谱，用更大的次数作为标杆，重新开始累加。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        # 用数组统计频率
        freq = [0] * 101
        for num in nums:
            freq[num] += 1

        max_cnt = 0  # 当前最大频率
        total = 0  # 最大频率的总和

        for cnt in freq:
            if cnt > max_cnt:      # 出现更大的频率
                max_cnt = cnt
                total = cnt        # 重置为当前频率
            elif cnt == max_cnt:   # 如果频率等于最大频率
                total += cnt       # 累加频率
        return total
```

```Java
// java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        // 用数组统计频率
        int[] freq = new int[101];
        for (int num : nums) {
            freq[num]++;
        }

        int maxCnt = 0;  // 当前最大频率
        int total = 0;   // 最大频率的总和

        for (int cnt : freq) {
            if (cnt > maxCnt) {     // 出现更大的频率
                maxCnt = cnt;
                total = cnt;        // 重置为当前频率
            } else if (cnt == maxCnt) { // 如果频率等于最大频率
                total += cnt;       // 累加频率
            }
        }
        return total;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，两次遍历
- 空间复杂度： $O(M)$，其中 $M=\max(nums)$，表示数组 $freq$ 的大小

---

### 一次遍历

将三个过程 **全部整合** 在一起。也就是说，统计当前元素的出现次数，判断它是否为当前最大次数，然后选择累加/重置。

为什么这种思路正确？因为每种数字的出现次数只会逐渐增大，第一个到达全局最大的数字，它就能作为累加的开端。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        freq = defaultdict(int)  # 哈希表
        max_cnt = ans = 0

        for num in nums:
            freq[num] += 1
            cnt = freq[num]

            if cnt > max_cnt:
                max_cnt = cnt    # 更新最大频率
                ans = cnt        # 重新计数
            elif cnt == max_cnt:
                ans += cnt       # 又一个元素达到最大频率

        return ans
```

```Java
// java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();  // 哈希表
        int maxCnt = 0;  // 当前最大频率
        int ans = 0;     // 最大频率的总和

        for (int num : nums) {
            int cnt = freq.getOrDefault(num, 0) + 1;
            freq.put(num, cnt);

            if (cnt > maxCnt) {
                maxCnt = cnt;  // 更新最大频率
                ans = cnt;     // 重新计数
            } else if (cnt == maxCnt) {
                ans += cnt;    // 又一个元素达到最大频率
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，一次遍历
- 空间复杂度： $O(n)$，表示哈希表 $freq$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-elements-with-maximum-frequency/solutions/3788699/mo-ni-ha-xi-san-ci-liang-ci-yi-ci-bian-l-7tmv/)
