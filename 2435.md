[Problem: 2435. 矩阵中和能被 K 整除的路径](https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/)

### 方法：记忆化搜索 & 动规 & 空间优化

起点为左上角 $(0,0)$，终点为右下角 $(m-1,n-1)$，这就是标准的 **网格搜索** 问题。也即，从起点到终点，**探寻所有路径**，判断符合的有几条。经典题目：[63.不同路径](https://leetcode.cn/problems/unique-paths-ii/description/)，题解为 [传送门](https://leetcode.cn/problems/unique-paths-ii/solutions/3067500/chang-gui-san-jie-ji-yi-hua-sou-suo-dong-4y1r/)。

**暴力**：对于任意位置而言，有两个方向可以选择，它们是不同的结果，所以每条路径都要进行尝试。

假设当前位置在 $(i,j)$ 处，还需要移动 $step$ 次。选定某个方向进行移动后，跳到了新位置，离终点更近，只剩下 $step-1$ 次移动。

这意味着，在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

**定义** $dfs(i,j,r)$ 表示从起点 $(0,0)$ 出发，到当前格子 $(i,j)$，且路径和为 $r$ 的总合法路径数。

**转移过程**：对于当前位置 $(i,j)$ 来说，它可能向下跳到 $(i+1,j)$，或者向右跳到 $(i,j+1)$。这两种方案 **互斥**，因为这两个状态 **不会同时发生**（路径不同），所以是 **独立计算后累加**。得到下面的状态转移方程：

$$
dfs(i,j,r) = dfs(i+1,j,newR)+dfs(i,j+1,newR')
$$

递归边界、递归入口、递归方向等细节比较简单，这里不再阐述。

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

记忆化数组 $memo$ 的初始值只要不等于某个 $dfs$ 的状态值即可，网格值 $\geq 0$，因此这里可以不赋初值，默认为 $0$ 表示方案无效（赋值为 $-1$ 更规范）。

实现上面的过程，代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])

        # 当前坐标，从起点到当前格子的路径和
        @cache
        def dfs(i, j, cur_rem):
            # 到达终点
            if i == m - 1 and j == n - 1:
                return 1 if cur_rem == 0 else 0
            
            count = 0
            
            # 尝试向下走，计算下一个的余数
            if i + 1 < m:
                new_rem = (cur_rem + grid[i+1][j]) % k
                count = (count + dfs(i + 1, j, new_rem)) % MOD
            
            # 尝试向右走
            if j + 1 < n:
                new_rem = (cur_rem + grid[i][j+1]) % k
                count = (count + dfs(i, j + 1, new_rem)) % MOD
            
            return count

        ans = dfs(0, 0, grid[0][0] % k)
        dfs.cache_clear()
        return ans
```

```Java
// java
class Solution {
    private static final int MOD = 1000000007;
    private int[][][] memo;
    private int m, n, k;
    private int[][] grid;

    public int numberOfPaths(int[][] grid, int k) {
        this.grid = grid;
        this.k = k;
        this.m = grid.length;
        this.n = grid[0].length;
        
        // memo[i][j][rem] 表示：到达坐标 (i, j) 且当前路径和模 k 为 rem 时的路径数
        this.memo = new int[m][n][k];
        // 初始
        return dfs(0, 0, grid[0][0] % k);
    }

    private int dfs(int i, int j, int curRem) {
        // 到达终点 (m-1, n-1)
        if (i == m - 1 && j == n - 1) {
            return curRem == 0 ? 1 : 0;
        }

        // 已经计算过
        if (memo[i][j][curRem] != 0) {
            return memo[i][j][curRem];
        }

        int count = 0;

        // 尝试向下走，计算下一个的余数
        if (i + 1 < m) {
            // 计算新的余数：(当前余数 + 下一格数值) % k
            int newRem = (curRem + grid[i + 1][j]) % k;
            count = (count + dfs(i + 1, j, newRem)) % MOD;
        }

        // 尝试向右走
        if (j + 1 < n) {
            int newRem = (curRem + grid[i][j + 1]) % k;
            count = (count + dfs(i, j + 1, newRem)) % MOD;
        }

        // 记录
        memo[i][j][curRem] = count;
        return count;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(m\times n\times k)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(m\times n\times k)$。

注意，这里的 $Python$ 代码一定要增加 $clear$ 的步骤，否则会超空间，卡在 $88/88$ 样例，非常逆天，全部通过依旧 $MLE$。其他语言不清楚，最好同理。

- 时间复杂度： $O(m\times n\times k)$，其中 $m,n$ 为数组 $grid$ 的行数和列数
- 空间复杂度： $O(m\times n\times k)$，保存多少状态，就需要多少空间

---

### 动态规划

将递归 $1:1$ 转化为递推。

**定义** $dp[i][j][r]$ 表示从起点 $(0,0)$ 出发，到当前格子 $(i,j)$，且路径和为 $r$ 的总合法路径数。

**状态转移方程**：

$$
dp[i][j][newR] = dp[i-1][j][r]+dp[i][j-1][r]
$$

**初始化**：将 $dp[i][j]$ 置为 $0$ 表示没有更新过。

**边界情况**：为了避免上面 $-1$ 产生的越界，假设 $grid[0][0]$ 值为 $x$，将 $dp[0][0][x]$ 置为 $1$，表示从它开始寻找路径，后续所有 $i,j>0$ 时才进行状态转移。

**方向**：由于 $dp[i][j]$ 的值需要状态 $dp[i-1][j]$ 以及 $dp[i][j-1]$ 的值，所以前两个维度都从小到大进行枚举，最后一个维度无所谓。

目标： $dp[m-1][n-1]$，表示移动到终点的总方案数。

动规五部曲在上面都已经加粗表示。代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        
        # dp[i][j][rem]：从起点 (0, 0) 走到位置 (i, j)
        # 且路径和模 k 的余数为 rem 的路径数量
        dp = [[[0] * k for _ in range(n)] for _ in range(m)]
        # 初始化起点
        dp[0][0][grid[0][0] % k] = 1
        
        for i in range(m):
            for j in range(n):
                # 遍历上一层可能的所有余数状态 r
                for r in range(k):
                    val = grid[i][j]
                    # 加上当前格子，得到新余数
                    next_rem = (r + val) % k
                    
                    # 1. 从上方转移
                    if i > 0:
                        dp[i][j][next_rem] = (dp[i][j][next_rem] + dp[i-1][j][r]) % MOD
                    # 2. 从左方转移
                    if j > 0:
                        dp[i][j][next_rem] = (dp[i][j][next_rem] + dp[i][j-1][r]) % MOD
                        
        # 到达终点且余数为 0
        return dp[m-1][n-1][0]
```

```Java
// java
class Solution {
    public int numberOfPaths(int[][] grid, int k) {
        int MOD = 1000000007;
        int m = grid.length, n = grid[0].length;
        
        // dp[i][j][rem]：从起点 (0, 0) 走到位置 (i, j)
        // 且路径和模 k 的余数为 rem 的路径数量
        int[][][] dp = new int[m][n][k];
        // 初始化起点
        dp[0][0][grid[0][0] % k] = 1;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 遍历上一层可能的所有余数状态 r
                for (int r = 0; r < k; r++) {
                    int val = grid[i][j];
                    // 加上当前格子，得到新余数
                    int nextRem = (r + val) % k;
                    
                    // 1. 从上方转移
                    if (i > 0) {
                        dp[i][j][nextRem] = (dp[i][j][nextRem] + dp[i - 1][j][r]) % MOD;
                    }
                    // 2. 从左方转移
                    if (j > 0) {
                        dp[i][j][nextRem] = (dp[i][j][nextRem] + dp[i][j - 1][r]) % MOD;
                    }
                }
            }
        }
        
        // 到达终点且余数为 0
        return dp[m - 1][n - 1][0];
    }
}
```

- 时间复杂度： $O(mnk)$
- 空间复杂度： $O(mnk)$，表示三维数组 $dp$ 的大小

---

### 空间优化

可以发现，计算状态 $dp[i][j][r]$ 时，只会用到 $dp[i-1][j]$ 以及 $dp[i][j-1]$ 的值，不会用到比 $i-1$ 或 $j-1$ 更早的状态。这里就采用滚动数组，优化掉第一维。

使用 $prev$ 数组存储 **上一轮** 的 $dp[i-1][j][r]$ 状态，以及 $curr$ 数组存储 **当前轮** 的 $dp[i][j][r]$ 状态。

**状态转移方程**：

$$
curr[j][newR] = prev[j][r] + curr[j-1][r]
$$

递推完一轮后，交换 $prev$ 与 $curr$ 就能达到 **滚动** 的效果。**本质**：将一个 $dp$ 三维矩阵进行缩减，只保留需要的两维子矩阵。

因此，定义 $dp[j][r]$ 表示到达当前行第 $j$ 列时，路径和模 $k$ 余数为 $r$ 的路径数。

对于当前的 $dp[j][r]$ 来说，没更新前，存储的是 $dp[i-1][j][r]$ 的值，而左侧的第 $j-1$ 列已经更新，也即 $dp[j-1][r]$ 对应的是 $dp[i][j-1][r]$ 的值。状态 **方程** 为：

$$
dp[j][newR] (新) = dp[j][r] (旧) + dp[j-1][r] (新)
$$

可以发现，状态转移方程基本没变，只是第一维被取消了。递推方向、递推边界、目标值等都基本相同，注意转化即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        
        # dp[j][r]：到达当前行第 j 列时，路径和模 k 余数为 r 的路径数
        dp = [[0] * k for _ in range(n)]
        # 初始化起点
        dp[0][grid[0][0] % k] = 1
        
        for i in range(m):
            for j in range(n):
                # 跳过起点
                if i == 0 and j == 0:
                    continue
                
                val = grid[i][j]
                # 使用临时数组，存储当前格子 (i, j) 更新后的 k 个余数状态
                new_cnt = [0] * k
                
                # 遍历所有可能的上一状态余数 r
                for r in range(k):
                    # 新余数
                    target_rem = (r + val) % k
                    
                    # 来自上方 (i-1, j)
                    if i > 0:
                        new_cnt[target_rem] = (new_cnt[target_rem] + dp[j][r]) % MOD
                    # 来自左方 (i, j-1)
                    if j > 0:
                        new_cnt[target_rem] = (new_cnt[target_rem] + dp[j-1][r]) % MOD
                
                # 滚动更新
                dp[j] = new_cnt
        
        # 到达终点且余数为 0
        return dp[n-1][0]
```

```Java
// java
class Solution {
    public int numberOfPaths(int[][] grid, int k) {
        int MOD = 1000000007;
        int m = grid.length, n = grid[0].length;
        
        // dp[j][r]：到达当前行第 j 列时，路径和模 k 余数为 r 的路径数
        int[][] dp = new int[n][k];
        // 初始化起点
        dp[0][grid[0][0] % k] = 1;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 跳过起点
                if (i == 0 && j == 0) {
                    continue;
                }
                
                int val = grid[i][j];
                // 使用临时数组，存储当前格子 (i, j) 更新后的 k 个余数状态
                int[] newCnt = new int[k];
                
                // 遍历所有可能的上一状态余数 r
                for (int r = 0; r < k; r++) {
                    // 新余数
                    int targetRem = (r + val) % k;
                    
                    // 来自上方 (i-1, j)
                    if (i > 0) {
                        newCnt[targetRem] = (newCnt[targetRem] + dp[j][r]) % MOD;
                    }
                    // 来自左方 (i, j-1)
                    if (j > 0) {
                        newCnt[targetRem] = (newCnt[targetRem] + dp[j - 1][r]) % MOD;
                    }
                }
                
                // 滚动更新
                dp[j] = newCnt;
            }
        }
        
        // 到达终点且余数为 0
        return dp[n - 1][0];
    }
}
```

- 时间复杂度： $O(mnk)$
- 空间复杂度： $O(nk)$，优化掉第一维

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/solutions/3842342/san-jie-ji-yi-hua-dfs-san-wei-dp-kong-ji-qt9x/)
