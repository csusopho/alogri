[Problem: 2943. 最大化网格图中正方形空洞的面积](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/description/)

### 贪心

移除一条线段，会将相邻的两个 $1 \times 1$ 的区域合并。只有移除 **编号连续** 的线段，才能使得合并后的区域连在一起，形成一个更大的连续空洞。

假设网格的线段编号为 $1, 2, 3, \dots$。初始状态下，相邻线段 $i$ 和 $i+1$ 之间的距离是 $1$。

- 如果移除了线段 $i$，那么线段 $i-1$ 和 $i+1$ 之间的空间被打通，距离变为 $1 + 1 = 2$
- 如果移除连续的线段 $i, i+1$，那么线段 $i-1$ 和 $i+2$ 之间的空间被打通，距离变为 $1 + 1 + 1 = 3$。

因此，如果移除一段连续的线段序列，长度为 $L$，由于这 $L$ 条线段原本隔开了 $L+1$ 个单元格，移除后这些单元格合并，形成的跨度为 $L+1$。

假设我们有 $k$ 条 **连续** 的横线段（比如线段 $3,4,5$），移除它们后，原本被这 $k$ 条线分隔开的 $k+1$ 个单位高度的区域就会合并成一个高度为 $k+1$ 的大区域。

**贪心**：想要得到最大的正方形空洞，需分别找到横向和纵向能构成的 **最大连续间隔**。

找出数组 $hBars$ 中 **最长的连续整数序列** 的长度，记为 $Len_h$，则能形成的最大高度间隙为 $H = Len_h + 1$。同理，找出数组 $vBars$ 中 **最长的连续整数序列** 的长度，记为 $Len_v$，则能形成的最大宽度间隙为 $W = Len_v + 1$。

有了最大的高度 $H$ 和最大的宽度 $W$，它们交叉形成的矩形空洞大小为 $W \times H$。由于题目要求 **正方形**，正方形的边长受限于较小的那一边，即 $S=\min(H, W)$，面积为 $S\times S$。

**连续的必要性**：如果不移除连续的线段，例如移除了 $2$ 和 $4$ 但保留了 $3$，那么在位置 $3$ 处依然有一条物理存在的线段阻隔，空洞无法贯通。因此，最大空洞的边长严格由 **连续移除的线段数量** 决定。

**贪心的有效性**：因为横向和纵向的移除互不干扰，求 “最大正方形” 等价于求 “横向最大跨度” 和 “纵向最大跨度” 的交集。要使交集（正方形）最大，必须保证横向和纵向各自达到其理论上的最大扩展能力。

注意，数组 $hBars$ 可能不是升序，需要手动 **排序** 从而方便寻找连续线段。同时，本题的 $n,m$ 完全用不到。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        # 计算数组中最长连续序列的长度所能构成的间隙大小
        def get_max_gap(bars):
            # 排序，以便查找连续整数
            bars.sort()
            # 最大连续计数，当前连续计数
            mx_conse = 1
            cur_conse = 1
            
            for i in range(1, len(bars)):
                if bars[i] == bars[i-1] + 1:
                    # 连续
                    cur_conse += 1
                else:
                    # 不连续，更新全局最大值，重置当前计数
                    mx_conse = max(mx_conse, cur_conse)
                    cur_conse = 1
            
            # 检查最后一次计数
            mx_conse = max(mx_conse, cur_conse)
            # 间隙大小 = 连续移除的线段数 + 1
            return mx_conse + 1

        # 横向、纵向
        max_h = get_max_gap(hBars)
        max_v = get_max_gap(vBars)
        # 正方形边长受限于较小的一边
        side = min(max_h, max_v)
        return side * side
```

```Java
// java
class Solution {
    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {
        // 横向、纵向
        int max_h = getMaxGap(hBars);
        int max_v = getMaxGap(vBars);
        // 正方形边长受限于较小的一边
        int side = Math.min(max_h, max_v);
        return side * side;
    }

    // 计算数组中最长连续序列的长度所能构成的间隙大小
    private int getMaxGap(int[] bars) {
        // 排序，以便查找连续整数
        Arrays.sort(bars);
        
        // 最大连续计数，当前连续计数
        int mx_conse = 1;
        int cur_conse = 1;
        
        for (int i = 1; i < bars.length; i++) {
            if (bars[i] == bars[i - 1] + 1) {
                // 连续
                cur_conse++;
            } else {
                // 不连续，更新全局最大值，重置当前计数
                mx_conse = Math.max(mx_conse, cur_conse);
                cur_conse = 1;
            }
        }
        
        // 检查最后一次计数
        mx_conse = Math.max(mx_conse, cur_conse);
        // 间隙大小 = 连续移除的线段数 + 1
        return mx_conse + 1;
    }
}
```

- 时间复杂度： $O(hlogh+vlogv)$，其中 $v,h$ 分别表示数组 $hBars,vBars$ 的长度
- 空间复杂度： $O(1)$，忽略排序的 $O(logv+logh)$ 的开销

---

### 线性

如何线性时间运行？

经典算法题：**求未排序数组中的最长连续序列长度**，对应力扣 $128$ 题。

利用 **哈希集合** $Set$ 的 $O(1)$ 查询特性。

首先，**寻找序列起点**：遍历集合中的每个元素 $x$。

- 如果 $x - 1$ **在** 集合中，说明 $x$ 不是一段连续序列的起点，跳过它（因为它会被 $x-1$ 或者更前面的数字扫描到）。
- 如果 $x - 1$ **不在** 集合中，说明 $x$ 是某一段连续序列的起点。

接着，**统计长度**：一旦找到了起点 $x$，通过 $while$ 循环检查 $x + 1$, $x + 2$... 是否在集合中，从而一次性统计出这段连续序列的长度。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        # 计算数组中最长连续序列的长度所能构成的间隙大小
        def get_max_gap(bars):
            # 转换为集合，方便查找
            num_set = set(bars)
            max_len = 0
            
            for x in num_set:
                # 只有当 x 是连续序列的起点时，才开始向后计数
                if (x - 1) not in num_set:
                    cur_num = x
                    
                    # 不断查找下一个连续数字
                    while (cur_num + 1) in num_set:
                        cur_num += 1
                    
                    max_len = max(max_len, cur_num - x + 1)
            
            # 间隙大小 = 连续移除的线段数 + 1
            return max_len + 1

        # 横向、纵向
        max_h = get_max_gap(hBars)
        max_v = get_max_gap(vBars)
        # 正方形边长受限于较小的一边
        side = min(max_h, max_v)
        return side * side
```

```Java
// java
class Solution {
    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {
        // 横向、纵向
        int max_h = getMaxGap(hBars);
        int max_v = getMaxGap(vBars);
        // 正方形边长受限于较小的一边
        int side = Math.min(max_h, max_v);
        return side * side;
    }

    // 计算数组中最长连续序列的长度所能构成的间隙大小
    private int getMaxGap(int[] bars) {
        // 转换为集合，方便查找
        Set<Integer> numSet = new HashSet<>();
        for (int bar : bars) {
            numSet.add(bar);
        }
        
        int max_len = 0;
        
        for (int x : numSet) {
            // 只有当 x 是连续序列的起点时，才开始向后计数
            if (!numSet.contains(x - 1)) {
                int cur_num = x;
                
                // 不断查找下一个连续数字
                while (numSet.contains(cur_num + 1)) {
                    cur_num++;
                }
                
                max_len = Math.max(max_len, cur_num - x + 1);
            }
        }
        
        // 间隙大小 = 连续移除的线段数 + 1
        return max_len + 1;
    }
}
```

- 时间复杂度： $O(h+v)$，一次集合转换，一次线性遍历
- 空间复杂度： $O(h+v)$，表示哈希 $numSet$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/solutions/3881058/shuang-jie-xun-zhao-lian-xu-xian-duan-pa-uc96/)
