[Problem: 190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/description/)

### 方法：调库 & 模拟 & 位运算

题意：先将整数转为 $32$ 位的二进制，然后把这个二进制翻转，最后转回十进制。

不想考虑那么多，那就直接调库，代码如下：

```Python
# python
class Solution:
    def reverseBits(self, n: int) -> int:
        # 转为整数并补齐
        binary_str = bin(n & 0xffffffff)[2:].zfill(32)
        # 反转字符串并转回
        return int(binary_str[::-1], 2)
```

```Java
// java
public class Solution {
    public int reverseBits(int n) {
        // 转为整数并补齐
        String binaryStr = Integer.toBinaryString(n);
        // 补齐 32 位
        while (binaryStr.length() < 32) {
            binaryStr = "0" + binaryStr;
        }
        
        // 反转字符串并转回
        StringBuilder reversed = new StringBuilder(binaryStr).reverse();
        return Integer.parseUnsignedInt(reversed.toString(), 2);
    }
}
```

为了方便分析，假设整数 $n$ 的二进制位数为 $W$。

- 时间复杂度： $O(W)$，遍历、反转、解析
- 空间复杂度： $O(W)$，创建字符串中间存储

---

### 模拟

将字符串反转，等价于从最后面的字符开始拼接，直至最前面的字符。

比如将串 $abcd$ 反转，也就是

- 先拼接 $d$，得到 $d$；
- 再拼接 $c$，得到 $dc$；
- 再拼接 $b$，得到 $dcb$；
- 再拼接 $a$，得到 $dcba$。

只需要从后往前遍历，向结果末尾拼接即可。二进制同理，可以用位运算的小技巧。

`& 1` 就是取出二进制的最后一位，`>> 1` 就是二进制丢弃最后一位。`<< 1` 就是整体左移一位，末尾填 $0$，此时使用 `|` 或运算将取出的位填在空出的末尾。

代码如下，已附加注释：

```Python
# python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        
        for _ in range(32):
            # 左移腾空位 + 取出 n 的最后一位
            res = (res << 1) | (n & 1)
            # n 右移丢弃最后一位
            n >>= 1
        
        return res
```

```Java
// java
public class Solution {
    public int reverseBits(int n) {
        int res = 0;
        
        for (int i = 0; i < 32; i++) {
            // 左移腾空位 + 取出 n 的最后一位
            res = (res << 1) | (n & 1);
            // n 右移丢弃最后一位
            n >>>= 1;
        }
        
        return res;
    }
}
```

- 时间复杂度： $O(W)$，一次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 分治

假设我们有 $8$ 个位置，每个位置上有一个小兵，分别标号 `a b c d e f g h`。目标是把它完全颠倒成 `h g f e d c b a`。

如果用循环法，是一个个搬；用位运算法，是 **成块成块地搬**。

**第一步：交换 “相邻的 1 位”**。

把这 $8$ 个人分成 $4$ 组：`(a b)` `(c d)` `(e f)` `(g h)`。每一组内部左右互换。

- `a b` -> `b a`
- `c d` -> `d c`
- $\dots$

得到 `b a d c f e h g`，注意看，本质是把 **奇数位** 和 **偶数位** 互换了。

**第二步：交换 “相邻的 2 位”**。

现在的队伍是 `ba dc fe hg`。每 $2$ 个划为一组：`(ba)` `(dc)` `(fe)` `(hg)`。再把相邻的两组互换：

- `(ba)` 和 `(dc)` 互换 -> `dc ba`
- `(fe)` 和 `(hg)` 互换 -> `hg fe`

得到 `d c b a h g f e`，注意看，前 $4$ 位内部已经反转了，且后 $4$ 位也是。

**第三步：交换 “相邻的 4 位”**。

现在的队伍是 `dcba hgfe`。每 $4$ 个划为一组：`(dcba)` `(hgfe)`。把这两组互换：

- `(dcba)` 和 `(hgfe)` 互换 -> `hgfe dcba`

得到 `h g f e d c b a`，成功！

我们只用了 $3$ 步就完成了 $8$ 位的反转。同理，如果是 $32$ 位，只需要再做 “交换 $8$ 位” 和 “交换 $16$ 位” 两步，总共 $5$ 步即可。

---

接下来使用 **位运算**，帮助我们进行二进制的反转。

`0x55555555` 的二进制是 `0101 0101 0101 ...`。

- $0$ 代表原来的位要移走。
- $1$ 代表原来的位要保留。

以第一步为例，

1. 首先执行 `(n & 0x55555555) << 1`
    - `0x55...` 是 `...0101`。
    - `n & 0x55...` 取出了所有偶数位，把奇数位清零。
    - `<< 1` 左移一位。
    - **效果**：把偶数位的人，搬到了奇数位上。
2. 然后执行 `(n >> 1) & 0x55555555`
    - `n >> 1` 把所有位右移一位，原来的奇数位跑到了偶数位上。
    - `& 0x55...` 再把杂质清零，只保留这些移过来的位。
    - **效果**：把奇数位的人，搬到了偶数位上。
3. 最后执行 `|` 或运算
    - 把上面两拨人拼在一起。
    - **最终效果**：奇偶位互换。

总结来看，

- 交换 $1$ 位：需要 `0101...` -> $16$ 进制的 $5$ -> `0x55555555`
- 交换 $2$ 位：需要 `0011...` -> $16$ 进制的 $3$ -> `0x33333333`
- 交换 $4$ 位：需要 `00001111...` -> $16$ 进制的 $0f$ -> `0x0f0f0f0f`
- 交换 $8$ 位：需要 `0000000011111111...` -> `0x00ff00ff`
- 交换 $16$ 位：`0x0000ffff`

这就是著名的 **分治位算法**，它比循环快，因为它充分利用了 $CPU$ 的并行处理能力，一次操作处理 $32$ 位，而且没有循环跳转带来的开销。

不过，在 $Python$ 中处理这个问题需要特别注意，因为 $Python$ 的整数是无限精度的，而不是固定的 $32$ 位。因此，在处理前使用 `n & 0xffffffff` 将输入强制转换为无符号的 $32$ 位整数形式，以避免负数移位带来的无限 $1$ 问题。

代码如下，已附加注释：

```Python
# python
class Solution:
    def reverseBits(self, n: int) -> int:
        # 确保输入在 32 位范围内
        n = n & 0xffffffff
        
        # 交换相邻 1 位
        n = (n >> 1) & 0x55555555 | (n & 0x55555555) << 1
        # 交换相邻 2 位
        n = (n >> 2) & 0x33333333 | (n & 0x33333333) << 2
        # 交换相邻 4 位
        n = (n >> 4) & 0x0f0f0f0f | (n & 0x0f0f0f0f) << 4
        # 交换相邻 8 位
        n = (n >> 8) & 0x00ff00ff | (n & 0x00ff00ff) << 8
        # 交换相邻 16 位
        n = (n >> 16) | (n << 16)

        # 最后一步左移可能会导致 Python 整数超过 32 位，所以最后再次掩码
        return n & 0xffffffff
```

```Java
// java
public class Solution {
    public int reverseBits(int n) {
        // Java int 固定 32 位
        
        // 交换相邻 1 位
        n = (n >>> 1) & 0x55555555 | (n & 0x55555555) << 1;
        // 交换相邻 2 位
        n = (n >>> 2) & 0x33333333 | (n & 0x33333333) << 2;
        // 交换相邻 4 位
        n = (n >>> 4) & 0x0f0f0f0f | (n & 0x0f0f0f0f) << 4;
        // 交换相邻 8 位
        n = (n >>> 8) & 0x00ff00ff | (n & 0x00ff00ff) << 8;
        // 交换相邻 16 位
        n = (n >>> 16) | (n << 16);

        // Java 会自动截断溢出位
        return n;
    }
}
```

- 时间复杂度： $O(logW)$，并行处理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/reverse-bits/solutions/3903515/san-jie-diao-ku-mo-ni-pin-jie-wei-yun-su-pmpn/)
