[Problem: 2483. 商店的最少代价](https://leetcode.cn/problems/minimum-penalty-for-a-shop/description/)

### 方法：前缀和 & 后缀 & 一次遍历

简单来说，在某个时间点 $t$ 选择关门，则前面的时间 $[0:t-1]$ 处于 “开门” 状态，后面的时间 $[t:n)$ 属于 “关门” 状态。

- 在开门状态时，有 $a$ 个 $'N'$ 顾客没到，则代价增加 $a$；
- 在关门状态时，有 $b$ 个 $'Y'$ 顾客到达，则代价增加 $b$；

总代价是 $a+b$，求哪个时间关门，代价最小。

如何快速求取任意子数组的和？**前缀和**。具体原理/做法，可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

一个简单的想法：使用两个前缀数组，统计 $[0:j]$ 子数组中的 $'Y/N'$ 的总数。那么，假设整个数组中 $Y$ 总数为 $total$，则当前时间点 $j$ 关门的代价为：

$$
prefixN[j] + (total - prefixY[j])
$$

**总结**：预处理出两个前缀数组，主循环一次遍历，计算每个时间点的代价，记录最小值。

代码如下，已附加注释：

```Python
# python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n = len(customers)
        
        # 前 i 小时 'N'/'Y' 的数量
        prefix_N = [0] * (n + 1)
        prefix_Y = [0] * (n + 1)
        
        # 累加前缀和
        for i in range(1, n + 1):
            prefix_N[i] = prefix_N[i - 1]
            prefix_Y[i] = prefix_Y[i - 1]
            # 更新
            if customers[i - 1] == 'N':
                prefix_N[i] += 1
            else:
                prefix_Y[i] += 1
        
        total_Y = prefix_Y[n]
        min_penalty = float('inf')
        ans = 0
        
        # 计算每个关门时间的代价
        for j in range(n + 1):
            # 前j小时的'N' + 后j小时的'Y'
            penalty = prefix_N[j] + (total_Y - prefix_Y[j])
            
            if penalty < min_penalty:
                min_penalty = penalty
                ans = j
        
        return ans
```

```Java
// java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();
        
        // 前 i 小时 'N'/'Y' 的数量
        int[] prefix_N = new int[n + 1];
        int[] prefix_Y = new int[n + 1];
        
        // 累加前缀和
        for (int i = 1; i <= n; i++) {
            prefix_N[i] = prefix_N[i - 1];
            prefix_Y[i] = prefix_Y[i - 1];
            // 更新
            if (customers.charAt(i - 1) == 'N') {
                prefix_N[i]++;
            } else {
                prefix_Y[i]++;
            }
        }
        
        int total_Y = prefix_Y[n];
        int min_penalty = Integer.MAX_VALUE;
        int ans = 0;
        
        // 计算每个关门时间的代价
        for (int j = 0; j <= n; j++) {
            // 前j小时的'N' + 后j小时的'Y'
            int penalty = prefix_N[j] + (total_Y - prefix_Y[j]);
            
            if (penalty < min_penalty) {
                min_penalty = penalty;
                ans = j;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为串 $customers$ 的长度
- 空间复杂度： $O(n)$，表示数组 $prefix$ 的大小

---

### 前后缀

实际上，总数 - 前缀 = 后缀，所以我们直接用后缀数组 $suffixY$ 来替换 $prefixY$ 即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n = len(customers)

        # prefix_N[i]表示前i小时中'N'的数量
        prefix_N = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_N[i] = prefix_N[i - 1] + (1 if customers[i - 1] == 'N' else 0)
        
        # suffix_Y[i]表示从第i小时开始到结束的'Y'的数量
        suffix_Y = [0] * (n + 1)  # suffix_Y[n]=0
        for i in range(n - 1, -1, -1):
            suffix_Y[i] = suffix_Y[i + 1] + (1 if customers[i] == 'Y' else 0)

        min_penalty = float('inf')
        ans = 0
        
        for j in range(n + 1):
            # 前j小时的'N' + 后j小时的'Y'
            penalty = prefix_N[j] + suffix_Y[j]
            
            if penalty < min_penalty:
                min_penalty = penalty
                ans = j
        
        return ans
```

```Java
// java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();

        // prefix_N[i]表示前i小时中'N'的数量
        int[] prefix_N = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            prefix_N[i] = prefix_N[i - 1] + (customers.charAt(i - 1) == 'N' ? 1 : 0);
        }
        
        // suffix_Y[i]表示从第i小时开始到结束的'Y'的数量
        int[] suffix_Y = new int[n + 1];  // suffix_Y[n]=0
        for (int i = n - 1; i >= 0; i--) {
            suffix_Y[i] = suffix_Y[i + 1] + (customers.charAt(i) == 'Y' ? 1 : 0);
        }

        int min_penalty = 100001;
        int ans = 0;
        
        for (int j = 0; j <= n; j++) {
            // 前j小时的'N' + 后j小时的'Y'
            int penalty = prefix_N[j] + suffix_Y[j];
            
            if (penalty < min_penalty) {
                min_penalty = penalty;
                ans = j;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 空间优化

“主循环” 是从前往后顺序遍历，“统计前缀和” 也是从前往后顺序遍历，所以将过程整合。

用两个变量 $leftN$ 以及 $rightY$ 替换两个数组，整体逻辑不变。

代码如下，已附加注释：

```Python
# python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n = len(customers)
        # 总的'Y'数量
        total_Y = sum(1 for c in customers if c == 'Y')
        
        # 开门期间的'N'数量
        left_N = 0
        # 关门期间的'Y'数量
        right_Y = total_Y
        min_penalty = total_Y  # 在第0小时关门的代价
        ans = 0
        
        for j in range(1, n + 1):
            if customers[j-1] == 'N':
                left_N += 1
            else:
                right_Y -= 1
            
            # 前j小时的'N' + 后j小时的'Y'
            penalty = left_N + right_Y
            
            if penalty < min_penalty:
                min_penalty = penalty
                ans = j
        
        return ans
```

```Java
// java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();
        // 总的'Y'数量
        int total_Y = 0;
        for (char c : customers.toCharArray()) {
            if (c == 'Y') total_Y++;
        }
        
        // 开门期间的'N'数量
        int left_N = 0;
        // 关门期间的'Y'数量
        int right_Y = total_Y;
        int min_penalty = total_Y;  // 在第0小时关门的代价
        int ans = 0;
        
        for (int j = 1; j <= n; j++) {
            if (customers.charAt(j - 1) == 'N') {
                left_N++;
            } else {
                right_Y--;
            }
            
            // 前j小时的'N' + 后j小时的'Y'
            int penalty = left_N + right_Y;
            
            if (penalty < min_penalty) {
                min_penalty = penalty;
                ans = j;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 一次遍历

我们可以将 “代价最小化” 转化为 “收益最大化” 问题。

第 $0$ 小时就关门，此时代价 $P_0$ = 后面所有出现的 $'Y'$ 的数量，相对收益 $Score$ 定义为 $0$。

如果不立即关门，而是多营业 $1$ 小时，会发生什么？

1）如果第 $i$ 小时遇到了 $'Y'$：

- 在第 $i$ 小时关门时，这个 $'Y'$ 会贡献 $1$ 点代价。
- 在第 $i+1$ 小时关门时，这个 $'Y'$ 变成了 “营业期间遇到顾客”，不计入代价。

也就是说，多开这一小时，总代价 **减少了 $1$**，相当于收益 $+1$。

2）如果第 $i$ 小时遇到了 $'N'$：

- 在第 $i$ 小时关门时，这个 $'N'$ 不会计入代价。
- 在第 $i+1$ 小时关门时，这个 $'N'$ 变成了 “营业期间没有顾客”，计入 $1$ 点代价。

也就是说，多开这一小时，总代价 **增加了 $1$**，相当于收益 $-1$。

**推导**：设第 $0$ 小时的代价为 $P_0$，第 $j$ 小时的代价为 $P_j$。根据上面的逻辑，我们在第 $j$ 小时积累的收益 $score$ 实际上等于：

$$score = P_0 - P_j$$

我们要找的是使 $P_j$ 最小的 $j$，这等价于找使 $P_0 - P_j$ 最大的 $j$。也就是说：

$$\min(Penalty) \iff \max(P_0 - Penalty) \iff \max(score)$$

那么，我们不需要知道总共有多少 $'Y'$、不需要存储前缀和数组，而是关注变化量：遇到 $'Y'$ 收益加一，遇到 $'N'$ 收益减一。

在这个波动过程中，**收益最高**（即代价减掉最多）的那个时间，就是答案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        # 当前营业相对于第0小时关门减少的代价
        cur_score = 0
        # 遍历过程中达到的最大收益
        max_score = 0
        # 达到最大收益时的关门时间
        best_hour = 0
        
        for i, char in enumerate(customers):
            # 'Y/N' 对应收益增加/减少
            if char == 'Y':
                cur_score += 1
            else:
                cur_score -= 1
            
            # 更新
            if cur_score > max_score:
                max_score = cur_score
                best_hour = i + 1
        
        return best_hour
```

```Java
// java
class Solution {
    public int bestClosingTime(String customers) {
        // 当前营业相对于第0小时关门减少的代价
        int cur_score = 0;
        // 遍历过程中达到的最大收益
        int max_score = 0;
        // 达到最大收益时的关门时间
        int best_hour = 0;
        
        for (int i = 0; i < customers.length(); i++) {
            char c = customers.charAt(i);
            // 'Y/N' 对应收益增加/减少
            if (c == 'Y') {
                cur_score++;
            } else {
                cur_score--;
            }
            
            // 更新
            if (cur_score > max_score) {
                max_score = cur_score;
                best_hour = i + 1;
            }
        }
        
        return best_hour;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-penalty-for-a-shop/solutions/3866479/si-jie-qian-zhui-he-hou-zhui-fen-jie-kon-40dm/)
