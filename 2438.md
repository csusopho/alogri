[Problem: 2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/description/)

### 方法：前缀和/前缀积

找一下规律，先看看这个 $powers$ 数组是什么：

- 当 $n=2$ 时，其二进制为 `10`，对应 `powers = [2]`，即 $2^1$
- 当 $n=15$ 时，其二进制为 `1111`，对应 `powers = [1,2,4,8]`，即 $2^0,2^1,2^2,2^3$

实际上，就是将 $n$ 分解为它的二进制形式，每个 $1$ 对应一个 $2$ 的幂，从而保证了使用最少数目的 $2$ 的幂的和等于 $n$。

为什么这样得到的 $powers$ **正确**？能发现，数组 $powers$ 一定没有重复元素，因为两个 $4$ 能组成 $8$，从小的次幂变为大的次幂，数组长度减小。

一个容易想到的思路：从大数字开始拆分 $n$。因为要用 $2$ 的幂组成 $n$，所以将 $n$ 变为二进制。此时，最大的数字一定是最高位 $1$ 对应的 $1000\dots_{(2)}$。同理次大、次次大等数字，都是二进制中的 $1$ 转化。

**总结**：将 $n$ 变为二进制，其中每个 $1$ 转化为一个 $2$ 的次幂，得到 $powers$ 数组。

---

每个 $queries[i]$ 表示 $powers$ 子数组中元素的连乘。根据数学知识可知，

$$
2^i\times 2^j=2^{i+j}
$$

因此，我们没必要使用普通的连乘，可以先转化为次幂的累加，将和记作 $s$，一次性计算 $2^{s}$，效果等价于连乘。

注意，本题的 $s$ 可能比较大，限定 $n\leq 10^9$，它远小于 $2^{30}-1$，所以想要 $1$ 达到最多，只能是 $2^{29}-1$，而 $1+2+\dots 29=435$，所以累加结果一定小于等于该数值。

诸如 $2^{100}$ 这种超大数字，如何快速计算？**快速幂**。它能将时间降至 $log$ 级别，模板、原理、图解，可以看这篇题解，[传送门](https://leetcode.cn/problems/double-modular-exponentiation/solutions/2862580/tu-pian-jie-shi-kuai-su-mi-by-priceless-ajaeu/)。

对子数组 $queries[i]$ 求和时，难道一个个慢慢累加？联想到 **前缀和**，它是一种能将 $O(n)$ 的统计转化为 $O(1)$ 的快速方法。具体原理及做法，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

**流程**：先根据 $n$ 构造出 $powers$ 数组，然后得到每个数字以 $2$ 为底的指数 $exps$ 数组，对它使用前缀和，得到 $prefix$ 数组。查询时，根据 $prefix$ 得到区间累加和 $s$，使用快速幂计算出 $2^s$。

可以发现，这里的 $powers$ 只是用来求出 $exps$，所以可以一步到位，直接从 $n$ 得到 $exps$，省去计算 $powers$ 这一步骤。

代码如下，已附加注释：

```Python
# python
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 10**9 + 7

        def fast_pow(base, exp):
            """快速幂计算 base^exp % MOD"""
            res = 1
            while exp > 0:
                if exp & 1:  # 如果当前最低位是1
                    res = (res * base) % MOD
                base = (base * base) % MOD
                exp >>= 1
            return res
        
        # 构造 exps 数组
        exps = []
        bit = 0
        while n > 0:
            if n & 1:
                exps.append(bit)
            bit += 1
            n >>= 1

        # 指数的前缀和
        prefix_exp = [0] * (len(exps) + 1)
        for i in range(len(exps)):
            prefix_exp[i+1] = prefix_exp[i] + exps[i]

        # 处理
        ans = []
        for l, r in queries:
            total_exp = prefix_exp[r + 1] - prefix_exp[l]
            power = fast_pow(2, total_exp)
            ans.append(power)
        return ans
```

```java
// java
class Solution {
    private final int MOD = 1_000_000_007;

    public int[] productQueries(int n, int[][] queries) {
        // 构造 exps 数组
        List<Integer> exps = new ArrayList<>();
        int bit = 0;
        int temp = n;
        while (temp > 0) {
            if ((temp & 1) == 1) {
                exps.add(bit);
            }
            bit += 1;
            temp >>= 1;
        }

        // 指数的前缀和
        int[] prefixExp = new int[exps.size() + 1];
        for (int i = 0; i < exps.size(); i++) {
            prefixExp[i + 1] = prefixExp[i] + exps.get(i);
        }

        // 处理
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int l = queries[i][0], r = queries[i][1];
            int totalExp = prefixExp[r + 1] - prefixExp[l];
            ans[i] = (int) fastPow(2, totalExp);
        }
        return ans;
    }
    
    // 快速幂计算 base^exp % MOD
    // 使用 long 避免中间乘法溢出
    private long fastPow(long base, int exp) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) { // 如果当前最低位是1
                res = (res * base) % MOD;
            }
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return res;
    }
}
```

将 $n$ 二进制中 $1$ 的个数记作 $m$，则 $m\leq log_{2}n$。将子数组累加和记作 $s$，它不超过 $435$。每次查询时，指数为 $s$，则快速幂的时间为 $logs$。

- 时间复杂度： $O(logn+m+q\times logs)$，其中 $m$ 是 $n$ 中二进制 $1$ 的个数，而 $q$ 是数组 $queries$ 的长度，且 $s$ 是区间的累加和
- 空间复杂度： $O(m)$，表示列表 $exps$ 以及 $prefix$ 的大小，返回值 $ans$ 一般不计入复杂度

---

### 前缀积

不想使用快速幂怎么办？就是想使用连乘怎么办？

我们已经求出了指数列表 $exps$，进行前缀和后，得出 $prefix$ 数组，它表示指数和。上面的操作中，是在 $prefix$ 中求子数组和然后快速幂。

如果我们 **提前计算** 出每个 $2^s$，其中 $s\in[1,\dots 435]$，存储在 $pows$ 数组中。那么，只需要在查询时，直接从 $pows$ 中取值，从而省去快速幂的时间！

本质上，就是 $exps\to prefix\to pows$，多了一步预处理，从而加速查询的效率。

代码如下，已附加注释：

```Python
# python
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 10**9 + 7
        
        # 拆 n 得到每个 2^k 的指数 k
        exps = []
        bit = 0
        temp = n
        while temp > 0:
            if temp & 1:
                exps.append(bit)
            bit += 1
            temp >>= 1
        
        # 指数的前缀和
        prefix = [0] * (len(exps) + 1)
        for i in range(len(exps)):
            prefix[i + 1] = prefix[i] + exps[i]
        
        # 预处理 pow2 数组存 2^i
        max_exp = prefix[-1]  # 最大指数
        pow2 = [1] * (max_exp + 1)
        for i in range(1, max_exp + 1):
            pow2[i] = (pow2[i - 1] * 2) % MOD
        
        # 查询
        ans = []
        for l, r in queries:
            total_exp = prefix[r + 1] - prefix[l]
            ans.append(pow2[total_exp])
        return ans
```

```java
// java
class Solution {
    private final int MOD = 1_000_000_007;

    public int[] productQueries(int n, int[][] queries) {
        // 构造 exps 数组
        List<Integer> exps = new ArrayList<>();
        int bit = 0;
        int temp = n;
        while (temp > 0) {
            if ((temp & 1) == 1) {
                exps.add(bit);
            }
            bit += 1;
            temp >>= 1;
        }

        // 指数的前缀和
        int[] prefix = new int[exps.size() + 1];
        for (int i = 0; i < exps.size(); i++) {
            prefix[i + 1] = prefix[i] + exps.get(i);
        }

        // 预处理 pow2 数组存 2^i % MOD
        int maxExp = prefix[prefix.length - 1];
        int[] pow2 = new int[maxExp + 1];
        pow2[0] = 1;
        for (int i = 1; i <= maxExp; i++) {
            pow2[i] = (int)((pow2[i - 1] * 2L) % MOD);
        }

        // 查询
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int l = queries[i][0], r = queries[i][1];
            int totalExp = prefix[r + 1] - prefix[l];
            ans[i] = pow2[totalExp];
        }

        return ans;
    }
}
```

- 时间复杂度： $O(logn+m+s+q)$，多了一步 $O(s)$ 的预处理，将每一步查询优化至 $O(1)$
- 空间复杂度： $O(m+s)$，增加数组 $pow2$ 的空间

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/range-product-queries-of-powers/solutions/3749459/yu-chu-li-qian-zhui-he-kuai-su-mi-you-hu-fkzm/)
