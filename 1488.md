[Problem: 1488. 避免洪水泛滥](https://leetcode.cn/problems/avoid-flood-in-the-city/description/)

### 方法：贪心+二分/最小堆

题意：如果 $rains[i]>0$ 则表示下雨，什么都不用做；反之，如果等于 $0$，则没下雨，称呼这一天为 “干燥日”，必须抽某个湖泊，防止发生洪水。

题目隐含几条信息：

- `rains[i] > 0` 表示第 $i$ 天时，第 $rains[i]$ 个湖泊会下雨。这意味着，只要下雨 $rain[i]$ 就不会等于 $0$！也即，根本不存在第 $0$ 个湖泊！
- 如果 `rains[i] > 0` ，那么 `ans[i] == -1`。这意味着，就算没有湖泊可以抽水，那也不能填 $-1$，因为 $-1$ 代表这一天下雨了，实际上是我们是要抽水！

**总结**：干燥日时，没湖泊可以抽，那也不能随便填，根据样例反推，填个 $1$ 就行。

为了防止洪水，如何在 “干燥日” 做出最优决策？也即，我们应该抽干哪个湖泊的水？理性的选择是：**抽干那个最快要再次下雨的、并且当前已满的湖泊**。

但是，在第 $i$ 天时，我们并不知道未来哪天会下雨。因此，我们不能简单地在遇到干燥日时就做决定。正确的思路是反过来：

1. **延迟决策**：我们将所有 “干燥日” 的索引 $i$ 先存起来，当作可以使用的 “机会”。
2. **被动处理**：某一天，一个已经满了的湖泊 **又要下雨** 了。这是一个非常紧急的情况！此时，我们再从存起来的 “机会” 中选择一个来使用。

因此，使用哈希表 $fullLakes$ 记录哪些湖泊已经满了，以及它们是哪一天被填满的。格式为 `{lake_id: rain_day_index}`。

同时，使用一个列表 $dryDays$ 来存放所有干燥日的索引。因为我们是从前往后遍历，所以索引是逐渐增大，这个列表是升序的！

---

设当前是第 $i$ 天，将 $rains[i]$ 记作 $lake$。

如果 `lake > 0`，则今天是下雨天：

- 首先，在最终答案 $ans$ 中，将 $ans[i]$ 设为 $-1$。
- 如果 $lake$ 存在于 $fullLakes$ 中，这意味着这个湖泊之前已经满了，如果不采取行动，今天就会发生洪水。
- 上次下雨的日期为 $fullLakes[lake]$，今天 $i$ 又再次下雨，因此我们需要这个区间内，找到一个干燥日来抽干这个湖泊。
- 我们在 $dryDays$ 列表中，使用二分查找来寻找 **第一个** 索引大于 $fullLakes[lake]$ 的干燥日。
- 如果找不到这样的干燥日，说明我们没有机会在两次降雨之间抽干湖水，洪水不可避免；
- 反之，如果找到了，那我们选择这个最早的、可用的干燥日 $use$，在答案 $ans$ 中设置 `ans[use] = lake`，表示我们在那天抽干了 $lake$ 湖。然后，将这个用掉的干燥日从 $dryDays$ 列表中移除。
- **无论之前是否满，今天下雨后，这个湖泊都变成满了**。所以，我们需要添加$fullLakes$ 中的记录：`fullLakes[lake] = i`。

如果 `lake = 0`，则今天是干燥日，将这一天的索引 $i$ 添加到 $dryDays$ 列表中，以备后续使用。

遍历结束后， $dryDays$ 列表中可能还有一些未使用的干燥日。对于这些天，我们没有必须抽干的湖泊，所以可以随便选择一个湖泊来抽干，比如湖泊 $1$。

---

以示例 $2$ 举例，其中 `rains2 = [1, 2, 0, 0, 2, 1]`。

- 第 $0$ 天：湖泊 $1$ 下雨，变满。`ans = [-1]`
- 第 $1$ 天：湖泊 $2$ 下雨，变满。`ans = [-1, -1]`
- 第 $2$ 天：干燥日，先存起来。`dry_days = [2]`
- 第 $3$ 天：干燥日，先存起来。`dry_days = [2, 3]`
- 第 $4$ 天：湖泊 $2$ 下雨，它在第 $1$ 天就满了。需要在 $(1, 4)$ 之间找个干燥日。最早是第 $2$ 天，所以在第 $2$ 天抽干湖泊 $2$。`ans=[-1, -1, 2, ...]`
- 第 $5$ 天：湖泊 $1$ 下雨，它在第 $0$ 天就满了。需要在 $(0, 5)$ 之间找个干燥日。最早是第 $3$ 天，所以在第 $3$ 天抽干湖泊 $1$。`ans=[-1, -1, 2, 1, -1, -1]`

为什么这个贪心策略是 **正确** 的？也即，如果有多个干燥日可选，为什么我们选择 **最早** 的那个？因为选择最早的干燥日，可以将更晚的干燥日留给未来的、可能更紧急的情况。这保留了最大的灵活性，这个策略的关键之处。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        # 找到第一个值严格大于 target 的元素的索引
        def search(arr, target):
            low, high = 0, len(arr) - 1
            # 如果找不到，插入点就在数组末尾
            ans = len(arr)
            
            while low <= high:
                mid = low + (high - low) // 2
                if arr[mid] > target:
                    # 这是一个可能的答案，但我们尝试寻找更早的
                    ans = mid
                    high = mid - 1
                else:
                    # mid 不满足条件，必须在右边寻找
                    low = mid + 1
            return ans
        
        n = len(rains)
        ans = [0] * n
        # 已满湖泊及其被填满的日期，格式: {lake_id: day_index}
        full_lakes = {}
        # 所有干燥日的索引
        dry_days = []

        for i, lake in enumerate(rains):
            if lake > 0:
                # 这是个下雨天，在答案中标记为 -1
                ans[i] = -1
                
                if lake in full_lakes:
                    # 这个湖之前已经满了，有洪水风险
                    # last_rain_day 是这个湖上一次下雨的日期
                    last_rain_day = full_lakes[lake]
                    
                    # 在 (last_rain_day, i) 之间找到一个干燥日
                    # 使用二分查找在 dry_days 中寻找第一个 > last_rain_day 的索引
                    idx = search(dry_days, last_rain_day)
                    
                    if idx == len(dry_days):
                        # 找不到干燥日，洪水无法避免
                        return []
                    
                    # 找到了一个可用的、最早的干燥日
                    available = dry_days[idx]
                    
                    # 在那天抽干这个湖
                    ans[available] = lake
                    
                    # 这个干燥日已经被用掉
                    dry_days.pop(idx)
                
                # 更新湖泊被填满的日期为今天
                full_lakes[lake] = i
            else:
                # 这是个干燥日，将其索引存起来备用
                dry_days.append(i)

        # 遍历结束后，处理所有未使用的干燥日
        # 对于这些天，我们可以随便抽干一个湖（例如湖泊 1）
        for day in dry_days:
            ans[day] = 1
            
        return ans
```

```Java
// java
class Solution {
    // 找到第一个值严格大于 target 的元素的索引
    private int search(List<Integer> arr, int target) {
        int low = 0, high = arr.size() - 1;
        // 如果找不到，插入点就在数组末尾
        int ans = arr.size();
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr.get(mid) > target) {
                // 这是一个可能的答案，但我们尝试寻找更早的
                ans = mid;
                high = mid - 1;
            } else {
                // mid 不满足条件，必须在右边寻找
                low = mid + 1;
            }
        }
        return ans;
    }

    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] ans = new int[n];
        // 已满湖泊及其被填满的日期，格式: {lake_id: day_index}
        Map<Integer, Integer> fullLakes = new HashMap<>();
        // 所有干燥日的索引
        List<Integer> dryDays = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int lake = rains[i];
            if (lake > 0) {
                // 这是个下雨天，在答案中标记为 -1
                ans[i] = -1;
                
                if (fullLakes.containsKey(lake)) {
                    // 这个湖之前已经满了，有洪水风险
                    // lastRainDay 是这个湖上一次下雨的日期
                    int lastRainDay = fullLakes.get(lake);
                    
                    // 在 (lastRainDay, i) 之间找到一个干燥日
                    // 使用二分查找在 dryDays 中寻找第一个 > lastRainDay 的索引
                    int idx = search(dryDays, lastRainDay);
                    
                    if (idx == dryDays.size()) {
                        // 找不到干燥日，洪水无法避免
                        return new int[0];
                    }
                    
                    // 找到了一个可用的、最早的干燥日
                    int available = dryDays.get(idx);
                    
                    // 在那天抽干这个湖
                    ans[available] = lake;
                    
                    // 这个干燥日已经被用掉
                    dryDays.remove(idx);
                }
                
                // 更新湖泊被填满的日期为今天
                fullLakes.put(lake, i);
            } else {
                // 这是个干燥日，将其索引存起来备用
                dryDays.add(i);
            }
        }

        // 遍历结束后，处理所有未使用的干燥日
        // 对于这些天，我们可以随便抽干一个湖（例如湖泊 1）
        for (int day : dryDays) {
            ans[day] = 1;
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $rains$ 的长度，每次二分的时间为 $O(logn)$，但是从列表中 $pop$ 的时间接近 $O(n)$，如果换成有序结构可以优化为 $log$
- 空间复杂度： $O(n)$，表示哈希表 $fullLakes$ 以及列表 $dryDays$ 的大小，返回值 $ans$ 一般不计入复杂度

---

### 最小堆

能否即时处理，而不是延迟处理？

当然可以！上面已经说过，在每个干燥日，我们优先处理最紧急的任务，也就是抽干那个即将 **最早再次下雨** 的湖泊。

怎么知道这个信息？**预处理**。首先遍历一次 $rains$ 数组，将每个湖泊未来的所有下雨日期存储起来。这样在做决策时，我们就能 “预知未来”。

再次遍历 $rains$ 数组，模拟每一天的过程。

- 遇到下雨天：将湖泊标记为 “已满”，并将其 **下一次** 的下雨日期加入一个最小堆。
- 遇到干燥日：检查最小堆。如果堆不为空，说明有已满的湖泊未来会下雨。我们贪心地选择 **堆顶** 元素（即最早要下雨的那个），并抽干对应的湖泊。

预处理使用的结构是哈希 $Map$，存储 `(湖泊, 队列(下雨日期))`；使用一个最小堆，存放已满湖泊的 “下一次” 下雨日期；以及一个哈希 $Set$，辅助判断湖泊是否已满。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        # 创建一个字典，键是湖泊编号，值是一个双端队列，存储该湖泊所有下雨的日期
        lake_to_rain_days = defaultdict(deque)
        for day, lake_id in enumerate(rains):
            if lake_id != 0:
                lake_to_rain_days[lake_id].append(day)

        # 最小堆，用于存放已满湖泊的【下一次】下雨日期
        pq = []
        # 哪些湖泊当前是满的
        full_lakes = set()
        ans = []

        for day, lake_id in enumerate(rains):
            if lake_id != 0:  # 当天是下雨天
                # 这个湖已经满了，洪水无法避免
                if lake_id in full_lakes:
                    return []
                
                # 没满
                ans.append(-1)
                full_lakes.add(lake_id)
                
                # 移除今天的日期，因为它已经发生了
                lake_to_rain_days[lake_id].popleft()
                
                # 如果这个湖未来还会下雨
                if lake_to_rain_days[lake_id]:
                    # 将它【下一次】下雨的日期加入优先队列
                    next_rain_day = lake_to_rain_days[lake_id][0]
                    heapq.heappush(pq, next_rain_day)

            else:  # 当天是干燥日
                # 检查优先队列，看是否有已满的湖泊未来需要处理
                if not pq:
                    # 如果队列为空，意味着所有已满的湖泊在未来都不会再下雨了
                    # 我们可以随便抽干一个湖
                    ans.append(1)
                else:
                    # 贪心选择：从优先队列中取出最紧急的下雨日期
                    day_of_next_rain = heapq.heappop(pq)
                    
                    # 通过日期反查出是哪个湖泊需要被抽干
                    lake_to_dry = rains[day_of_next_rain]
                    
                    # 记录
                    ans.append(lake_to_dry)
                    
                    # 将这个湖从“已满”集合中移除
                    full_lakes.remove(lake_to_dry)
                    
        return ans
```

```Java
// java
class Solution {
    public int[] avoidFlood(int[] rains) {
        // 创建一个字典，键是湖泊编号，值是一个双端队列，存储该湖泊所有下雨的日期
        Map<Integer, Deque<Integer>> lakeToRainDays = new HashMap<>();
        for (int day = 0; day < rains.length; day++) {
            int lakeId = rains[day];
            if (lakeId != 0) {
                lakeToRainDays.computeIfAbsent(lakeId, k -> new ArrayDeque<>()).add(day);
            }
        }

        // 最小堆，用于存放已满湖泊的【下一次】下雨日期
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        // 哪些湖泊当前是满的
        Set<Integer> fullLakes = new HashSet<>();
        int[] ans = new int[rains.length];

        for (int day = 0; day < rains.length; day++) {
            int lakeId = rains[day];
            if (lakeId != 0) { // 当天是下雨天
                // 这个湖已经满了，洪水无法避免
                if (fullLakes.contains(lakeId)) {
                    return new int[0];
                }
                
                // 没满
                ans[day] = -1;
                fullLakes.add(lakeId);
                
                // 移除今天的日期，因为它已经发生了
                lakeToRainDays.get(lakeId).pollFirst();
                
                // 如果这个湖未来还会下雨
                if (!lakeToRainDays.get(lakeId).isEmpty()) {
                    // 将它【下一次】下雨的日期加入优先队列
                    int nextRainDay = lakeToRainDays.get(lakeId).peekFirst();
                    pq.add(nextRainDay);
                }

            } else { // 当天是干燥日
                // 检查优先队列，看是否有已满的湖泊未来需要处理
                if (pq.isEmpty()) {
                    // 如果队列为空，意味着所有已满的湖泊在未来都不会再下雨了
                    // 我们可以随便抽干一个湖
                    ans[day] = 1;
                } else {
                    // 贪心选择：从优先队列中取出最紧急的下雨日期
                    int dayOfNextRain = pq.poll();
                    
                    // 通过日期反查出是哪个湖泊需要被抽干
                    int lakeToDry = rains[dayOfNextRain];
                    
                    // 记录
                    ans[day] = lakeToDry;
                    
                    // 将这个湖从“已满”集合中移除
                    fullLakes.remove(lakeToDry);
                }
            }
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，堆的调整为 $O(logn)$，双端队列的加入/弹出为 $O(1)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/avoid-flood-in-the-city/solutions/3799758/shuang-jie-tan-xin-yan-chi-jue-ce-er-fen-swsh/)
