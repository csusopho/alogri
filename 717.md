[Problem: 717. 1 比特与 2 比特字符](https://leetcode.cn/problems/1-bit-and-2-bit-characters/description/)

### 方法：正序/倒序遍历

用 $a$ 表示 $0$，用 $b$ 表示 $10/11$，对数组 $bits$ 编码，最后一个字符是否必须为 $a$？

通过编码的性质可知，**编码方式是唯一的**。

给定的字符编码 $0$、 $10$ 和 $11$ 构成了一种 **前缀码**。在这类编码方式中，我们比较熟悉的，就是哈夫曼编码，本题是特殊的一类。

前缀码的 **定义** 是：在这个编码方案中，没有任何一个码字是另一个码字的前缀。

- $0$ 不是 $10$ 或 $11$ 的前缀。
- $10$ 不是 $0$ 或 $11$ 的前缀（反之亦然）。
- $11$ 不是 $0$ 或 $10$ 的前缀（反之亦然）。

**为什么前缀码能保证唯一解码？**

因为从左到右读取比特流时，每一步的决策都是确定无疑的，没有任何歧义。

- 读到一个 $0$，立刻知道这是一个完整的一比特字符 $a$，不需要再往后看。
- 读到一个 $1$，立刻知道这肯定是一个两比特字符 $b$ 的开始，必须再读一位来完成解码（无论是 $10$ 还是 $11$）。

由于在解码的每一步都没有多种选择，因此对于一个给定的 $bits$ 数组，从头到尾的解码路径只有一条。例如，对于 $[1, 1, 1, 0]$，唯一的解码方式就是 $bb(11,10)$。

> $ps$：如果不好理解，可以根据连续 $1$ 数量的奇偶性，分情况讨论，慢慢推导。

总结一下，本题的解码 **流程唯一**，从前往后遍历：

- 遇到 $1$ 就编码为 $b$，并向后跳两次；
- 遇到 $0$ 就编码为 $a$，并向后跳一次。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        n, idx = len(bits), 0
        # 遇到1向后跳两次，遇到0就向后跳一次
        while idx < n - 1:
            if bits[idx] == 1:
                idx += 1
            idx += 1
        return idx == n - 1
```

```Java
// java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int n = bits.length, idx = 0;
        // 遇到1向后跳两次，遇到0就向后跳一次
        while (idx < n - 1) {
            if (bits[idx] == 1) {
                idx += 1;
            }
            idx += 1;
        }
        return idx == n - 1;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $bits$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 倒序

实际上，无需编码整个 $bit$ 数组。

因为题目确保最后一个字符是 $0$，因此仅需判断 **最后的** $0$ 是否 **独立** 构成一个一比特字符 $a$。一个 $0$ 无法独立，当且仅当它被它左边的一个 $1$ “配对” 成一个 $10$ 的两比特字符。

一个聪明的 **倒序** 解法：从倒数第二个元素开始，向左检查 **连续 $1$ 的数量**。

两比特字符必须以 $1$ 开头，考虑最后一个 $0$ 前面的比特序列。

- 如果倒数第二个比特是 $0$，例如 $[..., 0, 0]$，那么最后一个 $0$ 显然可以独立成为一个一比特字符 $a$。此时连续 $1$ 的数量是 $0$。
- 如果倒数第二个比特是 $1$，例如 $[..., 1, 0]$，从左到右解码时，这个 $1$ 必须和后面的 $0$ 结合形成 $10$，所以一定不能组成一比特字符 $a$。此时连续 $1$ 的数量是 $1$。
- 如果序列是 $[..., 1, 1, 0]$ 呢？解码到这个部分时， $11$ 会被解析成一个两比特字符，剩下的 $0$ 成为一个独立的一比特字符 $a$。此时连续 $1$ 的数量是 $2$。
- 如果序列是 $[..., 1, 1, 1, 0]$ 呢？ $11$ 会先被解析，剩下的这个 $10$ 也会被解析成一个两比特字符 $b$。所以最后一个 $0$ 不是独立的。此时连续 $1$ 的数量是 $3$。

通过上面的例子，我们可以发现一个规律：最后一个 $0$ 是否独立，完全取决于它前面 **连续 $1$ 的数量的奇偶性**。

- **偶数个 $1$**：这些 $1$ 可以两两配对为 $11$，不会 “占用” 最后的 $0$。因此，最后一个字符是一比特字符 $a$。
- **奇数个 $1$**：这些 $1$ 两两配对后，会剩下一个 $1$。这个剩下的 $1$ 必须和最后的 $0$ 结合成 $10$。因此，最后一个字符是两比特字符 $b$。

总结：从 $bits$ 数组的倒数第二个位置开始，向左计数，看看有多少个连续的 $1$。最后判断这个计数的奇偶性。

代码如下，已附加注释：

```Python
# python
class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        # 倒序向前
        i = len(bits) - 2
        
        # 最后一个 0 之前有多少个连续的 1
        cnts1 = 0
        while i >= 0 and bits[i] == 1:
            cnts1 += 1
            i -= 1
            
        # 偶数，最后一个 0 单独组成 a
        # 奇数，会和它前面的 1 组成 b
        return cnts1 % 2 == 0
```

```Java
// java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        // 倒序向前
        int i = bits.length - 2;
        
        // 最后一个 0 之前有多少个连续的 1
        int cnts1 = 0;
        while (i >= 0 && bits[i] == 1) {
            cnts1++;
            i--;
        }
            
        // 偶数，最后一个 0 单独组成 a
        // 奇数，会和它前面的 1 组成 b
        return cnts1 % 2 == 0;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/1-bit-and-2-bit-characters/solutions/3835238/shuang-jie-jie-du-ti-yi-shuo-ming-bian-m-oio9/)
