[Problem: 3607. 电网维护](https://leetcode.cn/problems/power-grid-maintenance/description/)

### 方法：DFS&并查集 + 排序

先解读一下题意，电站 $i$ 的编号是 $i$，如果给出 $[i,j],[j,k]$ 的连接，说明 $i,j,k$ 这三个电站 **相互连通**，属于同一个电网（连通块）。

查询 $1$：需要找出一个连通块中，最小编号且 **在线** 的电站；查询 $2$：让电站 $i$ **离线**，不会重新上线，可以理解为将它从连通块中移除。只有查询 $1$ 才会返回结果！

此时，相信大家已经理清逻辑：每个 “电网” 中是由很多 “节点” 组成，我们需要做的就是在 “电网” 中搜索最小 “节点”。

一个 **简单** 思路：根据给定的 $connections$ 构建无向图，每次查询时，使用 $BFS/DFS$ 在每个连通块内搜索，找出最小值。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        # 邻接表，键是电站ID，值是与其相连的电站列表
        adj = defaultdict(list)
        for u, v in connections:
            adj[u].append(v)
            adj[v].append(u)

        # 跟踪电站的在线状态
        is_online = [True] * (c + 1)
        res = []

        # 按顺序处理
        for query_type, x in queries:
            # 让电站 x 离线
            if query_type == 2:
                is_online[x] = False
                continue
            
            # 对电站 x 进行维护检查
            # 如果电站 x 本身在线
            if is_online[x]:
                res.append(x)
            # 如果电站 x 离线，则需要找到同电网中编号最小的在线电站
            else:
                min_online_id = float('inf')
                # BFS遍历x所在的连通分量
                q = deque([x])
                visited = {x}
                found = False
                
                while q:
                    cur = q.popleft()
                    
                    # 检查当前电站是否在线
                    if is_online[cur]:
                        found = True
                        min_online_id = min(min_online_id, cur)

                    # 将所有未访问过的邻居加入队列
                    for neighbor in adj[cur]:
                        if neighbor not in visited:
                            visited.add(neighbor)
                            q.append(neighbor)
                
                # 如果找到了在线电站，则记录结果，否则记录-1
                if found:
                    res.append(min_online_id)
                else:
                    res.append(-1)
                        
        return res
```

最坏情况下，整个图是完全连通的，即只有一个电网。无向图的点数是 $c$，边数是 $n$，一共 $q$ 次查询，每次都需要搜索整个图，所以总时间为 $O(q\times (c+n))$。

题目制定 $q,c,n$ 都是 $O(10^5)$ 量级，所以会超时，卡在 $668/671$ 样例。

---

### 排序+指针

在处理查询前，电网已经构建完成。此时，每个电网包含的节点都是已知的。上面的方法会重复搜索，我们完全可以利用这些结果，进行预处理！

比如某个电网包含节点 $3,4,2,1$，完全可以对它进行 **排序**，将它变为 $1,2,3,4$。如此一来，如果查询节点 $3$ 所在电网的最小节点，一步看出是 $1$！

那节点离线（删除）了怎么办？为每个排序后的电网维护一个 **指针**，它指向最小的有效节点！查询时，判断指针指向的节点是否离线，

- 如果离线，说明这个节点无效，则将指针向后移动，直到找到在线节点，或者到达末尾；
- 如果在线，说明节点有效，直接将它返回。

这个处理逻辑，近似 “懒删除” 的含义。

那怎么知道节点属于哪个电网？在 $DFS$ 构建连通块时，给每个连通块赋予独特标记，使用 **哈希表** 建立一个从 “电站 $ID$” 到 “所属电网 $ID$” 的映射。

**流程**：先构建邻接表（无向图），然后使用 $DFS$ 构建连通块，每个块内进行排序。查询时，通过指针找到最小的有效节点，记录答案。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        # 邻接表，键是电站ID，值是与其相连的电站列表
        adj = defaultdict(list)
        for u, v in connections:
            adj[u].append(v)
            adj[v].append(u)

        # 存储所有的“电网”（连通分量）
        components = []
        # 电站 i 属于第 k 个电网
        node_to_comp = [-1] * (c + 1)
        visited = [False] * (c + 1)

        # 构建一个连通分量
        def dfs(node, cur_comp):
            visited[node] = True
            cur_comp.append(node)
            for neighbor in adj[node]:
                if not visited[neighbor]:
                    dfs(neighbor, cur_comp)

        # 找出所有独立的电网
        for i in range(1, c + 1):
            # 从未访问过的节点开始，用DFS找到其所在电网的所有成员
            if not visited[i]:
                cur_comp = []
                dfs(i, cur_comp)
                # 对当前找到的电网成员进行排序
                cur_comp.sort()
                # 为该电网分配一个ID，并建立每个成员到该ID的映射
                comp_id = len(components)
                for node in cur_comp:
                    node_to_comp[node] = comp_id
                # 存储该电网
                components.append(cur_comp)
        
        is_online = [True] * (c + 1)
        # 为每个电网维护一个指针，指向当前最小的在线电站的索引
        min_online_ptr = [0] * len(components)
        res = []
        
        for query_type, x in queries:
            # 让电站 x 离线
            if query_type == 2:
                is_online[x] = False
                continue
            
            # 对电站 x 进行维护检查
            # 如果电站 x 本身在线
            if is_online[x]:
                res.append(x)
                continue

            # 找到电站 x 所属的电网
            comp_id = node_to_comp[x]
            
            # 节点是孤立的
            if comp_id == -1:
                # 这种情况意味着它自成一个电网，且它自己已经离线
                res.append(-1)
                continue

            component_list = components[comp_id]
            ptr = min_online_ptr[comp_id]
            
            # 从当前指针开始，向后移动，跳过所有已离线的电站
            while ptr < len(component_list) and not is_online[component_list[ptr]]:
                ptr += 1
            
            # 更新指针
            min_online_ptr[comp_id] = ptr

            # 移出范围，说明该电网已全部离线
            if ptr == len(component_list):
                res.append(-1)
            else:
                # 否则，找到了编号最小的在线电站
                res.append(component_list[ptr])
            
        return res
```

```Java
// java
class Solution {
    // 构建一个连通分量
    private void dfs(int node, List<Integer> curComp, Map<Integer, List<Integer>> adj, boolean[] visited) {
        visited[node] = true;
        curComp.add(node);
        // 注意：adj.getOrDefault 返回一个空列表，避免了空指针异常
        for (int neighbor : adj.getOrDefault(node, new ArrayList<>())) {
            if (!visited[neighbor]) {
                dfs(neighbor, curComp, adj, visited);
            }
        }
    }

    public int[] processQueries(int c, int[][] connections, int[][] queries) {
        // 邻接表，键是电站ID，值是与其相连的电站列表
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int[] conn : connections) {
            adj.computeIfAbsent(conn[0], k -> new ArrayList<>()).add(conn[1]);
            adj.computeIfAbsent(conn[1], k -> new ArrayList<>()).add(conn[0]);
        }

        // 存储所有的“电网”（连通分量）
        List<List<Integer>> components = new ArrayList<>();
        // 电站 i 属于第 k 个电网
        int[] node_to_comp = new int[c + 1];
        Arrays.fill(node_to_comp, -1);
        boolean[] visited = new boolean[c + 1];

        // 找出所有独立的电网
        for (int i = 1; i <= c; i++) {
            // 从未访问过的节点开始，用DFS找到其所在电网的所有成员
            if (!visited[i]) {
                List<Integer> curComp = new ArrayList<>();
                dfs(i, curComp, adj, visited);
                // 对当前找到的电网成员进行排序
                Collections.sort(curComp);
                // 为该电网分配一个ID，并建立每个成员到该ID的映射
                int compId = components.size();
                for (int node : curComp) {
                    node_to_comp[node] = compId;
                }
                // 存储该电网
                components.add(curComp);
            }
        }

        boolean[] is_online = new boolean[c + 1];
        Arrays.fill(is_online, true);
        // 为每个电网维护一个指针，指向当前最小的在线电站的索引
        int[] min_online_ptr = new int[components.size()];
        List<Integer> resList = new ArrayList<>();

        for (int[] query : queries) {
            int query_type = query[0];
            int x = query[1];
            
            // 让电站 x 离线
            if (query_type == 2) {
                is_online[x] = false;
                continue;
            }

            // 对电站 x 进行维护检查
            // 如果电站 x 本身在线
            if (is_online[x]) {
                resList.add(x);
                continue;
            }

            // 找到电站 x 所属的电网
            int compId = node_to_comp[x];

            // 节点是孤立的
            if (compId == -1) {
                // 这种情况意味着它自成一个电网，且它自己已经离线
                resList.add(-1);
                continue;
            }

            List<Integer> componentList = components.get(compId);
            int ptr = min_online_ptr[compId];

            // 从当前指针开始，向后移动，跳过所有已离线的电站
            while (ptr < componentList.size() && !is_online[componentList.get(ptr)]) {
                ptr++;
            }

            // 更新指针
            min_online_ptr[compId] = ptr;

            // 移出范围，说明该电网已全部离线
            if (ptr == componentList.size()) {
                resList.add(-1);
            } else {
                // 否则，找到了编号最小的在线电站
                resList.add(componentList.get(ptr));
            }
        }

        // 将结果列表转换为 int[]
        int[] result = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            result[i] = resList.get(i);
        }
        return result;
    }
}
```

- 时间复杂度： $O(n+q+clogc)$，其中 $n,q$ 分别是数组 $connections,queries$ 的长度。快排进行升序，每个指针最多各自移动一趟连通块，线性时间
- 空间复杂度： $O(c+n)$，表示邻接表、连通块、递归栈的大小，返回值 $res$ 不计入

---

### 并查集

构建连通块？联想到使用 **并查集**，具体的原理以及模版，可以看这篇题解，[传送门](https://leetcode.cn/problems/redundant-connection/solutions/2966966/bing-cha-ji-bao-li-mei-ju-zhao-huan-you-k08ct/)。

保持上面的逻辑，并使用「路径压缩」和「按秩合并」的优化算法，仅需要修改构建连通块的步骤即可。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        parent = list(range(c + 1))
        size = [1] * (c + 1)

        # 查找根节点并路径压缩
        def find(i):
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]

        # 按秩合并
        def union(i, j):
            root_i = find(i)
            root_j = find(j)
            if root_i != root_j:
                # 确保 root_i 是较大的树
                if size[root_i] < size[root_j]:
                    root_i, root_j = root_j, root_i
                parent[root_j] = root_i
                size[root_i] += size[root_j]

        # 构建电网（连通分量）
        for u, v in connections:
            union(u, v)

        # 按根节点对所有电站进行分组
        components_map = defaultdict(list)
        for i in range(1, c + 1):
            root = find(i)
            components_map[root].append(i)
            
        # 存储所有的电网
        components = []
        # 映射：电站ID -> 电网ID
        node_to_comp = [-1] * (c + 1)
        
        for root_node in components_map:
            # 对电网成员进行排序
            comp_list = sorted(components_map[root_node])
            # 为该电网分配一个ID，并建立每个成员到该ID的映射
            comp_id = len(components)
            for node in comp_list:
                node_to_comp[node] = comp_id
            # 存储该电网
            components.append(comp_list)

        is_online = [True] * (c + 1)
        # 每个电网一个指针
        min_online_ptr = [0] * len(components)
        res = []

        for query_type, x in queries:
            # 让电站 x 离线
            if query_type == 2:
                is_online[x] = False
                continue
            
            # 对电站 x 进行维护检查
            # 如果电站 x 本身在线
            if is_online[x]:
                res.append(x)
                continue

            # 找到电站 x 所属的电网
            comp_id = node_to_comp[x]
            component_list = components[comp_id]
            ptr = min_online_ptr[comp_id]
            
            # 移动指针，跳过所有离线的电站
            while ptr < len(component_list) and not is_online[component_list[ptr]]:
                ptr += 1
            
            # 更新指针
            min_online_ptr[comp_id] = ptr

            # 移出范围，说明该电网已全部离线
            if ptr == len(component_list):
                res.append(-1)
            else:
                res.append(component_list[ptr])

        return res
```

```Java
// java
class Solution {
    private int[] parent;
    private int[] size;

    // 查找根节点并路径压缩
    private int find(int i) {
        if (parent[i] != i) {
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    // 按秩合并
    private void union(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            // 确保 root_i 是较大的树
            if (size[root_i] < size[root_j]) {
                int temp = root_i;
                root_i = root_j;
                root_j = temp;
            }
            parent[root_j] = root_i;
            size[root_i] += size[root_j];
        }
    }

    public int[] processQueries(int c, int[][] connections, int[][] queries) {
        parent = new int[c + 1];
        size = new int[c + 1];
        for (int i = 0; i <= c; i++) {
            parent[i] = i;
            size[i] = 1;
        }

        // 构建电网（连通分量）
        for (int[] conn : connections) {
            union(conn[0], conn[1]);
        }

        // 按根节点对所有电站进行分组
        Map<Integer, List<Integer>> componentsMap = new HashMap<>();
        for (int i = 1; i <= c; i++) {
            int root = find(i);
            componentsMap.computeIfAbsent(root, k -> new ArrayList<>()).add(i);
        }

        // 存储所有的电网
        List<List<Integer>> components = new ArrayList<>();
        // 映射：电站ID -> 电网ID
        int[] node_to_comp = new int[c + 1];
        Arrays.fill(node_to_comp, -1);

        for (int rootNode : componentsMap.keySet()) {
            // 对电网成员进行排序
            List<Integer> compList = componentsMap.get(rootNode);
            Collections.sort(compList);
            // 为该电网分配一个ID，并建立每个成员到该ID的映射
            int compId = components.size();
            for (int node : compList) {
                node_to_comp[node] = compId;
            }
            // 存储该电网
            components.add(compList);
        }

        boolean[] is_online = new boolean[c + 1];
        Arrays.fill(is_online, true);
        // 每个电网一个指针
        int[] min_online_ptr = new int[components.size()];
        List<Integer> resList = new ArrayList<>();

        for (int[] query : queries) {
            int query_type = query[0];
            int x = query[1];

            // 让电站 x 离线
            if (query_type == 2) {
                is_online[x] = false;
                continue;
            }

            // 对电站 x 进行维护检查
            // 如果电站 x 本身在线
            if (is_online[x]) {
                resList.add(x);
                continue;
            }

            // 找到电站 x 所属的电网
            int compId = node_to_comp[x];
            List<Integer> componentList = components.get(compId);
            int ptr = min_online_ptr[compId];

            // 移动指针，跳过所有离线的电站
            while (ptr < componentList.size() && !is_online[componentList.get(ptr)]) {
                ptr++;
            }

            // 更新指针
            min_online_ptr[compId] = ptr;

            // 移出范围，说明该电网已全部离线
            if (ptr == componentList.size()) {
                resList.add(-1);
            } else {
                resList.add(componentList.get(ptr));
            }
        }

        return resList.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

- 时间复杂度： $O(n+q+clogc)$，使用了路径压缩，严谨的话写作 $n*α(c)$
- 空间复杂度： $O(c)$，不需要构建邻接表

---

### 优化

实际上，没必要使用指针去 “逻辑删除”，直接 “真正删除”。因为构建好电网后，我们再也 **不关心** 连通性，只需要知道每个电网中 **还剩余** 什么节点。

如果直接从列表头部 $pop$ 节点，会浪费 $O(len)$ 时间，所以可以换为 **降序** 排列。这样一来，每次删除节点都是从尾部弹出，花费时间是 $O(1)$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        sz = c + 1
        # parent[i] 存储节点 i 的父节点
        parent = list(range(sz))
        # rank[i] 用于按秩合并，优化并查集树的高度
        rank = [0] * sz

        # 查找节点的根，并进行路径压缩
        def find(node_id):
            # 递推形式
            while parent[node_id] != node_id:
                parent[node_id] = parent[parent[node_id]]
                node_id = parent[node_id]
            return node_id
        
        # 合并两个节点所在的集合，并按秩合并
        def union(node1, node2):
            root1, root2 = find(node1), find(node2)
            if root1 == root2: 
                return
            
            # 将秩小的树合并到秩大的树上
            if rank[root1] > rank[root2]:
                parent[root2] = root1
            elif rank[root1] < rank[root2]:
                parent[root1] = root2
            else: # 秩相等时，任意合并，并将合并后的根的秩加一
                parent[root1] = root2
                rank[root2] += 1

        # 构建电网（连通分量）
        for u, v in connections:
            union(u, v)
        
        # 按根节点对所有电站进行分组
        components_map = defaultdict(list)
        for station_id in range(1, sz):
            root = find(station_id)
            components_map[root].append(station_id)
        
        # 降序，使得编号最小的电站在列表末尾，方便 pop
        for component in components_map.values():
            component.sort(reverse=True)
        
        res = []
        # 电站 i 是否已离线
        is_offline = [False] * sz

        for query_type, station in queries:
            if query_type == 1:  # 维护检查
                if not is_offline[station]:
                    # 本身在线
                    res.append(station)
                else:
                    # 离线，找到其所在电网中编号最小的在线电站
                    root = find(station)
                    component = components_map[root]
                    
                    # 从列表末尾开始检查，并移除所有已离线的电站
                    while component and is_offline[component[-1]]:
                        component.pop()
                    
                    # 列表末尾是最小的
                    res.append(component[-1] if component else -1)

            elif query_type == 2:  # 电站离线
                is_offline[station] = True
        
        return res
```

```Java
// java
class Solution {
    // parent[i] 存储节点 i 的父节点
    private int[] parent;
    // rank[i] 用于按秩合并，优化并查集树的高度
    private int[] rank;

    // 查找节点的根，并进行路径压缩
    private int find(int node_id) {
        // 递推形式
        while (parent[node_id] != node_id) {
            parent[node_id] = parent[parent[node_id]];
            node_id = parent[node_id];
        }
        return node_id;
    }

    // 合并两个节点所在的集合，并按秩合并
    private void union(int node1, int node2) {
        int root1 = find(node1);
        int root2 = find(node2);
        if (root1 == root2) {
            return;
        }

        // 将秩小的树合并到秩大的树上
        if (rank[root1] > rank[root2]) {
            parent[root2] = root1;
        } else if (rank[root1] < rank[root2]) {
            parent[root1] = root2;
        } else { // 秩相等时，任意合并，并将合并后的根的秩加一
            parent[root1] = root2;
            rank[root2]++;
        }
    }

    public int[] processQueries(int c, int[][] connections, int[][] queries) {
        int sz = c + 1;
        // parent[i] 存储节点 i 的父节点
        parent = new int[sz];
        for (int i = 0; i < sz; i++) parent[i] = i;
        // rank[i] 用于按秩合并，优化并查集树的高度
        rank = new int[sz];

        // 构建电网（连通分量）
        for (int[] conn : connections) {
            union(conn[0], conn[1]);
        }

        // 按根节点对所有电站进行分组
        Map<Integer, List<Integer>> componentsMap = new HashMap<>();
        for (int stationId = 1; stationId < sz; stationId++) {
            int root = find(stationId);
            componentsMap.computeIfAbsent(root, k -> new ArrayList<>()).add(stationId);
        }

        // 降序，使得编号最小的电站在列表末尾，方便 pop
        for (List<Integer> component : componentsMap.values()) {
            component.sort(Collections.reverseOrder());
        }

        List<Integer> resList = new ArrayList<>();
        // 电站 i 是否已离线
        boolean[] is_offline = new boolean[sz];

        for (int[] query : queries) {
            int query_type = query[0];
            int station = query[1];

            if (query_type == 1) { // 维护检查
                if (!is_offline[station]) {
                    // 本身在线
                    resList.add(station);
                } else {
                    // 离线，找到其所在电网中编号最小的在线电站
                    int root = find(station);
                    List<Integer> component = componentsMap.get(root);

                    // 从列表末尾开始检查，并移除所有已离线的电站
                    while (!component.isEmpty() && is_offline[component.get(component.size() - 1)]) {
                        component.remove(component.size() - 1);
                    }

                    // 列表末尾是最小的
                    resList.add(!component.isEmpty() ? component.get(component.size() - 1) : -1);
                }
            } else if (query_type == 2) { // 电站离线
                is_offline[station] = true;
            }
        }
        
        return resList.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

- 时间复杂度： $O(n+q+clogc)$，同理
- 空间复杂度： $O(c)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/power-grid-maintenance/solutions/3825031/san-jie-bao-li-bfs-dfspai-xu-dan-zhi-zhe-47h6/)
