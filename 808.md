[Problem: 808. 分汤](https://leetcode.cn/problems/soup-servings/description/)

### 方法：DFS/DP

拿示例 $1$ 举例，初始容量是 $50$：

- 执行操作 $1$ 的概率是 $0.25$，$A$ 倒空 $B$ 有剩余，符合要求
- 执行操作 $2$ 的概率是 $0.25$，$A$ 倒空 $B$ 有剩余，符合要求
- 执行操作 $3$ 的概率是 $0.25$，$A,B$ 同时倒空，符合要求，但是指定要 $/2$
- 执行操作 $4$ 的概率是 $0.25$，$A$ 有剩余 $B$ 倒空，不符合要求

因此，答案就是 $0.25+0.25+0.25/2=0.675$。

多轮操作，就是概率相乘。总体上看，就是一棵 **四叉树**，每个分支的概率是 $0.25$，所以每次向下（操作叠加）都会乘以 $0.25$。用示例 $2$ 举例：

初始 $n=100 ml$，每个节点是 $(A 剩余, B 剩余)$，箭头表示一次操作，概率都是 $0.25$。

```Java
(100, 100)   # 初始状态
   ├── 0.25 → (0, 100)   # 倒出 (100, 0)  → A 先空
   ├── 0.25 → (25, 75)   # 倒出 (75, 25)
   ├── 0.25 → (50, 50)   # 倒出 (50, 50)
   └── 0.25 → (75, 25)   # 倒出 (25, 75)
```

然后这些子状态继续递归，例如从 $(25, 75)$ 出发：

```Java
(25, 75)     # 子状态
   ├── 0.25 → (0, 75)    # 倒出 (25, 0)  → A 先空
   ├── 0.25 → (0, 50)    # 倒出 (25, 25) → A 先空
   ├── 0.25 → (0, 25)    # 倒出 (25, 50) → A 先空
   └── 0.25 → (0,  0)    # 倒出 (25, 75) → 同时空
```

为什么是乘以 $0.25$？每轮操作与之前的所有轮次 **无关**，也就是独立同分布，根据乘法公定律可知，两个独立事件同时发生的概率是概率的乘积。

每轮操作时从 $4$ 种选择中挑一个，从而将父问题变为规模更小的子问题，而下一轮操作依旧是 $4$ 种选择挑一个。所以联想到 **递归**。

**定义** $dfs(a,b)$ 表示汤 $A$ 剩余 $a$ 毫升且汤 $B$ 剩余 $b$ 毫升，总的概率和。

每轮操作一共 $4$ 种选择，分别会让汤 $A,B$ 减少，**状态转移方程** 为：

$$
dfs(a,b) =
\frac{1}{4} \Bigl(
dfs(a-100, b)+dfs(a-75, b-25)+dfs(a-50, b-50)+dfs(a-25, b-75)
\Bigr)
$$

为了方便，上面的方程没有加上 $max(?,0)$ 的边界约束，实际上需要。递归边界、初始化等细节不再阐述，详情见代码。

切记，一定要用 **记忆化**。因为初始 $200ml$ 到分别 $100ml$，可以选择操作 $2,3$ 或者 $3,2$。两者在树中属于不同分支，但是后续子树的形状相同，是重复操作。也即，相同参数下，要避免重复搜索，需要增加记忆化手段。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

---

我们发现，随着 $n$ 的增大，答案也随之增大。当 $n$ 足够大时，最终答案 **趋近于 $1$**，可以用数学 + 概率分布来理解。  

从四种操作来看：

- $A$ **平均** 倒出量 = $(100 + 75 + 50 + 25) / 4 = 62.5 ml$
- $B$ **平均** 倒出量 = $(0 + 25 + 50 + 75) / 4 = 37.5 ml$

也即， $A$ 的倒出速度明显快于 $B$，约快 $62.5 / 37.5 = 1.67$ 倍，所以时间长了必然更早耗尽。

假设 $n\to \infty$，我们可以把问题近似为 **连续时间马尔可夫过程**，每一步的倒出量比例是固定的平均值，时间到 $t$ 时：

- $A(t) ≈ n - 62.5 * t$
- $B(t) ≈ n - 37.5 * t$

让 $A$ 提前或同时倒完，解方程可知 $t_A < t_B$，所以 $A$ 先空几乎是必然事件。 $n$ 越大，波动占比越小，概率越接近 $1$。

实际测试当 $n=5000$ 时，计算结果为 $0.9999967386599964$，与 $1.0$ 的差异 $< 10^{-6}$，符合要求，可以返回 $1$。这是一个经验阈值，略保守，具体测试下来 $4275$ 足够。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def soupServings(self, n: int) -> float:
        # 大输入优化：当 n 足够大时，结果无限趋近于 1
        if n > 5000:
            return 1.0

        # 当前汤 A 剩余 a 毫升，汤 B 剩余 b 毫升
        @cache
        def dfs(a, b):
            # 边界情况
            if a <= 0 and b <= 0:  # 同时倒完
                return 0.5
            if a <= 0:  # A 先倒完
                return 1.0
            if b <= 0:  # B先倒完
                return 0.0
            
            # 四种操作的概率分别都是0.25
            return 0.25 * (
                dfs(a - 100, b) +
                dfs(a - 75,  b - 25) +
                dfs(a - 50,  b - 50) +
                dfs(a - 25,  b - 75)
            )

        return dfs(n, n)
```

```Java
// java
class Solution {
    // memo数组用于记忆化
    private double[][] memo;

    public double soupServings(int n) {
        // 大输入优化：当 n 足够大时，结果无限趋近于 1
        if (n > 5000) {
            return 1.0;
        }
        // 概率一定大于0，所以这里可以不使用-1初始化
        memo = new double[n + 1][n + 1];
        return dfs(n, n);
    }

    // 当前汤 A 剩余 a 毫升，汤 B 剩余 b 毫升
    private double dfs(int a, int b) {
        // 边界情况
        if (a <= 0 && b <= 0) { // 同时倒完
            return 0.5;
        }
        if (a <= 0) { // A 先倒完
            return 1.0;
        }
        if (b <= 0) { // B先倒完
            return 0.0;
        }

        // 查缓存
        if (memo[a][b] != 0.0) {
            return memo[a][b];
        }

        // 四种操作的概率分别都是0.25
        double res = 0.25 * (
            dfs(Math.max(a - 100, 0), b) +
            dfs(Math.max(a - 75, 0), Math.max(b - 25, 0)) +
            dfs(Math.max(a - 50, 0), Math.max(b - 50, 0)) +
            dfs(Math.max(a - 25, 0), Math.max(b - 75, 0))
        );

        memo[a][b] = res;
        return res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(n^2)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n^2)$。

- 时间复杂度： $O(n^2)$，其中 $n$ 为题目给定容量，这里限制 $n\leq 5\times 10^3$
- 空间复杂度： $O(n^2)$，表示数组 $memo$ 的大小

---

### $DP$

将递归 $1:1$ 转为递推。

**定义** $dp[a][b]$ 汤 $A$ 剩余 $a$ 毫升且汤 $B$ 剩余 $b$ 毫升，总的概率和。初始化、递推边界等，根据递归同等转化即可，这里不再阐述。

**优化点**：能发现，四种操作都是 $25ml$ 的倍数。所以按照 $25$ 的单位，将分汤的数字范围大大减小。注意，如果不够倒就是剩余全倒完，所以是 **上取整** $ceil$，对于 $60ml$ 来说，它能倒 $3$ 次 $25ml$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def soupServings(self, n: int) -> float:
        # 大值直接近似 1
        if n > 5000:
            return 1.0

        # 缩放到 25ml 为一个单位
        N = math.ceil(n / 25)

        dp = [[0.0] * (N + 1) for _ in range(N + 1)]
        # 初始化边界
        dp[0][0] = 0.5
        for b in range(1, N + 1):
            dp[0][b] = 1.0
        for a in range(1, N + 1):
            dp[a][0] = 0.0

        # 自底向上填表
        for a in range(1, N + 1):
            for b in range(1, N + 1):
                dp[a][b] = 0.25 * (
                    dp[max(a - 4, 0)][b] +
                    dp[max(a - 3, 0)][max(b - 1, 0)] +
                    dp[max(a - 2, 0)][max(b - 2, 0)] +
                    dp[max(a - 1, 0)][max(b - 3, 0)])

        return dp[N][N]
```

```Java
// java
class Solution {
    public double soupServings(int n) {
        // 大值直接近似 1
        if (n > 5000) {
            return 1.0;
        }

        // 缩放到 25ml 为一个单位
        int N = (int) Math.ceil(n / 25.0);

        double[][] dp = new double[N + 1][N + 1];
        // 初始化边界
        dp[0][0] = 0.5;
        for (int b = 1; b <= N; b++) {
            dp[0][b] = 1.0;
        }
        for (int a = 1; a <= N; a++) {
            dp[a][0] = 0.0;
        }

        // 自底向上填表
        for (int a = 1; a <= N; a++) {
            for (int b = 1; b <= N; b++) {
                dp[a][b] = 0.25 * (
                    dp[Math.max(a - 4, 0)][b] +
                    dp[Math.max(a - 3, 0)][Math.max(b - 1, 0)] +
                    dp[Math.max(a - 2, 0)][Math.max(b - 2, 0)] +
                    dp[Math.max(a - 1, 0)][Math.max(b - 3, 0)]);
            }
        }

        return dp[N][N];
    }
}
```

- 时间复杂度： $O(m^2)$， $n$ 在整除 $25$ 后，得到的 $m\leq 200$
- 空间复杂度： $O(m^2)$，表示数组 $dp$ 的大小

---

### 预处理

如果数据是死的，也即相同输入一定能得到相同输出，那么常见操作就是 **打表**。

在动规中同理，将 $dp$ 的处理部分提到 **静态** 代码块中，提前进行计算。力扣平台是多次调用 $soup$ 方法跑所有样例，所以预处理中的内容只会计算一次。

代码如下，已附加注释：

```Python
# python
# 预处理最大范围
MAX_N = 180
# 创建 DP 表
dp = [[0.0] * (MAX_N + 1) for _ in range(MAX_N + 1)]

# 边界
dp[0][0] = 0.5
for b in range(1, MAX_N + 1):
    dp[0][b] = 1.0
for a in range(1, MAX_N + 1):
    dp[a][0] = 0.0

# 自底向上填表
for a in range(1, MAX_N + 1):
    for b in range(1, MAX_N + 1):
        dp[a][b] = 0.25 * (
            dp[max(a - 4, 0)][b] +
            dp[max(a - 3, 0)][max(b - 1, 0)] +
            dp[max(a - 2, 0)][max(b - 2, 0)] +
            dp[max(a - 1, 0)][max(b - 3, 0)])

class Solution:
    def soupServings(self, n: int) -> float:
        m = math.ceil(n / 25)
        if m >= MAX_N:
            return 1.0
        return dp[m][m]
```

```Java
// java
class Solution {
    private static final int MAX_N = 180;
    private static final double[][] dp = new double[MAX_N + 1][MAX_N + 1];

    // 静态代码块，类加载时预处理 DP 表
    static {
        // 初始化边界
        dp[0][0] = 0.5;
        for (int b = 1; b <= MAX_N; b++) {
            dp[0][b] = 1.0;
        }
        for (int a = 1; a <= MAX_N; a++) {
            dp[a][0] = 0.0;
        }

        // 自底向上填表
        for (int a = 1; a <= MAX_N; a++) {
            for (int b = 1; b <= MAX_N; b++) {
                dp[a][b] = 0.25 * (
                    dp[Math.max(a - 4, 0)][b] +
                    dp[Math.max(a - 3, 0)][Math.max(b - 1, 0)] +
                    dp[Math.max(a - 2, 0)][Math.max(b - 2, 0)] +
                    dp[Math.max(a - 1, 0)][Math.max(b - 3, 0)]
                );
            }
        }
    }

    public double soupServings(int n) {
        int m = (int) Math.ceil(n / 25.0);
        if (m >= MAX_N) {
            return 1.0;
        }
        return dp[m][m];
    }
}
```

- 时间复杂度： $O(1)$，预处理的时间与空间被均摊
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/soup-servings/solutions/3746043/san-jie-si-cha-shu-dfs-er-wei-dp-o1yu-ch-jbph/)
