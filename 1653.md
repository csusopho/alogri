[Problem: 1653. 使字符串平衡的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/description/)

### 前后缀 & DP

删除字符后，让所有的 $a$ 都排在 $b$ 的前面，则串 $s$ 平衡。

到底该怎么删？换个思路看，反正最后都是 $a$ 在左 $b$ 在右，那我们直接枚举最后左侧有几个 $a$ 即可，右边只剩下 $b$，其他都需要全删。

**总结**：枚举分割点 $i$，让串 $s[0,i]$ 中删除后只剩下 $a$，以及串 $s[i+1,n-1]$ 中删除后只剩下 $b$。

如何快速得知子数组/子串中有几个 $a$？想到 **前缀和**。具体原理/做法，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

定义 $prefix[i]$ 表示串 $s[0,i]$ 中 $b$ 的数量，以及 $suffix[i]$ 表示串 $s[i,n)$ 中 $a$ 的数量。

那么，假如当前分割点为 $i+1$，则前面的子串 $s[0:i]$ 含有 $prefix[i]$ 个 $b$ 需要删除；后面的子串 $s[i+1,n)$ 中含有 $suffix[i]$ 个 $a$ 需要删除。

**流程**：枚举所有分割点，分别计算出答案，取最小值。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        n = len(s)
        prefix_b = [0] * n
        suffix_a = [0] * n
        
        # 计算前缀 'b' 的数量
        prefix_b[0] = 1 if s[0] == 'b' else 0
        for i in range(1, n):
            prefix_b[i] = prefix_b[i-1] + (1 if s[i] == 'b' else 0)
        
        # 计算后缀 'a' 的数量
        suffix_a[-1] = 1 if s[-1] == 'a' else 0
        for i in range(n-2, -1, -1):
            suffix_a[i] = suffix_a[i+1] + (1 if s[i] == 'a' else 0)
        
        ans = float('inf')
        # 遍历所有可能的分割点
        for i in range(n + 1):
            # 左边的 'b' 数量
            left_b = prefix_b[i-1] if i > 0 else 0
            # 右边的 'a' 数量
            right_a = suffix_a[i] if i < n else 0
            total = left_b + right_a
            if total < ans:
                ans = total
        
        return ans
```

```Java
// java
class Solution {
    public int minimumDeletions(String s) {
        int n = s.length();
        int[] prefix_b = new int[n];
        int[] suffix_a = new int[n];
        
        // 计算前缀 'b' 的数量
        prefix_b[0] = s.charAt(0) == 'b' ? 1 : 0;
        for (int i = 1; i < n; i++) {
            prefix_b[i] = prefix_b[i-1] + (s.charAt(i) == 'b' ? 1 : 0);
        }
        
        // 计算后缀 'a' 的数量
        suffix_a[n-1] = s.charAt(n-1) == 'a' ? 1 : 0;
        for (int i = n - 2; i >= 0; i--) {
            suffix_a[i] = suffix_a[i+1] + (s.charAt(i) == 'a' ? 1 : 0);
        }
        
        int ans = Integer.MAX_VALUE;
        // 遍历所有可能的分割点
        for (int i = 0; i <= n; i++) {
            // 左边的 'b' 数量
            int left_b = (i > 0) ? prefix_b[i-1] : 0;
            // 右边的 'a' 数量
            int right_a = (i < n) ? suffix_a[i] : 0;
            int total = left_b + right_a;
            if (total < ans) {
                ans = total;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为串 $s$ 的长度
- 空间复杂度： $O(n)$，表示前后缀数组的大小

---

### 优化

总共串长为 $n$，则 $a,b$ 的总数量是固定的。

没必要定义前后缀数组，使用两个变量替换，分别表示前面 $b$ 以及后面 $a$ 的数量。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        n = len(s)
        # 右侧要删除的 'a' 的数量
        total_a = s.count('a')
        # 初始化
        ans = total_a
        # 左侧要删除的 'b' 的数量
        left_b = 0
        
        for i in range(n):
            # 更新
            if s[i] == 'b':
                left_b += 1
            else:
                total_a -= 1
            # 当前分割点在 i+1
            ans = min(ans, left_b + total_a)
        
        return ans
```

```Java
// java
class Solution {
    public int minimumDeletions(String s) {
        int n = s.length();
        // 右侧要删除的 'a' 的数量
        int total_a = 0;
        for (char c : s.toCharArray()) {
            if (c == 'a') total_a++;
        }
        
        // 初始化
        int ans = total_a;
        // 左侧要删除的 'b' 的数量
        int left_b = 0;
        
        for (int i = 0; i < n; i++) {
            // 更新
            if (s.charAt(i) == 'b') {
                left_b += 1;
            } else {
                total_a -= 1;
            }
            // 当前分割点在 i+1
            ans = Math.min(ans, left_b + total_a);
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### $DP$

定义 $dp[i]$ 表示让子串 $s[0,i-1]$）变平衡的最少删除次数。

同时定义 $countB$ 表示前面 $b$ 的数量，分情况讨论：

**情况 1：当前字符是 b**：

- 如果我们保留这个 $b$，它自然接在之前的平衡字符串后面，不会破坏平衡性（因为 $b$ 允许出现在末尾）。
- 不需要删除它来维持平衡。
- 则 $dp[i+1]=dp[i]$，但是计数器 $countB+1$。

**情况 2：当前字符是 a**：

因为 $a$ 不能出现在 $b$ 的后面。我们需要做决策来消除冲突，取以下两种方案的最小值：

1）删除这个 $a$：那么删除次数就是 “处理好前 $i-1$ 个字符的次数” 加上 “这次删除的 $1$ 次”。即 $dp[i]=dp[i-1] + 1$。
2）保留这个 $a$：为了满足平衡性，在这个 $a$ 之前出现的所有 $b$ 都必须被删除。即 $dp[i]=countB$。

得出状态转移方程：

$$
dp[i] = min(dp[i-1] + 1, countB)
$$

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        n = len(s)
        # dp[i] 表示字符串 s 的前 i 个字符变为平衡所需的最小删除次数
        dp = [0] * (n + 1)
        # 遇到的 'b' 的总数量
        count_b = 0

        for i in range(1, n + 1):
            char = s[i-1]
            
            if char == 'b':
                # 可以直接接在前面合法的平衡字符串后面，无需删除
                dp[i] = dp[i-1]
                count_b += 1
            else:
                # 删除这个 'a'，加一次操作
                # 保留这个 'a;，前面所有的 'b' 都必须被删除
                dp[i] = min(dp[i-1] + 1, count_b)
        
        return dp[n]
```

```Java
// java
class Solution {
    public int minimumDeletions(String s) {
        int n = s.length();
        // dp[i] 表示字符串 s 的前 i 个字符变为平衡所需的最小删除次数
        int[] dp = new int[n + 1];
        // 遇到的 'b' 的总数量
        int count_b = 0;

        for (int i = 1; i <= n; i++) {
            char c = s.charAt(i - 1);
            
            if (c == 'b') {
                // 可以直接接在前面合法的平衡字符串后面，无需删除
                dp[i] = dp[i-1];
                count_b += 1;
            } else {
                // 删除这个 'a'，加一次操作
                // 保留这个 'a;，前面所有的 'b' 都必须被删除
                dp[i] = Math.min(dp[i-1] + 1, count_b);
            }
        }
        
        return dp[n];
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 空间优化

可以发现， $dp[i]$ 的值仅与 $dp[i-1]$ 的值相关。

所以删除第一维，使用一维变量替换 $dp$ 数组。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        countB = 0
        dp = 0  # dp表示将s的前i个字符变平衡最少需要删除的次数

        for c in s:
            if c == 'a':
                dp = min(dp + 1, countB)
            else:
                countB += 1

        return dp
```

```Java
// java
class Solution {
    public int minimumDeletions(String s) {
        int countB = 0;
        int dp = 0;  // dp表示将s的前i个字符变平衡最少需要删除的次数

        for (char c : s.toCharArray()) {
            if (c == 'a') {
                dp = Math.min(dp + 1, countB);
            } else {
                countB += 1;
            }
        }

        return dp;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solutions/3898016/si-jie-qian-hou-zhui-fen-jie-you-hua-dp-mslms/)
