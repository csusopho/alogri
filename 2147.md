[Problem: 2147. 分隔长廊的方案数](https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/description/)

### 方法：乘法原理 & DP

题目要求每一段内 **恰好有两个座位**，也就是按顺序两两 “打包”：

- 第 $1、2$ 个座位必须在同一段；
- 第 $3、4$ 个座位必须在同一段；
- $\dots$
- 第 $2k-1、2k$ 个座位必须在同一段。

因此，屏风 **只能** 放置在第 $2k$ 个座位和第 $2k+1$ 个座位之间。

具体来说，假设我们有两个相邻的座位组。上一组的最后一个座位下标为 $pos[i-1]$，下一组的第一个座位下标为 $pos[i]$，那么中间的结构看起来像这样：

```Java
... S (植物, 植物, ...) S ...
    ↑                   ↑
 pos[i-1]             pos[i]
```

在这个区间内，屏风可以放在：

1. $pos[i-1]$ 的紧右边
2. 中间任意两个植物之间
3. $pos[i]$ 的紧左边

可选的放置位置总数 = $pos[i] - pos[i-1]$，或者说 **植物数 $+1$**。

前一段如何放置屏风，不会影响当前段的放置，也即每一对相邻组之间的切分是 **相互独立** 的事件。根据组合数学的 **乘法原理**，总方案数 = 所有间隔处可选方案数的乘积。

**边界处理**：如果座位总数是奇数，最后会剩下一个座位无法配对，不可能满足条件；或者座位数为 $0$，不满足 “恰好两个座位”，返回 $0$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        # 记录所有座位的下标
        pos = [i for i, char in enumerate(corridor) if char == 'S']
        
        # 没有座位，或座位总数不是偶数
        if not pos or len(pos) % 2:
            return 0
        
        ans, MOD = 1, 10 ** 9 + 7
        
        # 每一对 “相邻组” 之间的间隔
        for i in range(2, len(pos), 2):
            # "上一组" 的第二个座位和"下一组" 的第一个座位之间
            ans *= pos[i] - pos[i - 1]
            ans %= MOD
        
        return ans
```

```Java
// java
class Solution {
    public int numberOfWays(String corridor) {
        // 记录所有座位的下标
        List<Integer> pos = new ArrayList<>();
        for (int i = 0; i < corridor.length(); i++) {
            if (corridor.charAt(i) == 'S') {
                pos.add(i);
            }
        }
        
        // 没有座位，或座位总数不是偶数
        if (pos.isEmpty() || pos.size() % 2 != 0) {
            return 0;
        }
        
        long ans = 1;
        int MOD = 1_000_000_007;
        
        // 每一对 “相邻组” 之间的间隔
        for (int i = 2; i < pos.size(); i += 2) {
            // "上一组" 的第二个座位和"下一组" 的第一个座位之间
            ans *= (pos.get(i) - pos.get(i - 1));
            ans %= MOD;
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是串 $corridor$ 的长度
- 空间复杂度： $O(n)$，表示列表 $pos$ 的大小

---

### 动规

下面的解法非常晦涩难懂，我尽量解释，不要求掌握，看不懂直接跳过就行。

定义二维 $dp[i][state]$ 表示处理到第 $i$ 个字符时，当前这一段的状态为 $state$，有 $3$ 种情况：

- 状态 $0$（间隔/准备期）：
  - 含义：**当前段还没有座位**，或者刚结束上一段，正在经过植物。
  - 它存储的值是 **“累积器”**，具体来说是 **直到下一个座位出现之前，所有可能的切分方案总数**。
- 状态 $1$（只有一个 $S$ 等待下一个 $S$）：
  - 含义：**当前段恰好有 $1$ 个座位**。
  - 存储找到这第 $1$ 个座位时的合法方案数。
- 状态 $2$（刚凑齐一对）：
  - 含义：**当前段恰好有 $2$ 个座位（完整）**。
  - 存储刚刚完成配对时的方案数，作为后续计算的基数。

**状态转移** 逻辑：

- 遇到座位 $'S'$ 时：
  - 如果正在等待 **第 $1$ 个**，现在找到了新座位，方案数 $dp[i][1]$ 来自 $dp[i-1][0]$。
  - 如果正在等待 **第 $2$ 个**，同理找到后，方案数 $dp[i][2]$ 来自 $dp[i-1][1]$。
  - 屏风紧贴着上一组的第二个座位放，是 **下一组** 的初始切法。现在找到一个座位，上一组正好凑齐，方案数 $dp[i][0]$ 来自 $dp[i-1][1]$。
- 遇到植物 $'P'$ 时：
  - **已有** $1/2$ 个座位，而植物不影响座位计数，状态不变，方案数不变。
  - **处于间隔中**，这一步最难理解，也最为重要。上一对座位凑齐时的方案数是 $dp[i-1][2]$，每多遇到一个植物，就意味着多了一个可以放屏风的空隙。当前可能的方案数 = 之前的方案数 + 上一对刚凑齐时的基准方案数。

这个 $DP$ 的核心思想是 **把“乘法”拆成了“加法”**。

- 在第一种方法中，我们算出间隔长度 $L$，总方案数就是 $\times (L+1)$。
- 在 $DP$ 方法中，进入间隔时，手握基准方案数 $N$，也即之前方案总数。每遇到一个植物，方案总数加 $N$。因为多了一个切点，就多了一倍的基准可能性。最终累计结果就是 $N + N \times L = N \times (L+1)$。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        n = len(corridor)
        MOD = 10 ** 9 + 7
        
        # 准备状态/有 1 个座位/刚好 2 个座位 的方案数
        # dp[i][0] 是上一段的方案数 × 当前屏风可放置的位置数
        dp = [[0] * 3 for _ in range(n + 1)]
        # 初始化
        dp[0][0] = 1 
        dp[0][1] = 0
        dp[0][2] = 0
        
        for i in range(1, n + 1):
            # 遇到座位：状态发生轮转
            if corridor[i-1] == 'S':
                # 之前有1个，现在又来1个 -> 凑齐2个
                dp[i][2] = dp[i-1][1]
                # 之前是0个，现在来了1个 -> 变成1个
                dp[i][1] = dp[i-1][0]
                
                # 之前有1个座位，现在又来1个，刚凑齐一对
                # 下一段准备期的初始方案数 = 刚刚凑齐这对时的方案数
                # 相当于：屏风紧贴着第二个座位放，这算 1 种初始切法
                dp[i][0] = dp[i-1][1] 
                
            else:
                dp[i][1] = dp[i-1][1]
                dp[i][2] = dp[i-1][2]
                
                # 间隔里每遇到一个植物，就多了一个切分位置
                dp[i][0] = (dp[i-1][0] + dp[i-1][2]) % MOD
        
        # 必须恰好凑齐 2 个座位
        return dp[n][2]
```

```Java
// java
class Solution {
    public int numberOfWays(String corridor) {
        int n = corridor.length();
        int MOD = 1_000_000_007;
        
        // 准备状态/有 1 个座位/刚好 2 个座位 的方案数
        // dp[i][0] 是上一段的方案数 × 当前屏风可放置的位置数
        int[][] dp = new int[n + 1][3];
        
        // 初始化
        dp[0][0] = 1; 
        dp[0][1] = 0;
        dp[0][2] = 0;
        
        for (int i = 1; i <= n; i++) {
            // 遇到座位：状态发生轮转
            if (corridor.charAt(i - 1) == 'S') {
                // 之前有1个，现在又来1个 -> 凑齐2个
                dp[i][2] = dp[i - 1][1];
                // 之前是0个，现在来了1个 -> 变成1个
                dp[i][1] = dp[i - 1][0];
                
                // 之前有1个座位，现在又来1个，刚凑齐一对
                // 下一段准备期的初始方案数 = 刚刚凑齐这对时的方案数
                // 相当于：屏风紧贴着第二个座位放，这算 1 种初始切法
                dp[i][0] = dp[i - 1][1]; 
                
            } else {
                dp[i][1] = dp[i - 1][1];
                dp[i][2] = dp[i - 1][2];
                
                // 间隔里每遇到一个植物，就多了一个切分位置
                dp[i][0] = (dp[i - 1][0] + dp[i - 1][2]) % MOD;
            }
        }
        
        // 必须恰好凑齐 2 个座位
        return dp[n][2];
    }
}
```

- 时间复杂度： $O(n)$，速度非常慢
- 空间复杂度： $O(n)$

---

### 空间优化

这种方法速度最快，本质是二维 $DP$ 的状态压缩。如果你直接看别人的代码，非常难理解。铺垫完上面的推导，现在看，相对容易理解一点。

实测 $Python$ 耗时 $179ms$，超过 $100\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        MOD = 10 ** 9 + 7
        
        # 寻找新的一对座位的第1个S之前，所有可能的切分方案总数
        wait_first = 1
        # 已经找到了1个S，正在找第2个S
        wait_second = 0
        # 刚刚凑齐了一对S
        just_finished = 0
        
        for char in corridor:
            if char == 'S':
                # 1+1=2，变成了“完成状态”
                just_finished = wait_second
                # 0+1=1，变成了“半对状态”
                wait_second = wait_first
                
                # 下一个间隔的初始方案数，就是刚才凑齐那一刻的方案数
                wait_first = just_finished
                
            else:
                # 每遇到一个植物，就多了一种切分位置
                wait_first = (wait_first + just_finished) % MOD

        # 必须刚好凑齐一对
        return just_finished
```

```Java
// java
class Solution {
    public int numberOfWays(String corridor) {
        int MOD = 1_000_000_007;
        
        // 寻找新的一对座位的第1个S之前，所有可能的切分方案总数
        int wait_first = 1;
        // 已经找到了1个S，正在找第2个S
        int wait_second = 0;
        // 刚刚凑齐了一对S
        int just_finished = 0;
        
        for (char c : corridor.toCharArray()) {
            if (c == 'S') {
                // 1+1=2，变成了“完成状态”
                just_finished = wait_second;
                // 0+1=1，变成了“半对状态”
                wait_second = wait_first;
                
                // 下一个间隔的初始方案数，就是刚才凑齐那一刻的方案数
                wait_first = just_finished;
                
            } else {
                // 每遇到一个植物，就多了一种切分位置
                wait_first = (wait_first + just_finished) % MOD;
            }
        }
        
        // 必须刚好凑齐一对
        return just_finished;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/solutions/3856552/san-jie-fen-duan-cheng-fa-yuan-li-er-yi-f5536/)
