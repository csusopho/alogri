[Problem: 966. 元音拼写检查器](https://leetcode.cn/problems/vowel-spellchecker/description/)

### 方法：哈希

题意：对于每一个查询，都找出第一个最相似的单词。“相似” 的 **优先级**：

$$
完全相同 > 大小写错误 > 元音拼写错误 > 完全错误
$$

简单粗暴的想法：假设当前要查询 $qs$ 这个单词，遍历一次 $list$ 判断是否有完全相同的 $word$，接着再遍历一次 $list$ 判断是否有大小写不同的 $word$，同理再再遍历一次。三次检查都不匹配，当前答案才是空 `""`。

**难点**：如何判断两个单词是元音不同？当前遍历到第 $i$ 个字符，

- 如果 $word[i]$ 是元音，允许 $qs[i]$ 是不同的元音；
- 如果 $word[i]$ 是辅音，则 $qs[i]$ 必须是相同的辅音。

代码如下，已附加注释：

```Python
# python
class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        # 判断一个字符是否是元音
        def is_vowel(char):
            return char.lower() in 'aeiou'

        # 检查两个单词是否构成元音错误匹配
        def is_vowel_match(word1, word2):
            if len(word1) != len(word2):
                return False
            for c1, c2 in zip(word1, word2):
                low_c1 = c1.lower()
                low_c2 = c2.lower()
                if low_c1 != low_c2 and not (is_vowel(low_c1) and is_vowel(low_c2)):
                    return False
            return True

        ans = []
        # 为了效率，先用一个集合存储word
        wordset = set(wordlist)

        for query in queries:
            found_match = ""

            # 优先级 1: 完全匹配
            if query in wordset:
                ans.append(query)
                continue

            # 优先级 2: 大小写匹配
            case_match = False
            for word in wordlist:
                if word.lower() == query.lower():
                    ans.append(word)
                    case_match = True
                    break
            if case_match:
                continue

            # 优先级 3: 元音错误匹配
            vowel_match = False
            for word in wordlist:
                if is_vowel_match(word, query):
                    ans.append(word)
                    vowel_match = True
                    break
            if vowel_match:
                continue

            # 否则: 无匹配
            ans.append("")
            
        return ans
```

假设数组 $wordlist$ 长度为 $n$，而数组 $queries$ 的长度为 $q$，字符串平均长度为 $l$。题目限定 $n,q\leq 5\times 10^3$，且 $l\leq 7$。

最坏情况下，上述每个 $qs$ 都需要遍历三次 $wordlist$，总时间为 $O(n\times q\times l)$，复杂度接近 $O(10^8)$。所以超时，卡在 $50/55$ 样例。

---

### 预处理

我们可以对三种匹配进行优化。

将 $wordlist$ 存储在 $set$ 中，进行 “完全匹配” 耗费的时间更少。

什么是大小写不同？只要全部 **转为小写**，那就不存在大小写！因此，我们将 “小写串” 作为哈希的键，第一个对应的 $word$ 作为值。只要后续的 $qs$ 变为小写后，与这个键相同，那就能一步取出答案！

什么是元音不同？只要将元音都 **变为 `*`**，仅留下辅音即可！同理，将修改后的 “模式串” 作为哈希的键，第一个对应的 $word$ 作为值。

什么叫做第一个？很简单，如果转为模式串后，哈希中不存在该键，那就进行记录；否则，说明之前存在过，那就直接跳过不记录。

使用三个哈希，代码如下，已附加注释：

```Python
# python
class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        # 创建三个字典用于不同层级的匹配
        exact_match = set(wordlist)  # 精确
        case_match = {}   # 不区分大小写
        vowel_match = {}  # 忽略元音差异
        
        # 预处理单词列表，填充两个不敏感字典
        for word in wordlist:
            lower_word = word.lower()
            # 只在第一次出现时记录
            if lower_word not in case_match:
                case_match[lower_word] = word
            
            # 将元音替换为*，生成忽略元音的key
            vowel_removed = ''.join(['*' if c in 'aeiou' else c for c in lower_word])
            # 只在第一次出现时记录
            if vowel_removed not in vowel_match:
                vowel_match[vowel_removed] = word
        
        ans = []
        for query in queries:
            # 优先级1：精确匹配
            if query in exact_match:
                ans.append(query)
                continue
            
            lower_query = query.lower()
            # 优先级2：不区分大小写
            if lower_query in case_match:
                ans.append(case_match[lower_query])
                continue
            
            # 优先级3：忽略元音差异
            vowel_removed_query = ''.join(['*' if c in 'aeiou' else c for c in lower_query])
            if vowel_removed_query in vowel_match:
                ans.append(vowel_match[vowel_removed_query])
                continue
            
            # 无任何匹配
            ans.append("")
        
        return ans
```

```Java
// java
class Solution {
    public String[] spellchecker(String[] wordlist, String[] queries) {
        // 创建三个数据结构用于不同层级的匹配
        Set<String> exactMatch = new HashSet<>(); // 精确匹配
        Map<String, String> caseMatch = new HashMap<>(); // 不区分大小写匹配
        Map<String, String> vowelMatch = new HashMap<>(); // 忽略元音差异匹配

        // 预处理单词列表，填充两个不敏感的Map
        for (String word : wordlist) {
            exactMatch.add(word);
            
            String lowerWord = word.toLowerCase();
            // 只在第一次出现时记录
            caseMatch.putIfAbsent(lowerWord, word);

            // 将元音替换为占位符，生成忽略元音的key
            String vowelRemoved = deVowel(lowerWord);
            // 只在第一次出现时记录
            vowelMatch.putIfAbsent(vowelRemoved, word);
        }

        String[] ans = new String[queries.length];
        for (int i = 0; i < queries.length; i++) {
            String query = queries[i];

            // 优先级1：精确匹配
            if (exactMatch.contains(query)) {
                ans[i] = query;
                continue;
            }

            String lowerQuery = query.toLowerCase();
            // 优先级2：不区分大小写
            if (caseMatch.containsKey(lowerQuery)) {
                ans[i] = caseMatch.get(lowerQuery);
                continue;
            }

            // 优先级3：忽略元音差异
            String vowelRemovedQuery = deVowel(lowerQuery);
            if (vowelMatch.containsKey(vowelRemovedQuery)) {
                ans[i] = vowelMatch.get(vowelRemovedQuery);
                continue;
            }

            // 无任何匹配
            ans[i] = "";
        }

        return ans;
    }

    // 将字符串中的元音替换为占位符'*'
    private String deVowel(String str) {
        StringBuilder sb = new StringBuilder();
        for (char c : str.toCharArray()) {
            sb.append(isVowel(c) ? '*' : c);
        }
        return sb.toString();
    }

    // 判断一个字符是否是元音
    private boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
}
```

- 时间复杂度： $O((n+q)\times l)$，从哈希中寻找时间为 $O(l)$
- 空间复杂度： $O(n\times l)$，表示三个哈希的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/vowel-spellchecker/solutions/3781313/shuang-jie-bao-li-mo-ni-ha-xi-you-hua-xi-8afw/)
