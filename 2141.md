[Problem: 2141. 同时运行 N 台电脑的最长时间](https://leetcode.cn/problems/maximum-running-time-of-n-computers/description/)

### 方法：二分 & 贪心

题意能读懂，把数组求和，除以电脑数 $n$ 然后向下取整，不是答案吗？

这种思路是错误的，比如 $[8,4]$ 且 $n=2$，每台电脑肯定分不到 $12/2=6$ 的电量，最多只能每台电脑同时运行 $4$ 分钟。

关键点：一台电脑与一块电池 **一一对应**，电池不可切分。

也就是说，电池的电量可以被浪费，但是不能被同时分给多台电脑。一台电脑可以使用多块电池，比如 $[2,2,4]$ 且 $n=2$，那么最长运行时间为 $4$ 分钟。

**总结**：大电量电池只能被一台电脑使用，电量会冗余；多块小电池可以拼接为一块大电池，被同一电脑使用。

目标是求一个最大的时间 $T$。**问题转化**：如果我们确定了一个时间 $T$，怎么判断能否让 $n$ 台电脑都运行 $T$ 分钟？

**需求端**： $n$ 台电脑运行 $T$ 分钟，总共需要消耗 $n \times T$ 的电量。**供给端**：若干电池。

- 如果一个电池的电量 $b > T$，它最多只能贡献 $T$ 的电量。因为这台电脑只需要运行 $T$ 分钟，多余的电量虽然在这个电池里，但不能同时分身给其他电脑用。
- 如果一个电池的电量 $b \le T$，它可以把全部 $b$ 的电量贡献出来（等待其他电池补充）。

因此，我们定义一个判定的 $check$ 函数。对于给定的目标时间 $T$，系统能提供的最大有效电量是：

$$
\text{TotalPower} = \sum_{i} \min(\text{batteries}[i], T)
$$

如果 $\text{TotalPower} \ge n \times T$，说明时间 $T$ 是可行的。

由于如果时间 $T$ 可行，那么比 $T$ 小的时间一定也可行；如果 $T$ 不可行，比 $T$ 大的时间一定也不可行。满足 **单调性**，因此可以使用二分查找。

- **下界** $left$：默认 $0$，或者最小的电池电量。
- **上界** $right$：所有电池总电量除以 $n$。因为就算完美利用所有电量，平均每台电脑也只能分到这么多。

这道题的关键在于理解 $\min(b, T)$。虽然可以无限次交换电池，但本质上是 **总量匹配** 问题。只要总有效供给量大于总需求量，具体的交换方案一定存在。

使用最容易理解的 **闭区间二分**，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        # 二分查找的范围
        left, right = 0, sum(batteries) // n
        
        while left <= right:
            mid = (left + right) // 2
            
            # 所有电池能提供的最大有效电量
            valid_power = sum(min(b, mid) for b in batteries)
            
            if valid_power >= n * mid:
                # mid 可行，尝试更大的时间
                left = mid + 1
            else:
                # mid 太大，需要减小目标
                right = mid - 1
        
        # 循环结束时，left 指向 right + 1
        return right
```

```Java
// java
class Solution {
    public long maxRunTime(int n, int[] batteries) {
        long sum = 0;
        for (int b : batteries) {
            sum += b;
        }
        
        // 二分查找的范围
        long left = 0, right = sum / n;

        while (left <= right) {
            long mid = (left + right) / 2;
            
            // 所有电池能提供的最大有效电量
            long valid_power = 0;
            for (int b : batteries) {
                valid_power += Math.min(b, mid);
            }

            if (valid_power >= (long) n * mid) {
                // mid 可行，尝试更大的时间
                left = mid + 1;
            } else {
                // mid 太大，需要减小目标
                right = mid - 1;
            }
        }

        // 循环结束时，left 指向 right + 1
        return right;
    }
}
```

- 时间复杂度： $O(n\times logk)$，其中 $n$ 是数组 $batteries$ 的长度，而 $k$ 是二分上界，即数组总和除以 $n$，表示二分次数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 贪心

假设所有的电池里的电就像水一样，可以随意倒入一个大池子，然后再平均分给 $n$ 台电脑。那么，最长运行时间就是：

$$
T_{avg} = \frac{\text{所有电池总电量}}{n}
$$

如果某块电池的 **电量非常大**，则多出 $T_{avg}$ 的那部分电量会被浪费。这块 “超级电池” 只能管好它自己负责的那台电脑，多余的电量没法匀给那些快没电的电脑。

**贪心策略**：排除 “超级电池”。为了不让平均值被这些 “虚高” 的超级电池误导，我们需要把它们剔除出去单独处理。

先假设所有电池都能完全利用，计算 `当前平均值 = 总电量 / n`。然后，检查 **最大** 的那块电池。

- **最大电池电量 > 当前平均值**：这意味着这块电池足够强，完全可以 **独自负责一台电脑** 直到最后。因此，把它和它负责的那台电脑 **从问题中移除**。新问题变成：用剩下的电池，供养 $n-1$ 台电脑。此时，更新总电量 $total$，更新 $n$，然后重新计算平均值。
- **最大电池电量 $\le$ 当前平均值**：那么，其他所有电池肯定也都比平均值小。在这种情况下，**没有任何一块** 电池的电量会被浪费。所有的电量都能被充分利用来填补空缺。此时的答案就是当前的平均值（联想上面的 $check$）。

以 $n = 2$，电池为 $[1, 10]$ 举例。

- 总电量 $11$。平均值 $11 / 2 = 5.5$，最大的电池 $10$。由于 $10 > 5.5$，这块电池太强了，它肯定能撑过 $5.5$ 分钟。把它给其中一台电脑，这台电脑和这块电池 “退场”。
- 剩下 $n=1$，电池 $[1]$。新总电量 $1$，新平均值 $1 / 1 = 1$。最大的电池 $1$，由于 $1 \le 1$。满足条件，所以答案是 $1$。

**贪心法**：核心目标是 “找短板”，如果大电池太强就让它单飞，直到所有剩下的电池都不存在 “溢出” 的情况，此时的平均值就是最大值。

注意，这里有一个关键点：**分母是电脑数**。

题目已经指出，电池的数量多于电脑的数量，这里算出来的是 “平均运行时间”，会比 “平均每个电池的电量” 大得多。不要陷入数学误区：怎么会出现最大 < 平均，其实分母不一样。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        # 从小到大
        batteries.sort()
        total = sum(batteries)
        
        # 从最大的开始检查
        while batteries:
            # 拿出当前最大的电池
            large_battery = batteries[-1]
            
            # 理论上的平均运行时间
            # 这里的 total 和 n 都在变化
            avg_time = total // n
            
            # 贪心判断：
            if large_battery > avg_time:
                # 它能独自支撑一台电脑，且多余电量无法分给别人
                total -= large_battery
                batteries.pop()
                n -= 1
            else:
                # 如果最大电池 <= 平均时间，说明所有剩余电池都能被完美利用
                return avg_time
        
        return 0
```

```Java
// java
class Solution {
    public long maxRunTime(int n, int[] batteries) {
        // 从小到大
        Arrays.sort(batteries);
        
        long total = 0;
        for (int b : batteries) {
            total += b;
        }

        // 从最大的开始检查
        for (int i = batteries.length - 1; i >= 0; i--) {
            // 拿出当前最大的电池
            long large_battery = batteries[i];

            // 理论上的平均运行时间
            // 这里的 total 和 n 都在变化
            long avg_time = total / n;

            // 贪心判断：
            if (large_battery > avg_time) {
                // 它能独自支撑一台电脑，且多余电量无法分给别人
                total -= large_battery;
                n--; 
            } else {
                // 如果最大电池 <= 平均时间，说明所有剩余电池都能被完美利用
                return avg_time;
            }
        }

        return 0;
    }
}
```

- 时间复杂度： $O(n\times logn)$，瓶颈在于排序
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-running-time-of-n-computers/solutions/3846120/shuang-jie-xiao-dian-chi-pin-jie-da-dian-9t6a/)
