[Problem: 1339. 分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/description/)

### 方法：DFS & 优化

思路比较清晰：计算出当前子树和，那么 `另一棵子树和 = 总和 - 当前子树和`。

一棵子树的总和，就是遍历它的每个节点，然后累加遇到的值 —— $DFS$。

注意，本题最大的 **难点**：一定要先比较数值，再取模。

两种分割方案分别计算出的乘积为 $10^9+8,10^6$，模数 $MOD=10^9+7$。如果先取模，则会误判第二种方案更大！必须先比较数值，然后将较大者取模作为答案！

有小伙伴疑问，数字太大装不下怎么办？不用担心，看题目范围，所有节点全部相乘，不会超过 $long$ 的范围。

最容易想到的 **做法**：第一次 $DFS$ 计算出整个子树的总和，第二次 $DFS$ 计算出当前子树的总和，然后比较答案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7
        self.ans = 0
        self.total = 0
        
        # 计算整棵树的总和
        def dfs1(node):
            if not node:
                return
            self.total += node.val
            dfs1(node.left)
            dfs1(node.right)
            
        # 计算每个子树的和
        def dfs2(node):
            if not node:
                return 0
            
            # 后序遍历：先拿到左右子树的和
            left_sum = dfs2(node.left)
            right_sum = dfs2(node.right)
            
            # 当前子树的和 = 当前节点值 + 左子树和 + 右子树和
            curr_sub_sum = node.val + left_sum + right_sum
            
            # 计算乘积并更新最大值
            if curr_sub_sum < self.total: 
                product = curr_sub_sum * (self.total - curr_sub_sum)
                self.ans = max(self.ans, product)
            
            return curr_sub_sum

        dfs1(root)
        dfs2(root)
        return self.ans % MOD
```

```Java
// java
class Solution {
    long ans = 0;
    long total = 0;

    public int maxProduct(TreeNode root) {
        long MOD = 1000000007;
        ans = 0;
        total = 0;

        // 计算整棵树的总和
        dfs1(root);
        // 计算每个子树的和
        dfs2(root);

        return (int) (ans % MOD);
    }

    // 计算整棵树的总和
    private void dfs1(TreeNode node) {
        if (node == null) {
            return;
        }
        total += node.val;
        dfs1(node.left);
        dfs1(node.right);
    }

    // 计算每个子树的和
    private long dfs2(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 后序遍历：先拿到左右子树的和
        long left_sum = dfs2(node.left);
        long right_sum = dfs2(node.right);

        // 当前子树的和 = 当前节点值 + 左子树和 + 右子树和
        long curr_sub_sum = node.val + left_sum + right_sum;

        // 计算乘积并更新最大值
        if (curr_sub_sum < total) {
            long product = curr_sub_sum * (total - curr_sub_sum);
            if (product > ans) {
                ans = product;
            }
        }

        return curr_sub_sum;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是树中的节点个数，每个节点访问三次
- 空间复杂度： $O(n)$，表示最坏情况下的递归栈深度

---

### 另类解

或者说，我们可以将每个节点所在子树的总和 **直接记录** 在这个 **节点** 上。

那么，第一次 $DFS$ 修改每个节点为该子树的总和，全部总和则记录在根节点 $root$ 上。第二次 $DFS$ 就是遍历每个节点，计算乘积。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        # 直接修改 node.val 为该子树的总和
        def dfs1(node):
            if not node:
                return 0
            
            left_sum = dfs1(node.left)
            right_sum = dfs1(node.right)
            
            # 节点的值包含了左右子树和的总和
            node.val += left_sum + right_sum
            return node.val

        dfs1(root)
        # 根节点的值就是整棵树的总和
        total = root.val
        self.ans = 0
        
        # 计算最大乘积
        def dfs2(node):
            if not node:
                return
            
            curr_sub_sum = node.val
            # 当前子树和 * (总和 - 当前子树和)
            product = curr_sub_sum * (total - curr_sub_sum)
            
            # 更新最大值
            if product > self.ans:
                self.ans = product
            
            # 继续遍历左右子节点
            dfs2(node.left)
            dfs2(node.right)
            
        dfs2(root)
        return self.ans % (10**9 + 7)
```

```Java
// java
class Solution {
    long ans = 0;
    long total = 0;

    public int maxProduct(TreeNode root) {
        // 直接修改 node.val 为该子树的总和
        dfs1(root);
        // 根节点的值就是整棵树的总和
        total = root.val;
        ans = 0;

        // 计算最大乘积
        dfs2(root);
        
        return (int) (ans % 1000000007);
    }

    private long dfs1(TreeNode node) {
        if (node == null) {
            return 0;
        }

        long left_sum = dfs1(node.left);
        long right_sum = dfs1(node.right);

        // 节点的值包含了左右子树和的总和
        node.val += left_sum + right_sum;
        return node.val;
    }

    // 计算最大乘积
    private void dfs2(TreeNode node) {
        if (node == null) {
            return;
        }

        long curr_sub_sum = node.val;
        // 当前子树和 * (总和 - 当前子树和)
        long product = curr_sub_sum * (total - curr_sub_sum);

        // 更新最大值
        if (product > ans) {
            ans = product;
        }

        // 继续遍历左右子节点
        dfs2(node.left);
        dfs2(node.right);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 一次

上面的方法好理解，但是有些冗余。

使用一次 $DFS$，将每个节点所在子树的总和 **记录在列表中**。然后遍历列表，计算答案。

本质上来说，就是保留第一次 $DFS$，优化了第二次 $DFS$，用空间换时间。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        candidates = []  # 存储每棵子树的总和

        def dfs(node):
            if not node:
                return 0
            # 左右根，后序遍历
            # 当前子树的总和 = 左和 + 右和 + 当前节点值
            cur_sum = dfs(node.left) + dfs(node.right) + node.val
            candidates.append(cur_sum)
            return cur_sum

        total = dfs(root)  # 根节点所在的总和
        ans = max(s * (total - s) for s in candidates)

        return ans % (10**9+7)
```

```Java
// java
class Solution {
    List<Long> candidates = new ArrayList<>(); // 存储每棵子树的总和

    public int maxProduct(TreeNode root) {
        candidates.clear();
        
        long total = dfs(root); // 根节点所在的总和
        long ans = 0;
        
        for (long s : candidates) {
            long product = s * (total - s);
            if (product > ans) {
                ans = product;
            }
        }

        return (int) (ans % 1000000007);
    }

    private long dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 左右根，后序遍历
        // 当前子树的总和 = 左和 + 右和 + 当前节点值
        long cur_sum = dfs(node.left) + dfs(node.right) + node.val;
        candidates.add(cur_sum);
        return cur_sum;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/solutions/3874706/san-jie-xian-xiang-cheng-bi-jiao-zai-qu-a0dn6/)
