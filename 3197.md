[Problem: 3197. 包含所有 1 的最小矩形面积 II](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-ii/description/)

### 方法：模拟

前置题目：[面积 I](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-i/description/)，它要求单个矩形内，覆盖所有 $1$ 的最小子矩形。

三个子矩形，没有交集！如果将 $0$ 纳入这些子矩形，则就填满整个大矩形！**本质**：两刀切三块，每块内部找最小矩形覆盖全 $1$。

如何将一个大矩形切为三个小矩形？两刀，对应 **六种可能**。示意图如下：

![pic](https://pic.leetcode.cn/1755918239-qBIasJ-%E5%88%86%E5%9D%97.png)

切分出的小矩形中，如何找出覆盖全 $1$ 的最小子矩形？统计所有 $1$ 出现的 **最小/大** 的行、列下标 —— 前一题。

**暴力** 思路：枚举六种切分方案，对三个小矩形套用前一题解法。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        # 矩形左上角 (r1,c1) 右下角 (r2,c2)，返回覆盖所有 1 的最小矩形面积
        def min_area(r1, r2, c1, c2):
            top, bottom, left, right = m, -1, n, -1
            for i in range(r1, r2):
                for j in range(c1, c2):
                    if grid[i][j] == 1:
                        top = min(top, i)
                        bottom = max(bottom, i)
                        left = min(left, j)
                        right = max(right, j)
            if bottom == -1:  # 这一块没有1，面积为0
                return 0
            return (bottom - top + 1) * (right - left + 1)

        ans = float("inf")

        # --- 情况1: 横着切成三段 ---
        for i in range(1, m-1):
            for j in range(i+1, m):
                a1 = min_area(0, i, 0, n)
                a2 = min_area(i, j, 0, n)
                a3 = min_area(j, m, 0, n)
                if a1 and a2 and a3:  # 每块必须有1
                    ans = min(ans, a1 + a2 + a3)

        # --- 情况2: 竖着切成三段 ---
        for i in range(1, n-1):
            for j in range(i+1, n):
                a1 = min_area(0, m, 0, i)
                a2 = min_area(0, m, i, j)
                a3 = min_area(0, m, j, n)
                if a1 and a2 and a3:
                    ans = min(ans, a1 + a2 + a3)

        # --- 情况3: 左整块+右上+右下 ---
        for i in range(1, n):
            for j in range(1, m):
                a1 = min_area(0, m, 0, i)   # 左侧一整块
                a2 = min_area(0, j, i, n)   # 右上
                a3 = min_area(j, m, i, n)   # 右下
                if a1 and a2 and a3:
                    ans = min(ans, a1 + a2 + a3)

        # --- 情况4: 左上+左下+右整块 ---
        for i in range(1, m):
            for j in range(1, n):
                a1 = min_area(0, i, 0, j)
                a2 = min_area(i, m, 0, j)
                a3 = min_area(0, m, j, n)
                if a1 and a2 and a3:
                    ans = min(ans, a1 + a2 + a3)

        # --- 情况5: 上整块+下左+下右 ---
        for i in range(1, m):
            for j in range(1, n):
                a1 = min_area(0, i, 0, n)
                a2 = min_area(i, m, 0, j)
                a3 = min_area(i, m, j, n)
                if a1 and a2 and a3:
                    ans = min(ans, a1 + a2 + a3)

        # --- 情况6: 上左+上右+下整块 ---
        for i in range(1, m):
            for j in range(1, n):
                a1 = min_area(0, i, 0, j)
                a2 = min_area(0, i, j, n)
                a3 = min_area(i, m, 0, n)
                if a1 and a2 and a3:
                    ans = min(ans, a1 + a2 + a3)

        return -1 if ans == float("inf") else ans
```

```Java
// java
public class Solution {
    private int m, n;
    private int[][] grid;

    public int minimumSum(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        this.grid = grid;
        int ans = Integer.MAX_VALUE;

        // --- 情况1: 横着切成三段 ---
        for (int i = 1; i < m - 1; i++) {
            for (int j = i + 1; j < m; j++) {
                int a1 = minArea(new int[]{0, i}, new int[]{0, n});
                int a2 = minArea(new int[]{i, j}, new int[]{0, n});
                int a3 = minArea(new int[]{j, m}, new int[]{0, n});
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        // --- 情况2: 竖着切成三段 ---
        for (int i = 1; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                int a1 = minArea(new int[]{0, m}, new int[]{0, i});
                int a2 = minArea(new int[]{0, m}, new int[]{i, j});
                int a3 = minArea(new int[]{0, m}, new int[]{j, n});
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        // --- 情况3: 左整块+右上+右下 ---
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                int a1 = minArea(new int[]{0, m}, new int[]{0, i}); // 左侧一整块
                int a2 = minArea(new int[]{0, j}, new int[]{i, n}); // 右上
                int a3 = minArea(new int[]{j, m}, new int[]{i, n}); // 右下
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        // --- 情况4: 左上+左下+右整块 ---
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                int a1 = minArea(new int[]{0, i}, new int[]{0, j});
                int a2 = minArea(new int[]{i, m}, new int[]{0, j});
                int a3 = minArea(new int[]{0, m}, new int[]{j, n});
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        // --- 情况5: 上整块+下左+下右 ---
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                int a1 = minArea(new int[]{0, i}, new int[]{0, n});
                int a2 = minArea(new int[]{i, m}, new int[]{0, j});
                int a3 = minArea(new int[]{i, m}, new int[]{j, n});
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        // --- 情况6: 上左+上右+下整块 ---
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                int a1 = minArea(new int[]{0, i}, new int[]{0, j});
                int a2 = minArea(new int[]{0, i}, new int[]{j, n});
                int a3 = minArea(new int[]{i, m}, new int[]{0, n});
                if (a1 > 0 && a2 > 0 && a3 > 0) ans = Math.min(ans, a1 + a2 + a3);
            }
        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    // 矩形左上角 (r1,c1) 右下角 (r2,c2)，返回覆盖所有 1 的最小矩形面积
    private int minArea(int[] rowRange, int[] colRange) {
        int r1 = rowRange[0], r2 = rowRange[1];
        int c1 = colRange[0], c2 = colRange[1];
        int top = m, bottom = -1, left = n, right = -1;
        for (int i = r1; i < r2; i++) {
            for (int j = c1; j < c2; j++) {
                if (grid[i][j] == 1) {
                    top = Math.min(top, i);
                    bottom = Math.max(bottom, i);
                    left = Math.min(left, j);
                    right = Math.max(right, j);
                }
            }
        }
        if (bottom == -1) return 0; // 这一块没有1，面积为0
        return (bottom - top + 1) * (right - left + 1);
    }
}
```

横三块枚举时间为 $O(m^2)$，竖三块时间为 $O(n^2)$，另外四种 “L 型” / “┬ 型” / “┴ 型” 的切法时间为 $O(m\times n)$。每次切完，子块需要求面积，时间为 $O(m\times n)$。

- 时间复杂度： $O(m^3n^2+m^2n^3)$，其中 $m,n$ 分别为矩阵 $grid$ 的行数、列数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 递归

**本质**：第一刀将大矩形变为两个小矩形；然后挑出一个矩形，第二刀再次一分为二。这两个过程相似，且目标相同，联想到 **递归**。

**定义** $dfs(r1,r2,c1,c2,k)$ 表示将当前左上角为 $(r1,c1)$ 右下角为 $(r2,c2)$ 的矩形切成 $k$ 块后，能得到的最小面积值。

状态转移：一生二，要么横切要么竖切，对应枚举行或者列。还要从两个子矩形中挑选一个继续切，所以（第五参数）一个状态是 $k-1$，另一个是 $1$。

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

其他细节不再阐述，详情见下面的代码，已附加注释：

```Python
# python
class Solution:
    def minimumSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        # 给定矩形范围 [r1:r2], [c1:c2]，返回覆盖所有 1 的最小矩形面积
        def min_area(r1, r2, c1, c2):
            top, bottom, left, right = m, -1, n, -1
            for i in range(r1, r2):
                for j in range(c1, c2):
                    if grid[i][j] == 1:
                        top = min(top, i)
                        bottom = max(bottom, i)
                        left = min(left, j)
                        right = max(right, j)
            if bottom == -1:  # 这一块没有1
                return None
            return (bottom - top + 1) * (right - left + 1)

        # 递归函数：把矩形 [r1:r2, c1:c2] 切成 k 个部分
        @cache
        def splitK(r1, r2, c1, c2, k):
            if k == 1:
                return min_area(r1, r2, c1, c2)

            best = inf

            # 水平切
            for mid in range(r1+1, r2):
                top = splitK(r1, mid, c1, c2, 1)
                bottom = splitK(mid, r2, c1, c2, k-1)
                if top is not None and bottom is not None:
                    best = min(best, top + bottom)

                top2 = splitK(r1, mid, c1, c2, k-1)
                bottom2 = splitK(mid, r2, c1, c2, 1)
                if top2 is not None and bottom2 is not None:
                    best = min(best, top2 + bottom2)

            # 垂直切
            for mid in range(c1+1, c2):
                left = splitK(r1, r2, c1, mid, 1)
                right = splitK(r1, r2, mid, c2, k-1)
                if left is not None and right is not None:
                    best = min(best, left + right)

                left2 = splitK(r1, r2, c1, mid, k-1)
                right2 = splitK(r1, r2, mid, c2, 1)
                if left2 is not None and right2 is not None:
                    best = min(best, left2 + right2)

            return None if best == inf else best

        ans = splitK(0, m, 0, n, 3)
        return -1 if ans is None else ans
```

```Java
// java
public class Solution {
    private int[][] grid;
    private int m, n;
    private Integer[][][][][] memo;

    // 给定矩形范围 [r1:r2], [c1:c2]，返回覆盖所有 1 的最小矩形面积
    private Integer minArea(int r1, int r2, int c1, int c2) {
        int top = m, bottom = -1, left = n, right = -1;
        for (int i = r1; i < r2; i++) {
            for (int j = c1; j < c2; j++) {
                if (grid[i][j] == 1) {
                    top = Math.min(top, i);
                    bottom = Math.max(bottom, i);
                    left = Math.min(left, j);
                    right = Math.max(right, j);
                }
            }
        }
        if (bottom == -1) { // 这一块没有1
            return null;
        }
        return (bottom - top + 1) * (right - left + 1);
    }

    // 递归函数：把矩形 [r1:r2, c1:c2] 切成 k 个部分
    private Integer splitK(int r1, int r2, int c1, int c2, int k) {
        if (memo[r1][r2][c1][c2][k] != null) {
            return memo[r1][r2][c1][c2][k];
        }

        if (k == 1) {
            Integer area = minArea(r1, r2, c1, c2);
            memo[r1][r2][c1][c2][k] = area;
            return area;
        }

        int best = Integer.MAX_VALUE;

        // 水平切
        for (int mid = r1 + 1; mid < r2; mid++) {
            Integer top = splitK(r1, mid, c1, c2, 1);
            Integer bottom = splitK(mid, r2, c1, c2, k - 1);
            if (top != null && bottom != null) best = Math.min(best, top + bottom);

            Integer top2 = splitK(r1, mid, c1, c2, k - 1);
            Integer bottom2 = splitK(mid, r2, c1, c2, 1);
            if (top2 != null && bottom2 != null) best = Math.min(best, top2 + bottom2);
        }

        // 垂直切
        for (int mid = c1 + 1; mid < c2; mid++) {
            Integer left = splitK(r1, r2, c1, mid, 1);
            Integer right = splitK(r1, r2, mid, c2, k - 1);
            if (left != null && right != null) best = Math.min(best, left + right);

            Integer left2 = splitK(r1, r2, c1, mid, k - 1);
            Integer right2 = splitK(r1, r2, mid, c2, 1);
            if (left2 != null && right2 != null) best = Math.min(best, left2 + right2);
        }

        Integer result = (best == Integer.MAX_VALUE) ? null : best;
        memo[r1][r2][c1][c2][k] = result;
        return result;
    }

    public int minimumSum(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;

        // 初始化 5 维 memo 数组
        memo = new Integer[m + 1][m + 1][n + 1][n + 1][4]; 
        Integer ans = splitK(0, m, 0, n, 3);
        return (ans == null) ? -1 : ans;
    }
}
```

- 时间复杂度： $O(m^3n^2+m^2n^3)$，其中 $m,n$ 分别为矩阵 $grid$ 的行数、列数
- 空间复杂度： $O(m^2n^2)$，保存多少状态，就需要多少空间

---

### 预处理

在一个矩形中，寻找覆盖全 $1$ 的子矩形，暴力搜索速度太慢，如何优化？

- 一行由多个点构成，如果我们知道这一行最前/后 $1$ 的位置 $l,r$，那么覆盖它们的最短线段的长度就是 $r-l+1$；
- 同理，一个矩形是由多行/列构成，如果知道最上方一行最左侧 $1$ 的位置，最上最右、最下最左、最下最右的位置，那么这个矩形的面积也能计算。

因此，我们需要 **预处理**，得到前缀+后缀，先计算每行/列的最前/后 $1$ 的位置，然后扩展至二维，找出每个矩形的最小覆盖矩形。

有个问题：预处理只能得到包含边界（前后缀）的矩形，**中间部分** 的矩形怎么办？同样逻辑，我们可以利用行/列扩展至二维，在切分后，内部实时进行计算。

代码如下，已附加详细注释：

```Python
# python
Rect = Tuple[int, int, int, int]  # 矩形表示 (top, bottom, left, right)

class Solution:
    def minimumSum(self, grid: List[List[int]]) -> int:
        m = len(grid)  # 行数
        n = len(grid[0])  # 列数

        # 1. 预处理：每行/列最左最右/最上最下的 1
        row_min = [n] * m
        row_max = [-1] * m
        col_min = [m] * n
        col_max = [-1] * n
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row_min[i] = min(row_min[i], j)
                    row_max[i] = max(row_max[i], j)
                    col_min[j] = min(col_min[j], i)
                    col_max[j] = max(col_max[j], i)

        # 2. 预处理：快速查找每行/列左右上下最近的 1
        next_one_right = [[n] * n for _ in range(m)]  # 每行向右第一个 1
        prev_one_left = [[-1] * n for _ in range(m)]  # 每行向左最后一个 1
        for i in range(m):
            nxt = n
            for j in range(n-1, -1, -1):
                if grid[i][j] == 1:
                    nxt = j
                next_one_right[i][j] = nxt
            prev = -1
            for j in range(n):
                if grid[i][j] == 1:
                    prev = j
                prev_one_left[i][j] = prev

        next_one_down = [[m] * m for _ in range(n)]  # 每列向下第一个 1
        prev_one_up = [[-1] * m for _ in range(n)]   # 每列向上最后一个 1
        for j in range(n):
            nxt = m
            for i in range(m-1, -1, -1):
                if grid[i][j] == 1:
                    nxt = i
                next_one_down[j][i] = nxt
            prev = -1
            for i in range(m):
                if grid[i][j] == 1:
                    prev = i
                prev_one_up[j][i] = prev

        # 3. 辅助函数：更新矩形 & 计算面积
        def update_rect(rect, top, bottom, left, right) -> Rect:
            """将一个新矩形并入已有矩形，得到最小覆盖矩形"""
            if rect is None:
                return (top, bottom, left, right)
            t, b, l, r = rect
            return (min(t, top), max(b, bottom), min(l, left), max(r, right))

        def area(rect) -> int:
            """计算矩形面积"""
            if rect is None:
                return 0
            t, b, l, r = rect
            return (b - t + 1) * (r - l + 1)

        # 4. 前缀/后缀矩形预处理
        # row_pref[i] 是前 i 行中覆盖所有 1 的最小矩形
        row_pref = [None] * (m + 1)
        rect = None
        for i in range(m):
            if row_max[i] != -1:  # 该行有 1
                rect = update_rect(rect, i, i, row_min[i], row_max[i])
            row_pref[i + 1] = rect
        # row_suff[i] 是从第 i 行到最后一行中覆盖所有 1 的最小矩形
        row_suff = [None] * (m + 1)
        rect = None
        for i in range(m - 1, -1, -1):
            if row_max[i] != -1:
                rect = update_rect(rect, i, i, row_min[i], row_max[i])
            row_suff[i] = rect

        col_pref = [None] * (n + 1)  # 前 j 列
        rect = None
        for j in range(n):
            if col_max[j] != -1:
                rect = update_rect(rect, col_min[j], col_max[j], j, j)
            col_pref[j + 1] = rect

        col_suff = [None] * (n + 1)  # j 到最后一列
        rect = None
        for j in range(n - 1, -1, -1):
            if col_max[j] != -1:
                rect = update_rect(rect, col_min[j], col_max[j], j, j)
            col_suff[j] = rect

        ans = inf

        # 5. 六种切法枚举
        # ----- 横三段 -----
        for i in range(1, m - 1):
            top_rect = row_pref[i]  # 上段矩形
            if top_rect is None:
                continue
            mid_rect = None  # 中段矩形
            for j in range(i + 1, m):
                r = j - 1  # 中段最后一行
                if row_max[r] != -1:
                    mid_rect = update_rect(mid_rect, r, r, row_min[r], row_max[r])
                bot_rect = row_suff[j]  # 下段矩形
                if mid_rect is None or bot_rect is None:
                    continue
                cur = area(top_rect) + area(mid_rect) + area(bot_rect)
                ans = min(ans, cur)

        # ----- 竖三段 -----
        for i in range(1, n - 1):
            left_rect = col_pref[i]  # 左段矩形
            if left_rect is None:
                continue
            mid_rect = None  # 中段矩形
            for j in range(i + 1, n):
                c = j - 1
                if col_max[c] != -1:
                    mid_rect = update_rect(mid_rect, col_min[c], col_max[c], c, c)
                right_rect = col_suff[j]  # 右段矩形
                if mid_rect is None or right_rect is None:
                    continue
                cur = area(left_rect) + area(mid_rect) + area(right_rect)
                ans = min(ans, cur)

        # ----- 左整块 + 右上下 -----
        for cut_col in range(1, n):
            left_rect = col_pref[cut_col]
            if left_rect is None:
                continue

            minc = [n] * m  # 每行右边部分最左 1 列索引
            maxc = [-1] * m  # 每行右边部分最右 1 列索引
            any_right = False
            for r in range(m):
                x = next_one_right[r][cut_col]  # 右边第一个 1
                if x < n:
                    minc[r] = x
                    if row_max[r] >= cut_col:
                        maxc[r] = row_max[r]
                        any_right = True
            if not any_right:
                continue

            # 构造右上段前缀矩形
            up_pref = [None] * (m + 1)
            rect = None
            for r in range(m):
                if minc[r] < n:
                    rect = update_rect(rect, r, r, minc[r], maxc[r])
                up_pref[r + 1] = rect

            # 构造右下段后缀矩形
            down_suff = [None] * (m + 1)
            rect = None
            for r in range(m - 1, -1, -1):
                if minc[r] < n:
                    rect = update_rect(rect, r, r, minc[r], maxc[r])
                down_suff[r] = rect

            # 枚举横向切分行
            for cut_row in range(1, m):
                up_rect = up_pref[cut_row]
                down_rect = down_suff[cut_row]
                if up_rect is None or down_rect is None:
                    continue
                cur = area(left_rect) + area(up_rect) + area(down_rect)
                ans = min(ans, cur)

        # ----- 右整块 + 左上下（对称） -----
        for cut_col in range(1, n):
            right_rect = col_suff[cut_col]
            if right_rect is None:
                continue
            # 每行最左/右1的列索引
            minc = [n] * m
            maxc = [-1] * m
            any_left = False
            for r in range(m):
                if row_min[r] < cut_col:  # 这一行左边部分有 1
                    minc[r] = row_min[r]
                    pr = prev_one_left[r][cut_col - 1]
                    if pr >= 0:
                        maxc[r] = pr
                        any_left = True
            if not any_left:
                continue
            # 构造左上段前缀矩形
            up_pref = [None] * (m + 1)
            rect = None
            for r in range(m):
                if minc[r] < n:
                    rect = update_rect(rect, r, r, minc[r], maxc[r])
                up_pref[r + 1] = rect
            # 构造左下段后缀矩形
            down_suff = [None] * (m + 1)
            rect = None
            for r in range(m - 1, -1, -1):
                if minc[r] < n:
                    rect = update_rect(rect, r, r, minc[r], maxc[r])
                down_suff[r] = rect
            # 枚举右块的横向切分行
            for cut_row in range(1, m):
                up_rect = up_pref[cut_row]
                down_rect = down_suff[cut_row]
                if up_rect is None or down_rect is None:
                    continue
                cur = area(right_rect) + area(up_rect) + area(down_rect)
                ans = min(ans, cur)

        # ----- 上整块 + 下左右 -----
        for cut_row in range(1, m):
            up_rect = row_pref[cut_row]
            if up_rect is None:
                continue
            # 每列最上/下1的行索引
            minr = [m] * n
            maxr = [-1] * n
            any_bottom = False
            for c in range(n):
                x = next_one_down[c][cut_row]  # 下块第一个 1 的行
                if x < m:
                    minr[c] = x
                    if col_max[c] >= cut_row:  # 下块有 1
                        maxr[c] = col_max[c]
                        any_bottom = True
            if not any_bottom:
                continue
            # 构造下左段前缀矩形
            left_pref = [None] * (n + 1)
            rect = None
            for c in range(n):
                if minr[c] < m:
                    rect = update_rect(rect, minr[c], maxr[c], c, c)
                left_pref[c + 1] = rect
            # 构造下右段后缀矩形
            right_suff = [None] * (n + 1)
            rect = None
            for c in range(n - 1, -1, -1):
                if minr[c] < m:
                    rect = update_rect(rect, minr[c], maxr[c], c, c)
                right_suff[c] = rect
            # 枚举下块纵向切分列
            for cut_col in range(1, n):
                left_rect = left_pref[cut_col]
                right_rect = right_suff[cut_col]
                if left_rect is None or right_rect is None:
                    continue
                cur = area(up_rect) + area(left_rect) + area(right_rect)
                ans = min(ans, cur)

        # ----- 下整块 + 上左右 -----
        for cut_row in range(1, m):
            down_rect = row_suff[cut_row]
            if down_rect is None:
                continue

            minr = [m] * n
            maxr = [-1] * n
            any_top = False
            for c in range(n):
                pr = prev_one_up[c][cut_row - 1]  # 上块最下 1
                if pr >= 0:
                    maxr[c] = pr
                    if col_min[c] < cut_row:  # 上块有 1
                        minr[c] = col_min[c]
                        any_top = True
            if not any_top:
                continue
            # 上左段前缀矩形
            left_pref = [None] * (n + 1)
            rect = None
            for c in range(n):
                if minr[c] < m:
                    rect = update_rect(rect, minr[c], maxr[c], c, c)
                left_pref[c + 1] = rect
            # 上右段后缀矩形
            right_suff = [None] * (n + 1)
            rect = None
            for c in range(n - 1, -1, -1):
                if minr[c] < m:
                    rect = update_rect(rect, minr[c], maxr[c], c, c)
                right_suff[c] = rect
            # 枚举上块纵向切分列
            for cut_col in range(1, n):
                left_rect = left_pref[cut_col]
                right_rect = right_suff[cut_col]
                if left_rect is None or right_rect is None:
                    continue
                cur = area(down_rect) + area(left_rect) + area(right_rect)
                ans = min(ans, cur)

        return -1 if ans == inf else ans
```

```Java
// java
class Solution {
    // 矩形表示 (top, bottom, left, right)
    static class Rect {
        int top, bottom, left, right;
        Rect(int t, int b, int l, int r) {
            this.top = t;
            this.bottom = b;
            this.left = l;
            this.right = r;
        }
    }

    private int[][] grid;
    private int m, n;

    // 更新矩形: 将新矩形并入已有矩形，返回最小覆盖矩形
    private Rect updateRect(Rect rect, int top, int bottom, int left, int right) {
        if (rect == null) {
            return new Rect(top, bottom, left, right);
        }
        return new Rect(
            Math.min(rect.top, top),
            Math.max(rect.bottom, bottom),
            Math.min(rect.left, left),
            Math.max(rect.right, right)
        );
    }

    // 计算矩形面积
    private int area(Rect rect) {
        if (rect == null) return 0;
        return (rect.bottom - rect.top + 1) * (rect.right - rect.left + 1);
    }

    public int minimumSum(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;

        int[] rowMin = new int[m];
        int[] rowMax = new int[m];
        int[] colMin = new int[n];
        int[] colMax = new int[n];
        Arrays.fill(rowMin, n);
        Arrays.fill(rowMax, -1);
        Arrays.fill(colMin, m);
        Arrays.fill(colMax, -1);

        // 1. 预处理：每行/列最左最右/最上最下的 1
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    rowMin[i] = Math.min(rowMin[i], j);
                    rowMax[i] = Math.max(rowMax[i], j);
                    colMin[j] = Math.min(colMin[j], i);
                    colMax[j] = Math.max(colMax[j], i);
                }
            }
        }

        // 2. 预处理：快速查找每行/列左右上下最近的 1
        int[][] nextOneRight = new int[m][n]; // 每行向右第一个 1
        int[][] prevOneLeft = new int[m][n];  // 每行向左最后一个 1
        for (int i = 0; i < m; i++) {
            int nxt = n;
            for (int j = n - 1; j >= 0; j--) {
                if (grid[i][j] == 1) nxt = j;
                nextOneRight[i][j] = nxt;
            }
            int prev = -1;
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) prev = j;
                prevOneLeft[i][j] = prev;
            }
        }

        int[][] nextOneDown = new int[n][m]; // 每列向下第一个 1
        int[][] prevOneUp = new int[n][m];   // 每列向上最后一个 1
        for (int j = 0; j < n; j++) {
            int nxt = m;
            for (int i = m - 1; i >= 0; i--) {
                if (grid[i][j] == 1) nxt = i;
                nextOneDown[j][i] = nxt;
            }
            int prev = -1;
            for (int i = 0; i < m; i++) {
                if (grid[i][j] == 1) prev = i;
                prevOneUp[j][i] = prev;
            }
        }

        // 4. 前缀/后缀矩形预处理
        Rect[] rowPref = new Rect[m + 1]; // 前 i 行
        Rect rect = null;
        for (int i = 0; i < m; i++) {
            if (rowMax[i] != -1) {
                rect = updateRect(rect, i, i, rowMin[i], rowMax[i]);
            }
            rowPref[i + 1] = rect;
        }

        Rect[] rowSuff = new Rect[m + 1]; // 从 i 行到最后
        rect = null;
        for (int i = m - 1; i >= 0; i--) {
            if (rowMax[i] != -1) {
                rect = updateRect(rect, i, i, rowMin[i], rowMax[i]);
            }
            rowSuff[i] = rect;
        }

        Rect[] colPref = new Rect[n + 1]; // 前 j 列
        rect = null;
        for (int j = 0; j < n; j++) {
            if (colMax[j] != -1) {
                rect = updateRect(rect, colMin[j], colMax[j], j, j);
            }
            colPref[j + 1] = rect;
        }

        Rect[] colSuff = new Rect[n + 1]; // j 到最后
        rect = null;
        for (int j = n - 1; j >= 0; j--) {
            if (colMax[j] != -1) {
                rect = updateRect(rect, colMin[j], colMax[j], j, j);
            }
            colSuff[j] = rect;
        }

        int ans = Integer.MAX_VALUE;

        // 5. 六种切法枚举
        // ----- 横三段 -----
        for (int i = 1; i < m - 1; i++) {
            Rect topRect = rowPref[i];
            if (topRect == null) continue;
            Rect midRect = null;
            for (int j = i + 1; j < m; j++) {
                int r = j - 1;
                if (rowMax[r] != -1) {
                    midRect = updateRect(midRect, r, r, rowMin[r], rowMax[r]);
                }
                Rect botRect = rowSuff[j];
                if (midRect == null || botRect == null) continue;
                ans = Math.min(ans, area(topRect) + area(midRect) + area(botRect));
            }
        }

        // ----- 竖三段 -----
        for (int i = 1; i < n - 1; i++) {
            Rect leftRect = colPref[i];
            if (leftRect == null) continue;
            Rect midRect = null;
            for (int j = i + 1; j < n; j++) {
                int c = j - 1;
                if (colMax[c] != -1) {
                    midRect = updateRect(midRect, colMin[c], colMax[c], c, c);
                }
                Rect rightRect = colSuff[j];
                if (midRect == null || rightRect == null) continue;
                ans = Math.min(ans, area(leftRect) + area(midRect) + area(rightRect));
            }
        }

        // ----- 左整块 + 右上下 -----
        for (int cutCol = 1; cutCol < n; cutCol++) {
            Rect leftRect = colPref[cutCol];
            if (leftRect == null) continue;

            int[] minc = new int[m];
            int[] maxc = new int[m];
            Arrays.fill(minc, n);
            Arrays.fill(maxc, -1);
            boolean anyRight = false;
            for (int r = 0; r < m; r++) {
                int x = nextOneRight[r][cutCol];
                if (x < n) {
                    minc[r] = x;
                    if (rowMax[r] >= cutCol) {
                        maxc[r] = rowMax[r];
                        anyRight = true;
                    }
                }
            }
            if (!anyRight) continue;

            Rect[] upPref = new Rect[m + 1];
            rect = null;
            for (int r = 0; r < m; r++) {
                if (minc[r] < n) {
                    rect = updateRect(rect, r, r, minc[r], maxc[r]);
                }
                upPref[r + 1] = rect;
            }

            Rect[] downSuff = new Rect[m + 1];
            rect = null;
            for (int r = m - 1; r >= 0; r--) {
                if (minc[r] < n) {
                    rect = updateRect(rect, r, r, minc[r], maxc[r]);
                }
                downSuff[r] = rect;
            }

            for (int cutRow = 1; cutRow < m; cutRow++) {
                Rect upRect = upPref[cutRow];
                Rect downRect = downSuff[cutRow];
                if (upRect == null || downRect == null) continue;
                ans = Math.min(ans, area(leftRect) + area(upRect) + area(downRect));
            }
        }

        // ----- 右整块 + 左上下（对称） -----
        for (int cutCol = 1; cutCol < n; cutCol++) {
            Rect rightRect = colSuff[cutCol];
            if (rightRect == null) continue;

            int[] minc = new int[m];
            int[] maxc = new int[m];
            Arrays.fill(minc, n);
            Arrays.fill(maxc, -1);
            boolean anyLeft = false;
            for (int r = 0; r < m; r++) {
                if (rowMin[r] < cutCol) {
                    minc[r] = rowMin[r];
                    int pr = prevOneLeft[r][cutCol - 1];
                    if (pr >= 0) {
                        maxc[r] = pr;
                        anyLeft = true;
                    }
                }
            }
            if (!anyLeft) continue;

            Rect[] upPref = new Rect[m + 1];
            rect = null;
            for (int r = 0; r < m; r++) {
                if (minc[r] < n) {
                    rect = updateRect(rect, r, r, minc[r], maxc[r]);
                }
                upPref[r + 1] = rect;
            }

            Rect[] downSuff = new Rect[m + 1];
            rect = null;
            for (int r = m - 1; r >= 0; r--) {
                if (minc[r] < n) {
                    rect = updateRect(rect, r, r, minc[r], maxc[r]);
                }
                downSuff[r] = rect;
            }

            for (int cutRow = 1; cutRow < m; cutRow++) {
                Rect upRect = upPref[cutRow];
                Rect downRect = downSuff[cutRow];
                if (upRect == null || downRect == null) continue;
                ans = Math.min(ans, area(rightRect) + area(upRect) + area(downRect));
            }
        }

        // ----- 上整块 + 下左右 -----
        for (int cutRow = 1; cutRow < m; cutRow++) {
            Rect upRect = rowPref[cutRow];
            if (upRect == null) continue;

            int[] minr = new int[n];
            int[] maxr = new int[n];
            Arrays.fill(minr, m);
            Arrays.fill(maxr, -1);
            boolean anyBottom = false;
            for (int c = 0; c < n; c++) {
                int x = nextOneDown[c][cutRow];
                if (x < m) {
                    minr[c] = x;
                    if (colMax[c] >= cutRow) {
                        maxr[c] = colMax[c];
                        anyBottom = true;
                    }
                }
            }
            if (!anyBottom) continue;

            Rect[] leftPref = new Rect[n + 1];
            rect = null;
            for (int c = 0; c < n; c++) {
                if (minr[c] < m) {
                    rect = updateRect(rect, minr[c], maxr[c], c, c);
                }
                leftPref[c + 1] = rect;
            }

            Rect[] rightSuff = new Rect[n + 1];
            rect = null;
            for (int c = n - 1; c >= 0; c--) {
                if (minr[c] < m) {
                    rect = updateRect(rect, minr[c], maxr[c], c, c);
                }
                rightSuff[c] = rect;
            }

            for (int cutCol = 1; cutCol < n; cutCol++) {
                Rect leftRect = leftPref[cutCol];
                Rect rightRect = rightSuff[cutCol];
                if (leftRect == null || rightRect == null) continue;
                ans = Math.min(ans, area(upRect) + area(leftRect) + area(rightRect));
            }
        }

        // ----- 下整块 + 上左右 -----
        for (int cutRow = 1; cutRow < m; cutRow++) {
            Rect downRect = rowSuff[cutRow];
            if (downRect == null) continue;

            int[] minr = new int[n];
            int[] maxr = new int[n];
            Arrays.fill(minr, m);
            Arrays.fill(maxr, -1);
            boolean anyTop = false;
            for (int c = 0; c < n; c++) {
                int pr = prevOneUp[c][cutRow - 1];
                if (pr >= 0) {
                    maxr[c] = pr;
                    if (colMin[c] < cutRow) {
                        minr[c] = colMin[c];
                        anyTop = true;
                    }
                }
            }
            if (!anyTop) continue;

            Rect[] leftPref = new Rect[n + 1];
            rect = null;
            for (int c = 0; c < n; c++) {
                if (minr[c] < m) {
                    rect = updateRect(rect, minr[c], maxr[c], c, c);
                }
                leftPref[c + 1] = rect;
            }

            Rect[] rightSuff = new Rect[n + 1];
            rect = null;
            for (int c = n - 1; c >= 0; c--) {
                if (minr[c] < m) {
                    rect = updateRect(rect, minr[c], maxr[c], c, c);
                }
                rightSuff[c] = rect;
            }

            for (int cutCol = 1; cutCol < n; cutCol++) {
                Rect leftRect = leftPref[cutCol];
                Rect rightRect = rightSuff[cutCol];
                if (leftRect == null || rightRect == null) continue;
                ans = Math.min(ans, area(downRect) + area(leftRect) + area(rightRect));
            }
        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}
```

- 时间复杂度： $O(m^2+n^2+mn)$，枚举时查找全 $1$ 覆盖的时间变为 $O(1)$
- 空间复杂度： $O(mn)$，表示各种辅助数组的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-ii/solutions/3761313/tu-jie-bao-li-mei-ju-ji-yi-hua-dfs-jiu-j-zdsk/)
