[Problem: 1404. 将二进制表示减到 1 的步骤数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/)

### 方法：模拟 & 找规律

题意很清晰，我们直接暴力模拟即可。

将字符串 $s$ 转为 **十进制数字**，然后判断奇偶性，不断操作直至变为 $1$。

代码如下：

```Python
# python
class Solution:
    def numSteps(self, s: str) -> int:
        num = int(s, 2)  # 转为十进制整数
        steps = 0
        while num > 1:
            if num % 2 == 0:
                num //= 2    # 偶数除以 2
            else:
                num += 1     # 奇数加 1
            steps += 1
        return steps
```

这样做有个问题：其他语言不能随便将 $500$ 位长度的串转为数字？

因此，最好 **逐位** 进行操作。考虑到十进制中加法都是从低位开始（个、十、百、千），它对应字符串的高位到低位。

引入一个 $carry$ 变量表示 **进位**，从右往左扫描（忽略最高位）：

- 当前位计算后的真实值是 $val = s[i] - '0' + carry$。
- 如果 $val=1$，说明是 **奇数**：它必须先执行 $+1$ 操作变成偶数，再执行 $/2$ 操作将末尾 $0$ 砍掉。这总共需要 **两步**。同时因为触发了加法，所以 $carry$ 变成 $1$。
- 如果 $val = 0$ 或 $val = 2$，说明是 **偶数**：只需要执行 $/2$ 操作将末尾 $0$ 砍掉。这总共需要 **一步**。如果 $val = 0$，进位还是 $0$；如果 $val = 2$，说明进位被延续了，进位还是 $1$，所以 $carry$ 无需操作。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSteps(self, s: str) -> int:
        steps = 0
        carry = 0
        
        # 从后往前
        for i in range(len(s) - 1, 0, -1):
            # 当前位计算后的实际值
            val = int(s[i]) + carry
            
            if val == 1:
                # 先 +1 再 //2，花费两步，产生进位
                steps += 2
                carry = 1
            else:
                # 只需 //2 一步
                steps += 1
        
        # 最高位必定是 1
        return steps + carry
```

```Java
// java
class Solution {
    public int numSteps(String s) {
        int steps = 0;
        int carry = 0;
        
        // 从后往前
        for (int i = s.length() - 1; i > 0; i--) {
            // 当前位计算后的实际值
            int val = (s.charAt(i) - '0') + carry;
            
            if (val == 1) {
                // 先 +1 再 //2，花费两步，产生进位
                steps += 2;
                carry = 1;
            } else {
                // 只需 //2 一步
                steps += 1;
            }
        }
        
        // 最高位必定是 1
        return steps + carry;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是字符串 $s$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 找规律

上面步骤有些繁琐，观察规律：

**情况 A**：字符串只有最高位是 $1$，后面全是 $0$，例如 $1000$，

这种情况下，数字一直是偶数，没有任何进位。我们只需要不断除以 $2$，把末尾的 $0$ 一个个砍掉。总步数 = $0$ 的数量 = $len(s) - 1$。

**情况 B**：字符串中除了最高位的 $1$，后面还有其他的 $1$，例如 $10110"$，

我们从右往左看，分为三个部分：

1）**末尾的连续 0**（在遇到第一个 $1$ 之前）：

它们都是偶数，直接除以 $2$ 砍掉。每个 $0$ 需要一次右移操作。

2）**倒数第一个 1**（从右往左遇到的第一个 $1$）：

遇到它时，数字是奇数，必须加上 $1$，这是一次操作。加上 $1$ 后，这个 $1$ 变成了 $0$，并且向左产生了一个 **进位**。变成 $0$ 后，我们还要把它除以 $2$ 砍掉，又是一次操作。

3）**被进位波及的中间位**（从倒数第一个 $1$ 的左边，一直到最高位）：

只要产生了进位，这个进位就像波浪一样向左传递。

- 遇到 $1$：原有的 $1$ 加上进位变成了 $1$，当前位变成 $0$，**进位继续向左传递**。由于变成了 $0$，需要增加一次操作，将末尾 $0$ 砍掉。
- 遇到 $0$：原有的 $0$ 加上进位变成了 $1$。此时它是奇数，使用一次加法操作，它又变成了 $0$，并再次 **产生进位继续向左传递**。再增加一次操作，将末尾 $0$ 砍掉。

**结论**：一旦遇到了第一个 $1$ 并触发了加法，**进位就会一直传播到最左端**。在这个过程中，中间的所有的 $0$ 都需要额外经历一次 “加 $1$” 操作；而中间的 $1$ 顺水推舟直接变成 $0$，不需要额外的加法。

4）**最高位的 1**：

原本最高位只是个 $1$，不需要处理就结束了。但因为进位一路传到了最前面，最高位的 $1$ 加进了位变成了 $1$。这导致原数字 **多出了一位**！我们需要多执行一次右移操作，把新产生的 $0$ 砍掉，最后剩下最高位的 $1$。

---

对于情况 $B$，我们将所有操作步数加起来：

1. 基础右移操作：除了最终留下的那个 $1$，原本字符串的每一位都要被砍掉（右移）。这固定需要 $len(s) - 1$ 步。
2. 倒数第一个 $1$ 的加法操作：需要一步。
3. 中间的 $0$ 的加法操作：中间有几个 $0$，就需要几次加法操作。
4. 最高位进位导致的额外右移操作：需要一步。

把以上四项加起来：**总步数** = $(len(s) - 1) + 1 + zero + 1$。

因此，我们无需真的执行加法/移位操作，直接判断字符串 **本身**。也即 $s$ 最后一个 $1$ 的位置、到最高位中间 $0$ 的个数、总长度。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSteps(self, s: str) -> int:
        zero = 0
        i = len(s) - 1
        
        # 找到最后一个 1 的位置
        while i >= 0 and s[i] != '1':
            i -= 1
            
        # 只有最高位的 1，一直除以 2 即可
        if i == 0:
            return len(s) - 1
            
        # 从倒数第一个 1 开始，往左到最高位之间，有几个 0
        while i > 0:
            if s[i] == '0':
                zero += 1
            i -= 1
            
        # 总步数 = 0 的数量 + 字符串长度 + 1
        return zero + len(s) + 1
```

```Java
// java
class Solution {
    public int numSteps(String s) {
        int zero = 0;
        int i = s.length() - 1;
        
        // 找到最后一个 1 的位置
        while (i >= 0 && s.charAt(i) != '1') {
            i--;
        }
        
        // 只有最高位的 1，一直除以 2 即可
        if (i == 0) {
            return s.length() - 1;
        }
        
        // 从倒数第一个 1 开始，往左到最高位之间，有几个 0
        while (i > 0) {
            if (s.charAt(i) == '0') {
                zero++;
            }
            i--;
        }
        
        // 总步数 = 0 的数量 + 字符串长度 + 1
        return zero + s.length() + 1;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/solutions/3908664/shuang-jie-dao-xu-zhu-wei-mo-ni-shu-xue-9919y/)
