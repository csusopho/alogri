[Problem: 2683. 相邻值的按位异或](https://leetcode.cn/problems/neighboring-bitwise-xor/description/)

### 方法：模拟 & 数学

为了方便表述，将数组 $derived$ 记作 $d$，数组 $original$ 记作 $o$。

题意：原数组为 $o$，相邻两元素异或后，得到数组 $d$。两个数组中只含有 $0$ 和 $1$，那么给定 $d$，能够得到 $o$？

异或 $XOR$，**运算规则** 是 $0$ ^ $0=0,0$ ^ $1=1,1$ ^ $1=0$。相同为 $0$，相异为 $1$。所以满足 **自反性**： $a$ ^ $a$ = $0$，因此推导出 **逆运算**：

$$
a \oplus b = c ⇒ c \oplus a = b，也等价于 c \oplus b = a
$$

原理：在等式 $a$ ^ $b$ = $c$ 的两段都 “异或” $a$，则有 $a$ ^ $a$ ^ $b$ = $c$ ^ $a$，即 $b$ = $c$ ^ $a$。

那么，通过数组 $d$ 可以倒推 $o$，已知 $d[i]$ = $o[i]$ ^ $o[i+1]$，所以有 $o[i+1]$ = $d[i]$ ^ $o[i]$，实现从前往后递推。

**模拟**：数组 $o$ 一定是 $0/1$ 开头，分别枚举两种情况下，推导的 $o$ 数组是否符合要求！

代码如下，已附加注释：

```Python
# python
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        n = len(derived)
    
        for start in [0, 1]:  # 初始字符为0或1
            original = [start]
            for i in range(n - 1):  # 推导后续字符
                next_val = derived[i] ^ original[-1]
                original.append(next_val)
            
            # 最后验证首尾两个字符
            if (original[-1] ^ original[0]) == derived[-1]:
                return True  # 找到合法解

        return False  # 两种尝试都失败
```

```Java
// java
class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int n = derived.length;

        // 初始字符为 0 或 1
        for (int start = 0; start <= 1; start++) {
            int[] original = new int[n];
            original[0] = start;

            // 根据派生关系逐位推导
            for (int i = 0; i < n - 1; i++) {
                original[i + 1] = derived[i] ^ original[i];
            }

            // 验证首尾两个字符
            if ((original[n - 1] ^ original[0]) == derived[n - 1]) {
                return true;
            }
        }
        return false;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $derived$ 的长度
- 空间复杂度： $O(n)$，表示数组 $original$ 的长度

---

### 空间优化

可以发现，每个新的 $o[i]$ 只会用到前一个 $o[i-1]$，不会用到更多的状态！因此，可以仿照 $DP$ 的逻辑，进行空间优化，使用变量进行替换。

**定义** $nextZ$ 表示以 $0$ 开头的 $o$ 数组状态变量，替换 $o[i+1]$ 和 $o[i]$，也即

$$
新 nextZ = 旧 nextZ + d[i]
$$

同理，定义 $nextO$ 表示以 $1$ 开头的 $o $ 数组状态变量。

不过，首尾元素怎么处理？以 $nextZ$ 举例，最后的 $nextZ$ 表示末尾元素，而首元素是 $0$，所以判断 $nextZ$ ^ $0$ 是否等于 $d[n-1]$。所以，让循环多进行一次，就能让等式两边多 “异或” 一次 $d[n-1]$。也即，最后判断 $nextZ$ 是否等于首元素 $0$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        # 分别以0/1开头
        next_z, next_o = 0, 1

        for val in derived:
            next_z ^= val
            next_o ^= val
        
        return next_z == 0 or next_o == 1

```

```Java
// java
class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        // 分别以0/1开头
        int nextZ = 0, nextO = 1;

        for (int val : derived) {
            nextZ ^= val;
            nextO ^= val;
        }

        return nextZ == 0 || nextO == 1;
    }
}
```

---

可以发现，首元素是 $0/1$，则最后判断 “异或” $n$ 次后是否等于 $0/1$。因此，无需使用两个变量，简化为一个变量即可。

```Python
# python
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        fx = 0  # 首元素
        for val in derived:
            fx ^= val
        return fx == 0
```

```Java
// java
class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int fx = 0;  // 首元素
        for (int val : derived) {
            fx ^= val;
        }
        return fx == 0;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $derived$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 数学

又因为 “异或” 运算保证 “相同为 $0$”，而数组中只有 $0$ 和 $1$。上面的逻辑是：判断异或 $n$ 次后的尾元素是否等于首元素。

只有 $1$ 才能让两数变为相反值，因此 “首尾是否相同” 取决于 “不同” 是否为 **偶数次**！总而言之，判断数组 $d$ 中 $1$ 的出现次数，即统计总和！

代码如下：

```Python
# python
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        return sum(derived) % 2 == 0
```

```Java
// java
class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int sum = 0;
        for (int val : derived) {
            sum += val;
        }
        return sum % 2 == 0;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/neighboring-bitwise-xor/solutions/3738433/si-jie-mo-ni-kong-jian-you-hua-shu-xue-y-y1p6/)
