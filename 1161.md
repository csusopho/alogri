[Problem: 1161. 最大层内元素和](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/description/)

### 方法：DFS & BFS & 优化

计算每一层的元素和，找出总和最大且序号最小的行。

先给出 $DFS$ 解法。注意不能在 $dfs$ 函数内更新最大值，因为这一层和没有累加完，后续元素可能是负数，所以使用 $levelSum$ 数组 **记录每层的和**，最后遍历统计。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        # 使用足够大的数组来存储每层的和
        level_sums = [0] * 10001
        max_level = 0
        
        # 当前节点node，层级为level
        def dfs(node, level):
            nonlocal max_level 
            
            # 更新最大层数
            max_level = max(max_level, level)
            # 累加当前层的节点值
            level_sums[level] += node.val
            
            # 递归左右子树
            if node.left:
                dfs(node.left, level + 1)
            if node.right:
                dfs(node.right, level + 1)

        # 从第 1 层开始递归
        dfs(root, 1)
        ans = 1
        max_sum = level_sums[1]
        
        # 遍历所有层级找到最大和
        for i in range(2, max_level + 1):
            if max_sum < level_sums[i]:
                max_sum = level_sums[i]
                ans = i
                
        return ans
```

```Java
// java
class Solution {
    static int N = 10010;
    // 使用足够大的数组来存储每层的和
    static int[] levelSums = new int[N];
    int maxLevel;
    
    public int maxLevelSum(TreeNode root) {
        Arrays.fill(levelSums, 0);
        maxLevel = 1;
        
        // 从第 1 层开始递归
        dfs(root, 1, levelSums);
        
        int ans = 1;
        int maxSum = levelSums[1];
        
        // 遍历所有层级找到最大和
        for (int i = 2; i <= maxLevel; i++) {
            if (maxSum < levelSums[i]) {
                maxSum = levelSums[i];
                ans = i;
            }
        }
        
        return ans;
    }

    // 当前节点node，层级为level
    private void dfs(TreeNode node, int level, int[] levelSums) {
        // 更新最大层数
        maxLevel = Math.max(maxLevel, level);
        // 累加当前层的节点值
        levelSums[level] += node.val;
        
        // 递归左右子树
        if (node.left != null) {
            dfs(node.left, level + 1, levelSums);
        }
        if (node.right != null) {
            dfs(node.right, level + 1, levelSums);
        }
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是树中的节点个数，最大深度为 $O(n)$
- 空间复杂度： $O(U)$，其中 $U=10^5$ 表示最大节点个数

---

### $BFS$

最容易想到的解法是 **层序遍历** $BFS$，每层遍历完更新最值即可。

记得要用双端队列，而不是普通列表，不然左侧弹出为 $O(L)$，非常浪费时间。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        # 初始化队列
        q = deque([root])
        
        # 初始化最大和
        max_sum = -100001
        ans_level = 1
        curr_level = 1

        while q:
            # 当前层的节点和
            level_sum = 0
            # 当前层的节点数量
            size = len(q)
            
            for _ in range(size):
                node = q.popleft()
                level_sum += node.val
                
                # 将下一层的节点加入队列
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            
            # 当前层处理完毕，检查是否为最大和
            if level_sum > max_sum:
                max_sum = level_sum
                ans_level = curr_level
            
            # 进入下一层
            curr_level += 1
            
        return ans_level
```

```Java
// java
class Solution {
    public int maxLevelSum(TreeNode root) {
        // 初始化队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        
        // 初始化最大和
        int maxSum = -100001;
        int ansLevel = 1;
        int currLevel = 1;

        while (!q.isEmpty()) {
            // 当前层的节点和
            int levelSum = 0;
            // 当前层的节点数量
            int size = q.size();
            
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                levelSum += node.val;
                
                // 将下一层的节点加入队列
                if (node.left != null) {
                    q.offer(node.left);
                }
                if (node.right != null) {
                    q.offer(node.right);
                }
            }
            
            // 当前层处理完毕，检查是否为最大和
            if (levelSum > maxSum) {
                maxSum = levelSum;
                ansLevel = currLevel;
            }
            
            // 进入下一层
            currLevel++;
        }
        
        return ansLevel;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 数组

如果你嫌弃弹入弹出比较麻烦，那也可以用数组形式，存储每层的节点。

其中 $leftIdx$ 表示左侧弹出的指针，而 $rightIdx$ 表示右侧压入的指针。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        # 数组形式存储节点
        queue = [None] * 10001
        # 右侧进入，左侧弹出
        right_idx = 0
        left_idx = 0
        
        # 根节点入队
        queue[right_idx] = root
        right_idx += 1
        
        max_val = -100001
        ans_level = -1
        cur_level = 0
        
        # 队列不为空
        while right_idx != left_idx:
            cur_level += 1
            # 计算当前层节点数
            size = right_idx - left_idx
            curr_sum = 0
            
            # 遍历当前层
            for _ in range(size):
                # 出队
                node = queue[left_idx]
                left_idx += 1
                
                curr_sum += node.val
                
                # 左子树入队
                if node.left:
                    queue[right_idx] = node.left
                    right_idx += 1
                
                # 右子树入队
                if node.right:
                    queue[right_idx] = node.right
                    right_idx += 1
            
            # 更新最大值
            if curr_sum > max_val:
                max_val = curr_sum
                ans_level = cur_level
        
        return ans_level
```

```Java
// java
class Solution {
    public int maxLevelSum(TreeNode root) {
        // 数组形式存储节点
        TreeNode[] queue = new TreeNode[10001];
        // 右侧进入，左侧弹出
        int rightIdx = 0;
        int leftIdx = 0;
        
        // 根节点入队
        queue[rightIdx] = root;
        rightIdx++;
        
        int maxVal = -100001;
        int ansLevel = -1;
        int curLevel = 0;
        
        // 队列不为空
        while (rightIdx != leftIdx) {
            curLevel++;
            // 计算当前层节点数
            int size = rightIdx - leftIdx;
            int currSum = 0;
            
            // 遍历当前层
            for (int i = 0; i < size; i++) {
                // 出队
                TreeNode node = queue[leftIdx];
                leftIdx++;
                
                currSum += node.val;
                
                // 左子树入队
                if (node.left != null) {
                    queue[rightIdx] = node.left;
                    rightIdx++;
                }
                
                // 右子树入队
                if (node.right != null) {
                    queue[rightIdx] = node.right;
                    rightIdx++;
                }
            }
            
            // 更新最大值
            if (currSum > maxVal) {
                maxVal = currSum;
                ansLevel = curLevel;
            }
        }
        
        return ansLevel;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(U)$

---

### 交替

或者说，让每个队列只存储当前这一层的所有节点，进入下一层就换一个新的队列。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        # q 存储当前层的所有节点
        q = [root]
        
        max_sum = -float('inf')
        ans_level = 1
        curr_level_num = 1
        
        while q:
            # 计算当前层的和
            curr_sum = sum(node.val for node in q)
            
            # 更新最大值
            if curr_sum > max_sum:
                max_sum = curr_sum
                ans_level = curr_level_num
            
            # 构建下一层的节点列表
            next_q = []
            for node in q:
                if node.left:
                    next_q.append(node.left)
                if node.right:
                    next_q.append(node.right)
            
            # 替换，进入下一层
            q = next_q
            curr_level_num += 1
        
        return ans_level
```

```Java
// java
class Solution {
    public int maxLevelSum(TreeNode root) {
        // q 存储当前层的所有节点
        List<TreeNode> q = new ArrayList<>();
        q.add(root);
        
        int maxSum = Integer.MIN_VALUE;
        int ansLevel = 1;
        int currLevelNum = 1;
        
        while (!q.isEmpty()) {
            // 计算当前层的和
            int currSum = 0;
            for (TreeNode node : q) {
                currSum += node.val;
            }
            
            // 更新最大值
            if (currSum > maxSum) {
                maxSum = currSum;
                ansLevel = currLevelNum;
            }
            
            // 构建下一层的节点列表
            List<TreeNode> nextQ = new ArrayList<>();
            for (TreeNode node : q) {
                if (node.left != null) {
                    nextQ.add(node.left);
                }
                if (node.right != null) {
                    nextQ.add(node.right);
                }
            }
            
            // 替换，进入下一层
            q = nextQ;
            currLevelNum++;
        }
        
        return ansLevel;
    }
}
```

在二叉树背景下，一层队列（即树的最大宽度）最多存储多少节点？

二叉树想要 “最宽”，必须是 **满二叉树** 或 **完全二叉树**。

为了让某一层有 $W$ 个节点，它的上一层必须至少有 $\lceil W/2 \rceil$ 个节点。假设最宽的一层有 $W$ 个节点，那么整棵树的节点总数 $n$ 至少为：

$$
n \approx W + \frac{W}{2} + \frac{W}{4} + ... + 1 \approx 2W
$$

所以，总共 $10^5$ 节点最多只能支撑宽度约为 $W=5000$ 的层。

- 时间复杂度： $O(n)$
- 空间复杂度： $O(W)$

经实测，速度最快的 $Python$ 代码是 “交替” 方法，而 $Java$ 代码是 $DFS$ 方法。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/solutions/3873877/si-jie-dfs-bfs-shu-zu-xing-shi-jiao-ti-y-9jbf/)
