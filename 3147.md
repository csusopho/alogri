[Problem: 3147. 从魔法师身上吸取的最大能量](https://leetcode.cn/problems/taking-maximum-energy-from-the-mystic-dungeon/description/)

### 方法：DFS & DP & 优化

人话：从任意位置 $i$ 出发，间隔 $k$ 到下一个位置，直到末尾，累加这条路径的总和。

如果我们直接模拟，会写出下面的代码：

```Python
# python
class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)
        
        # 前向模拟
        ans = float('-inf')
        for i in range(n):
            # 对于每一个 i 作为一个起点
            cur_energy = 0
            j = i
            # 从起点 i 开始向后进行
            while j < n:
                cur_energy += energy[j]
                j += k
            # 取最大值
            ans = max(ans, cur_energy)
        
        return ans
```

假设数组 $energy$ 的长度为 $n$，当 $k=1$ 时，上述代码复杂度退化为 $O(n^2)$ 复杂度。题目限制 $n\leq 10^5$，所以会超时，卡在 $522/533$ 样例。

直接看别人代码，动规/反向/后缀，会把人搞蒙，这里我们一步步推导。

---

### $DFS$

上述代码超时的本质，是没有利用 **已知结果**。

如果我们求出了从位置 $x+k$ 出发的路径和，有必要再求从位置 $x$ 出发的路径吗？直接一步到位，路径 $x$ 总和 = 路径 $x+k$ 总和 + $energy[x]$。

因此，我们想到 **从后往前/从下往上** 的方式进行计算。

**定义** $dfs(i)$ 表示从位置 $i$ 出发能获得的总能量。

根据题意可知，转移方程为：

$$
dfs(i)=dfs(i+k)+energy[i]
$$

其他细节，比如递归边界，递归入口等这里不再阐述，比较简单，看一遍代码即可。

切记，一定要 **记忆化**！由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的。不要让 $x\to x+k$ 导致 $dfs(x+k)$ 被多次重复计算！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)

        # 计算从 i 出发所能获得的总能量
        @cache
        def dfs(i):
            # 路径结束
            if i >= n:
                return 0
            # 当前能量 = 当前位置的能量 + 从下一个位置 (i + k) 开始的能量
            return energy[i] + dfs(i + k)

        ans = float('-inf')
        # 遍历所有可能的起始点
        for i in range(n):
            cur_energy = dfs(i)
            if cur_energy > ans:
                ans = cur_energy
        
        return ans
```

```Java
// java
class Solution {
    private int[] energy;
    private int k;
    private int n;
    private Integer[] memo;

    public int maximumEnergy(int[] energy, int k) {
        this.n = energy.length;
        this.energy = energy;
        this.k = k;
        this.memo = new Integer[n]; // 记忆化数组，Integer默认值为null

        int ans = Integer.MIN_VALUE;
        // 遍历所有可能的起始点
        for (int i = 0; i < n; i++) {
            int curEnergy = dfs(i);
            if (curEnergy > ans) {
                ans = curEnergy;
            }
        }
        
        return ans;
    }

    // 计算从 i 出发所能获得的总能量
    private int dfs(int i) {
        // 路径结束
        if (i >= n) {
            return 0;
        }
        
        // 如果已经计算过，直接返回记忆化的结果
        if (memo[i] != null) {
            return memo[i];
        }

        // 当前能量 = 当前位置的能量 + 从下一个位置 (i + k) 开始的能量
        int result = energy[i] + dfs(i + k);
        
        // 将结果存入记忆化数组
        memo[i] = result;
        return result;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数只有一个，状态个数等于 $O(n)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(n)$。

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $energy$ 的长度
- 空间复杂度： $O(n)$，保存多少状态，就需要多少空间

---

### $DP$

将递归 $1:1$ 转化为递推。

同理，**定义** $dp[i]$ 表示从位置 $i$ 出发能获得的总能量。

**状态转移方程**：

$$
dp[i] = dp[i+k]+energy[i]
$$

**方向**：从大到小枚举！因为 $dp[i]$ 的值需要状态 $dp[i+k]$ 的值，必须先算出后者！

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)
        # dp[i] 表示从索引 i 出发能获得的总能量
        dp = [0] * n
        
        # 必须从后向前遍历，因为 dp[i] 的计算依赖于 dp[i+k]
        for i in range(n - 1, -1, -1):
            # 获取当前位置的能量
            cur_energy = energy[i]
            # 加上从下一个位置 (i + k) 开始的能量
            nxt_energy = dp[i + k] if i + k < n else 0
            # 状态转移
            dp[i] = cur_energy + nxt_energy
        
        # 所有可能起点中能获得的最大能量
        return max(dp)
```

```Java
// java
class Solution {
    public int maximumEnergy(int[] energy, int k) {
        int n = energy.length;
        // dp[i] 表示从索引 i 出发能获得的总能量
        int[] dp = new int[n];
        
        // 必须从后向前遍历，因为 dp[i] 的计算依赖于 dp[i+k]
        for (int i = n - 1; i >= 0; i--) {
            // 获取当前位置的能量
            int curEnergy = energy[i];
            // 加上从下一个位置 (i + k) 开始的能量
            int nextEnergy = (i + k < n) ? dp[i + k] : 0;
            // 状态转移
            dp[i] = curEnergy + nextEnergy;
        }
        
        // 找到 dp 数组中的最大值，即为所有可能起点中能获得的最大能量
        int ans = Integer.MIN_VALUE;
        for (int e : dp) {
            if (e > ans) {
                ans = e;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，一次遍历
- 空间复杂度： $O(n)$

---

### 原地

如果想节省空间，或者说进行空间优化，可以选择原地进行 $DP$。也即，将 $energy$ 当作 $DP$ 数组，从后往前更新！

一般不推荐这种写法，因为实际工程中不缺这点空间，反而会污染数据。如果在笔试中写出这种解法，面试官可能还会询问原因。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)
        
        # 倒序
        for i in range(n - k - 1, -1, -1):
            # 将 k 步之后路径上的总能量，累加到当前位置
            # 循环结束后，energy[i] 就代表了从 i 出发的完整路径的总能量
            energy[i] += energy[i + k]
        
        return max(energy)
```

```Java
// java
class Solution {
    public int maximumEnergy(int[] energy, int k) {
        int n = energy.length;

        // 倒序
        for (int i = n - k - 1; i >= 0; i--) {
            // 将 k 步之后路径上的总能量，累加到当前位置
            // 这样，energy[i] 就代表了从位置 i 出发可以获得的总能量
            energy[i] += energy[i + k];
        }

        int ans = Integer.MIN_VALUE;
        for (int e : energy) {
            if (e > ans) {
                ans = e;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

仔细想想，总共有 $n$ 个点，必须间隔 $k$，那么路径的终点一定是 $[n-k,n-1]$ 范围内的某个点！

因此，我们可以倒序枚举，从终点开始 **向前枚举**。注意，每次加入新的元素后，必须更新一次答案，因为这个点可能是当前路径的起点！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        # 后缀和
        n = len(energy)
        # 单个点作为一条路径！
        ans = energy[-1] 
        
        # 遍历 k 个路径的终点
        for i in range(n-1, n-k-1, -1):
            temp = 0
            
            # 沿着路径向前遍历
            while i >= 0:
                temp += energy[i]
                # 更新最值
                if temp > ans:
                    ans = temp
                # 跳到路径上的前一个元素
                i -= k

        return ans
```

```Java
// java
class Solution {
    public int maximumEnergy(int[] energy, int k) {
        // 后缀和
        int n = energy.length;
        // 单个点作为一条路径！
        int ans = energy[n - 1];
        
        // 遍历 k 个路径的终点
        for (int i = n - 1; i >= n - k; i--) {
            int temp = 0;
            int j = i;
            
            // 沿着路径向前遍历
            while (j >= 0) {
                temp += energy[j];
                // 更新最值
                if (temp > ans) {
                    ans = temp;
                }
                // 跳到路径上的前一个元素
                j -= k;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/taking-maximum-energy-from-the-mystic-dungeon/solutions/3802223/si-jie-ji-yi-hua-dfs-di-tui-dp-yuan-di-h-byq4/)
