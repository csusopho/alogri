[Problem: 756. 金字塔转换矩阵](https://leetcode.cn/problems/pyramid-transition-matrix/description/)

### 方法：DFS & 剪枝

金字塔是一层一层向上构建的。

- 如果当前层是 $bottom$（长度为 $N$），那么下一层将会有 $N-1$ 个块。
- 下一层的第 $i$ 个块，是由当前层的第 $i$ 个和第 $i+1$ 个块决定的，即 $bottom[i]$ 和 $bottom[i+1]$。
- 根据 $allowed$ 规则，一对基座块可能对应 **多种** 顶部块，这就产生了分支。

比如示例 $2$ 中，底座 $AA$ 对应 $B,C$ 两种顶块。如果底层是 $AAA$，则会产生 $2\times 2=4$ 种可能，也即上一层是 $BB,BC,CB,CC$ 中任意一种。

下一层的方案由上一层决定，且每层的构建逻辑相同，父问题 -> 子问题，联想到 **递归**。

本题的核心思路：枚举所有分支可能，然后判断是否有一条路径能到达塔顶。同时，给定的 $allowed$ 表固定不变，为了快速查找 “基座-顶部” 对应关系，预处理 **哈希表** 存储该结构。

**定义** $dfs(cur,next)$ 表示用当前层 $cur$ 构建下一层 $next$，最终能否堆到塔顶。

无需使用 $idx$ 索引，如果 $next$ 的长度为 $cur$ 长度 $-1$，就说明下一层拼接完成。

- 如果 $next$ 还没填满，则 $len(next)$ 正好指向当前 $cur$ 中，我们需要处理的那一对积木的位置 $cur[i]$ 和 $cur[i+1]$。
- 如果 $next$ 填满了，就换行判断，把 $next$ 变成新的 $cur$，清空 $next$ 开启下一轮递归。

**终止条件**：

- 成功：如果当前层长度为 $1$，说明堆到了塔顶，返回 $True$。
- 失败：如果在某一层找不到任何合法的下一层，返回 $False$。

在搜索过程中，可能会多次遇到相同的 “行状态”。例如，不同的底层组合可能在第 $3$ 层生成了相同的字符串 $ABC$，导致重复计算，因此可以用记忆化搜索来优化。

记忆化的 **本质** 就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有两个，所以记忆化数组需要两维。 $Java$ 中使用哈希记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # 预处理 得到map["AB"] = ["C", "D"]
        rule_book = defaultdict(list)
        for p in allowed:
            rule_book[p[0:2]].append(p[2])

        # cur 是当前层，nextPart 是正在构建的下一层
        @cache
        def dfs(cur, nextPart):
            # 到达塔尖
            if len(cur) == 1:
                return True
            
            # 当下一层构建完毕，则换行
            if len(nextPart) == len(cur) - 1:
                return dfs(nextPart, "")
            
            # 尝试构建下一层
            idx = len(nextPart)
            # 找到当前层对应的基座
            base = cur[idx : idx+2]
            
            # 尝试所有合法的顶块，将它拼接到 nextPart 后面
            if base in rule_book:
                for top in rule_book[base]:
                    if dfs(cur, nextPart + top):
                        return True
            # 构建失败
            return False

        return dfs(bottom, "")
```

```Java
// java
class Solution {
    Map<String, List<Character>> ruleBook = new HashMap<>();
    Map<String, Boolean> memo = new HashMap<>();

    public boolean pyramidTransition(String bottom, List<String> allowed) {
        // 预处理 得到map["AB"] = ["C", "D"]
        for (String p : allowed) {
            String base = p.substring(0, 2);
            char top = p.charAt(2);
            ruleBook.computeIfAbsent(base, k -> new ArrayList<>()).add(top);
        }

        return dfs(bottom, "");
    }

    // cur 是当前层，nextPart 是正在构建的下一层
    private boolean dfs(String cur, String nextPart) {
        // 到达塔尖
        if (cur.length() == 1) {
            return true;
        }

        // 拼接作为哈希表的 key
        String key = cur + "|" + nextPart;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        // 当下一层构建完毕，则换行
        if (nextPart.length() == cur.length() - 1) {
            boolean res = dfs(nextPart, "");
            memo.put(key, res);
            return res;
        }

        // 尝试构建下一层
        int idx = nextPart.length();
        // 找到当前层对应的基座
        String base = cur.substring(idx, idx + 2);

        // 尝试所有合法的顶块，将它拼接到 nextPart 后面
        if (ruleBook.containsKey(base)) {
            for (Character top : ruleBook.get(base)) {
                if (dfs(cur, nextPart + top)) {
                    memo.put(key, true);
                    return true;
                }
            }
        }

        // 构建失败
        memo.put(key, false);
        return false;
    }
}
```

字母表大小记作 $A$，本题规定只有 $A=6$ 种不同字母。每个基座都有 $O(A)$ 种分支，而金字塔共有 $n\times (n-1)/2$ 个位置需要填充。记忆化后，每个状态只计算一次，故时间复杂度为 $O(A^{n^2})$，实际时间远低于此。

每一层构建需要递归 $n$ 次，金字塔高 $n$ 层，总递归深度与块的总数成正比，即 $O(n^2)$。保存多少状态，就需要多少空间。每个状态由两个字符串组成，最坏情况下需要存储的状态数量也与构建过程中的分支数量有关，即 $O(n^2)$。

- 时间复杂度： $O(A^{n^2})$，其中 $n$ 为数组 $bottom$ 的长度，且 $A=6$ 为字母集大小
- 空间复杂度： $O(n^2)$，表示递归深度以及 $memo$ 的大小

---

### 单参数

上面代码的速度非常慢，是因为每次都在循环内部，使用 $+$ 去拼接串并递归。

因此，我们完全可以手动地 **拼完** 下一层的所有可能后，再递归到下一层级。**定义** $dfs(cur)$ 表示用当前层 $cur$ 能否构建完金字塔。

- 前一个基座有 $[A]$ 一种可能塔顶，当前基座有 $[B,C]$ 两种可能塔顶，则拼接出 $[AB,AC]$ 两种可能。
- 新的基座有 $[D,E]$ 两种可能塔顶，则拼接出 $[ABD,ABE,ACD,ACE]$ 四种可能。
- 同理，类推到下一层拼接完成。

将拼接完成的下一层分别 $dfs$，只要有一个到达塔顶就算成功。如果 $len(cur)=1$，说明达到塔顶。反之，若找不到任何合法的下一层，失败。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # 预处理，得到map["AB"] = ["C", "D"]
        rule_book = defaultdict(list)
        for p in allowed:
            rule_book[p[0:2]].append(p[2])

        @cache
        def dfs(cur):
            # 到达塔顶，成功
            if len(cur) == 1:
                return True
            
            # 手动构建下一层的所有可能
            candidates = [""]
            
            # 遍历当前层的每一对积木
            for i in range(len(cur) - 1):
                base = cur[i : i+2]
                
                # 某一对积木没有对应的顶块，说明这一整行都废了
                if base not in rule_book:
                    return False
                
                possible_tops = rule_book[base]
                
                # 手动拼接
                # 旧列表: ["A", "B"]
                # 新顶块: ["X", "Y"]
                # 新列表: ["AX", "AY", "BX", "BY"]
                new_candidates = []
                for partial_str in candidates:
                    for top in possible_tops:
                        new_candidates.append(partial_str + top)
                
                # 更新候选列表，准备处理下一对
                candidates = new_candidates
            
            # 递归下探，其中包含了所有生成的完整 next_row
            for next_row in candidates:
                if dfs(next_row):
                    return True
            
            return False

        return dfs(bottom)
```

```Java
// java
class Solution {
    Map<String, List<Character>> ruleBook = new HashMap<>();
    Map<String, Boolean> memo = new HashMap<>();

    public boolean pyramidTransition(String bottom, List<String> allowed) {
        // 预处理，得到map["AB"] = ["C", "D"]
        for (String p : allowed) {
            String base = p.substring(0, 2);
            char top = p.charAt(2);
            ruleBook.computeIfAbsent(base, k -> new ArrayList<>()).add(top);
        }

        return dfs(bottom);
    }

    private boolean dfs(String cur) {
        // 到达塔顶，成功
        if (cur.length() == 1) {
            return true;
        }

        // 检查备忘录
        if (memo.containsKey(cur)) {
            return memo.get(cur);
        }

        // 手动构建下一层的所有可能
        List<String> candidates = new ArrayList<>();
        candidates.add("");

        // 遍历当前层的每一对积木
        for (int i = 0; i < cur.length() - 1; i++) {
            String base = cur.substring(i, i + 2);

            // 某一对积木没有对应的顶块，说明这一整行都废了
            if (!ruleBook.containsKey(base)) {
                memo.put(cur, false);
                return false;
            }

            List<Character> possibleTops = ruleBook.get(base);
            
            // 手动拼接
            // 旧列表 ["A", "B"] + 当前 ["X", "Y"] -> 新列表 ["AX", "AY", "BX", "BY"]
            List<String> newCandidates = new ArrayList<>();
            for (String partialStr : candidates) {
                for (Character top : possibleTops) {
                    newCandidates.add(partialStr + top);
                }
            }

            // 更新候选列表，准备处理下一对
            candidates = newCandidates;
        }

        // 递归下探，其中包含了所有生成的完整 next_row
        for (String nextRow : candidates) {
            if (dfs(nextRow)) {
                memo.put(cur, true);
                return true;
            }
        }

        memo.put(cur, false);
        return false;
    }
}
```

- 时间复杂度： $O(A^{n^2})$，其中 $n$ 为数组 $board$ 的行数，每个网格最多遍历一次
- 空间复杂度： $O(A^n)$，每一层生成的 $candidates$ 列表可能会变得非常大

---

### 剪枝

看了一眼通过速度最快的代码，思路很好，这里仅做分享。

使用双参数的 $dfs$，**最关键** 的一步：如果正在构建的下一层片段已经超过 $2$ 个，先暂停当前构建，去检查下一层是否是 “死路”。如果 $next$ 无法堆成金字塔，那么无论 $cur$ 后面生成什么，这条路都死定了。

这种思路应该叫做 “激进剪枝”。检查完下一层后，再用当前层继续构建。

其他做法基本相同，先判断是否到达塔顶，然后取出 $cur$ 的头两个字符构建下一层。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # 预处理，构建规则字典
        patterns = defaultdict(list)
        for p in allowed:
            patterns[p[:2]].append(p[2])
        
        # 当前层剩余待处理的片段，下一层目前已生成的片段
        @lru_cache(None)
        def dfs(curr, next_part):
            # 激进剪枝
            # 如果下一层片段已经超过2个，先检查下一层是否是“死路”
            if len(next_part) >= 2:
                if not dfs(next_part, ''):
                    return False

            # 当前行的只剩最后一对积木
            if len(curr) == 2:
                # 下一层是空，说明 curr 是金字塔顶端的最后两个积木
                if not next_part:
                    return curr in patterns
                
                # 完成当前行的构建，将 t 拼接到 next_part，换行
                possible_tops = patterns.get(curr, [])
                return any(dfs(next_part + t, '') for t in possible_tops)

            # 当前行还没处理完，取出头部一对
            # curr 向右缩减，next_part 累加 t
            else:
                pair = curr[:2]
                possible_tops = patterns.get(pair, [])
                return any(dfs(curr[1:], next_part + t) for t in possible_tops)

        return dfs(bottom, '')
```

```Java
// java
class Solution {
    // 存储规则：map["AB"] = ['C', 'D']
    Map<String, List<Character>> patterns = new HashMap<>();
    // 备忘录
    Map<String, Boolean> memo = new HashMap<>();

    public boolean pyramidTransition(String bottom, List<String> allowed) {
        // 预处理，构建规则字典
        for (String p : allowed) {
            String base = p.substring(0, 2);
            char top = p.charAt(2);
            patterns.computeIfAbsent(base, k -> new ArrayList<>()).add(top);
        }

        return dfs(bottom, "");
    }

    // 当前层剩余待处理的片段，下一层目前已生成的片段
    private boolean dfs(String curr, String nextPart) {
        // 拼接作为哈希表的 key
        String key = curr + "|" + nextPart;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        // 激进剪枝
        // 如果下一层片段已经超过2个，先递归检查这个片段本身是否是“死路”
        if (nextPart.length() >= 2) {
            if (!dfs(nextPart, "")) {
                memo.put(key, false);
                return false;
            }
        }

        // 当前行只剩最后一对积木
        if (curr.length() == 2) {
            // 下一层为空，说明 curr 是塔尖下的最后两个积木
            if (nextPart.isEmpty()) {
                boolean res = patterns.containsKey(curr);
                memo.put(key, res);
                return res;
            }

            // 完成当前行的构建，将生成的 top 拼接到 nextPart 后，换行
            if (patterns.containsKey(curr)) {
                for (Character t : patterns.get(curr)) {
                    if (dfs(nextPart + t, "")) {
                        memo.put(key, true);
                        return true;
                    }
                }
            }
        }
        // 当前行还没处理完，逐格构建
        else {
            String pair = curr.substring(0, 2);
            if (patterns.containsKey(pair)) {
                for (Character t : patterns.get(pair)) {
                    // curr 向右移动一位，nextPart 累加生成的 t
                    if (dfs(curr.substring(1), nextPart + t)) {
                        memo.put(key, true);
                        return true;
                    }
                }
            }
        }

        // 所有尝试都失败
        memo.put(key, false);
        return false;
    }
}
```

- 时间复杂度： $O(A^{n^2})$
- 空间复杂度： $O(n^2)$

实测 $Python$ 运行速度为 $14ms$，比灵神的位运算写法 $15ms$ 更快一筹。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/pyramid-transition-matrix/solutions/3868307/san-jie-shuang-dan-can-shu-dfs-ji-jin-ji-0zzz/)
