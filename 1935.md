[Problem: 1935. 可以输入的最大单词数](https://leetcode.cn/problems/maximum-number-of-words-you-can-type/description/)

### 方法：模拟 & 一行流

单词中不存在损坏的字母，则是完好单词，否则是损坏单词。

那么，如何判断一个串 $s1$ 中包含另一个串 $s2$ 中的字母呢？

- 暴力双 $for$，枚举所有二元组，时间是 $O(len1\times len2)$；
- 一/两个串转为 $set$ 集合，再枚举判断，时间是 $O(len1+len2)$；
- 都转为集合后，调库判断是否有交集，时间是 $O(min(len1,len2))$。

对于本题来说，直接 **模拟**：判断每个 $word$ 与 $broken$ 的关系即可。这里使用第二种方法，一行流解法中再使用第一和第三种方法。

代码如下，已附加注释：

```Python
# python
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        # 损坏字母放入集合中
        broken_set = set(brokenLetters)
        # 分割成单词列表
        words = text.split(' ')
        ans = 0
        
        for word in words:
            can_type = True
            for char in word:
                # 如果字母在损坏集合中
                if char in broken_set:
                    can_type = False
                    break
            
            if can_type:  # 否则，完好无损
                ans += 1
                
        return ans
```

```Java
// java
class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        // 损坏字母放入集合中
        Set<Character> brokenSet = new HashSet<>();
        for (char c : brokenLetters.toCharArray()) {
            brokenSet.add(c);
        }
        
        // 分割成单词列表
        String[] words = text.split(" ");
        int ans = 0;
        
        for (String word : words) {
            boolean canType = true;
            for (char c : word.toCharArray()) {
                // 如果字母在损坏集合中
                if (brokenSet.contains(c)) {
                    canType = false;
                    break;
                }
            }
            
            if (canType) {  // 否则，完好无损
                ans++;
            }
        }
                
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为字符串 $text$ 的长度，哈希判断的时间为 $O(1)$
- 空间复杂度： $O(n+m)$，其中 $m$ 是串 $broken$ 的长度

---

### 一行流

$\textbf{仅供整活使用，一般不推荐}$，了解语法即可。

先展示暴力双 $for$ 的第一种写法，使用 $any$ 判断：

```Python
# python
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        return sum(not any(char in brokenLetters for char in word) for word in text.split())
```

```Java
// java
class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        return Arrays.stream(text.split(" "))
                     .mapToInt(word -> word.chars().anyMatch(c -> brokenLetters.indexOf(c) >= 0) ? 0 : 1)
                     .sum();
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(n)$，表示切割生成的列表开销

再来看看双 $set$ 的第三种解法，判断是否存在 “交集”：

```Python
# python
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        return sum(set(word).isdisjoint(set(brokenLetters)) for word in text.split())
```

```Java
// java
class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        // 先转为 Set
        Set<Character> brokenSet = brokenLetters.chars().mapToObj(c -> (char) c).collect(Collectors.toSet());
        // 在流处理中高效检查
        return (int) Arrays.stream(text.split(" ")).filter(word -> word.chars().noneMatch(c -> brokenSet.contains((char) c))).count();
    }
}
```

- 时间复杂度： $O(n+m)$，实际上 $python$ 中的 $broken$ 加上 $set$ 后每次都需要计算，导致复杂度变为 $O(n+m\times k)$，其中 $k$ 为单词数，可以直接去除这个 $set$
- 空间复杂度： $O(n+m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-number-of-words-you-can-type/solutions/3782257/mo-ni-bao-li-mei-ju-setyou-hua-jiao-ji-p-0r4r/)
