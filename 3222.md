[Problem: 3222. 求出硬币游戏的赢家](https://leetcode.cn/problems/find-the-winning-player-in-coin-game/description/)

### 方法：数学

题意：每轮游戏中，一个玩家需要挑选硬币组成价值为 $115$ 的组合。求 $Alice$ 先手的情况下，谁最先用完硬币。

硬币只有 $75$ 和 $10$ 两种面额，假设分别选择两种硬币 $a,b$ 个。求解二元一次方程 $75a + 10b = 115$，它有 **唯一** 正整数解 $a = 1, b = 4$。

也就是说，想要凑成总和 $115$，两种类型的硬币只能分别使用 $1,4$ 个。

而两种硬币的容量分别只有 $x,y$ 个，那么价值为 $75$ 的硬币将在 $x$ 轮后用完，价值为 $10$ 的硬币将在 $\lfloor y / 4 \rfloor$ 轮后用完。

总结，令 $k = \min(x, \lfloor y / 4 \rfloor)$，这是能玩的回合数。

$Alice$ 先手，刚到 $Ta$ 手里算第一轮， $Ta$ 想要赢的话必须是自己能有硬币用，而 $Bob$ 没有，所以只能玩奇数轮；同理， $Bob$ 后手， $Ta$ 想要赢的话只能玩偶数轮。

**做法**：判断 $k$ 的奇偶性，如果是奇数则 $Alice$ 胜，如果是偶数则 $Bob$ 胜。

那假如有多种方案的硬币能组成目标值，怎么办？博弈，使用 $DFS$ 或者动规。自己选过后，要保证对方不能赢，才算自己赢。

定义 $dfs(i,j)$ 表示自己先手的情况下，剩余两种硬币数量为 $i,j$ 时，能赢为 $True$，反之为 $False$。转移过程就是通过不同方案得到后续 $dfs$，只要有一个为 $False$，那就选那个方案。 $DP$ 同理。

本题只需要一次判断，代码如下：

```Python
# python
class Solution:
    def losingPlayer(self, x: int, y: int) -> str:
        return "Alice" if min(x, y // 4) % 2 else "Bob"
```

```Python
# python
class Solution {
    public String losingPlayer(int x, int y) {
        return Math.min(x, y / 4) % 2 != 0 ? "Alice" : "Bob";
    }
}
```

- 时间复杂度： $O(1)$，只进行一次判断
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-the-winning-player-in-coin-game/solutions/2977591/shu-xue-pan-duan-qi-ou-xing-tan-lun-bo-y-9hj4/)
