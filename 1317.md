[Problem: 1317. 将整数转换为两个无零整数的和](https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/description/)

### 方法：暴力 & 构造 & 随机

题意：寻找 $a,b$ 使得两者之和等于 $n$，且数位中都不能含有 $0$。

如何判断数位中有 $0$？有三种方法：

```Python
1. 转为字符串，然后判断是否有字符 `'0'`
def is_no_zero(x):
    return '0' not in str(x)
```

```Python
2. 使用 / 和 %，从低到高循环判断每一位
def is_no_zero(x):
    while x > 0:
        if x % 10 == 0:
            return False
        x //= 10
    return True
```

```Python
3. 同理，但是换成递归写法
def is_no_zero(x):
    if x == 0:  # 递归边界
        return True
    remain = x % 10  # 余数
    if remain == 0:
        return False
    else:
        return is_no_zero(x // 10)
```

**暴力** 思路：从小到大枚举 $a$，用 $n$ 相减得到 $b$，然后调用上述方法，判断这两个数是否含有 $0$。代码如下：

```Python
# python
class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        def is_no_zero(x):
            if x == 0:  # 递归边界
                return True
            remain = x % 10  # 余数
            if remain == 0:
                return False
            else:
                return is_no_zero(x // 10)
        
        for i in range(1, n):
            if is_no_zero(i) and is_no_zero(n-i):
                return [i, n - i]
```

```Java
// java
class Solution {
    public int[] getNoZeroIntegers(int n) {
        for (int i = 1; i < n; i++) {
            if (isNoZero(i) && isNoZero(n - i)) {
                return new int[]{i, n - i};
            }
        }
        return new int[]{};  // 走不到这
    }

    // 判断一个数字是否不含数字0
    private boolean isNoZero(int x) {
        if (x == 0) { // 递归边界
            return true;
        }
        int remain = x % 10; // 余数
        if (remain == 0) {
            return false;
        } else {
            return isNoZero(x / 10);
        }
    }
}
```

- 时间复杂度： $O(n\times logn)$，判断一个数字的时间为 $O(logn)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 构造

不能有 $0$ 出现在数位，产生一个 **想法**：如果我们直接构造 $a$，让 $b=n-a$ 同时也无零，就能避免暴力。

举个例子，假设 $n=1010$，

- 如果选 $a=1$，则 $b=1009$，但是 $b$ 有零
- 如果选 $a=11$，则 $b=999$，两个都合法

这提示我们可以 **逐位处理**，从而避免产生 $0$。

假设当前位是 $6$，只有 $0+6$ 这种情况才有可能凑出 $0$。那么，我们完全可以将 $1$ 分给 $a$，剩余的 $5$ 分给 $b$，确保一定不会产生 $0$！

第一个 **问题**：如果当前位就是 $0$，无法分给 $a$ 一个 $1$。那么，我们需要借位，从高位借一个 $10$，当前位变为 $10$，那 $a$ 能分到 $1$，而 $b$ 分到 $9$。

第二个 **问题**：如果当前位是 $1$，那 $b$ 就分到 $0$，这不符合要求。同理借位，从高位借一个 $10$，当前位变为 $11$，那 $a$ 能分到 $2$，而 $b$ 分到 $9$。

总结，设某一位为 $d$：

- 若 $d > 1$，拆成 $1$ 和 $d-1$
- 若 $d = 1$，借位，然后拆成 $2+9$
- 若 $d = 0$，借位，然后拆成 $1+9$

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        a, b = 0, 0  # 分别存储两个结果数
        base = 1     # 当前处理的位 (个位=1, 十位=10, ...)
        remain = n   # 还没有被处理的高位部分

        while remain > 1:
            digit = remain % 10  # 当前正在处理的最低位
            remain //= 10

            if digit <= 1:
                # 如果当前位是 0 或 1：必须借位
                # 分配给 a 当前位 = (digit + 1)，并向更高位借 1
                a += (digit + 1) * base
                remain -= 1
            else:
                # 当前位 ≥ 2：直接分配 1 给 a，剩下的 digit-1 给 b
                a += base

            base *= 10

        b = n - a
        return [a, b]
```

```Java
// java
class Solution {
    public int[] getNoZeroIntegers(int n) {
        int a = 0, b = 0;  // 分别存储两个结果数
        int base = 1;      // 当前处理的位 (个位=1, 十位=10, ...)
        int remain = n;    // 还没有被处理的高位部分

        while (remain > 1) {
            int digit = remain % 10;  // 当前正在处理的最低位
            remain /= 10;

            if (digit <= 1) {
                // 如果当前位是 0 或 1：必须借位
                // 分配给 a 当前位 = (digit + 1)，并向更高位借 1
                a += (digit + 1) * base;
                remain -= 1;
            } else {
                // 当前位 ≥ 2：直接分配 1 给 a，剩下的 digit-1 给 b
                a += base;
            }

            base *= 10;
        }

        b = n - a;
        return new int[]{a, b};
    }
}
```

- 时间复杂度： $O(logn)$
- 空间复杂度： $O(1)$

---

### 随机

因为题目保证一定存在解，所以我们可以用 **随机数法**：在 $[1,n-1]$ 的范围内随机生成 $a$，然后得出 $b$，判断两数是否符合。

调库 $random$，代码如下：

```Python
# python
class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        def is_no_zero(x):
            while x > 0:
                if x % 10 == 0:
                    return False
                x //= 10
            return True
        
        while True:
            a = random.randint(1, n - 1)
            b = n - a
            if is_no_zero(a) and is_no_zero(b):
                return [a, b]
```

```Java
// java
class Solution {
    public int[] getNoZeroIntegers(int n) {
        Random rand = new Random();
        while (true) {
            int a = rand.nextInt(n - 1) + 1; // 生成 [1, n-1] 的随机数
            int b = n - a;
            if (isNoZero(a) && isNoZero(b)) {
                return new int[]{a, b};
            }
        }
    }

    private boolean isNoZero(int x) {
        while (x > 0) {
            if (x % 10 == 0) {
                return false;
            }
            x /= 10;
        }
        return true;
    }
}
```

- 时间复杂度： $O(logn)$，正确答案很多，期望在常数次数内达成，最坏情况下永远无法生成，具体公式可以看灵神的题解
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/solutions/3775377/wu-jie-bao-li-de-san-chong-pan-duan-zhu-9wqnu/)
