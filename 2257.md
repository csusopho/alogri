[Problem: 2257. 统计网格图中没有被保卫的格子数](https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/description/)

### 方法：暴力 & 转化思路

一个警卫能探索四个方向，会被 警卫/墙 挡住视线。本质来说，这题是 **网格搜索** 问题，每个警卫是起点，判断最后有多少地方不能到达。

虽然这一题能按照 $DFS/BFS$ 的解法进行，但是网格大小 $m\times n$ 是 $O(10^5)$ 量级，没有必要大费周章。

直接 **暴力** 做法：从每个警卫出发，沿着四个射线进行搜索，直到到达边界/障碍物。

怎么知道当前格子是墙/警卫？使用 **标记**。提前处理，将这些 “障碍物” 设为 $-1$ 表示不可越过。同时，搜索过的路径，说明能被警卫保护，标记为 $1$。

**答案**：网格初始化为 $0$，最后统计一遍网格，累计值为 $0$，也就是没被保护的格子数量。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        # 初始化网格，0表示未被保卫，1表示被保卫，-1表示墙或警卫
        grid = [[0 for _ in range(n)] for _ in range(m)]
        
        # 标记墙和警卫的位置
        for i, j in walls:
            grid[i][j] = -1
        for i, j in guards:
            grid[i][j] = -1
        
        # 方向数组：东、南、西、北
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        for i, j in guards:
            for di, dj in directions:
                x, y = i + di, j + dj
                while 0 <= x < m and 0 <= y < n:
                    if grid[x][y] == -1:
                        break  # 遇到墙或警卫，停止
                    grid[x][y] = 1  # 标记为被保卫
                    x += di
                    y += dj
        
        # 统计未被保卫的格子数量
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    count += 1
        return count
```

```Java
// java
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        // 初始化网格，0表示未被保卫，1表示被保卫，-1表示墙或警卫
        int[][] grid = new int[m][n];
        
        // 标记墙和警卫的位置
        for (int[] wall : walls) {
            grid[wall[0]][wall[1]] = -1;
        }
        for (int[] guard : guards) {
            grid[guard[0]][guard[1]] = -1;
        }
        
        // 方向数组：东、南、西、北
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        for (int[] guard : guards) {
            int i = guard[0];
            int j = guard[1];
            for (int[] dir : directions) {
                int di = dir[0];
                int dj = dir[1];
                int x = i + di;
                int y = j + dj;
                while (x >= 0 && x < m && y >= 0 && y < n) {
                    if (grid[x][y] == -1) {
                        break;  // 遇到墙或警卫，停止
                    }
                    grid[x][y] = 1;  // 标记为被保卫
                    x += di;
                    y += dj;
                }
            }
        }
        
        // 统计未被保卫的格子数量
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

如果将上述 “统计答案” 的步骤换成 $sum$ 调库快速求和，速度会更快，时间从 $349ms$ 的 $85\%$ 变为 $259ms$ 的 $94\%$。不过上述写法空间耗费最小，能达到 $38M$，超越 $100\%$。

- 时间复杂度： $O(n\times m+g\times(m+n))$，其中 $g$ 为数组 $guards$ 的行数
- 空间复杂度： $O(n\times m)$，表示数组 $grid$ 的大小

---

### 反向思考

上面做法中，最后还需要遍历一次网格 $grid$ 用于累加 $0$ 的数量。

**转化思路**：答案从 $m\times n$ 开始向下递减，沿着警卫的某个方向搜索时，遇到 “能保卫” 的格子，就对答案进行 $-1$，并标记为 $mask$ 表示已经搜索过。

总体思路不变，都是预处理一遍，然后从警卫开始搜索，只不过省去最后一步。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        grid = [[0] * n for _ in range(m)]
        ans = m * n
        # 标记已经被警卫保护
        mark = 6

        # 标记墙和警卫的位置，同理使用-1标记
        for r, c in guards:
            grid[r][c] = -1
            ans -= 1
        for r, c in walls:
            grid[r][c] = -1
            ans -= 1 

        # 方向数组：东、南、西、北
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        # 计算他们能保护的区域
        for i, j in guards:
            for di, dj in directions:
                x, y = i + di, j + dj
                # 沿着当前方向前进
                while 0 <= x < m and 0 <= y < n:
                    # 视线中断
                    if grid[x][y] == -1:
                        break
                    
                    # 已经被计算过，无需标记，继续检查
                    if grid[x][y] == mark:
                        x, y = x + di, y + dj
                        continue  # 跳过后续处理
                    
                    # 现在被守卫，标记
                    grid[x][y] = mark
                    ans -= 1
                    x, y = x + di, y + dj
        
        return ans
```

```Java
// java
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n];
        int ans = m * n;
        // 标记已经被警卫保护
        int mark = 6;

        // 标记墙和警卫的位置，同理使用-1标记
        for (int[] guard : guards) {
            grid[guard[0]][guard[1]] = -1;
            ans--;
        }
        for (int[] wall : walls) {
            grid[wall[0]][wall[1]] = -1;
            ans--;
        }

        // 方向数组：东、南、西、北
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        // 计算他们能保护的区域
        for (int[] guard : guards) {
            int i = guard[0];
            int j = guard[1];
            for (int[] dir : directions) {
                int di = dir[0];
                int dj = dir[1];
                int x = i + di;
                int y = j + dj;
                // 沿着当前方向前进
                while (x >= 0 && x < m && y >= 0 && y < n) {
                    // 视线中断
                    if (grid[x][y] == -1) {
                        break;
                    }
                    
                    // 已经被计算过，无需标记，继续检查
                    if (grid[x][y] == mark) {
                        x = x + di;
                        y = y + dj;
                        continue; // 跳过后续处理
                    }
                    
                    // 现在被守卫，标记
                    grid[x][y] = mark;
                    ans--;
                    x = x + di;
                    y = y + dj;
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(g\times(m+n))$，省去最后统计，这种方法速度最快
- 空间复杂度： $O(n\times m)$，同理

---

### 另类解

一定必须从 “警卫” 出发吗？每个 “起点” 都搜索一遍是否麻烦？我们可以使用一种 “状态累积” 的解法，让每个单元格只搜索四次。

**行扫描**：

- 从左到右遍历每一行，用一个状态变量来记录 “当前是否处于一个守卫的视野中”。
- 当遇到一个守卫时，我们开启这个状态。
- 当遇到一个墙壁时，我们关闭这个状态。
- 只要状态为 $True$，那么遇到的所有空单元格都会被标记为“水平方向受保护”。
- 然后，我们再从右到左遍历每一行，用同样的方法标记。这样就处理完了所有水平方向的保护情况。

**列扫描**：同理，我们从上到下和从下到上遍历每一列，标记所有 “垂直方向受保护” 的单元格。

最后，一个单元格是 “未被守卫的”，当且仅当它本身不是守卫或墙壁，并且它既没有被水平方向保护，也没有被垂直方向保护。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        # 0: 空地, 1: 守卫, 2: 墙壁, 3: 被保护的空地
        grid = [[0] * n for _ in range(m)]

        # 在网格上放置守卫和墙壁
        for r, c in guards:
            grid[r][c] = 1
        for r, c in walls:
            grid[r][c] = 2

        # 遍历每一行 (水平扫描)
        for r in range(m):
            # 从左到右
            in_sight = False
            for c in range(n):
                cell_state = grid[r][c]
                if cell_state == 1:  # 遇到守卫，开启视野
                    in_sight = True
                elif cell_state == 2:  # 遇到墙壁，中断视野
                    in_sight = False
                
                # 如果在视野中，并且当前是空地，则标记为被保护
                if in_sight and grid[r][c] == 0:
                    grid[r][c] = 3

            # 从右到左
            in_sight = False
            for c in range(n - 1, -1, -1):
                cell_state = grid[r][c]
                if cell_state == 1:
                    in_sight = True
                elif cell_state == 2:
                    in_sight = False
                
                if in_sight and grid[r][c] == 0:
                    grid[r][c] = 3

        # 遍历每一列 (垂直扫描)
        for c in range(n):
            # 从上到下
            in_sight = False
            for r in range(m):
                cell_state = grid[r][c]
                if cell_state == 1:
                    in_sight = True
                elif cell_state == 2:
                    in_sight = False
                
                if in_sight and grid[r][c] == 0:
                    grid[r][c] = 3
            
            # 从下到上
            in_sight = False
            for r in range(m - 1, -1, -1):
                cell_state = grid[r][c]
                if cell_state == 1:
                    in_sight = True
                elif cell_state == 2:
                    in_sight = False
                
                if in_sight and grid[r][c] == 0:
                    grid[r][c] = 3

        # 统计结果
        return sum(row.count(0) for row in grid)
```

```Java
// java
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        // 0: 空地, 1: 守卫, 2: 墙壁, 3: 被保护的空地
        int[][] grid = new int[m][n];

        // 在网格上放置守卫和墙壁
        for (int[] guard : guards) {
            grid[guard[0]][guard[1]] = 1;
        }
        for (int[] wall : walls) {
            grid[wall[0]][wall[1]] = 2;
        }

        // 遍历每一行 (水平扫描)
        for (int r = 0; r < m; r++) {
            // 从左到右
            boolean in_sight = false;
            for (int c = 0; c < n; c++) {
                int cell_state = grid[r][c];
                if (cell_state == 1) {  // 遇到守卫，开启视野
                    in_sight = true;
                } else if (cell_state == 2) {  // 遇到墙壁，中断视野
                    in_sight = false;
                }
                
                // 如果在视野中，并且当前是空地，则标记为被保护
                if (in_sight && grid[r][c] == 0) {
                    grid[r][c] = 3;
                }
            }

            // 从右到左
            in_sight = false;
            for (int c = n - 1; c >= 0; c--) {
                int cell_state = grid[r][c];
                if (cell_state == 1) {
                    in_sight = true;
                } else if (cell_state == 2) {
                    in_sight = false;
                }
                
                if (in_sight && grid[r][c] == 0) {
                    grid[r][c] = 3;
                }
            }
        }

        // 遍历每一列 (垂直扫描)
        for (int c = 0; c < n; c++) {
            // 从上到下
            boolean in_sight = false;
            for (int r = 0; r < m; r++) {
                int cell_state = grid[r][c];
                if (cell_state == 1) {
                    in_sight = true;
                } else if (cell_state == 2) {
                    in_sight = false;
                }
                
                if (in_sight && grid[r][c] == 0) {
                    grid[r][c] = 3;
                }
            }
            
            // 从下到上
            in_sight = false;
            for (int r = m - 1; r >= 0; r--) {
                int cell_state = grid[r][c];
                if (cell_state == 1) {
                    in_sight = true;
                } else if (cell_state == 2) {
                    in_sight = false;
                }
                
                if (in_sight && grid[r][c] == 0) {
                    grid[r][c] = 3;
                }
            }
        }

        // 统计结果
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

- 时间复杂度： $O(n\times m)$，这种方法速度最慢
- 空间复杂度： $O(n\times m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/solutions/3821454/san-jie-tuo-zhan-si-lu-bao-li-sou-suo-fa-wr3o/)
