[Problem: 2327. 知道秘密的人数](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/description/)

### 方法：DP & 优化

若某人在第 $i$ 天知道秘密，则他会在天数区间

$$
[i+\text{delay},\; i+\text{forget}-1]
$$

的每一天各告诉 $1$ 个新人。

因此，我们需要跟踪每天有多少人 “新知道秘密”。那有小伙伴疑问，忘记的人怎么统计？实际上，我们统计的是 **增量**。比如第 $1$ 人在第 $forget$ 天遗忘，他就停止了对答案的增量，也就不再参与传播。

总结：**第 $i$ 天的新知道人数 $=$ 之前还没忘记的人在今天传播的结果**。

每天告诉 $1$ 个新人，那么第 $i$ 天的新知道人数由所有满足

$$j+\text{delay} \leq i \leq j+\text{forget}-1$$

的 $j$ 累加得到。因此，**定义** $dp[i]$ 表示第 $i$ 天 **新知道** 秘密的人数。

根据上面的推导可知，状态转移 **方程** 为：

$$
dp[i] = \sum_{j=\max(1,\, i-\text{forget}+1)}^{i-\text{delay}} dp[j]
$$

在第 i 天，能传播的人必须满足上述区间，这样自动就排除了那些已经忘记的人，因为他们的 $j < i-forget+1$ 不会进入求和区间。

最后，我们要统计第 $n$ 天结束时还记得秘密的人数，他们是在 $[n-forget+1,n]$ 这段时间学会的，因此 **答案** 为

$$
\sum_{i=n-\text{forget}+1}^{n} dp[i]
$$

举个例子，设 $n=6,\; delay=2,\; forget=4$

- 第 $1$ 天： $dp[1] = 1$，只有 $1$ 人知道
- 第 $2$ 天： $dp[2] = 0$，没人能传播
- 第 $3$ 天： $dp[3] = 1$，第 $1$ 天的人开始传播
- 第 $4$ 天： $dp[4] = 1$，第 $1$ 天的人还能传播
- 第 $5$ 天： $dp[5] = 2$，第 $1$ 天的人最后一天传播 $+$ 第 $3$ 天的人传播
- 第 $6$ 天： $dp[6] = 2$，第 $1$ 天的人已忘记，只剩第 $3、4$ 天的人传播

因此，第 6 天时新知道人数总和为：

$$
dp[3] + dp[4] + dp[5] + dp[6] = 1 + 1 + 2 + 2 = 6
$$

为了避免 $int$ **溢出**，请使用 $long$ 进行相加，最后才强转 $int$。

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        MOD = 10**9 + 7
        # dp[i] 表示第 i 天 “新增” 知道秘密的人数
        dp = [0] * (n + 1)
        dp[1] = 1
        
        for i in range(2, n + 1):
            # 遍历之前所有人，看他们能否在第 i 天分享
            for j in range(1, i):
                if i - j >= delay and i - j < forget:
                    dp[i] = (dp[i] + dp[j]) % MOD
        
        # 统计最后还记得秘密的人
        ans = 0
        for i in range(max(1, n - forget + 1), n + 1):
            ans = (ans + dp[i]) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int peopleAwareOfSecret(int n, int delay, int forget) {
        int MOD = 1_000_000_007;
        // dp[i] 表示第 i 天 “新增” 知道秘密的人数
        int[] dp = new int[n + 1];
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            // 遍历之前所有人，看他们能否在第 i 天分享
            for (int j = 1; j < i; j++) {
                if (i - j >= delay && i - j < forget) {
                    dp[i] = (dp[i] + dp[j]) % MOD;
                }
            }
        }

        // 统计最后还记得秘密的人
        long ans = 0;
        for (int i = Math.max(1, n - forget + 1); i <= n; i++) {
            ans = (ans + dp[i]) % MOD;
        }

        return (int) ans;
    }
}
```

- 时间复杂度： $O(n^2)$
- 空间复杂度： $O(n)$，表示数组 $dp$ 的大小

---

### 前缀和

本质上，转移过程是对 $dp[l,r]$ 的子数组进行求和！

对于 *子数组求和* 问题，上面的做法就是 **前缀和**，它是一种能将 $O(n)$ 的统计转化为 $O(1)$ 的快速方法。具体原理及做法，可以看看我的 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

具体来说，使用前缀和 $pre[k]$ 表示 $\sum_{t=1}^k dp[t]$。那么，上式能简化为

$$
dp[i] = pre[i-\text{delay}] - pre[i-\text{forget}]
$$

调整代码，已附加注释：

```Python
# python
class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        MOD = 10**9 + 7
        # dp[i]: 第 i 天新知道的人数
        dp = [0] * (n + 1)
        pre = [0] * (n + 1)  # 前缀和
        
        dp[1] = 1  # 初始化
        pre[1] = 1
        
        for i in range(2, n + 1):
            L = max(1, i - forget + 1)   # 区间左端
            R = i - delay                # 区间右端
            if R >= L:
                # 区间和 = pre[R] - pre[L-1]
                dp[i] = (pre[R] - pre[L - 1]) % MOD
            else:
                dp[i] = 0
            pre[i] = (pre[i - 1] + dp[i]) % MOD
        
        # 统计在第 n 天结束时还记得秘密的人
        start = max(1, n - forget + 1)
        ans = 0
        for i in range(start, n + 1):
            ans = (ans + dp[i]) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int peopleAwareOfSecret(int n, int delay, int forget) {
        int MOD = 1_000_000_007;
        // dp[i]: 第 i 天新知道的人数
        int[] dp = new int[n + 1];
        int[] pre = new int[n + 1];  // 前缀和

        dp[1] = 1;   // 初始化
        pre[1] = 1;

        for (int i = 2; i <= n; i++) {
            int L = Math.max(1, i - forget + 1); // 区间左端
            int R = i - delay;                   // 区间右端
            if (R >= L) {
                // 区间和 = pre[R] - pre[L-1]
                dp[i] = (int) (((long) pre[R] - pre[L - 1] + MOD) % MOD);
            } else {
                dp[i] = 0;
            }
            pre[i] = (int) (((long) pre[i - 1] + dp[i]) % MOD);
        }

        // 统计在第 n 天结束时还记得秘密的人
        int start = Math.max(1, n - forget + 1);
        long ans = 0;
        for (int i = start; i <= n; i++) {
            ans = (ans + dp[i]) % MOD;
        }

        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/solutions/3776574/shuang-jie-bao-li-dp-qian-zhui-he-you-hu-pnr1/)
