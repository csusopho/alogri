[Problem: 2221. 数组的三角和](https://leetcode.cn/problems/find-triangular-sum-of-an-array/description/)

### 方法：模拟 & 数学 & 预处理

`当前数 = 上两个数之和 % 10`，注意下标即可。

直接 **原地模拟**，得出下面的代码，空间超过 $100\%$：

```Python
# python
class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        # 模拟
        n = len(nums)
        for i in range(n):
            for j in range(n - i - 1):
                nums[j] = (nums[j] + nums[j + 1]) % 10 
        return nums[0]
```

```Java
// java
class Solution {
    public int triangularSum(int[] nums) {
        // 模拟
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                nums[j] = (nums[j] + nums[j + 1]) % 10;
            }
        }
        return nums[0];
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 数学

观察前几轮的计算，可以发现一个规律，假设初始数组是 $[n_0, n_1, n_2, n_3, ...]$

- 第一轮后： $[(n_0+n_1), (n_1+n_2), (n_2+n_3), ...]$
- 第二轮后： $[((n_0+n_1)+(n_1+n_2)), ((n_1+n_2)+(n_2+n_3)), ...]$，这可以展开为 $[(n_0 + 2n_1 + n_2), (n_1 + 2n_2 + n_3), ...]$
- 第三轮后： $[(n_0 + 3n_1 + 3n_2 + n_3), ...]$

**总结**：每一轮中每一项的系数是多少？杨辉三角中的二项式系数。

挑选第 $i$ 行的任意一项，第 $j$ 个元素的权重恰好是二项式系数 $C(i,j)$，即在 $i$ 个元素中选择 $j$ 个的组合数。

因此，三角和可以通过以下数学公式计算：

$$
ans = \sum_{i=0}^{n-1}\left(C(n-1, i)\times nums[i]\right) \% 10
$$

最终剩下的第 $n-1$ 行的那个唯一元素，就是 $nums$ 中所有元素的加权和。

举个例子，假设 `nums = [1, 2, 3, 4, 5]`。通过数学公式计算，可知 `C(4,0)*1 + C(4,1)*2 + C(4,2)*3 + C(4,3)*4 + C(4,4)*5 = 1*1 + 4*2 + 6*3 + 4*4 + 1*5 = 48`。最后取模得到 $8$，符合最终结果。

$Java$ 代码在计算时，会超出 $long$ 怎么办？那就是使用 $BigInteger$。

调库计算组合数，代码如下，已附加注释：

```Python
# python
class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        n = len(nums)

        # 三角和的最终结果是 Σ (C(n-1, i) * nums[i]) % 10
        # 其中 C(n-1, i) 是二项式系数
        m = n - 1
        total = 0
        for i in range(n):
            coefficient = math.comb(m, i)
            total += coefficient * nums[i]

        return total % 10
```

```Java
// java
import java.math.BigInteger;

class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        int m = n - 1;
        BigInteger total = BigInteger.ZERO;

        for (int i = 0; i < n; i++) {
            BigInteger coeff = binomial(BigInteger.valueOf(m), BigInteger.valueOf(i));
            BigInteger term = coeff.multiply(BigInteger.valueOf(nums[i]));
            total = total.add(term);
        }

        // 只取个位数
        return total.mod(BigInteger.TEN).intValue();
    }

    // 计算 C(n, k)
    private BigInteger binomial(BigInteger n, BigInteger k) {
        if (k.compareTo(n.subtract(k)) > 0) {
            k = n.subtract(k);
        }
        BigInteger result = BigInteger.ONE;
        for (BigInteger i = BigInteger.ZERO; i.compareTo(k) < 0; i = i.add(BigInteger.ONE)) {
            result = result.multiply(n.subtract(i))
                           .divide(i.add(BigInteger.ONE));
        }
        return result;
    }
}
```

- 时间复杂度： $O(n^2)$，可以大致看作是两个从 $0$ 到 $n/2$ 的线性增长序列
- 空间复杂度： $O(1)$

---

### 优化

根据数学知识，组合数的公式为：

$$
C(n, k) = \frac{n!}{k!(n-k)!}
$$

在任意一行的某一项中，第 $j$ 个元素的系数为 $C(i,j)$，第 $j+1$ 个元素的系数是 $C(i,j+1)$。因此，可以利用之前计算的结果，递推当前公式！

$$
C(n, k) = \frac{C(n, k-1)\times (n - k + 1)}{k}
$$

最后一行的元素，第一项系数为 $C(n-1,0)$，后续项无需再调库计算，快速利用已知结果递推！代码如下，已附加详细注释：

```Python
# python
class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        n = len(nums)
        m = n - 1
        
        # 第一个二项式系数 C(m, 0) = 1
        comb = 1
        # 第一项是 C(m, 0) * nums[0]
        total = nums[0] * comb
        
        for k in range(1, n):
            # 递推公式 C(m, k) = C(m, k-1) * (m - k + 1) / k
            # 这里的整数除法 // 是精确的，因为组合数必为整数
            comb = comb * (m - k + 1) // k
            total += nums[k] * comb
        
        return total % 10
```

```Java
// java
import java.math.BigInteger;

class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        int m = n - 1;

        // 第一个二项式系数 C(m, 0) = 1
        BigInteger comb = BigInteger.ONE;
        BigInteger total = BigInteger.valueOf(nums[0]).multiply(comb);

        for (int k = 1; k < n; k++) {
            // comb = comb * (m - k + 1) / k
            comb = comb.multiply(BigInteger.valueOf(m - k + 1))
                       .divide(BigInteger.valueOf(k));
            total = total.add(BigInteger.valueOf(nums[k]).multiply(comb));
        }

        // 只取个位数
        return total.mod(BigInteger.TEN).intValue();
    }
}
```

- 时间复杂度： $O(n)$，每一次的计算简化为 $O(1)$
- 空间复杂度： $O(1)$

---

### 预处理

组合数具有以下递推式：

$$
C(i, j) = C(i-1, j-1) + C(i-1, j)
$$

因此，我们可以提前计算出第 $n-1$ 行每一个 **系数值**，然后在主函数中再相乘累加。

无论输入是什么，这一段都是恒等的数学计算，不会改变，所以提到 **静态** 代码块中！力扣平台是多次调用 $count$ 方法跑所有样例，预处理中的内容只会计算一次。

代码如下，已附加详细注释：

```Python
# python
MAX_N = 1001
# C_mod_10[i][j] 将存储 C(i, j) % 10 的值
C_mod_10 = [[0] * MAX_N for _ in range(MAX_N)]

# 预处理
for i in range(MAX_N):
    # 帕斯卡三角的边界：C(i, 0) = 1
    C_mod_10[i][0] = 1
    for j in range(1, i + 1):
        # 使用递推公式 C(i, j) = C(i-1, j-1) + C(i-1, j)
        # 每一步都取模，防止数字过大
        C_mod_10[i][j] = (C_mod_10[i-1][j-1] + C_mod_10[i-1][j]) % 10

class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        n = len(nums)
        m = n - 1
        
        total = 0
        for k in range(n):
            # 直接取出
            coefficient = C_mod_10[m][k]
            total = (total + nums[k] * coefficient) % 10
            
        return total
```

```Java
// java
class Solution {
    // 最大 n
    static final int MAX_N = 1001;
    // C_mod_10[i][j] 将存储 C(i, j) % 10 的值
    static int[][] C_mod_10 = new int[MAX_N][MAX_N];

    // 静态代码块，类加载时完成预处理
    static {
        // 预处理
        for (int i = 0; i < MAX_N; i++) {
            // 帕斯卡三角的边界：C(i, 0) = 1
            C_mod_10[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                // 使用递推公式 C(i, j) = C(i-1, j-1) + C(i-1, j)
                // 每一步都取模，防止数字过大
                C_mod_10[i][j] = (C_mod_10[i - 1][j - 1] + C_mod_10[i - 1][j]) % 10;
            }
        }
    }

    public int triangularSum(int[] nums) {
        int n = nums.length;
        int m = n - 1;

        int total = 0;
        for (int k = 0; k < n; k++) {
            // 直接取出 C(m, k) % 10
            int coefficient = C_mod_10[m][k];
            total = (total + nums[k] * coefficient) % 10;
        }

        return total;
    }
}
```

- 时间复杂度： $O(n)$，均摊后的计算时间为 $O(1)$
- 空间复杂度： $O(1)$，空间同样被均摊

已知 `C(n, k) = n! / (k! * (n-k)!)`，在进行模运算时，会写成 `(n! * inv(k!) * inv((n-k)!)) % m`，其中 `inv(a)` 是 `a` 在模 `m` 下的乘法逆元。

什么是逆元？如何计算模的逆？可以看这篇 [题解](https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/solutions/3702131/san-jie-er-wei-dp-zu-he-shu-xue-fei-ma-x-l9ae/)。本题也可以使用逆元加速计算，同理预处理逻辑，感兴趣的小伙伴请评论区留言，我再附加代码。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-triangular-sum-of-an-array/solutions/3795896/si-jie-yuan-di-mo-ni-zu-he-shu-ji-suan-y-oto9/)
