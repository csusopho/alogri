[Problem: 3719. 最长平衡子数组 I](https://leetcode.cn/problems/longest-balanced-subarray-i/description/)

### 哈希

题意很清晰，就是找子数组，判断其中不同奇数与偶数的数量。

**暴力** 做法就是遍历所有子数组，也即所有的 $(i, j)$ 组合。

对于每一个 $(i, j)$，统计其中有多少个不重复的偶数和奇数。如果两者数量相等，则用当前子数组的长度 $j - i + 1$ 更新最大长度 $ans$。

如何统计不重复奇数/偶数？放入集合 $set$ 中自动去重。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        
        # 枚举起点
        for i in range(n):
            # 枚举终点
            for j in range(i, n):
                # 截取
                sub_array = nums[i : j+1]
                # 暴力统计
                even_set = set()
                odd_set = set()
                
                for num in sub_array:
                    if num % 2 == 0:
                        even_set.add(num)
                    else:
                        odd_set.add(num)
                
                # 判断是否平衡
                if len(even_set) == len(odd_set):
                    ans = max(ans, j - i + 1)
        
        return ans
```

这种做法的时间为 $O(n^3)$，会超时，经实测，卡在 $961/999$ 样例。

---

### 滑窗

上面的过程非常冗余。子数组 $[i,j+1]$ 就是 $[i,j]$ 向右扩展一次，统计完短的子数组 $[i,j]$ 后，没必要再重新统计 $[i,j+1]$。

**优化点**：固定起点 $i$ 后，随着 $j$ 的向右移动，**增量地** 更新集合 $set$。

> 本质是利用单调性，随着子数组长度的增大，集合里的元素只会越来越多。

同时加入 **剪枝**：如果剩下的元素加起来都不够打破当前的记录 $ans$，就直接停止外层循环。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        
        for i in range(n):
            # 剩余长度不如当前找到的最大长度
            if n - i <= ans:
                break
            
            even_set = set()
            odd_set = set()
            
            # 从 i 开始向右扩展 j
            for j in range(i, n):
                num = nums[j]
                
                # 增量更新集合
                if num % 2 == 0:
                    even_set.add(num)
                else:
                    odd_set.add(num)
                
                # 检查是否平衡
                if len(even_set) == len(odd_set):
                    curr_len = j - i + 1
                    if curr_len > ans:
                        ans = curr_len
        
        return ans
```

```Java
// java
class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        int ans = 0;
        
        for (int i = 0; i < n; i++) {
            // 剩余长度不如当前找到的最大长度
            if (n - i <= ans) {
                break;
            }
            
            Set<Integer> evenSet = new HashSet<>();
            Set<Integer> oddSet = new HashSet<>();
            
            // 从 i 开始向右扩展 j
            for (int j = i; j < n; j++) {
                int num = nums[j];
                
                // 增量更新集合
                if (num % 2 == 0) {
                    evenSet.add(num);
                } else {
                    oddSet.add(num);
                }
                
                // 检查是否平衡
                if (evenSet.size() == oddSet.size()) {
                    int currLen = j - i + 1;
                    if (currLen > ans) {
                        ans = currLen;
                    }
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示两个哈希 $set$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-balanced-subarray-i/solutions/3900040/mei-ju-ha-xi-bao-li-chao-shi-hua-chuang-l5rgj/)
