[Problem: 1277. 统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/)

### 方法：暴力 & 前缀和 & DP

注意，子矩阵必须是正方形。

**暴力** 想法：枚举所有起点，枚举所有可能边长，判断子正方形是否全为 $1$。

比如，正方形左上角是 $(i,j)$，边长为 $k$，则右下角是 $(i+k,j+k)$，判断这 $k\times k$ 的所有方格是否全为 $1$。代码如下：

```Python
# python
class Solution:
    def countSquares(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0
        
        # 枚举左上角 (i, j)
        for i in range(m):
            for j in range(n):
                # 枚举边长
                max_len = min(m - i, n - j)  # 最大可能边长
                for size in range(1, max_len + 1):
                    flag = True
                    # 检查 size * size 区域是否全为 1
                    for x in range(i, i + size):
                        for y in range(j, j + size):
                            if mat[x][y] == 0:
                                flag = False
                                break
                        if not flag:
                            break
                    if flag:
                        ans += 1
        return ans
```

```Java
// java
class Solution {
    public int countSquares(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int ans = 0;

        // 枚举左上角 (i, j)
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 枚举边长
                int maxLen = Math.min(m - i, n - j);  // 最大可能边长
                for (int size = 1; size <= maxLen; size++) {
                    boolean flag = true;
                    // 检查 size * size 区域是否全为 1
                    for (int x = i; x < i + size; x++) {
                        for (int y = j; y < j + size; y++) {
                            if (mat[x][y] == 0) {
                                flag = false;
                                break;
                            }
                        }
                        if (!flag) break;
                    }
                    if (flag) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
}
```

$Python$ 语言耗时 $8718ms$，超过 $5\%$，勉强能过。

起点任意选，而终点不能任意，会受到边长的限制。先枚举边长，再遍历这 $k\times k$ 方格内的所有数，时间复杂度为

$$
\sum_{k=1}^{\min(m,n)} k^2
$$

将 $min(m,n)$ 简记为 $L$，根据数学知识可知

$$
\sum_{k=1}^{L} k^2 = \frac{L(L+1)(2L+1)}{6} \approx O(L^3)
$$

- 时间复杂度： $O(m\times n\times L^3)$，其中 $m,n$ 为矩阵 $mat$ 的行数和列数，且 $L=min(m,n)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 前缀和

每次对 $k\times k$ 的区域重复扫描，非常浪费时间。如果该区域全是 $1$，那么累加和一定是 $k\times k$！求子区域的总和，联想到 **前缀和**。

二维前缀和的具体原理、推导，可以看这篇 [图解](https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/2993541/tu-jie-er-wei-qian-zhui-he-tui-dao-ji-su-61oc/)。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countSquares(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0

        # 构建二维前缀和数组
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        for r in range(m):
            for c in range(n):
                prefix[r + 1][c + 1] = (
                    prefix[r + 1][c] 
                    + prefix[r][c + 1] 
                    - prefix[r][c] 
                    + mat[r][c]
                )

        # 枚举正方形边长 k
        for k in range(1, min(m, n) + 1):
            # 枚举正方形右下角坐标 (r, c)
            for r in range(k - 1, m):
                for c in range(k - 1, n):
                    r1, c1 = r - k + 1, c - k + 1  # 左上角
                    r2, c2 = r, c                  # 右下角
                    total = (
                        prefix[r2 + 1][c2 + 1]
                        - prefix[r1][c2 + 1]
                        - prefix[r2 + 1][c1]
                        + prefix[r1][c1]
                    )
                    # 如果子矩阵和 == k*k，则全为 1
                    if total == k * k:
                        ans += 1

        return ans
```

```Java
// java
class Solution {
    public int countSquares(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int ans = 0;

        // 构建二维前缀和数组 prefix
        int[][] prefix = new int[m + 1][n + 1];
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                prefix[r + 1][c + 1] = prefix[r + 1][c] 
                                     + prefix[r][c + 1] 
                                     - prefix[r][c] 
                                     + mat[r][c];
            }
        }

        // 枚举正方形边长 k
        for (int k = 1; k <= Math.min(m, n); k++) {
            // 枚举正方形右下角坐标 (r, c)
            for (int r = k - 1; r < m; r++) {
                for (int c = k - 1; c < n; c++) {
                    int r1 = r - k + 1, c1 = c - k + 1;  // 左上角
                    int r2 = r, c2 = c;                  // 右下角
                    int total = prefix[r2 + 1][c2 + 1]
                              - prefix[r1][c2 + 1]
                              - prefix[r2 + 1][c1]
                              + prefix[r1][c1];
                    // 如果子矩阵和 == k*k，则全为 1
                    if (total == k * k) {
                        ans++;
                    }
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(m\times n\times L)$
- 空间复杂度： $O(m\times n)$，表示数组 $prefix$ 的大小

---

### $DP$

观察前缀和代码的构建部分，会发现一个 **规律**：一个边长为 $k$ 的正方形，它一定是由更小的正方形扩展出来的。

比如，右下角在 $(i,j)$ 的边长为 $k$ 的正方形，必然包含了：

- $(i-1, j)$ 左边的正方形；
- $(i, j-1)$ 上边的正方形；
- $(i-1, j-1)$ 左上角的正方形。

一旦这三个正方形不是全为 $1$，当前这个包含它们的正方形一定会包含 $0$！所以，总大小和「这三个方向能扩展的最小边长」有关。

我们不用每次重新检查整个子矩阵，而是 **用之前的结果递推新的结果** —— $DP$。

**定义** $dp[i][j]$ 表示 以 $(i,j)$ 为 **右下角** 的最大全 $1$ 正方形的边长。

**状态转移**：当前正方形的大小，取决于左上方这三个正方形，有

$$
dp[i][j] =\min \big( dp[i-1][j],\ dp[i][j-1],\ dp[i-1][j-1] \big) + 1
$$

当然，前提是当前 $(i,j)$ 方格的值是 $1$，不然肯定构不成正方形。

假设当前以 $(i,j)$ 为右下角的正方形最大边长是 $3$，则说明一共有边长为 $1,2,3$ 的三个正方形是全 $1$ 的！因此，最终答案是 $dp$ 数组的 **总和**。

**递推方向**：当前 $(i,j)$ 需要 $(i-1,j-1)$ 等状态，所以是从上往下，从左往右递推。

**边界情况**：第一行 $dp[0][j]$ 以及第一列 $dp[i][0]$ 应该设置为 $1$，表示 $1\times 1$ 小正方形。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countSquares(self, mat: List[List[int]]) -> int:
        # dp[i][j]表示以(i,j)位置为右下角边界点所构成的正方形的最大边长
        m, n = len(mat), len(mat[0])
        dp = [[0] * n for _ in range(m)]
        ans = 0

        for r in range(m):
            for c in range(n):
                if mat[r][c] == 1:
                    if r == 0 or c == 0:
                        # 第一行/第一列：只能由自己构成 1×1 的正方形
                        dp[r][c] = 1
                    else:
                        # 状态转移：取左、上、左上三个方向的最小值 + 1
                        dp[r][c] = min(
                            dp[r - 1][c], 
                            dp[r][c - 1], 
                            dp[r - 1][c - 1]
                        ) + 1
                    # 累加当前点贡献的正方形数量
                    ans += dp[r][c]

        return ans
```

```Java
// java
class Solution {
    public int countSquares(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        // dp[i][j]表示以(i,j)位置为右下角边界点所构成的正方形的最大边长
        int[][] dp = new int[m][n];
        int ans = 0;

        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (mat[r][c] == 1) {
                    if (r == 0 || c == 0) {
                        // 第一行/第一列：只能由自己构成 1×1 的正方形
                        dp[r][c] = 1;
                    } else {
                        // 状态转移：取左、上、左上三个方向的最小值 + 1
                        dp[r][c] = Math.min(
                            Math.min(dp[r - 1][c], dp[r][c - 1]),
                            dp[r - 1][c - 1]
                        ) + 1;
                    }
                    // 累加当前点贡献的正方形数量
                    ans += dp[r][c];
                }
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(m\times n)$，表示数组 $dp$ 的大小

---

### 原地修改

我们是按照 $i,j$ 递增的顺序填写 $DP$ 表。一旦使用过 $mat[i][j]$ 后，再也不会第二次使用。因此，我们可以将 $mat$ 当作 $dp$，原地进行修改！

代码如下：

```Python
# python
class Solution:
    def countSquares(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0
        for i in range(m):
            for j in range(n):
                if i and j and mat[i][j]:
                    mat[i][j] += min(mat[i-1][j], mat[i][j-1], mat[i-1][j-1])
                ans += mat[i][j]
        return ans
```

```Java
// java
class Solution {
    public int countSquares(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int ans = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 如果不是第一行或第一列，且当前位置为 1
                if (i > 0 && j > 0 && mat[i][j] == 1) {
                    // 状态转移：取左、上、左上三个方向的最小值 + 当前值
                    mat[i][j] += Math.min(
                        Math.min(mat[i - 1][j], mat[i][j - 1]),
                        mat[i - 1][j - 1]
                    );
                }
                // 累加当前点贡献的正方形数量
                ans += mat[i][j];
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solutions/3758286/si-jie-bao-li-er-wei-qian-zhui-he-dp-yua-6n8q/)
