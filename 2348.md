[Problem: 2348. 全 0 子数组的数目](https://leetcode.cn/problems/number-of-zero-filled-subarrays/description/)

### 方法：双指针 & 数学

长度为 $3$ 的数组 $[0,0,0]$ 有多少个子数组？

- 子数组 $[0]$ 出现了三次；
- 子数组 $[0,0]$ 出现了两次；
- 子数组 $[0,0,0]$ 出现了一次。

因此，答案是 $1+2+3=6$。**推广** 可知，长度为 $n$ 的数组拥有 $1+2+\dots n$ 数量的子数组，根据等差数列的公式可得，该结果是 $\frac{n\times(n+1)}{2}$。

在本题中，子数组必须全是 $0$。也即，我们需要寻找 **连续** 为 $0$ 的子数组长度，然后套用上面的公式，计算出当前子数组数量。

使用 **双指针**，让两个指针内的值全是 $0$，代码如下：

```Python
# python
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        left = 0
        
        while left < n:
            if nums[left] != 0:  # 跳过非零
                left += 1
                continue
            
            # 找到一段连续的零
            right = left
            while right < n and nums[right] == 0:
                right += 1
            
            # 区间 [left, right-1] 全是零，长度为 L
            L = right - left
            # 这段零的子数组数量是 L*(L+1)//2
            ans += L * (L + 1) // 2
            
            # 下一段从 right 开始
            left = right
        
        return ans
```

```Java
// java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        int n = nums.length;
        long ans = 0;
        int left = 0;

        while (left < n) {
            if (nums[left] != 0) {  // 跳过非零
                left++;
                continue;
            }

            // 找到一段连续的零
            int right = left;
            while (right < n && nums[right] == 0) {
                right++;
            }

            // 区间 [left, right-1] 全是零，长度为 L
            int L = right - left;
            // 这段零的子数组数量是 L*(L+1)//2
            ans += (long)L * (L + 1) / 2;

            // 下一段从 right 开始
            left = right;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，双指针最多各移动一遍
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

将 $1$ 视作障碍物，它将数组 $nums$ 分割分为不同块，本质上我们就在统计每一块中连续 $0$ 的个数。因此，只需要一个变量 $cnt$ 进行计数，保留单指针 $right$ 即可，左指针 $left$ 可忽略（因为 $cnt=right-left+1$）。

不用数学公式最后累加，而是分步累加，代码如下：

```Python
# python
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        ans = 0  # 总和
        cnt = 0   # 每一个块连续的0的个数

        for x in nums:
            if x == 0:  # 累加
                cnt += 1
                ans += cnt
            else:  # 重置
                cnt = 0
        
        return ans
```

```Java
// java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans = 0;  // 总和
        long cnt = 0;  // 每一个块连续的0的个数

        for (int x : nums) {
            if (x == 0) {  // 累加
                cnt += 1;
                ans += cnt;
            } else {  // 重置
                cnt = 0;
            }
        }

        return ans;
    }
}
```

如果将 “每一步” 的累加换成 “最后一步” 的数学公式，速度更快。代码如下：

```Python
# python
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        cnt = 0   # 当前连续零的长度

        for i in range(n):
            if nums[i] == 0:
                cnt += 1
            else:
                if cnt > 0:
                    ans += cnt * (cnt + 1) // 2
                    cnt = 0  # 重置

        # 注意最后可能以 0 结尾，需要再加一次
        if cnt > 0:
            ans += cnt * (cnt + 1) // 2

        return ans
```

```Java
// java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        int n = nums.length;
        long ans = 0;
        long cnt = 0;   // 当前连续零的长度

        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                cnt += 1;
            } else {
                if (cnt > 0) {
                    // 一段长度为 cnt 的连续零，贡献 cnt*(cnt+1)/2
                    ans += cnt * (cnt + 1) / 2;
                    cnt = 0;  // 重置
                }
            }
        }

        // 注意最后可能以 0 结尾，需要再加一次
        if (cnt > 0) {
            ans += cnt * (cnt + 1) / 2;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，一次遍历
- 空间复杂度： $O(1)$

可以将数字变为字符串后根据 $1$ 进行切割，分块计数；或者将代码压缩为一行。其他解法这里不再阐述，感兴趣的小伙伴请自行尝试。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-zero-filled-subarrays/solutions/3757077/san-jie-shuang-zhi-zhen-dan-zhi-zhen-yi-v717w/)
