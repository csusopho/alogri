[Problem: 1356. 根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/description/)

### 方法：模拟 & 调库

题目有两个维度的排序标准：

- **第一优先级**：二进制表示中 $1$ 的数目，升序排列。
- **第二优先级**：如果 $1$ 的数目相同，则按照数字本身的数值大小，升序排列。

如何统计一个二进制数中 $1$ 的个数？

正常我们可能会用除法 $n \% 2$ 结合 $n // 2$ 逐位判断，但这很慢。实际上，有一个 **位运算** 技巧：对于任何一个非零整数 $n$，执行 `n = n & (n - 1)`，它直接把 $n$ 二进制表示中 **最右侧** 的 $1$ 变成 $0$。

比如 $n = 12$，二进制是 $1100$：

- 第 $1$ 次：`12 & 11`，也即 `1100 & 1011 = 1000`，结果变成 $8$。
- 第 $2$ 次：`8 & 7`，也即 `1000 & 0111 = 0000`，结果变成 $0$。
- 循环 $2$ 次就变成了 $0$，说明有 $2$ 个 $1$。

数字里有几个 $1$ 就只循环几次，完美跳过所有的 $0$，既快又简单。

既然 **第一优先级** 是 “1 的个数”，而对于常规的 $32$ 位整数，其中 $1$ 的个数最多只有 $32$ 个。我们可以直接准备 $33$ 个 “桶”。遍历数组，算出每个数的 $1$ 的个数，然后丢进对应的桶里（桶排序思路）。

已经按桶（1的个数）分好类了，现在第一优先级天然满足。按照题目 **第二优先级** 要求，只要把每个有数字的桶内部，按数值大小进行普通的升序排列。

最后，把所有桶 *按顺序* 拼接起来，就是答案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        # 计算 1 的个数
        def get_bit_count(n):
            count = 0
            while n > 0:
                n &= (n - 1)  # 消除最低位的 1
                count += 1
            return count

        # 准备桶
        buckets = [[] for _ in range(33)]
        # 模拟分组
        for num in arr:
            bit_count = get_bit_count(num)
            buckets[bit_count].append(num)
            
        # 处理第二优先级
        ans = []
        for bucket in buckets:
            # 当前桶为空
            if not bucket:
                continue
            
            # 按数值本身排序
            bucket.sort() 
            # 按顺序加入结果
            ans.extend(bucket)
        
        return ans
```

```Java
// java
class Solution {
    public int[] sortByBits(int[] arr) {
        // 准备桶
        List<Integer>[] buckets = new ArrayList[33];
        for (int i = 0; i < 33; i++) {
            buckets[i] = new ArrayList<>();
        }

        // 模拟分组
        for (int num : arr) {
            int bitCount = getBitCount(num);
            buckets[bitCount].add(num);
        }
        
        // 处理第二优先级
        int[] ans = new int[arr.length];
        int index = 0;
        for (List<Integer> bucket : buckets) {
            // 当前桶为空
            if (bucket.isEmpty()) {
                continue;
            }
            
            // 按数值本身排序
            Collections.sort(bucket);
            // 按顺序加入结果
            for (int num : bucket) {
                ans[index++] = num;
            }
        }
        
        return ans;
    }

    // 计算 1 的个数
    private int getBitCount(int n) {
        int count = 0;
        while (n > 0) {
            n &= (n - 1);  // 消除最低位的 1
            count++;
        }
        return count;
    }
}
```

- 时间复杂度： $O(n\times k)$，其中 $n$ 是数组 $arr$ 的长度，而 $k$ 是每个数字中 $1$ 的个数
- 空间复杂度： $O(n)$，使用列表 $buckets$ 存储所有数字

---

### 调库

如何计算二进制中 $1$ 的数目？不加思考，直接调库！

如何实现多条件排序？在 $Python$ 中，如果给 $sorted()$ 函数的 $key$ 参数传递一个返回 **元组** 的函数，则会自动先按照元组的第一个元素进行排序；如果第一个元素相同，则会自动按照第二个元素排序，以此类推。

因此，为数组中的每一个元素 $x$ 构造这样一个元组：`(x二进制中1的个数, x本身)`。

最终，直接调用 `sorted(arr, key=lambda x: (x.bit_count(), x))` 即可。

这种方法反而速度最快， $Python$ 耗时 $0ms$，代码如下：

```Python
# python
class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        # 对于数组中的每个元素 x，生成一个元组 (x二进制中1的个数, x本身)
        # 元组的顺序：第一优先级、第二优先级
        return sorted(arr, key=lambda x: (x.bit_count(), x))
```

```Java
// java
class Solution {
    public int[] sortByBits(int[] arr) {
        // 对于数组中的每个元素 x，生成一个元组 (x二进制中1的个数, x本身)
        // 元组的顺序：第一优先级、第二优先级
        return Arrays.stream(arr)
                .boxed()
                .sorted(Comparator.comparingInt(Integer::bitCount).thenComparingInt(x -> x))
                .mapToInt(Integer::intValue)
                .toArray();
    }
}
```

- 时间复杂度： $O(n\times logn)$，快排，计算二进制 $1$ 的时间可以看作 $O(1)$
- 空间复杂度： $O(n)$，额外创建新列表

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/solutions/3907870/shuang-jie-mo-ni-tong-pai-xu-diao-ku-0ms-ncpr/)
