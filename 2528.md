[Problem: 2528. 最大化城市的最小电量](https://leetcode.cn/problems/maximize-the-minimum-powered-city/description/)

### 方法：二分+差分+贪心

最优策略？最大化最小？~~这是人话？~~ 为了方便表述，将 $stations$ 记作 $st$。解读一下：

初始的供电站分布是 $st$，我们可以选择额外增加供电站。每个供电站的影响范围（半径）是 $r$，可增加的数量是 $k$。每座城市收到左右 $r$ 范围的供电。

比如在示例 $1$ 中 $st=[1,2,4,5,0]$。城市 $1$ 初始有 $st[1]=2$ 座供电站，它收到左右 $r=1$ 范围的供电，也即城市 $0,1,2$，累加总电量是 $1+2+4=7$。如果不增加供电，此时城市 $0$ 收到的供电最少，仅有 $1+2=3$ 的总电量。

因此，我们需要采取 **最优** 策略，让最少电量的城市所拥有的电量变多。

---

我们发现，解题的 **关键** 就在于：如何选取策略？换个思路来看，假设目标是让城市的「最少」电量达到 $x$，是否可以增加「不超过」 $k$ 个供电站来实现？

**贪心策略**：从左到右 $[0,n-1]$ 遍历每个城市。对于当前城市 $i$，检查它的电量：

- 如果电量小于 $x$，我们必须增加新的供电站来满足它。
- 为了最有效地利用新增的供电站（即让它们能覆盖到尽可能多的后续城市），我们应该把它们建在能覆盖到城市 $i$ 的最右边的位置。这个位置是 $i + r$。
- 此时，增加 $needed = x - power$ 个供电站，并全部建在城市 $i + r$。

将新电站建在能覆盖当前城市 $i$ 的最右侧位置 $i+r$，是为了在满足当前需求的同时，**最大化** 对未来（右侧）城市的潜在贡献，从而最有效地利用每一个新增的发电站。

为什么正确？

通俗地来说，新增的电站必须能给城市 $i$ 供电。这意味着，必须把电站建在 $[i-r, i+r]$ 这个区间内的某个城市 $p$，最大值是 $i+r$。任何其他建在 $p < i+r$ 的选择，都会让这个电站的覆盖范围更早地在右侧结束，从而减少了对未来的帮助。

我们也可以从 **反证法** 的角度来理解。

假设存在一种最优的建站方案 $OPT$，它也使用了 $opt <= k$ 个电站，使得所有城市的电量都达到了目标值 $x$。用 $GREEDY$ 表示我们的贪心算法生成的建站方案。我们从左到右比较 $GREEDY$ 和 $OPT$ 的决策。

假设我们检查到某一个电量不足的城市是 $i$。

- $GREEDY$ 的决策是：在城市 $i+r$ 建立 $needed$ 个电站。
- $OPT$ 的决策可能是：为了满足城市 $i$，它在某个位置 $p < i+r$ 建立了一些电站，这是一个分歧点。

现在，我们来调整一下 $OPT$ 的方案，把它变得更像 $GREEDY$。我们将 $OPT$ 方案中那个建在 $p$ 的电站，“移动” 到 $i+r$ 的位置。我们称这个新方案为 $OPT'$。

- 对于所有 $j\leq i$ 的城市：它们的电量不受影响，因为我们的分歧点是 $i$，在这之前的决策都是一样的。
- 对于 $j > i$ 的城市：原先建在 $p$ 的电站，其覆盖范围是 $[p-r, p+r]$。现在建在 $i+r$ 的电站，其覆盖范围是 $[i, i+2r]$。因为 $p<i+r$，所以 $p+r<i+2r$。这意味着，**新方案 $OPT'$ 对所有未来城市的供电情况，只会变得更好，或者保持不变。**

也即，我们通过这个“交换”，将 $OPT$ 方案修改为了 $OPT'$。后者使用了同样数量的电站，同样满足了所有城市的需求，所以 $OPT'$ 也是一个最优解。并且 $OPT'$ 在处理城市 $i$ 的策略上与 $GREEDY$ 相同。

我们可以不断重复这个过程，一步一步地将任何一个最优解 $OPT$ 转换成我们的贪心解 $GREEDY$，而方案始终保持最优。这就证明了，我们的贪心解 $GREEDY$ 本身就是一个最优解。

---

那么，如何寻找这个 $x$ 是多少呢？**二分查找**。

- 假设范围是 $[left, right]$，其中 $left$ 的一个可能下界是 $0$， $right$ 的一个安全上界是所有现有供电站总数再加上 $k$。
- 我们取中间值 $mid$，然后调用 $check(mid)$。
- 如果返回 $True$，意味着可以使所有城市电量至少为 $mid$，说明 $mid$ 是一个可能的结果，我们尝试寻找更大的值，因此移动 $left = mid + 1$。
- 如果返回 $False$，意味着无法达到 $mid$，说明 $mid$ 太大了，我们需要降低目标，因此移动 $right = mid - 1$。
- 二分查找结束后，最大的可行 $mid$ 值就是答案 $x$。

如何实现 $check(x)$ 函数？

首先，我们需要计算在不增加任何新供电站的情况下，每个城市的初始电量。这可以通过一次 **滑动窗口** 在 $O(n)$ 时间内完成。对于城市 $i$，其电量是 $st$ 数组在 $[i-r, i+r]$ 范围内的和。

然后，调用上面的贪心策略，计算出 $needed$ 个需要新增的供电站。

如果每次增加供电站后，都去更新所有受影响城市的电量，那么 $check$ 函数的复杂度会是 $O(n\times r)$，速度太慢。可以使用一个 **差分** 数组来优化。

- 维护一个变量 $boost$，表示由新增供电站给当前城市 $i$ 带来的额外电量。
- 在检查城市 $j$ 时，决定在 $j+r$ 处增加 $d$ 个电站，那么从城市 $j$ 到 $j+2r$ 的电量都会增加 $d$。此时，立刻让 $boost$ 立刻增加 $d$，并且在 $j+2r+1$ 的位置，这个增益效果需要被撤销，即 `diff[j+2r+1] -= d`。
- 这样，当我们遍历到城市 $i$ 时，只需让 `boost += diff[i]`，就可以得到当前正确的增益值。整个 $check$ 函数的时间复杂度就降到了 $O(n)$。

**总结**：主体函数进行二分，辅助函数内先计算初始电量，然后贪心增加供电站，并使用差分记录下这种增益，以便正确计算最终电量。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)

        # 是否能让所有城市的电量都至少为 target
        def check(target):
            # 1. 计算每个城市的初始电量
            power = [0] * n
            window_sum = sum(stations[0 : min(n, r + 1)])
            power[0] = window_sum
            # 滑窗移动
            for i in range(1, n):
                # 加上新进入范围的供电站
                if i + r < n:
                    window_sum += stations[i + r]
                # 减去离开范围的供电站
                if i - r - 1 >= 0:
                    window_sum -= stations[i - r - 1]
                power[i] = window_sum

            # 2. 贪心策略检查和增加供电站
            k_used = 0
            # 记录在城市 i 电量增益的变化量
            diff = [0] * (n + 1)
            # 当前城市从新增供电站获得的电量增益
            boost = 0

            for i in range(n):
                # 更新当前城市的增益
                boost += diff[i]
                
                # 如果当前城市电量不足
                if power[i] + boost < target:
                    # 计算需要增加的供电站数量
                    needed = target - (power[i] + boost)
                    
                    k_used += needed
                    if k_used > k:  # 供电站不够用
                        return False
                    
                    # 立即增加当前城市的增益
                    boost += needed
                    
                    # 在 i+r 处增加电站，影响范围是 [i, i+2r]
                    end_idx = i + 2 * r + 1
                    if end_idx < n:
                        diff[end_idx] -= needed
                    
            return True

        # 二分查找
        left = 0
        right = sum(stations) + k
        ans = 0

        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                # 可能是答案，或者还有更大的可能
                ans = mid
                left = mid + 1
            else:
                # 不可行，需要降低
                right = mid - 1
                
        return ans
```

```Java
// java
class Solution {
    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;

        // 二分查找
        long left = 0;
        long right = 0;
        for (int station : stations) {
            right += station;
        }
        right += k;
        
        long ans = 0;

        while (left <= right) {
            long mid = left + (right - left) / 2;
            if (check(mid, stations, r, k, n)) {
                // 可能是答案，或者还有更大的可能
                ans = mid;
                left = mid + 1;
            } else {
                // 不可行，需要降低
                right = mid - 1;
            }
        }
        return ans;
    }

    // 是否能让所有城市的电量都至少为 target
    private boolean check(long target, int[] stations, int r, int k, int n) {
        // 1. 计算每个城市的初始电量
        long[] power = new long[n];
        long window_sum = 0;
        for (int i = 0; i < Math.min(n, r + 1); i++) {
            window_sum += stations[i];
        }
        power[0] = window_sum;
        
        // 滑窗移动
        for (int i = 1; i < n; i++) {
            window_sum = power[i - 1];
            // 加上新进入范围的供电站
            if (i + r < n) {
                window_sum += stations[i + r];
            }
            // 减去离开范围的供电站
            if (i - r - 1 >= 0) {
                window_sum -= stations[i - r - 1];
            }
            power[i] = window_sum;
        }

        // 2. 贪心策略检查和增加供电站
        long k_used = 0;
        // 记录在城市 i 电量增益的变化量
        long[] diff = new long[n + 1];
        // 当前城市从新增供电站获得的电量增益
        long boost = 0;

        for (int i = 0; i < n; i++) {
            // 更新当前城市的增益
            boost += diff[i];
            
            // 如果当前城市电量不足
            if (power[i] + boost < target) {
                // 计算需要增加的供电站数量
                long needed = target - (power[i] + boost);
                
                k_used += needed;
                if (k_used > k) { // 供电站不够用
                    return false;
                }
                
                // 立即增加当前城市的增益
                boost += needed;
                
                // 在 i+r 处增加电站，影响范围是 [i, i+2r]
                int end_idx = i + 2 * r + 1;
                if (end_idx < n) {
                    diff[end_idx] -= needed;
                }
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(n\times logM)$，其中 $n$ 是数组 $stations$ 的长度，而 $M$ 是数组元素的总和再加上 $k$，前者是检查时间，后者是二分总次数
- 空间复杂度： $O(n)$，表示数组 $power,diff$ 的大小

---

### 预处理

每座城市的初始电量，都是 **固定不变** 的，所以完全没必要在 $check$ 函数内每次都重复计算！

因此，我们提前在主循环中，计算出每个城市的初始电量。可以使用 **前缀和**，或者使用 **差分**，两者效果是等价的。题解链接为 [前者](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/) 和 [后者](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solutions/2899892/chai-fen-mei-ju-chai-fen-yuan-li-ying-yo-pbel/)，这里使用后一种方法。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)

        # 差分，计算每个城市的初始电量
        diff = [0] * (n + 1)
        for i in range(n):
            if stations[i] == 0:
                continue
            # i 位置的电站，会给 [i-r, i+r] 范围内的城市供电
            left_bound = max(0, i - r)
            right_bound = min(n, i + r + 1)
            diff[left_bound] += stations[i]
            diff[right_bound] -= stations[i]

        # 是否能让所有城市的电量都至少为 target
        def check(target):
            # 复制一个新数组
            cur_diff = diff.copy()
            remain = k  # 剩余可建造的电站数量
            power = 0   # 当前城市总电量

            # 从左到右遍历每个城市
            for i in range(n):
                # 通过累加差分值，计算出当前城市的电量
                power += cur_diff[i]

                # 如果当前城市电量不足
                if power < target:
                    # 计算需要增加的电站数量
                    needed = target - power
                    
                    if remain < needed:  # 供电站不够用
                        return False
                    
                    # 增加电站
                    power += needed
                    remain -= needed
                    
                    # 在 i+r 处增加电站，影响范围是 [i, i+2r]
                    end_idx = min(n, i + 2 * r + 1)
                    cur_diff[end_idx] -= needed
            
            return True

        # 二分查找
        left, right = 0, sum(stations) + k
        ans = 0
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                # 可能是答案，或者还有更大的可能
                ans = mid
                left = mid + 1
            else:
                # 不可行，需要降低
                right = mid - 1
        return ans
```

```Java
// java
class Solution {
    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;

        // 差分，计算每个城市的初始电量
        long[] diff = new long[n + 1];
        for (int i = 0; i < n; i++) {
            if (stations[i] == 0) {
                continue;
            }
            // i 位置的电站，会给 [i-r, i+r] 范围内的城市供电
            int left_bound = Math.max(0, i - r);
            int right_bound = Math.min(n, i + r + 1);
            diff[left_bound] += stations[i];
            diff[right_bound] -= stations[i];
        }
        
        // 二分查找
        long left = 0;
        long right = 0;
        for (int station : stations) {
            right += station;
        }
        right += k;

        long ans = 0;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            if (check(mid, diff, n, r, k)) {
                // 可能是答案，或者还有更大的可能
                ans = mid;
                left = mid + 1;
            } else {
                // 不可行，需要降低
                right = mid - 1;
            }
        }
        return ans;
    }

    // 是否能让所有城市的电量都至少为 target
    private boolean check(long target, long[] diff, int n, int r, int k) {
        // 复制一个新数组
        long[] cur_diff = Arrays.copyOf(diff, diff.length);
        long remain = k;  // 剩余可建造的电站数量
        long power = 0;   // 当前城市总电量

        // 从左到右遍历每个城市
        for (int i = 0; i < n; i++) {
            // 通过累加差分值，计算出当前城市的电量
            power += cur_diff[i];

            // 如果当前城市电量不足
            if (power < target) {
                // 计算需要增加的电站数量
                long needed = target - power;
                
                if (remain < needed) { // 供电站不够用
                    return false;
                }
                
                // 增加电站
                power += needed;
                remain -= needed;
                
                // 在 i+r 处增加电站，影响范围是 [i, i+2r]
                int end_idx = Math.min(n, i + 2 * r + 1);
                if (end_idx < n) { // 只有在影响范围不出界时才需要标记减少
                   cur_diff[end_idx] -= needed;
                }
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(n\times logM)$，同理
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximize-the-minimum-powered-city/solutions/3825842/shuang-jie-er-fen-tan-xin-chai-fen-yu-ch-64gk/)
