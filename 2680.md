[Problem: 2680. 最大或值](https://leetcode.cn/problems/maximum-or/description/)

### 方法：贪心

题意：你可以修改元素，一次 “乘 $2$” 就代表一次操作。求最多 $k$ 次操作后，所有元素的 “或” 结果的最大值是多少。

我们注意到，这题并 **不限定** 一个元素 **只能一次** 操作。也就是说，你可以选择将 $k$ 次操作均摊到不同元素，或者只供一个元素使用。

如果题目指定每个元素只能一次乘 $2$，那就可以使用 **动态规划**，也即每个元素只有「选」或「不选」进行操作的两种可能。

如果不限定的话，还想要使用动规，那么在状态转移时必须增加一个 $for$ 枚举每个数到底操作几次，比较麻烦。

实际上，本题的正确解法是 **贪心**，也就是将 $k$ 次操作集中在一个元素上。

**问题一**：为什么贪心的思路正确？

因为本题是 或 $OR$ 运算，乘 $2$ 代表左移一位。或运算出来的结果的 **最高位** 取决于数组里面数据的最高位，最高位越高，结果自然就越大。

理想情况下，把位数最长的数乘以 $k$ 次 $2$ 能让总结果增加 $2^k$，但是用在更短的数上一定不会大于这个收益，因为最后或出来的结果最高位的 $1$ 没有改变。

上面的这段话是陈述句，如果改变一下句式，那就是 **反证法** 的本质，这里不再赘述。

**问题二**：为什么不是对数组中的最大值左移 $k$ 次？

因为本题是 $n$ 个数进行或运算，一个数的最优，并不能推导出 **全局** 的最优。举个例子，数组 $nums=[5,4,2],k=1$。从二进制的角度看，

- 最大数为 $101$，左移 $1$ 次后为 $1010$，其他数的或结果为 $110$，此时答案为 $1110$；
- 假如对 $4_{(2)}=100$ 进行左移，得到 $1000$，其他数的或结果为 $111$，此时答案为 $1111$。

所以，正确的贪心应该是将 $k$ 次左移运用在位数最长的数。如果有好几个长度一样的数，那就都需要尝试，看看哪个收益最大。

为了 **统一操作**，直接遍历 $n$ 个数，对每个数都尝试左移 $k$ 次，然后与其他数进行或运算，找出最大值。

**问题三**：如何得知除了第 $i$ 个元素外，其他数的或运算结果？

用数学表示，就是要求出 $[0:i)$ 以及 $(i,n)$ 的运算结果。那这不就是 **前后缀分解** 吗？

使用一次前缀和，得到 $pre$ 数组，其中 $pre[i]$ 表示 $[0:i]$ 的或结果；使用一次后缀和，得到 $suf$ 数组，其中 $suf[i]$ 表示 $[i:n-1]$ 的或结果。

**优化**：因为还需要一次遍历，对每个数进行左移；所以将这次的遍历与上面的前/后缀进行融合，一边求出前/后缀，一边进行左移。

也即，三次遍历变为两次遍历。这里进行左移时，选择从左往右遍历，所以取消前缀和数组，改为使用一个变量 $pre$，它表示 $[0:i]$ 的或结果。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        n = len(nums)
        # 后缀或运算数组，suf[i]表示从nums[i]到nums[n-1]的或运算结果
        suf = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suf[i] = suf[i + 1] | nums[i]
        
        ans = 0
        pre = 0  # 前缀或运算结果
        for i in range(n):
            # 计算当前最大值
            ans = max(ans, pre | (nums[i] << k) | suf[i + 1])
            # 更新前缀或
            pre |= nums[i]
        
        return ans
```

```java
// java
class Solution {
    public long maximumOr(int[] nums, int k) {
        int n = nums.length;
        // 后缀或运算数组，suf[i] 表示从 nums[i] 到 nums[n-1] 的或运算结果
        long[] suf = new long[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suf[i] = suf[i + 1] | nums[i];
        }

        long ans = 0;
        long pre = 0;  // 前缀或运算结果
        for (int i = 0; i < n; i++) {
            // 计算当前最大值
            ans = Math.max(ans, pre | ((long) nums[i] << k) | suf[i + 1]);
            // 更新前缀或
            pre |= nums[i];
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，两次遍历
- 空间复杂度： $O(n)$，表示后缀数组 $suf$ 的大小

空间复杂度为 $O(1)$ 的写法，理解起来较为复杂，感兴趣的小伙伴可以在评论区留言，我看到后就再补上。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-or/solutions/3621959/tan-xin-qian-hou-zhui-fen-jie-you-hua-ji-wtxt/)
