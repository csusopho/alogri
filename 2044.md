[Problem: 2044. 统计按位或能得到最大值的子集数目](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/description/)

### 方法：DFS & DP

子集 = 子序列，如果子序列的或值 = 最大或值，则这个子序列符合要求。

**或** 运算规则：`0 | 1 = 1`，`1 | 1 = 1`，`0 | 0 = 0`。也就是说，两个数字进行或运算，结果只会不变或增大。那么，数组中的最大或值 $mx$ = 所有数参与或。

**暴力**：枚举所有子序列，计算它们的或值，判断是否等于 $mx$。

> 注意，在数组 $[2,2,4]$ 中，第 $0$ 个元素的子序列 $[2,4]$ 和第 $1$ 个元素的子序列 $[2,4]$ 是不同的！题目指明，每个元素都是独特的。

如何构造子序列？任意元素只有「选」或「不选」加入一个子序列中，所以联想到 **递归**。定义 $dfs(i,cur)$ 表示从前往后处理到第 $i$ 个元素，当前子序列的或值为 $cur$ 时，继续向后拼接。

**状态转移**：

- 元素 $nums[i]$ 要么加入子序列，或值更新为 $new=cur|nums[i]$，即

$$dfs(i,cur)=dfs(i+1,new)$$

- 要么不加入子序列，或值不变，即

$$dfs(i,cur)=dfs(i+1,cur)$$

我们知道，每个 $DFS$ 状态都是树上的一个分支。由于 “或值” 只会递增，所以每个分支是否等于 $mx$，可以放在中间判断，也可以放在枚举结束判断。

经测试，前者的 $Python$ 耗时 $219ms$，后者耗时 $267ms$，速度略快。**特别提醒**，本题是因为递增的关系，所以将 “叶子部分” 的判断挪到 “树枝部分” 不会出错。其他题目里面，必须在 $i=n$ 结束的时候才能判断。

递归的细节我不再阐述，就是 “不选 —— 撤销 —— 选择”，这种 **回溯** 的逻辑，如果不太清楚，可以看看这篇 [N皇后](https://leetcode.cn/problems/n-queens/solutions/3006469/hui-su-po-su-jie-fa-yi-wei-you-hua-dfstu-gdhu/)。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        # 写法一
        n = len(nums)
        max_or = 0
        ans = 0

        # 先计算最大按位或
        for num in nums:
            max_or |= num

        def dfs(index, curr_or):
            nonlocal ans
            if index == n:
                return
            # 包含当前元素
            new_or = curr_or | nums[index]
            # 在中间部分进行判断！
            if new_or == max_or:
                ans += 1
            dfs(index + 1, new_or)
            # 不包含当前元素
            dfs(index + 1, curr_or)

        dfs(0, 0)
        return ans
```

```Java
// java
public class Solution {
    private int ans = 0;

    public int countMaxOrSubsets(int[] nums) {
        // 写法一
        int n = nums.length;
        int maxOr = 0;

        // 先计算最大按位或
        for (int num : nums) {
            maxOr |= num;
        }

        dfs(0, 0, nums, n, maxOr);

        return ans;
    }

    private void dfs(int index, int currOr, int[] nums, int n, int maxOr) {
        if (index == n) {
            return;
        }

        // 包含当前元素
        int newOr = currOr | nums[index];
        // 在中间部分进行判断！
        if (newOr == maxOr) {
            ans++;
        }

        dfs(index + 1, newOr, nums, n, maxOr);
        // 不包含当前元素
        dfs(index + 1, currOr, nums, n, maxOr);
    }
}
```

```Python
# python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        # 写法二
        n = len(nums)
        ans = 0
        max_or = 0

        # 计算最大按位或
        for num in nums:
            max_or |= num
        
        def dfs(index, curr_or):
            nonlocal ans
            if index == n:
                # 结束部分进行判断！
                if curr_or == max_or:
                    ans += 1
                return
            
            # 不选当前元素
            dfs(index + 1, curr_or)
            # 选当前元素
            dfs(index + 1, curr_or | nums[index])

        dfs(0, 0)
        return ans
```

```Java
// java
public class Solution {
    private int ans = 0;

    public int countMaxOrSubsets(int[] nums) {
        // 写法二
        int n = nums.length;
        int maxOr = 0;

        // 先计算最大按位或
        for (int num : nums) {
            maxOr |= num;
        }

        dfs(0, 0, nums, n, maxOr);

        return ans;
    }

    private void dfs(int index, int currOr, int[] nums, int n, int maxOr) {
        if (index == n) {
            // 结束部分进行判断！
            if (currOr == maxOr) {
                ans++;
            }
            return;
        }

        // 不选当前元素
        dfs(index + 1, currOr, nums, n, maxOr);
        // 选当前元素
        dfs(index + 1, currOr | nums[index], nums, n, maxOr);
    }
}
```

- 时间复杂度： $O(2^n)$，其中 $n$ 为数组 $nums$ 的长度，每个元素有两种选择，一共 $n$ 个元素，一共 $2^n$ 种方案，数学计算的时间为 $O(1)$
- 空间复杂度： $O(n)$，表示递归栈的深度

---

### 二进制枚举

数组中的数只有「选」或「不选」两种可能，所以能用 $0$ 表示没选，而 $1$ 表示已选。

集合可以用 **二进制** 表示，一个数的二进制从低到高的第 $i$ 位为 $1$ 表示 $i$ 在集合中，为 $0$ 表示 $i$ 不在集合中。例如集合 $\{0,1,4\}$ 对应的二进制数为 $10011$。

应用到数组中，数 $5=101$ 可以代表数组中的第 $0$ 个和第 $2$ 个元素被选中，其余元素都没选择。在本题中，就是用一个 **掩码** 表示一个二进制数，即数组的选择情况。

通过 **移位** 的方式，可以快速判断某个数是否在集合中或者添加某个数到集合中。第 $i$ 位为 $1$ 就表示 $nums[i]$ 在集合中，增加一个数就代表将第 $i$ 位置 $1$。

举个例子，状态 $0010$ 表示包含数字 $nums[1]$，而 $0010|(1<<2) = 0110$ 就表示在此基础上，增加一个 $nums[2]$。

扩展思考，发现 $0000$ 就代表空集， $1111$ 就代表全集。反正一个整数就代表一个集合，从小到大不断累加整数，就能得到不同的集合！也就是枚举子集！模版如下：

```Java
// 空集为 0，全集为 2^n
for (int mask = 0; mask < (1 << n); ++mask) {
    // 处理每个子集
}
```

再结合上面的 “一个整数表示数组的选择情况”，处理每个集合，模板如下：

```Java
// 遍历集合：判断mask的每一位，总共n位
for (int i = 0; i < n; i++) {
    if (((mask >> i) & 1) == 1) { // i=1 表示第 i 位已选
        // 处理 i 的逻辑
    }
}
```

**本质**：枚举所有可能的子集，然后判断每一个子集的或值。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        n = len(nums)
        max_or = 0
        ans = 0

        # 先计算最大按位或
        for num in nums:
            max_or |= num

        # 枚举所有非空子集
        for mask in range(1, 1 << n):
            curr_or = 0
            for i in range(n):
                if (mask >> i) & 1:  # 说明选中当前元素
                    curr_or |= nums[i]
            if curr_or == max_or:
                ans += 1

        return ans
```

```Java
// java
class Solution {
    public int countMaxOrSubsets(int[] nums) {
        int n = nums.length;
        int maxOr = 0;
        int ans = 0;

        // 先计算最大按位或
        for (int num : nums) {
            maxOr |= num;
        }

        // 枚举所有非空子集
        for (int mask = 1; mask < (1 << n); mask++) {
            int currOr = 0;
            for (int i = 0; i < n; i++) {
                if (((mask >> i) & 1) == 1) { // 说明选中当前元素
                    currOr |= nums[i];
                }
            }
            if (currOr == maxOr) {
                ans++;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times 2^n)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### $DP$

小子集拼接元素后，能形成大子集。比如在数组 $[1,2,3]$ 中，所有子集的形成过程：

- 初始化为空集 $[]$；
- 对于元素 $1$ 来说，可选可不选，得到 $[],[1]$；
- 同理元素 $2$，在上面的基础上拼接，得到 $[],[1],[2],[1,2]$；
- 同理元素 $3$，得到 $[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]$。

每个子集都有不同的或值，使用 $DP$ **模拟每一步** 的操作。实际上，我们并不关心子集到底由什么构成，只需要知道子集的或值是什么，有几个。比如子集 $[1,2]$ 可以看作我们拥有一个 $1|2$ 的子集。

**定义** $dp[x]$ 表示或值为 $x$ 的子集数量。

**转移过程**：从前往后枚举 $nums$ 的元素，用来扩充子集。只有一个元素，就单独作为子集；最终答案就是 $dp[mx]$。

同时，将 “更新 $dp$” 的过程与 “计算最大 $mx$” 的过程合二为一。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        # dp[or_val] = 对应的子集数量
        dp = defaultdict(int)
        max_or = 0

        for num in nums:
            new_dp = dp.copy()
            # 单独加一个新数，形成新子集
            new_dp[num] += 1

            # 将 num 添加到所有已有子集上，更新 OR 值
            for or_val, count in dp.items():
                new_or = or_val | num
                new_dp[new_or] += count

            dp = new_dp  # 滚动更新
            max_or |= num

        return dp[max_or]
```

```Java
// java
class Solution {
    public int countMaxOrSubsets(int[] nums) {
        // dp[or_val] = 对应的子集数量
        Map<Integer, Integer> dp = new HashMap<>();
        int maxOr = 0;

        for (int num : nums) {
            Map<Integer, Integer> newDp = new HashMap<>(dp);
            // 单独加一个新数，形成新子集
            newDp.put(num, newDp.getOrDefault(num, 0) + 1);

            // 将 num 添加到所有已有子集上，更新 OR 值
            for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {
                int orVal = entry.getKey();
                int count = entry.getValue();
                int newOr = orVal | num;
                newDp.put(newOr, newDp.getOrDefault(newOr, 0) + count);
            }

            dp = newDp;  // 滚动更新
            maxOr |= num;
        }

        return dp.getOrDefault(maxOr, 0);
    }
}
```

题目限定 $nums[i]\le 10^5$，由于 $2^{17}=131072$，则数字的最大位数为 $17$。因此，所有元素按位或后，最大或值 $mx$ 一定小于 $2^{18}$。

将这个数字记作 $m$，它是 $dp$ 键的最大值，也就是最大空间。每次枚举时，都会复制一份新的 $dp$ 并枚举旧 $dp$，时间不超过 $O(m)$。

- 时间复杂度： $O(n\times m)$，其中 $n$ 为数组 $nums$ 的长度，而 $m<2^{18}$
- 空间复杂度： $O(m)$，表示哈希表 $dp$ 的大小

---

### 优化

在上面的操作中，将新答案都放入 $newDp$ 中，然后滚动更新。刚刚完成复制时， $dp=newDp$。同样的逻辑，如果我们将 $newDp$ 当作 “旧的”，那么完全可以将答案都放入 $dp$ 中，从而省去 “滚动” 这一步。

初始化部分，将 $dp[0]$ 记作 $1$ 表示空集。那么，就无需单独添加当前 $num$ 去作为新的子集！直接拼接在空集后即可！

优化后 $python$ 语言耗时从 $9ms\rightarrow 3ms$，时间超过 $100\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        # dp[or_val] = 对应的子集数量
        dp = defaultdict(int)
        # 初始化一个空集
        dp[0] = 1
        max_or = 0

        for num in nums:
            new_dp = dp.copy()

            # 用旧dp得到新dp，将new_dp视作旧的！
            for or_val in new_dp:
                new_or = or_val | num
                # 这一步操作！
                dp[new_or] += new_dp[or_val]
            
            max_or |= num

        return dp[max_or]
```

```Java
// java
class Solution {
    public int countMaxOrSubsets(int[] nums) {
        // dp[or_val] = 对应的子集数量
        Map<Integer, Integer> dp = new HashMap<>();
        // 初始化一个空集
        dp.put(0, 1);
        int maxOr = 0;

        for (int num : nums) {
            // 用旧dp得到新dp，将new_dp视作旧的！
            Map<Integer, Integer> newDp = new HashMap<>(dp);

            for (Map.Entry<Integer, Integer> entry : newDp.entrySet()) {
                int orVal = entry.getKey();
                int count = entry.getValue();
                int newOr = orVal | num;
                // 这一步操作！
                dp.put(newOr, dp.getOrDefault(newOr, 0) + count);
            }

            maxOr |= num;
        }

        return dp.getOrDefault(maxOr, 0);
    }
}
```

- 时间复杂度： $O(n\times m)$，同理
- 空间复杂度： $O(m)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solutions/3735628/wu-jie-dfshui-su-er-jin-zhi-mei-ju-dp-zh-fre1/)
