[Problem: 3651. 带传送的最小路径成本](https://leetcode.cn/problems/minimum-cost-path-with-teleportations/description/)

### DP & 优化

可以从任意单元格传送到 **更小** 的单元格。第一想法是，把所有 $A\to B$ 传送都建成图的边。但是边的数量会达到 $O(m^2n^2)$，再去跑 $Dijkstra$ 极可能超时。

传送只能用 $k$ 次，且大幅缩短终点距离，所以考虑 **分层** 进行。

**定义** $dp[t][i][j]$ 表示使用不超过 $t$ 次传送，到达坐标 $(i, j)$ 的最小成本。

每一次从 $t-1$ 层推导到 $t$ 层时，包含两个步骤：传送/移动。

在第 $t$ 次传送中，我们可以从 $t-1$ 层的任意格子 $(u, v)$ 传送到 $(i, j)$，前提是 $grid[i][j] <= grid[u][v]$。换句话说，由于传送成本为 $0$，想通过传送到达 $(i, j)$，成本是所有满足 $grid[u][v] >= grid[i][j]$ 的格子中 $dp[t-1][u][v]$ 的最小值。

- 哪些格子值更大？自然地，想到将所有格子按数值 **从大到小** 排序。
- 如何移动到数值小的格子？由于已排序，所以从大到小遍历数值。维护一个 “全局见到的最小成本 $minCost$”，它已经见证过之前那些值更大的格子。对于数值为 $V$ 的格子，它们可以接收来自所有数值 $\ge V$ 的格子的传送。因此，我们只需要再遍历一次 $t-1$ 层，就能更新当前 $(i,j)$ 格子。

在完成传送更新后，我们可能以极低的成本降落在某个格子上。接着，可以在当前第 $t$ 层内继续进行普通移动（向右或向下）。那就是一个简单的网格 $DP$：

$$
dp[t][i][j] = min(dp[t][i][j], dp[t][i-1][j] + grid[i][j], dp[t][i][j-1] + grid[i][j])
$$

---

上面是思路推导，下面是具体处理。

**预处理**：将网格中所有坐标按其数值分组，并按数值从大到小排序。其中 $groups$ 存储 `(数值, 相同数值的所有坐标)`，以及 $sortedValues$ 存储排序后的所有数值。

初始时在第 $0$ 层，不用传送，将 $dp[0][0][0]$ 置为 $0$。接着，进行一次普通移动的 $DP$ 传播，从左上到右下，计算出不使用传送时的基础成本 $dp[0][i][j]$。

对于每一次传送机会 $t\in [1,k]$：

- 首先，复制之前的 $dp[t-1]$ 状态到 $dp[t]$。因为我们可以选择不使用这次传送机会，保留原状。
- 然后，进行传送更新，遍历 $sortedValues$（从大到小）：
  - 获取该数值对应的所有坐标
  - 计算这些坐标在上一轮 $dp$ 中的最小成本 $min(dp[t-1][r][c])$
  - 更新全局的 $minCost$（所有数值 $\ge$ 当前数值的格子中的最小成本）
  - 传送成本为 $0$，所以直接继承源点的成本。将该组所有坐标的 $dp[t][r][c]$ 更新为 $min(dp[t][r][c], minCost)$
- 最后，进行移动更新：在 $dp[t]$ 上再次进行一次普通移动的 $DP$ 传播，因为传送后可以继续走，且仍然在当前层，不消耗传送次数。

---

注意，本题的 **核心** 是理解 $minCost$ 这个变量的含义。它表示之前所有值更大的格子，所能消耗的最小成本。利用它，我们可以轻松传送到值更小的格子，且是最优路径。

围绕这个变量，提前进行排序分组，方便遍历值更大的格子。先遍历 $k-1$ 层，更新 $minCost$，然后再更新值小的 $(i,j)$ 格子，也是同样逻辑。

还有一点，切记先进行传送，再进行移动。因为传送无成本，确保全局最优解。而 $DP$ 的初始化同理，也是 $0$ 次传送，再让每个格子移动。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        
        # 按数值分组
        groups = {}
        for r in range(m):
            for c in range(n):
                val = grid[r][c]
                if val not in groups:
                    groups[val] = []
                groups[val].append((r, c))
        
        # 将数值从大到小排序
        sorted_vals = sorted(groups.keys(), reverse=True)
        # dp[t][i][j] 表示不超过 t 次传送，到达坐标 (i, j) 的最小成本
        dp = [[[inf] * n for _ in range(m)] for _ in range(k + 1)]
        
        # 初始化第 0 层，不传送
        dp[0][0][0] = 0
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                
                cost = grid[i][j]
                from_top = dp[0][i-1][j] if i > 0 else inf
                from_left = dp[0][i][j-1] if j > 0 else inf
                
                dp[0][i][j] = min(from_top, from_left) + cost
        
        # 逐层计算
        for t in range(1, k + 1):
            # 如果不传送，直接沿用上一层的最优解
            for i in range(m):
                for j in range(n):
                    dp[t][i][j] = dp[t-1][i][j]
            
            # 处理传送
            min_cost = inf
            
            for val in sorted_vals:
                # 在 t-1 层中，当前数值 val 的最小成本
                for r, c in groups[val]:
                    min_cost = min(min_cost, dp[t-1][r][c])
                
                # 在 t 层中，尝试通过传送更新当前数值 val 的格子
                for r, c in groups[val]:
                    dp[t][r][c] = min(dp[t][r][c], min_cost)
            
            # 普通移动
            for i in range(m):
                for j in range(n):
                    if i == 0 and j == 0:
                        continue
                    
                    cost = grid[i][j]
                    # 向下一格
                    if i > 0:
                        dp[t][i][j] = min(dp[t][i][j], dp[t][i-1][j] + cost)
                    # 向右一格
                    if j > 0:
                        dp[t][i][j] = min(dp[t][i][j], dp[t][i][j-1] + cost)
        
        return dp[k][m-1][n-1]
```

```Java
// java
class Solution {
    public int minCost(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        int inf = Integer.MAX_VALUE / 2;
        
        // 按数值分组
        Map<Integer, List<int[]>> groups = new HashMap<>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                int val = grid[r][c];
                groups.computeIfAbsent(val, x -> new ArrayList<>()).add(new int[]{r, c});
            }
        }
        
        // 将数值从大到小排序
        List<Integer> sortedVals = new ArrayList<>(groups.keySet());
        sortedVals.sort((a, b) -> b - a);
        
        // dp[t][i][j] 表示不超过 t 次传送，到达坐标 (i, j) 的最小成本
        int[][][] dp = new int[k + 1][m][n];
        for (int t = 0; t <= k; t++) {
            for (int i = 0; i < m; i++) {
                Arrays.fill(dp[t][i], inf);
            }
        }
        
        // 初始化第 0 层，不传送
        dp[0][0][0] = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                
                int cost = grid[i][j];
                int fromTop = (i > 0) ? dp[0][i - 1][j] : inf;
                int fromLeft = (j > 0) ? dp[0][i][j - 1] : inf;
                
                if (Math.min(fromTop, fromLeft) != inf) {
                    dp[0][i][j] = Math.min(fromTop, fromLeft) + cost;
                }
            }
        }
        
        // 逐层计算
        for (int t = 1; t <= k; t++) {
            // 如果不传送，直接沿用上一层的最优解
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    dp[t][i][j] = dp[t - 1][i][j];
                }
            }
            
            // 处理传送
            int minCost = inf;
            
            for (int val : sortedVals) {
                List<int[]> coords = groups.get(val);
                // 在 t-1 层中，当前数值 val 的最小成本
                for (int[] p : coords) {
                    minCost = Math.min(minCost, dp[t - 1][p[0]][p[1]]);
                }
                
                // 在 t 层中，尝试通过传送更新当前数值 val 的格子
                for (int[] p : coords) {
                    dp[t][p[0]][p[1]] = Math.min(dp[t][p[0]][p[1]], minCost);
                }
            }
            
            // 普通移动
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (i == 0 && j == 0) {
                        continue;
                    }
                    
                    int cost = grid[i][j];
                    // 向下一格
                    if (i > 0 && dp[t][i - 1][j] != inf) {
                        dp[t][i][j] = Math.min(dp[t][i][j], dp[t][i - 1][j] + cost);
                    }
                    // 向右一格
                    if (j > 0 && dp[t][i][j - 1] != inf) {
                        dp[t][i][j] = Math.min(dp[t][i][j], dp[t][i][j - 1] + cost);
                    }
                }
            }
        }
        
        return dp[k][m - 1][n - 1];
    }
}
```

- 时间复杂度： $O(k\times m\times n)$，其中 $m,n$ 分别是数组 $grid$ 的行数和列数，排序的时间为 $O(mnlog(mn))$。外部循环 $k$ 次，内部循环遍历所有格子
- 空间复杂度： $O(k\times m\times n)$，表示数组 $dp$ 的大小

---

### 空间优化

递推过程中没用到 $dp[t-1]$ 更早的状态，常规 $DP$ 操作，优化掉第一维空间。

其他逻辑不变，这里不再阐述。经实测，优化后 $Python$ 耗时 $4110ms\to 2688ms$，超过 $82\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        
        # 按数值分组
        groups = {}
        for r in range(m):
            for c in range(n):
                val = grid[r][c]
                if val not in groups:
                    groups[val] = []
                groups[val].append((r, c))
        
        # 将数值从大到小排序
        sorted_vals = sorted(groups.keys(), reverse=True)
        # 优化掉第一维
        dp = [[inf] * n for _ in range(m)]

        # 初始化第 0 层，不传送
        dp[0][0] = 0
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                cost = grid[i][j]
                from_top = dp[i-1][j] if i > 0 else inf
                from_left = dp[i][j-1] if j > 0 else inf
                dp[i][j] = min(from_top, from_left) + cost
                    
        # 逐层计算
        for _ in range(k):
            new_dp = [row[:] for row in dp]
            
            # 处理传送
            min_cost = inf
            
            for val in sorted_vals:
                # 在上一轮 dp 中，当前数值 val 的最小成本
                for r, c in groups[val]:
                    min_cost = min(min_cost, dp[r][c])
                
                # 这些格子作为传送的目标点
                for r, c in groups[val]:
                    if min_cost < new_dp[r][c]:
                        new_dp[r][c] = min_cost
            
            # 普通移动
            for i in range(m):
                for j in range(n):
                    if i == 0 and j == 0:
                        continue
                    cost = grid[i][j]
                    # 向下一格
                    if i > 0 and new_dp[i-1][j] + cost < new_dp[i][j]:
                        new_dp[i][j] = new_dp[i-1][j] + cost
                    # 向右一格
                    if j > 0 and new_dp[i][j-1] + cost < new_dp[i][j]:
                        new_dp[i][j] = new_dp[i][j-1] + cost
            # 滚动更新
            dp = new_dp

        return dp[m-1][n-1]
```

```Java
// java
class Solution {
    public int minCost(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        int inf = Integer.MAX_VALUE / 2;
        
        // 按数值分组
        Map<Integer, List<int[]>> groups = new HashMap<>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                int val = grid[r][c];
                groups.computeIfAbsent(val, x -> new ArrayList<>()).add(new int[]{r, c});
            }
        }
        
        // 将数值从大到小排序
        List<Integer> sortedVals = new ArrayList<>(groups.keySet());
        sortedVals.sort((a, b) -> b - a);
        
        // 优化掉第一维
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], inf);
        }

        // 初始化第 0 层，不传送
        dp[0][0] = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                int cost = grid[i][j];
                int fromTop = (i > 0) ? dp[i - 1][j] : inf;
                int fromLeft = (j > 0) ? dp[i][j - 1] : inf;
                
                if (Math.min(fromTop, fromLeft) != inf) {
                    dp[i][j] = Math.min(fromTop, fromLeft) + cost;
                }
            }
        }
                    
        // 逐层计算
        for (int step = 0; step < k; step++) {
            int[][] newDp = new int[m][n];
            for (int i = 0; i < m; i++) {
                newDp[i] = dp[i].clone();
            }
            
            // 处理传送
            int minCost = inf;
            
            for (int val : sortedVals) {
                List<int[]> coords = groups.get(val);
                // 在上一轮 dp 中，当前数值 val 的最小成本
                for (int[] p : coords) {
                    minCost = Math.min(minCost, dp[p[0]][p[1]]);
                }
                
                // 这些格子作为传送的目标点
                for (int[] p : coords) {
                    if (minCost < newDp[p[0]][p[1]]) {
                        newDp[p[0]][p[1]] = minCost;
                    }
                }
            }
            
            // 普通移动
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (i == 0 && j == 0) {
                        continue;
                    }
                    int cost = grid[i][j];
                    // 向下一格
                    if (i > 0 && newDp[i - 1][j] != inf && newDp[i - 1][j] + cost < newDp[i][j]) {
                        newDp[i][j] = newDp[i - 1][j] + cost;
                    }
                    // 向右一格
                    if (j > 0 && newDp[i][j - 1] != inf && newDp[i][j - 1] + cost < newDp[i][j]) {
                        newDp[i][j] = newDp[i][j - 1] + cost;
                    }
                }
            }
            // 滚动更新
            dp = newDp;
        }

        return dp[m - 1][n - 1];
    }
}
```

- 时间复杂度： $O(k\times m\times n)$
- 空间复杂度： $O(m\times n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-cost-path-with-teleportations/solutions/3890760/dp-xiang-dui-rong-yi-li-jie-de-xie-fa-pa-che1/)
