[Problem: 712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/)

### 方法：DP & 空间优化

删除字符，让剩余的串相同。那么，剩下的这个串就是它们的一个 **公共子序列**。想要让删除的和最小，由于总和固定，等同于 “保留的和” 最大。

- $LCS$ 问题：求公共子序列的 **最大长度**。
- 本题：求公共子序列的 **最大 $ASCII$ 码值之和**。

$LCS$ 的原理/模版，可以看我写的这篇 [题解](https://leetcode.cn/problems/uncrossed-lines/solutions/2876264/lcs-er-wei-dpliang-chong-kong-jian-you-h-y2gu/)。本题就是再次基础上的变种。

如何寻找（两个字符串之间 $ASCII$ 值总和最大的）公共子序列？

**定义** $dp[i][j]$ 表示从字符串 $s1$ 的前 $i$ 个字符和 $s2$ 的前 $j$ 个字符中挑选，得到的公共子序列的最大和。

**状态转移方程：**

- 当 $s1[i-1] = s2[j-1]$ 时，字符相等，因为我们要最大化总和，所以应该把这个字符加入到公共子序列中，则有

$$
dp[i][j] = dp[i-1][j-1] + \text{ord}(s1[i-1])
$$

- 当 $s1[i-1] \not= s2[j-1]$ 时，字符不相等，无法同时选这两个字符。我们要么忽略 $s1$ 的当前字符，要么忽略 $s2$ 的当前字符，看谁剩下的公共部分权重大。则有

$$
dp[i][j] = \max(dp[i-1][j], dp[i][j-1])
$$

有小伙伴疑问，“都不选” 的情况怎么不考虑？实际上，它已经被容纳进去。上面表示，必然不使用 $s1[i]$（但可能使用 $s2[j]$）和必然不使用 $s2[j]$（但可能使用 $s1[i]$）的 $LCS$ 长度。

初始化：空字符串没有公共子序列，所以 $dp[0][n]$ 以及 $dp[m][0]$ 都是 $0$。

答案 = 所有字符总和 $totalSum$ - $2\times$ 最大公共部分和 $dp[m][n]$。

其余细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # dp[i][j] 表示 s1[:i] 和 s2[:j] 的最大公共 ASCII 和
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 字符相同，累加 ASCII 值
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + ord(s1[i - 1])
                # 字符不同，取之前的最大值
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        # 计算原始字符串的总 ASCII 和
        total_ascii_sum = sum(ord(c) for c in s1) + sum(ord(c) for c in s2)
        # 总和 - 2 * 最大公共部分的和
        return total_ascii_sum - 2 * dp[m][n]
```

```java
// java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // dp[i][j] 表示 s1[:i] 和 s2[:j] 的最大公共 ASCII 和
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 字符相同，累加 ASCII 值
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + s1.codePointAt(i - 1);
                }
                // 字符不同，取之前的最大值
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // 计算原始字符串的总 ASCII 和
        int totalAsciiSum = 0;
        for (char c : s1.toCharArray()) totalAsciiSum += c;
        for (char c : s2.toCharArray()) totalAsciiSum += c;
        
        // 总和 - 2 * 最大公共部分的和
        return totalAsciiSum - 2 * dp[m][n];
    }
}
```

- 时间复杂度： $O(n \times m)$，其中 $m,n$ 分别为串 $s1,s2$ 的长度
- 空间复杂度： $O(n \times m)$，表述数组 $dp$ 的大小

---

### 空间优化

可以发现，计算状态 $dp[i][j]$ 时，只会用到 $dp[i-1][j]$ 以及 $dp[i][j-1]$ 的值，不会用到比 $i-1$ 或 $j-1$ 更早的状态。这里就采用滚动数组，优化掉第一维。

使用 $prev$ 数组存储 **上一轮** 的 $dp[i-1]$ 状态，以及 $curr$ 数组存储 **当前轮** 的 $dp[i]$ 状态。

**状态转移方程**：

$$
curr[j+1] = prev[j] + \text{ord}(s1[i-1])
$$

或

$$
curr[j+1] = \max(prev[j+1], curr[j])
$$

递推完一轮后，交换 $prev$ 与 $curr$ 就能达到 **滚动** 的效果。**本质**：将一个 $dp$ 矩阵进行缩减，只保留需要的两行。

可以发现，状态转移方程基本没变，只是第一维被取消了。递推方向、递推边界、目标值等都基本相同，注意转化即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # 前一行的状态，当前行的状态
        dp_prev = [0] * (n + 1)
        dp_curr = [0] * (n + 1)

        for i in range(m):
            for j in range(n):
                # 字符相同，公共长度+1
                if s1[i] == s2[j]:
                    dp_curr[j + 1] = dp_prev[j] + ord(s1[i])
                # 字符不同，取较大者
                else:
                    dp_curr[j + 1] = max(dp_prev[j + 1], dp_curr[j])
            # 更新上一行和当前行
            dp_prev, dp_curr = dp_curr, dp_prev

        total_ascii_sum = sum(ord(c) for c in s1) + sum(ord(c) for c in s2)
        return total_ascii_sum - 2 * dp_prev[n]
```

```java
// java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 前一行的状态，当前行的状态
        int[] dpPrev = new int[n + 1];
        int[] dpCurr = new int[n + 1];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 字符相同，公共长度+1
                if (s1.charAt(i) == s2.charAt(j)) {
                    dpCurr[j + 1] = dpPrev[j] + s1.codePointAt(i);
                }
                // 字符不同，取较大者
                else {
                    dpCurr[j + 1] = Math.max(dpPrev[j + 1], dpCurr[j]);
                }
            }
            // 更新上一行和当前行
            int[] temp = dpPrev;
            dpPrev = dpCurr;
            dpCurr = temp;
        }

        int totalAsciiSum = 0;
        for (char c : s1.toCharArray()) totalAsciiSum += c;
        for (char c : s2.toCharArray()) totalAsciiSum += c;

        return totalAsciiSum - 2 * dpPrev[n];
    }
}
```

- 时间复杂度： $O(n \times m)$
- 空间复杂度： $O(n)$

---

### 正向

上面的思路是 “求最大保留”，也可以直接定义 $DP$ 来 “求最小删除”。

**定义** $dp[i][j]$ 表示使 $s1[:i]$ 和 $s2[:j]$ 相等所需的最小删除 $ASCII$ 和。

**初始化**：

- $dp[0][0] = 0$
- $dp[i][0]$：由于 $s2$为空，必须删除 $s1$ 所有字符，等于 $s1[:i]$ 的累加和。
- $dp[0][j]$：由于 $s1$为空，必须删除 $s2$ 所有字符，等于 $s2[:j]$ 的累加和。

**状态转移**：

- 若 $s1[i-1] = s2[j-1]$，不需要删除，代价同 $dp[i-1][j-1]$
- 若不相等，类比得到 $min(删除s1当前字符 + dp[i-1][j], 删除s2当前字符 + dp[i][j-1])$

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # dp[i][j] 表示使 s1[:i-1] 和 s2[:j-1] 相等所需的最小删除和
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        # 初始化，删除所有字符
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    # 如果当前字符相同，不需要删除
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 不同，删除 s1[i-1] 或 s2[j-1]
                    dp[i][j] = min(
                        dp[i - 1][j] + ord(s1[i - 1]),
                        dp[i][j - 1] + ord(s2[j - 1])
                    )
        
        return dp[m][n]
```

```java
// java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // dp[i][j] 表示使 s1[:i-1] 和 s2[:j-1] 相等所需的最小删除和
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化，删除所有字符
        for (int j = 1; j <= n; j++) {
            dp[0][j] = dp[0][j - 1] + s2.codePointAt(j - 1);
        }
        for (int i = 1; i <= m; i++) {
            dp[i][0] = dp[i - 1][0] + s1.codePointAt(i - 1);
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // 如果当前字符相同，不需要删除
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 不同，删除 s1[i-1] 或 s2[j-1]
                    dp[i][j] = Math.min(
                        dp[i - 1][j] + s1.codePointAt(i - 1),
                        dp[i][j - 1] + s2.codePointAt(j - 1)
                    );
                }
            }
        }

        return dp[m][n];
    }
}
```

- 时间复杂度： $O(n \times m)$
- 空间复杂度： $O(n \times m)$

经实测，第一版 $Python$ 耗时 $117ms$，超过 $99.2\%$；第二版耗时 $115ms$，超过 $99.7\%$，速度最快；第三版耗时较长，仅超过 $92\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3877104/san-jie-zheng-fan-xiang-si-kao-er-wei-dp-bivz/)
