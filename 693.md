[Problem: 693. 交替位二进制数](https://leetcode.cn/problems/binary-number-with-alternating-bits/description/)

### 方法：暴力 & 位运算

题意很清晰，**最直观** 的方法：将数字转换成二进制字符串，然后遍历字符串，检查每一位是否与前一位相同。如果发现有两个相邻的字符相同，说明不是交替出现的。

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        # 将数字转换为二进制字符串
        binary_str = bin(n)[2:]

        # 遍历相邻字符
        for i in range(len(binary_str) - 1):
            # 当前字符和下一位字符相同
            if binary_str[i] == binary_str[i+1]:
                return False
        
        # 符合要求
        return True
```

```Java
// java
class Solution {
    public boolean hasAlternatingBits(int n) {
        // 将数字转换为二进制字符串
        String binaryStr = Integer.toBinaryString(n);

        // 遍历相邻字符
        for (int i = 0; i < binaryStr.length() - 1; i++) {
            // 当前字符和下一位字符相同
            if (binaryStr.charAt(i) == binaryStr.charAt(i + 1)) {
                return false;
            }
        }
        
        // 符合要求
        return true;
    }
}
```

- 时间复杂度： $O(logn)$，遍历二进制的每一位
- 空间复杂度： $O(logn)$，表示字符串 $binaryStr$ 的大小

---

### 位运算

我们可以利用位运算的优秀特性。

**第一步**：`m = n ^ (n >> 1)`。

目标：验证错位后的异或结果是否全为 $1$。

- 右移 `n >> 1`：将二进制数向右移动一位
- 异或 `^`：相同为 $0$，不同为 $1$

1）如果 $n$ 是交替的，例如 $1010$，那么有

$$
\begin{aligned}
n &= 1010_2 \\
n >> 1 &= 0101_2 \\
\hline
n \oplus (n >> 1) &= 1111_2
\end{aligned}
$$

结果 $m$ 变成了全 $1$ 的序列。

2）如果 $n$ 不是交替的，例如 $1100$，那么有

$$
\begin{aligned}
n &= 1100_2 \\
n >> 1 &= 0110_2 \\
\hline
n \oplus (n >> 1) &= 1010_2
\end{aligned}
$$

结果 $m$ 中间出现了 $0$，不是全 $1$。

**结论 1**：如果 $n$ 是交替位，那么 $m$ 一定是由一串连续的 $1$ 组成的。

---

**第二步**：`m & (m + 1) == 0`。

目标：检查 $m$ 是否是由全 $1$ 组成。

1）假设 $m$ 全是 $1$，比如 $1111_2$，那么 $m+1$ 会产生进位，变成 $10000_2$。

这时候做按位与 `&`，得到

$$
\begin{aligned}
m \quad &= 01111_2 \\
m + 1 &= 10000_2 \\
\hline
\& \quad &= 00000_2
\end{aligned}
$$

结果为 $0$。

2）假设 $m$ 中间有 $0$，比如 $1010_2$，那么 $m+1$ 为 $1011_2$。

这时候做按位与，得到

$$
\begin{aligned}
m \quad &= 1010_2 \\
m + 1 &= 1011_2 \\
\hline
\& \quad &= 1010_2
\end{aligned}
$$

结果不为 $0$。

**结论 2**：只有当 $m$ 的二进制表示全是 $1$ 时，`m & (m + 1)` 才会等于 $0$。

总结上面的流程，得出如下代码：

```Python
# python
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        m = n ^ (n >> 1)
        return m & (m + 1) == 0
```

```Java
// java
class Solution {
    public boolean hasAlternatingBits(int n) {
        int m = n ^ (n >> 1);
        return (m & (m + 1)) == 0;
    }
}
```

- 时间复杂度： $O(1)$，位运算
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/binary-number-with-alternating-bits/solutions/3904391/shuang-jie-bao-li-zhuan-zi-fu-chuan-wei-8o3tv/)
