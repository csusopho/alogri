[Problem: 2970. 统计移除递增子数组的数目 I](https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i/description/)

### 方法：前后缀+双指针

**题意：** 移除子数组，剩下的序列严格递增

假设移除的部分是 $[i,j]$，那么就会剩下 $[0,i-1]$ 的左侧部分，以及 $[j+1,n]$ 的右侧部分。如果剩下的序列组合后是严格递增的，那就需要满足 $3$ 个条件：

1. 左侧部分递增
2. 右侧部分递增
3. 连接处递增，即 $nums[i-1]<nums[j+1]$

对于区间问题，很容易联想到 **前缀** 的思想。这里需要快速判断多个区间是否严格递增，比如 $[0,1],[0,2],...,[0,i]$ 等区间，使用前缀的思想一次遍历即可。

这里使用实例 $1$ 中的例子 $[1,2,3,4]$ 举例，解释前缀思想。定义一个前缀数组 $pre$，其中 $pre[i]$ 表示数组 $nums$ 的区间 $[0,i]$ 的最大值。

- $pre[0]$ 对应 $nums[0,0]$，所以 $pre[0]=nums[0]=1$
- $pre[1]$ 对应 $nums[0,1]$，所以 $pre[1]=max(pre[0],nums[1])=2$
- $pre[2]$ 对应 $nums[0,2]$，所以 $pre[2]=max(pre[1],nums[2])=3$
- ...

通过前缀数组，我们可以快速得到某个前缀区间的最大值。同理后缀数组，定义一个后缀数组 $post$，其中 $post[j]$ 表示数组 $nums[j,n-1]$ 的最大值。

前后缀数组能帮助我们快速判断前面的 $1$ 和 $2$ 条件是否成立，而第 $3$ 个条件就是比较左区间的右端点与右区间的左端点的大小，即 $nums[i-1]$ 与 $nums[j+1]$ 的关系，这一点只需要遍历的时候加个 $if$ 判断即可。

> 以上的假设基于的是一般情况，也就是左右区间的长度都大于 0。如果不满足那就表示 3 个条件只存在 1 个，同样符合上面的推导。

最难的部分在于如何利用前后缀 —— **双指针**

**思路：** 现在左右两边都不确定长度，想到固定一边枚举另外一边。这里选择枚举右侧区间的长度，让左指针移动去进行匹配（固定左枚举右）。

**做法：** 已知左右两侧都递增（前提，否则不满足条件 $1$ 或 $2$），那么如何让连接处也递增呢？**消减左边长度，去满足右边。**

也就是说，枚举右边的长度从 $0$ 到 $n$，让左侧去满足拼接条件。右侧已递增，它的左边界最小；左侧已递增，它的右边界最大。那就让左侧区间的右边界一直向左移动，那就会逐渐逼近直到小于右侧左边界，从而满足。

这里求的是递增子数组的 **总数**，那么所有情况都要考虑到。假设当前右侧区间的左端点为 $j$ ，左侧区间的右端点是 $i$，有 $nums[i]<nums[j]$，同时 $nums[i+1]\geq nums[j]$ 。所以此时可以删除的子数组为 $[0,j-1],[1,j-1],...[i+1,j-1]$，总数为 $i+2$。

每次枚举右区间时，对应不同的左端点 $i'$，也就有不同的长度 $i'+2$。最后的答案就是每次的累加和，即 $\sum (i+2)$。

如何移动左边界？见代码。

```Python
# python代码
class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        # 前后缀+双指针
        n = len(nums)
        i = 0
        while i < n - 1 and nums[i] < nums[i + 1]:
            i += 1
        if i == n - 1:  # 整个数组严格递增
            return n * (n + 1) // 2

        ans = i + 2  # 不保留后缀
        # 枚举保留的后缀为nums[j:]
        j = n - 1
        # 右指针每次移动一位，左指针匹配
        while j == n - 1 or nums[j] < nums[j + 1]:
            # 寻找左区间，移动左指针
            while i >= 0 and nums[i] >= nums[j]:
                i -= 1
            # 可以保留前缀nums[:i+1],nums[:i],...,nums[:0] 一共i+2个
            ans += i + 2
            j -= 1  # 右指针移动
        return ans
```

```java
// java代码
class Solution {
    public int incremovableSubarrayCount(int[] nums) {
        // 双指针
        int i = 0, n = nums.length;
        while (i + 1 < n && nums[i] < nums[i + 1]) {
            ++i;
        }
        if (i == n - 1) {  // 全数组递增
            return n * (n + 1) / 2;
        }
        int ans = i + 2;  // 初始值
        for (int j = n - 1; j > 0; --j) {  // 右指针每次移动一位
            // 移动左指针去匹配
            while (i >= 0 && nums[i] >= nums[j]) {
                --i;
            }
            ans += i + 2;  // 累加答案
            // 右区间不满足，退出
            if (nums[j - 1] >= nums[j]) {
                break;
            }
        }
        return ans;
    }
}
```

- 时间复杂度：$O(n)$，双指针移动时每个元素仅遍历一次
- 空间复杂度：$O(1)$，仅用常数个额外变量

代码中已附加注释，这里解释几个问题：

- 为什么初始值也是 $i+2$ ？因为右区间长度为 $0$ 的情况循环中没有判断，所以提前累加，表示移除 $nums[0:n-1],nums[1:n-1],...,nums[i+1:n-1]$ 这一共 $i+2$ 种情况。

- 如果数组不递增或者指针到达边界怎么办？上面代码中每次都是累加 $i + 2$，假如越界则 $i=-1$，那么每次都累加 $1$，代表只保留右区间，移除左区间，对应一种方案。

> ps：感谢灵神的思路分享，欢迎大家关注这位大佬 @灵茶山艾府

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i/solutions/2837565/qian-hou-zhui-shuang-zhi-zhen-by-pricele-rs71/)
