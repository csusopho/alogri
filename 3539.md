[Problem: 3539. 魔法序列的数组乘积之和](https://leetcode.cn/problems/find-sum-of-array-product-of-magical-sequences/description/)

### 方法：DFS

组成序列时，仔细看，我们是从 $nums$ 中挑选 **下标** $i$，而不是 **数值** $nums[i]$！

- 选取 **不重复** 下标：假设 $m=2,k=2,nums=[2,4]$，序列 $seq=[0,1]$ 是一个有效构造。此时的总和是 $2^0+2^1=3$，二进制为 $11_{(2)}$，其中包含两个置位，符合题目要求。
- 选取 **重复** 下标：假设 $m=3,k=1,nums=[2,4]$，序列 $seq=[0,0,1]$ 是一个有效的构造，其中下标 $0$ 被重复选取。此时的总和是 $2^0+2^0+2^1=4$，二进制为 $100_{(2)}$，包含一个置位，符合题目要求。

只有在统计答案时，才会用到 $nums[i]$。将上述选取好的序列，根据下标取出值，然后累乘。比如 $seq=[0,1]$ 时，对应到 $nums[0]\times nums[1]$。

总的来看，就是从 $[0,n-1]$ 中挑选 $m$ 个下标 $I_0,I_1,\dots,I_{m-1}$，使得

$$
S=\sum_{j=0}^{m-1}2^{I_j}
$$

中包含 $k$ 个二进制的 $1$。

先叠甲，本人没见过这种题型，我没解出来这道题，所以参考了灵神的题解。这里只作经验分享，如有误差还请见谅。

---

### 找规律

将选取好的 $seq$ 序列，放入 $nums$ 数组，得到累乘结果

$$
f(I)=\prod_{j=0}^{m-1}nums[I_j]
$$

不同序列得到不同结果，累加到答案中。

注意，序列 $[0,1,2]$ 与 $[2,0,1]$ 是不同的 $seq$ 序列，但是累乘结果相同，也即对答案的贡献相同。所以，我们只考虑一个下标 **选了几次**，而不是 **选择顺序**。从原本的排列问题，变为了组合问题。根据数学知识可知，在一个长度为 $m$ 的序列中，如果数字 $x$ 重复出现 $t$ 次，那么一共能组成 $\frac{m!}{t!}$ 个不同排列。

具体来说，在一个序列中，假设下标 $i$ 重复选了 $j$ 次，它就对应 $\textit{nums}[i]^j$。要选 $m$ 个下标，则有 $m!$ 个不同的下标排列，所以这个序列在答案中的重复次数是 $\frac{m!}{j!}$。

例如 $n=2, m=7$ ，选了 $3$ 个下标 $0$ 和 $4$ 个下标 $1$ ，那么它的数组乘积是 $\textit{nums}[0]^3 \cdot \textit{nums}[1]^4$，在答案中的次数为 $\frac{7!}{3!4!}$。

这种选法如果符合 $k$ 个 $1$ 的要求，那么对答案的贡献为

$$
\frac{7!}{3!4!} \cdot \textit{nums}[0]^3 \cdot \textit{nums}[1]^4
$$

把 $7!$ 提出来，变形得

$$
7! \cdot \left(\frac{\textit{nums}[0]^3}{3!}\right) \cdot \left(\frac{\textit{nums}[1]^4}{4!}\right)
$$

可以发现，每一项都是 $nums[i]^j/j!$，将它看作单个下标的通项。

一般地，设我们分别选了 $c_0, c_1, c_2, \dots, c_{n-1}$ 个下标 $0, 1, 2, \dots, n-1$，那么

$$
f(I) = \prod_{j=0}^{m-1} \textit{nums}[I_j] = \prod_{i=0}^{n-1} \textit{nums}[i]^{c_i}
$$

枚举 $c_i$，把 $m!$ 提出来，累加后的答案为

$$
\sum_I f(I) = \sum_I \prod_{i=0}^{n-1} \textit{nums}[i]^{c_i} = m! \sum_{c_0+\dots+c_{n-1}=m} \prod_{i=0}^{n-1} \frac{\textit{nums}[i]^{c_i}}{c_i!}
$$

---

### 关键点

**总结**：问题转化为，从 $[0,n-1]$ 中挑 $m$ 个下标，判断是否符合要求，然后累加。

如何顺序地挑选下标？使用 **递归** 的方式。当前下标挑几个？**枚举**。挑选的结果，用上面这个公式进行累加。剩下最大的 **难点**：如何判断挑选好的下标符合要求？

用第一个公式，也就是判断 $S=\sum_{j=0}^{m-1} 2^{I_j} = \sum_{i=0}^{n-1} c_i 2^i$ 的二进制中，是否恰好有 $k$ 个 $1$？

我们是从小到大枚举下标 $i$ ，假设当前的 $i=6$ ，那么后续加到 $S$ 中的数一定 $\ge 2^6$ ，一定不会影响 $S$ 的小于 $i$ 的比特位。

也就是说，低位已经考虑完成，现在考虑 **高位**。引出灵神题解中的重要结论：将 $S$ 右移 $i$ 位。对于 $S$ 来说，假设低位已经填充 $a$ 个 $1$，则高位还需填充 $k-a$ 个 $1$。因此，原本要求的是 $S$，现在变为对 “右移 $S$” 的要求。

---

### $DFS$

从前往后选择下标，我们需要知道如下信息：

- 当前枚举的下标 $i$。
- 还剩下 $\textit{leftM}$ 个下标需要选。
- 当前累加的 $S$，其右移 $i$ 位的结果是 $x$，即 $\lfloor\frac{S}{2^i}\rfloor = x$。
- 去掉右移掉的 $1$ 后，$S$ 还需包含恰好 $\textit{leftK}$ 个 $1$。

**定义** $\textit{dfs}(i, \textit{leftM}, x, \textit{leftK})$ 表示在上述情况下，继续选择下标能得到的总答案。

当前下标 $i$ 能重复选几次？在 $j\in[0,leftM]$ 内枚举，此时向后递归：

- 当前枚举的下标是 $i+1$。
- 还剩下 $\textit{leftM}-j$ 个下标需要选。
- 当前累加的 $S' = S+j \cdot 2^i$，其右移 $i+1$ 位的结果是 $\lfloor\frac{S'}{2^{i+1}}\rfloor = \lfloor\frac{x+j}{2}\rfloor$。
- 去掉右移掉的 $1$ 后，$S$ 还需包含恰好 $\textit{leftK}-\textit{bit}$ 个 $1$，其中 $\textit{bit}=(x+j) \bmod 2$。

如果 $\textit{bit} \le \textit{leftK}$，那么可以递归到 $r = \textit{dfs}(i+1, \textit{leftM}-j, \lfloor\frac{x+j}{2}\rfloor, \textit{leftK}-\textit{bit})$。把 $r$ 乘以 $\frac{\textit{nums}[i]^j}{j!}$，累加到 $\textit{dfs}(i, \textit{leftM}, x, \textit{leftK})$ 中，得到 **转移方程**：

$$
\textit{dfs}(i, \textit{leftM}, x, \textit{leftK}) = \sum_{j=0}^{\textit{leftM}} \textit{dfs}(i+1, \textit{leftM}-j, \lfloor\frac{x+j}{2}\rfloor, \textit{leftK}-\textit{bit}) \cdot \frac{\textit{nums}[i]^j}{j!}
$$

其中枚举的 $j$ 还需要满足 $\textit{bit} \le \textit{leftK}$。

**递归边界**： $i=n$ 时，如果 $\textit{leftM}=0$ 且 $x$ 的二进制中恰好有 $\textit{leftK}$ 个 $1$，那么找到了一个合法序列，返回 $1$，否则返回 $0$。此外，如果 $\textit{leftM}=0$ 或者 $\textit{leftK}=0$，则后续无法选任何数，同理返回 $0/1$。

**递归入口**： $\textit{dfs}(0, m, 0, k)$，将它乘以 $m!$ 就是答案。

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此用记忆化搜索来优化。

预处理增加 $\textit{powV}[i][j] = \textit{nums}[i]^j$，提前计算阶乘/逆元，则无需递归内再慢慢计算，从而加速计算过程。

其他细节不再阐述，代码如下，已附加详细注释：

```Python
# python
MOD = 1_000_000_007
# 定义阶乘数组的最大长度
MX = 31

# 预计算阶乘
fac = [0] * MX  # fac[i] = i!
fac[0] = 1
for i in range(1, MX):
    fac[i] = fac[i - 1] * i % MOD

# 预计算阶乘的逆元，使用费马小定理
inv_f = [0] * MX  # inv_f[i] = (i!)^(-1) mod MOD
inv_f[-1] = pow(fac[-1], -1, MOD)
for i in range(MX - 1, 0, -1):
    inv_f[i - 1] = inv_f[i] * i % MOD

class Solution:
    def magicalSum(self, m: int, k: int, nums: List[int]) -> int:
        n = len(nums)
        # 预计算 nums 中每个数的幂，pow_v[i][j] = nums[i]^j
        pow_v = [[1] * (m + 1) for _ in range(n)]
        for i, v in enumerate(nums):
            for j in range(1, m + 1):
                pow_v[i][j] = pow_v[i][j - 1] * v % MOD

        @cache
        def dfs(i, left_m, x, left_k):
            """
                i: 当前考虑 nums 的第 i 个数
                left_m: 剩余可选的元素总数
                x: S 的更高位部分（S >> i）的进位
                left_k: S 的二进制表示中还需要的 1 的个数
            """
            c1 = x.bit_count() # 计算当前进位 x 中 1 的个数
            
            # 可行性剪枝：
            # 如果当前进位中 1 的个数加上剩余可选元素总数还小于需要的 1 的个数
            # 说明无论如何也凑不够 left_k 个 1
            if c1 + left_m < left_k:
                return 0
            
            # 递归出口
            # 1. 所有数字都考虑完了
            # 2. 没有剩余可选元素了
            # 3. 不需要更多的 1 了
            if i == n or left_m == 0 or left_k == 0:
                # 只有当所有元素都用完并且进位 x 恰好凑够了需要的 1 的个数时
                # 才是一种有效的组合，返回 1，否则返回 0
                return 1 if left_m == 0 and c1 == left_k else 0

            res = 0

            # 枚举选择 j 个 nums[i]
            for j in range(left_m + 1):
                # 由于我们是按位考虑，这里只关心对第 i 位及之后的影响
                # (x + j) 表示当前位的总和
                # 计算 (x + j) 的最低位，即对 S 的第 i 位的影响
                # 如果为 1，则 left_k 减 1
                bit = (x + j) & 1
                
                # 递归到下一位 (i + 1)
                # left_m - j: 剩余可选元素数量
                # (x + j) >> 1: 新的进位，传递到更高位
                # left_k - bit: 剩余需要的 1 的数量
                r = dfs(i + 1, left_m - j, (x + j) >> 1, left_k - bit)
                
                # r 是子问题的解
                # pow_v[i][j] 是 nums[i]^j，代表选择 j 个 nums[i] 的那部分的乘积
                # inv_f[j] 是 1/j!，因为这里我们只关心选择的个数，不关心顺序
                # 所以要除以 j! 来处理重复组合
                res += r * pow_v[i][j] * inv_f[j]
                
            return res % MOD

        # 最终结果需要乘以 m!，因为我们之前除去了顺序的影响
        return dfs(0, m, 0, k) * fac[m] % MOD
```

```Java
// java
class Solution {
    private static final int MOD = 1_000_000_007;
    // 定义阶乘数组的最大长度
    private static final int MX = 31;

    private static final long[] F = new long[MX]; // F[i] = i!
    private static final long[] INV_F = new long[MX]; // INV_F[i] = i!^-1

    static {
        // 预计算阶乘
        F[0] = 1;
        for (int i = 1; i < MX; i++) {
            F[i] = F[i - 1] * i % MOD;
        }
        // 预计算阶乘的逆元，使用费马小定理
        INV_F[MX - 1] = pow(F[MX - 1], MOD - 2);
        for (int i = MX - 1; i > 0; i--) {
            INV_F[i - 1] = INV_F[i] * i % MOD;
        }
    }

    private static long pow(long x, int n) {
        // 快速幂
        long res = 1;
        for (; n > 0; n /= 2) {
            if (n % 2 > 0) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
        }
        return res;
    }

    public int magicalSum(int m, int k, int[] nums) {
        int n = nums.length;
        int[][] powV = new int[n][m + 1];
        // 预计算 nums 中每个数的幂，pow_v[i][j] = nums[i]^j
        for (int i = 0; i < n; i++) {
            powV[i][0] = 1;
            for (int j = 1; j <= m; j++) {
                powV[i][j] = (int) ((long) powV[i][j - 1] * nums[i] % MOD);
            }
        }

        // 记忆化
        int[][][][] memo = new int[n][m + 1][m / 2 + 1][k + 1];
        for (int[][][] a : memo) {
            for (int[][] b : a) {
                for (int[] c : b) {
                    Arrays.fill(c, -1);
                }
            }
        }

        // 最终结果需要乘以 m!，因为我们之前除去了顺序的影响
        return (int) (dfs(0, m, 0, k, powV, memo) * F[m] % MOD);
    }

    // i: 当前考虑 nums 的第 i 个数
    // left_m: 剩余可选的元素总数
    // x: S 的更高位部分（S >> i）的进位
    // left_k: S 的二进制表示中还需要的 1 的个数
    private long dfs(int i, int leftM, int x, int leftK, int[][] powV, int[][][][] memo) {
        // 计算当前进位 x 中 1 的个数
        int c1 = Integer.bitCount(x);
        // 可行性剪枝
        // 如果当前进位中 1 的个数加上剩余可选元素总数还小于需要的 1 的个数
        // 说明无论如何也凑不够 left_k 个 1
        if (c1 + leftM < leftK) {
            return 0;
        }

        // 递归出口
        // 1. 所有数字都考虑完了
        // 2. 没有剩余可选元素了
        // 3. 不需要更多的 1 了
        if (i == powV.length || leftM == 0 || leftK == 0) {
            // 只有当所有元素都用完并且进位 x 恰好凑够了需要的 1 的个数时
            // 才是一种有效的组合，返回 1，否则返回 0
            return leftM == 0 && c1 == leftK ? 1 : 0;
        }

        // 已经计算过
        if (memo[i][leftM][x][leftK] != -1) {
            return memo[i][leftM][x][leftK];
        }

        long res = 0;
        // 枚举选择 j 个 nums[i]
        for (int j = 0; j <= leftM; j++) {
            // 由于我们是按位考虑，这里只关心对第 i 位及之后的影响
            // (x + j) 表示当前位的总和
            // 计算 (x + j) 的最低位，即对 S 的第 i 位的影响
            // 如果为 1，则 left_k 减 1
            int bit = (x + j) & 1;

            // 递归到下一位 (i + 1)
            // left_m - j: 剩余可选元素数量
            // (x + j) >> 1: 新的进位，传递到更高位
            // left_k - bit: 剩余需要的 1 的数量
            long r = dfs(i + 1, leftM - j, (x + j) >> 1, leftK - bit, powV, memo);

            // r 是子问题的解
            // pow_v[i][j] 是 nums[i]^j，代表选择 j 个 nums[i] 的那部分的乘积
            // inv_f[j] 是 1/j!，因为这里我们只关心选择的个数，不关心顺序
            // 所以要除以 j! 来处理重复组合
            res = (res + r * powV[i][j] % MOD * INV_F[j]) % MOD;
        }

        // 记忆化
        return memo[i][leftM][x][leftK] = (int) res;
    }
}
```

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数共有四个，状态个数等于 $O(nm^2k)$，单个状态的计算时间为 $O(m)$，所以总时间复杂度为 $O(nm^3k)$。

注意，预处理阶乘及逆元的部分，被提到 **静态** 代码块中，会提前进行计算。力扣平台是多次调用 $magicalSum$ 方法跑所有样例，所以预处理中的内容只会计算一次。对应的时间与空间，每次都均摊至 $O(1)$。

- 时间复杂度： $O(nm^3k)$，其中 $n$ 为数组 $nums$ 的长度
- 空间复杂度： $O(nm^2k)$，保存多少状态，就需要多少空间

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-sum-of-array-product-of-magical-sequences/solutions/3803880/dfs-zu-he-shu-xue-mei-ju-zhong-fu-ci-shu-1kek/)
