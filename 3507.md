[Problem: 3507. 移除最小数对使数组有序 I](https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-i/description/)

### 递归 & 模拟

题意：计算相邻对的元素和，最小那对的左边元素会 “吃掉” 右边元素，直到这个数组递增。

每次的操作相同，并且一次操作后会将整个序列变为子序列，因此想到 **递归**。

定义 $dfs(arr,op)$ 表示已经完成 $op$ 次操作，继续对数组 $arr$ 进行操作，返回总操作次数。

不用递归也行，但递归的写法相对优雅，这里做一个简洁介绍。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        def dfs(nums, operations):
            # 基本情况：如果数组已经是非递减的，返回操作次数
            if all(nums[i] <= nums[i+1] for i in range(len(nums)-1)):
                return operations
            
            # 找到相邻元素对中和最小的最左边一对
            min_sum = float('inf')
            min_index = -1
            for i in range(len(nums)-1):
                cur_sum = nums[i] + nums[i+1]
                if cur_sum < min_sum:
                    min_sum = cur_sum
                    min_index = i
            
            # 用这对元素的和替换这对元素
            new_nums = nums[:min_index] + [min_sum] + nums[min_index+2:]
            
            # 递归处理新数组
            return dfs(new_nums, operations + 1)
        
        return dfs(nums, 0)
```

```Java
// java
class Solution {
    public int minimumPairRemoval(int[] nums) {
        // 将数组转换为 List
        List<Integer> list = new ArrayList<>();
        for (int num : nums) list.add(num);
        return dfs(list, 0);
    }

    private int dfs(List<Integer> nums, int operations) {
        // 基本情况：如果数组已经是非递减的，返回操作次数
        boolean isSorted = true;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums.get(i) > nums.get(i + 1)) {
                isSorted = false;
                break;
            }
        }
        if (isSorted) {
            return operations;
        }

        // 找到相邻元素对中和最小的最左边一对
        int min_sum = 50001;
        int min_index = -1;
        for (int i = 0; i < nums.size() - 1; i++) {
            int cur_sum = nums.get(i) + nums.get(i + 1);
            if (cur_sum < min_sum) {
                min_sum = cur_sum;
                min_index = i;
            }
        }

        // 用这对元素的和替换这对元素
        List<Integer> new_nums = new ArrayList<>();
        for (int i = 0; i < min_index; i++) {
            new_nums.add(nums.get(i));
        }
        new_nums.add(min_sum);
        for (int i = min_index + 2; i < nums.size(); i++) {
            new_nums.add(nums.get(i));
        }

        // 递归处理新数组
        return dfs(new_nums, operations + 1);
    }
}
```

- 时间复杂度： $O(n^2)$，递归深度为 $O(n)$，每次操作时间为 $O(n)$，等差数列求和
- 空间复杂度： $O(n^2)$，每一层递归都创建了一个新的数组列表

---

### 模拟

我们直接运用模拟大法，一边计算相邻对元素和，一边判断数组是否非递减。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        ans = 0
        
        while len(nums) > 1:
            n = len(nums)
            min_pair_sum = inf  # 最小相邻和
            merge_idx = -1  # 相邻融合的左边元素
            is_sorted = True  # 假设当前轮次是有序的
            
            for i in range(1, n):
                prev, curr = nums[i - 1], nums[i]
                
                # 检查递增性
                if curr < prev:
                    is_sorted = False
                
                # 寻找最小相邻和
                cur_sum = prev + curr
                if cur_sum < min_pair_sum:
                    min_pair_sum = cur_sum
                    merge_idx = i - 1
            
            # 如果全数组已经是非递减的，提前结束
            if is_sorted:
                break

            # 合并
            ans += 1
            nums[merge_idx] = min_pair_sum
            nums.pop(merge_idx + 1)
        
        return ans
```

```Java
// java
class Solution {
    public int minimumPairRemoval(int[] nums) {
        List<Integer> list = new ArrayList<>();
        for (int num : nums) list.add(num);

        int ans = 0;

        while (list.size() > 1) {
            int n = list.size();
            int min_pair_sum = 50001; // 最小相邻和
            int merge_idx = -1; // 相邻融合的左边元素
            boolean is_sorted = true; // 假设当前轮次是有序的

            for (int i = 1; i < n; i++) {
                int prev = list.get(i - 1);
                int curr = list.get(i);

                // 检查递增性
                if (curr < prev) {
                    is_sorted = false;
                }

                // 寻找最小相邻和
                int cur_sum = prev + curr;
                if (cur_sum < min_pair_sum) {
                    min_pair_sum = cur_sum;
                    merge_idx = i - 1;
                }
            }

            // 如果全数组已经是非递减的，提前结束
            if (is_sorted) {
                break;
            }

            // 合并
            ans += 1;
            list.set(merge_idx, min_pair_sum);
            list.remove(merge_idx + 1);
        }

        return ans;
    }
}
```

或者另一种写法：

```Python
# python
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        ans = 0

        while True:
            is_sorted = True
            # 最小和的相邻对
            best_left, best_right = 0, 1
            
            for i in range(1, len(nums)):
                # 是否非递减
                if nums[i - 1] > nums[i]:
                    is_sorted = False
                
                # 当前对的和 < 记录的最佳对的和
                if nums[i - 1] + nums[i] < nums[best_left] + nums[best_right]:
                    best_left, best_right = i - 1, i
            
            if is_sorted:
                break
            else:
                # 执行合并
                nums[best_left] += nums[best_right]
                del nums[best_right]
             
            ans += 1

        return ans
```

```Java
// java
class Solution {
    public int minimumPairRemoval(int[] nums) {
        List<Integer> list = new ArrayList<>();
        for (int num : nums) list.add(num);

        int ans = 0;

        while (true) {
            //防止 list.get 越界
            if (list.size() < 2) break;

            boolean is_sorted = true;
            // 最小和的相邻对
            int best_left = 0, best_right = 1;

            for (int i = 1; i < list.size(); i++) {
                // 是否非递减
                if (list.get(i - 1) > list.get(i)) {
                    is_sorted = false;
                }

                // 当前对的和 < 记录的最佳对的和
                int currentSum = list.get(i - 1) + list.get(i);
                int bestSum = list.get(best_left) + list.get(best_right);
                
                if (currentSum < bestSum) {
                    best_left = i - 1;
                    best_right = i;
                }
            }

            if (is_sorted) {
                break;
            } else {
                // 执行合并
                int sum = list.get(best_left) + list.get(best_right);
                list.set(best_left, sum);
                list.remove(best_right);
            }

            ans += 1;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n^2)$，弹出或删除元素会使后续所有元素移动，每次操作近乎 $O(n)$
- 空间复杂度： $O(n)$，不过 $Python$ 是原地 $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-i/solutions/3886461/mo-ni-di-gui-di-tui-san-chong-bu-tong-xi-ztr2/)
