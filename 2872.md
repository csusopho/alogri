[Problem: 2872. 可以被 K 整除连通块的最大数目](https://leetcode.cn/problems/maximum-number-of-k-divisible-components/description/)

### 方法：DFS

题意：断连某些边，将一棵树变为多个连通块，每个块的总和能被整除 $k$。

在树形结构中遍历，联想到 $DFS$。如何让连通块数最多？一个 **贪心** 想法：只要某棵子树的总和能被 $k$ 整除，就立刻切分，让它单独作为一个连通块。

为什么贪心策略正确？

假设我们在节点 $u$ 处，计算出以 $u$ 为根的子树总和为 $S_u$。

1）**若 $S_u \% k == 0$**：

- 这个子树本身已经满足 “合法连通块” 的条件。
- 如果我们将它保留，连接到父节点 $p$，它对父节点 $p$ 所在的连通块的总和贡献是 $S_u$。
- 在模 $k$ 的运算下， $(S_p + S_u) \% k$ 等价于 $(S_p + 0) \% k$。也就是说，**保留这个子树对父节点凑成 $k$ 的倍数没有任何帮助**（贡献为 $0$）。
- 既然保留它没有帮助，而切断它能直接让连通块数量 $+1$，根据贪心原则，最优解必然包含这个切割。

2）**若 $S_u \% k \neq 0$**：

- 这个子树不能独立存在。
- 因此，必须保留它与父节点的连接，将其值累加到父节点上，期待与父节点或其他兄弟节点合并后凑成 $k$ 的倍数。

**结论**：我们在遍历过程中，一旦遇到满足条件的子树就立即分割，这样一定能得到最大的连通块数量。

---

为什么不同根节点只会有一个答案（**根无关性**）？

**基于切割边的性质：**

- 在这个问题中，我们将树分割成若干连通块，本质上是选择树上的某些边进行 **删除**。
- 判断一条边 $(u, v)$ **是否可以被删除的条件** 是：如果不经过这条边，整个树被分成的两部分（一部分包含 $u$，另一部分包含 $v$），它们各自的和是否都能被 $k$ 整除。
- 题目隐含条件是 **整棵树的总和** $S_{total}$ 一定能被 $k$ 整除，即 $S_{total} \equiv 0 \pmod k$。
- 设边 $(u, v)$ 将树分为集合 $A$ 和集合 $B$，如果 $\sum A \equiv 0 \pmod k$，那么必然有 $\sum B = S_{total} - \sum A \equiv 0 - 0 \equiv 0 \pmod k$。
- 这意味着，一条边是否是 “合法切割边”，只取决于树的结构和数值分布，而是一个 **全局属性**，不依赖于我们是从 $u$ 走到 $v$ 还是从 $v$ 走到 $u$。

**遍历视角的统一：**
换一个根节点进行 $DFS$ 时，我们只是改变了遍历边的顺序。但是，

- 所有满足 “子树和能被 $k$ 整除” 的边，在任何遍历顺序下，当 $DFS$ 回溯经过这条边时，都会发现该侧连通块的和是 $k$ 的倍数。
- 算法统计的是 “有多少个子树满足条件”。由于总和是 $k$ 的倍数，整棵树最后剩下的那个部分（包含根的部分）也一定满足条件。
- 因此，无论以谁为根，被判定为 “可以切断” 的边的集合是完全固定的。答案（连通块数）等于 **可切断的边数 +1**，这个值是恒定的。

那么，我们如何编写 $DFS$ 代码？递归，先递再归。

- 从父节点 “递” 下去，累加所有子节点（子树）和；
- 从子节点 “归” 上来，根据和判断是否切割当前节点。

**定义** $dfs(u,p)$ 计算以 $u$ 为根的子树剩余的、无法独立分割的值的总和，并将贡献给父节点 $p$。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        # 建立无向图
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        self.ans = 0
        
        # 当前节点是 u，父节点是 p，返回子树的累加和
        def dfs(u, p):
            # 当前子树的总和
            cur_sum = values[u]
            
            for v in adj[u]:
                if v != p:
                    # 累加子树返回的剩余值
                    cur_sum += dfs(v, u)
            
            # 贪心判断
            # 是否在 u 和 p 之间切一刀
            if cur_sum % k == 0:
                self.ans += 1
                return 0  # 该连通块已独立
            else:
                return cur_sum  # 不能独立
        
        # 从任意节点开始遍历
        dfs(0, -1)
        return self.ans
```

```Java
// java
class Solution {
    private int ans;
    private List<Integer>[] adj;
    
    public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) {
        // 建立无向图
        adj = new ArrayList[n];
        Arrays.setAll(adj, i -> new ArrayList<>());
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            adj[u].add(v);
            adj[v].add(u);
        }
        
        this.ans = 0;
        
        // 从任意节点开始遍历
        dfs(0, -1, values, k);
        return this.ans;
    }

    // 当前节点是 u，父节点是 p，返回子树的累加和
    private long dfs(int u, int p, int[] values, int k) {
        // 当前子树的总和
        long cur_sum = values[u];
        
        for (int v : adj[u]) {
            if (v != p) {
                // 累加子树返回的剩余值
                cur_sum += dfs(v, u, values, k);
            }
        }
        
        // 贪心判断
        // 是否在 u 和 p 之间切一刀
        if (cur_sum % k == 0) {
            this.ans += 1;
            return 0;  // 该连通块已独立
        } else {
            return cur_sum;  // 不能独立
        }
    }
}
```

- 时间复杂度： $O(n)$，构建一次邻接表，递归时每个节点访问一次
- 空间复杂度： $O(n)$，表示邻接表 $adj$ 以及递归栈的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/3844066/tan-xin-zi-shu-li-ke-qie-fen-shuo-ming-t-z4uk/)
