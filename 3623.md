[Problem: 3623. 统计梯形的数目 I](https://leetcode.cn/problems/count-number-of-trapezoids-i/description/)

### 方法：组合数学+前缀和

什么是梯形？两条对边平行，其余两边随意。在本题中，“水平梯形” 要求这一对（两条）边是平行于 $x$ 轴。

也即，我们需要找到四个点，其中两个点的纵坐标 $y1$ 相同，构成一条底边，另外两个点的纵坐标 $y2$ 也相同，构成另一条底边，但这两个纵坐标的值不能相等（不然就变成线段了）。

因此，容易想到对 $y$ 坐标进行 **排序** 分组，让相同的 $(x1,y),(x2,y)\dots$ 划分为一组。

对于任意一个 $y$ 坐标，如果组内有 $k$ 个点，那么可以选择的水平线段（由两个点组成）数量为组合数 $C_k^2 = \frac{k \times (k-1)}{2}$。如果 $k < 2$，则无法构成线段，数量为 $0$。

假设在 $y_i$ 处有 $a$ 条线段，在 $y_j$ 处有 $b$ 条线段，那么这两层可以组成的梯形数量为 $a \times b$。最终是计算所有不同高度对 $(y_i, y_j)$ 的线段数量 **乘积之和**。

假设预处理后，不同 $y$ 对应的线段数量列表为 $[s_1, s_2, s_3, \dots, s_m]$，那么答案是 $\sum_{i < j} (s_i \times s_j)$。

如果我们使用 **暴力** 双 $for$，外层循环选择一行作为 “底边” 索引 $i$，内层循环选择另一行作为 “顶边” 索引 $j$，时间复杂度近似 $O(n^2)$，会超时！

本质上，上面的过程是计算 $s_i$ 与 $s_0,\dots,s_{i-1}$ 的乘积。因此，通过 **前缀和** 的思想在线性时间内完成：在遍历列表时，将当前数值 $s_i$ 乘以 “之前所有数值之和”，累加到结果中，然后更新 “之前所有数值之和”。

也即，将下式

$$
Ans = \sum_{i} \sum_{j < i} (Seg_i \times Seg_j)
$$

利用乘法分配律（前缀和思想），优化为

$$
Ans = \sum_{i} (Seg_i \times \sum_{j < i} Seg_j)
$$

代码如下，已附加注释：

```Python
# python
class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        MOD = 10**9 + 7
        n = len(points)
        
        # 按 y 坐标排序
        points.sort(key=lambda p: p[1])
        ans = 0
        prefix_segs = 0  # 之前所有的水平线段数
        
        i = 0
        while i < n:
            # 这一组 y 的起点
            start = i
            current_y = points[i][1]
            # 连续 y 相同的段
            while i < n and points[i][1] == current_y:
                i += 1
            
            # 当前这一层点数
            count = i - start
            # 计算能构成的线段数
            if count >= 2:
                current_segs = count * (count - 1) // 2
                # 当前层线段 * 之前所有层的线段
                ans = (ans + current_segs * prefix_segs) % MOD
                # 更新前缀和
                prefix_segs = (prefix_segs + current_segs) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int countTrapezoids(int[][] points) {
        int MOD = 1000000007;
        int n = points.length;
        
        // 按 y 坐标排序
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        long ans = 0;
        long prefix_segs = 0;  // 之前所有的水平线段数
        
        int i = 0;
        while (i < n) {
            // 这一组 y 的起点
            int start = i;
            int current_y = points[i][1];
            // 连续 y 相同的段
            while (i < n && points[i][1] == current_y) {
                i++;
            }
            
            // 当前这一层点数
            long count = i - start;
            // 计算能构成的线段数
            if (count >= 2) {
                long current_segs = count * (count - 1) / 2;
                // 当前层线段 * 之前所有层的线段
                ans = (ans + current_segs * prefix_segs) % MOD;
                // 更新前缀和
                prefix_segs = (prefix_segs + current_segs) % MOD;
            }
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $points$ 的长度，瓶颈在于排序
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

---

### 哈希

如果使用了排序，那就结合双指针将同样的 $y$ 值进行分组。换个思路，没必要使用排序，改换成 **哈希表** 存储 `(y值，组内点数)` 进行分组也同理。

**流程**：先计算每个 $y$ 坐标的组内点数，然后计算水平边的数量，最后利用上面的公式 & 前缀和，累加答案数。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        MOD = 10**9 + 7
    
        # 统计每个 y 坐标上的点数
        y_counts = defaultdict(int)
        for x, y in points:
            y_counts[y] += 1
        
        # 每个 y 坐标能形成的水平边数量
        segment_counts = []
        for count in y_counts.values():
            if count >= 2:
                segs = count * (count - 1) // 2
                segment_counts.append(segs)
        
        # 所有不同 y 坐标对的线段数乘积之和
        ans = 0
        cur_sum = 0

        # 对于当前的线段数 seg，它能与之前所有累积的线段数 cur_sum 进行组合
        for seg in segment_counts:
            # 累加：当前层的线段数 * 之前所有层的线段总数
            ans = (ans + seg * cur_sum) % MOD
            # 更新前缀和
            cur_sum = (cur_sum + seg) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int countTrapezoids(int[][] points) {
        int MOD = 1000000007;
    
        // 统计每个 y 坐标上的点数
        Map<Integer, Integer> y_counts = new HashMap<>();
        for (int[] p : points) {
            y_counts.put(p[1], y_counts.getOrDefault(p[1], 0) + 1);
        }
        
        // 每个 y 坐标能形成的水平边数量
        List<Long> segment_counts = new ArrayList<>();
        for (int count : y_counts.values()) {
            if (count >= 2) {
                long segs = (long) count * (count - 1) / 2;
                segment_counts.add(segs);
            }
        }
                
        // 所有不同 y 坐标对的线段数乘积之和
        long ans = 0;
        long cur_sum = 0;

        // 对于当前的线段数 seg，它能与之前所有累积的线段数 cur_sum 进行组合
        for (long seg : segment_counts) {
            // 累加：当前层的线段数 * 之前所有层的线段总数
            ans = (ans + seg * cur_sum) % MOD;
            // 更新前缀和
            cur_sum = (cur_sum + seg) % MOD;
        }
        
        return (int) ans;
    }
}
```

实际上，没必要单独拆分出一个 $for$ 循环去计算 “水平线段数”，将它与 “计算答案” 的过程合二为一即可。简化代码后，性能稍许提升，实测 $Python$ 运行时间为 $68ms$，超过 $93\%$。

```Python
# python
class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        MOD = 1_000_000_007
        
        # 统计每个 y 坐标上点数
        point_counts = Counter(y for _, y in points).values()
        
        ans = 0
        prev_segments = 0  # 记录之前所有层能构成的水平边总数
        
        for count in point_counts:
            # 当前层能构成的水平边数量
            curr_segments = count * (count - 1) // 2
            
            if curr_segments > 0:
                # 累加：当前层边数 * 之前所有层的边数
                ans = (ans + curr_segments * prev_segments) % MOD
                # 更新前缀和
                prev_segments = (prev_segments + curr_segments) % MOD
        
        return ans
```

```Java
// java
class Solution {
    public int countTrapezoids(int[][] points) {
        int MOD = 1000000007;
        
        // 统计每个 y 坐标上点数
        Map<Integer, Integer> point_counts = new HashMap<>();
        for (int[] p : points) {
            point_counts.put(p[1], point_counts.getOrDefault(p[1], 0) + 1);
        }
        
        long ans = 0;
        long prev_segments = 0;  // 记录之前所有层能构成的水平边总数
        
        for (int count : point_counts.values()) {
            // 当前层能构成的水平边数量
            long curr_segments = (long) count * (count - 1) / 2;
            
            if (curr_segments > 0) {
                // 累加：当前层边数 * 之前所有层的边数
                ans = (ans + curr_segments * prev_segments) % MOD;
                // 更新前缀和
                prev_segments = (prev_segments + curr_segments) % MOD;
            }
        }
        
        return (int) ans;
    }
}
```

- 时间复杂度： $O(n)$，线性遍历
- 空间复杂度： $O(n)$，表示哈希表 $yCounts$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-number-of-trapezoids-i/solutions/3847027/san-jie-zhao-shui-ping-xian-duan-zu-he-s-mgcm/)
