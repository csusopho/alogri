[Problem: 1884. 鸡蛋掉落-两枚鸡蛋](https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/description/)

### 方法：记忆化搜索 & 动规

题意：有 *两个* 鸡蛋，它们都是究极“钢蛋”。如果从楼上扔下，只会在大于 $f$ 层的高度碎掉，也即 $f$ 是极限 $dead$ 线，求找到它的最少步骤。

如果总楼层数 $n=8$，那么 $f$ 的值只可能是 $1$ ~ $8$ 中的某个数。那该怎么找到它呢？

假设选择从 $3$ 楼扔下去一个蛋：

- 如果蛋碎了，那 $f$ 一定是 $1,2,3$ 中的某个数
- 如果蛋没碎，那 $f$ 一定是 $4,5,6,7,8,9$ 中的某个数

注意，你只有两个蛋，即只有两次碎的机会！

- 如果第一枚蛋碎了，只能尝试从 $1$ 楼、 $2$ 楼、 $3$ 楼开始扔第二枚蛋，不能换成其他 **顺序**，否则无法确定到底是哪一层
- 如果第一枚蛋没碎，就尝试在 $4$ ~ $8$ 楼中任意挑一楼继续扔下它

对于“猜数字”游戏，它的最快方法就是不断折半。对于本题来说，同样也有技巧。

**策略**：让第一枚蛋成为“冤种”，利用它去探路。一旦它碎了，第二枚蛋就只能顺序枚举；一旦它没碎，就利用它继续探路。

### 记忆化搜索

“探路”的楼层怎么选择？不清楚规律的话，就暴力一点，每层楼都尝试看看。

还是上面的例子，第一枚蛋能在 $1$ ~ $9$ 中任意选；如果没碎，第二次就在 $4$ ~ $9$ 中任意选。这意味着，在一次选择后，会把原问题变成一个和原问题 *相似的、规模更小* 的子问题。这时候就可以用 **递归** 解决。

**定义** $dfs(i)$ 表示在一共 $i$ 层楼的建筑上扔鸡蛋，能确定 $f$ 的最小操作次数。

如果第一枚蛋选择在第 $j$ 楼扔下，有两种情况：

- 蛋碎了，那就只能按照 $1$ ~ $j-1$ 的顺序扔第二枚蛋，加上最初的一步一共 $j$ 次操作
- 蛋没碎，那就尝试在 $j+1$ ~ $i$ 的楼层继续扔，一共 $dfs(i-j)+1$ 次操作

为什么是 $i-j$？如果答案 $f=4$，在 $4$ ~ $9$ 楼去尝试；和答案 $f=1$，在 $1$ ~ $6$ 楼去尝试是一样的。这两种情况需要的操作次数一致，所以能等价替换。

两种情况取 **最大**。因为不确定蛋到底碎没碎，想要确定得到最终的 $f$ 值，步骤更多才能确保一定方案可行。

上面说的是在第 $j$ 层楼扔的情况，我们需要每层楼都进行尝试，枚举所有可能。所有楼层取 **最小**，因为是最佳方案。

得到下面的 **转移方程**：

$$
dfs(i) = \min_{j=1}^{i} \max(j, dfs(i - j) + 1)
$$

不好理解最大最小？想象自己是一个游戏玩家，锻造武器的关键点是多少不清楚，为了百分百成功，一定是选择花费多的方案，这属于不可控部分；但是，不同地点的属性加成还是清楚的，一定是挑花费少的风水宝地。

**递归边界**： $dfs(0)=0$，最少一层楼，第 $0$ 层楼不需要扔鸡蛋。

**递归目标**： $dfs(n)$，表示总共 $n$ 层楼，递归寻找答案。

**递归方向**：从大到小，状态 $i$ 的值需要状态 $i-j$ 的值，内部枚举所有可能

整个递归中有大量重复递归调用（递归参数相同）。由于 **递归函数没有副作用**，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化。

**记忆化** 的本质就是减少分支数，避免重复搜索，降低时间复杂度。递归的参数只有一个，所以记忆化数组只需要一维。 $Java$ 中使用数组记录， $Python$ 中直接使用 $@cache$ 装饰器即可。

记忆化数组的初始值只要不等于某个 $dfs$ 的状态值即可，这里不赋初值，默认为 $0$ 就行，因为楼层数大于等于 $1$，操作次数一定大于 $0$。

实现上面的过程，代码如下，已附加注释：

```Python
# python
@cache  # 记忆化
def dfs(i: int) -> int:
    if i == 0:  # 边界值
        return 0
    # 所有方案取最小
    return min(max(j, dfs(i - j) + 1) for j in range(1, i + 1))

class Solution:
    def twoEggDrop(self, n: int) -> int:
        return dfs(n)
```

```Java
// java
public class Solution {
    // 存储记忆化结果
    private Map<Integer, Integer> memo = new HashMap<>();
    
    // 递归
    private int dfs(int i) {
        if (i == 0) {  // 边界值
            return 0;
        }
        if (memo.containsKey(i)) {  // 计算过
            return memo.get(i);
        }
        // 所有方案取最小
        int minResult = Integer.MAX_VALUE;
        for (int j = 1; j <= i; j++) {
            minResult = Math.min(minResult, Math.max(j, dfs(i - j) + 1));
        }
        memo.put(i, minResult);  // 记忆化
        return minResult;
    }
    
    public int twoEggDrop(int n) {
        return dfs(n);
    }
}
```

记忆化后，每个状态只会计算一次，时间复杂度 = 状态个数 $×$ 单个状态的计算时间。本题尝试 $1$ ~ $n$ 的所有楼层，一共 $n$ 个状态；每个状态内部进行 $for$ 循环枚举，时间为 $O(n)$，所以总的时间复杂度为 $O(n^2)$。

- 时间复杂度： $O(n^2)$，其中 $n$ 为楼层总数，且 $n\leq 1000$
- 空间复杂度： $O(n)$，保存多少状态，就需要多少空间

---

### 动态规划

将递归 $1:1$ 转为递推。

**定义** $dp[i]$ 表示在一共 $i$ 层楼的建筑上扔鸡蛋，能确定 $f$ 的最小操作次数。

**状态转移方程**：

$$
dp[i] = \min_{j=1}^{i} \max(j, dp[i - j] + 1)
$$

**递推边界**： $dp[0]=0$，最少一层楼，第 $0$ 层楼不需要扔鸡蛋。

**初始化**：全部赋值为 $+\infty$ 表示没有计算过。

**方向**：从小到大， $dp[i]$ 的值需要状态 $dp[i-j]$ 的值。

目标： $dp[n]$，表示总共 $n$ 层楼。

动规五部曲在上面都已经加粗表示。代码如下，已附加详细注释：

```Python
# python
class Solution:
    def twoEggDrop(self, n: int) -> int:
        dp = [float('inf')] * (n + 1)
        dp[0] = 0  # 边界
        for i in range(1, n + 1):  # 从小到大
            for j in range(1, i + 1):  # 使用前面的状态递推后面的状态
                dp[i] = min(dp[i], max(j, dp[i - j] + 1))
        return dp[n]
```

```Java
// java
public class Solution {
    public int twoEggDrop(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {  // 从小到大
            for (int j = 1; j <= i; j++) {  // 使用前面的状态递推后面的状态
                dp[i] = Math.min(dp[i], Math.max(j, dp[i - j] + 1));
            }
        }
        return dp[n];
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 为楼层总数，且 $n\leq 1000$
- 空间复杂度： $O(n)$，表示辅助 $dp$ 数组的空间

总数据量不大，~~甚至可以打表~~。数值都是固定的，可以使用 $static$ 预处理，将计算动规数组的部分移到静态块中，这样力扣就只会计算一次，大幅优化时间。

当然，本题也能从数学的角度出发，找规律。在示例 $2$ 中，楼层是从 $100\rightarrow 99\rightarrow 97\rightarrow 94\rightarrow 90\dots$ 依次减 $1,2,3,4,5,\dots$ 直至楼层数等于 $0$。

这些元素的差是一个首项为 $1$ 公差为 $1$ 的等差数列，可以猜测最优策略应该是从 $n$ 开始倒序减去等差数列的项，不断相减就能得到答案。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solutions/2948715/chang-gui-shuang-jie-ji-yi-hua-sou-suo-d-pmak/)
