[Problem: 2419. 按位与最大的最长子数组](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/description/)

### 方法：两/一次遍历

与 $AND$ 运算规则：`0 & 0 = 0`，`0 & 1 = 0`，`1 & 1 = 1`。也就是说，与运算的结果只能 **不变或减小**！想要让按位与最大，那就只能每个数字都最大，且相同。

**转化问题**：寻找子数组，其中每个元素都是 $max(nums)$。

无需使用双指针/滑窗！只需要一个计数器 $cnt$，它用来记录当前这个元素的 **重复次数**。遇到相同元素，则 $cnt+1$；否则，清零 $cnt$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        # 找到数组中的最大值
        mx = max(nums)

        ans = 0
        cnt = 0  # 计数器

        for num in nums:
            if num == mx:
                cnt += 1  # 如果当前值等于最大值，增加计数
            else:
                cnt = 0   # 否则重置计数
            if cnt > ans:
                ans = cnt  # 更新最大长度

        return ans
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        // 找到数组中的最大值
        int mx = -1;
        for (int num : nums) {
            if (num > mx) {
                mx = num;
            }
        }

        int ans = 0;
        int cnt = 0;  // 计数器

        for (int num : nums) {
            if (num == mx) {
                cnt += 1;  // 如果当前值等于最大值，增加计数
            } else {
                cnt = 0;   // 否则重置计数
            }
            if (cnt > ans) {
                ans = cnt;  // 更新最大长度
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，两次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 一次遍历

“寻找最大值” 与 “统计重复次数” 都是从前往后遍历，将两者合二为一！

代码如下，已附加注释：

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        mx = -1  # 最大值
        ans = 0
        cnt = 0  # 计数器

        for num in nums:
            if num > mx:
                # 发现更大的值，更新最大值并重置计数器
                mx = num
                cnt = 1
                ans = 1
            elif num == mx:
                # 如果等于当前最大值，增加连续计数
                cnt += 1
            else:
                # 小于最大值，重置连续计数器
                ans = max(ans, cnt)
                cnt = 0

        return max(ans, cnt)
```

```Java
// java
class Solution {
    public int longestSubarray(int[] nums) {
        int mx = -1;  // 最大值
        int ans = 0;
        int cnt = 0;  // 计数器

        for (int num : nums) {
            if (num > mx) {
                // 发现更大的值，更新最大值并重置计数器
                mx = num;
                cnt = 1;
                ans = 1;
            } else if (num == mx) {
                // 如果等于当前最大值，增加连续计数
                cnt += 1;
            } else {
                // 小于最大值，重置连续计数器
                ans = Math.max(ans, cnt);
                cnt = 0;
            }
        }

        return Math.max(ans, cnt);
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，一次遍历
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

当然，更快的 $Python$ 写法是使用 $groupby$，耗时 $9ms$，超越 $100\%$。

```Python
# python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        mx = max(nums)
        return max(len(list(g)) for c,g in groupby(nums) if c==mx)
```

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solutions/3737375/nao-jin-ji-zhuan-wan-wu-xu-shuang-zhi-zh-aqb1/)
