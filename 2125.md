[Problem: 2125. 银行中的激光束数量](https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/description/)

### 方法：计数

看示例 $1$，很明显，排除空行后，只能 **相邻** 两行进行 **全连接**。假如上一行有 $x$ 个设备，当前一行有 $y$ 个设备，则能产生 $x\times y$ 个激光束。

**做法**：统计每一行中 $1$ 的个数，让相邻两行的数量相乘，然后不断累加即可。

- 将 “统计 $1$” 与 “相乘计算” 计算合二为一，只需要一次遍历；
- 增加 $if$ 判断，如果设备数是 $0$ 直接跳过，速度会更快。

使用上面这两点优化，速度达到最快。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        ans = 0
        # 前一行的设备数量
        pre_cnt = 0

        # 遍历银行的每一行
        for row in bank:
            # 当前行的设备数量
            cur_cnt = row.count('1')
            if cur_cnt == 0:
                continue

            # 当前行的设备会和上一行有设备的行形成激光束
            if pre_cnt > 0:
                ans += pre_cnt * cur_cnt
            
            # 更新“上一个有设备的行”的设备数量
            pre_cnt = cur_cnt
        
        return ans
```

```Java
// java
class Solution {
    public int numberOfBeams(String[] bank) {
        int ans = 0;
        // 前一行的设备数量
        int preCnt = 0;

        // 遍历银行的每一行
        for (String row : bank) {
            // 当前行的设备数量
            int curCnt = 0;
            for (int i = 0; i < row.length(); i++) {
                if (row.charAt(i) == '1') {
                    curCnt++;
                }
            }
            // 如果当前行没有设备
            if (curCnt == 0) {
                continue;
            }

            // 当前行的设备会和上一行有设备的行形成激光束
            if (preCnt > 0) {
                ans += preCnt * curCnt;
            }
            
            // 更新“上一个有设备的行”的设备数量
            preCnt = curCnt;
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n\times m)$，其中 $n,m$ 分别是矩阵 $bank$ 的行数和列数
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 一行流

$\textbf{仅供整活使用，一般不推荐}$，了解语法即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        return sum(pre * cur for pre, cur in pairwise(cnt for cnt in map(lambda r: r.count('1'), bank) if cnt))
```

```Java
// java
class Solution {
    public int numberOfBeams(String[] bank) {
        return Arrays.stream(bank)
                // 将行映射为设备数 
                .map(row -> (int) row.chars().filter(ch -> ch == '1').count())
                // 过滤掉没有设备的行
                .filter(count -> count > 0)
                // 使用 reduce 进行累加计算
                .reduce(new int[]{0, 0}, (acc, curCnt) -> 
                    new int[]{acc[0] + acc[1] * curCnt, curCnt}, 
                    (acc1, acc2) -> acc1)[0];
    }
}
```

- 时间复杂度： $O(n\times m)$
- 空间复杂度： $O(1)$，而 $Java$ 会在循环中创建 “有效行数” $k$ 个小对象

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/solutions/3816441/shuang-jie-ji-shu-mo-ni-ti-su-yi-xing-li-er1m/)
