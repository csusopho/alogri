[Problem: 2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/description/)

### 方法：DFS & DP & 空间优化

什么是 $0-1$ 背包？

- 一个容量为 $W$ 的背包，有 $N$ 个物品；
- 每个物品的重量是 $w_i$，价值是 $v_i$；
- 目标是在不超过背包容量 $W$ 的前提下，让所选物品的总价值最大；
- 每个物品只能选 $0$ 次或 $1$ 次。

这类问题的通解是「记忆化」或「动规」，具体原理及推导，可以看这篇 [题解]((https://leetcode.cn/problems/partition-equal-subset-sum/solutions/3642816/0-1bei-bao-ji-yi-hua-sou-suo-er-wei-dp-y-ljap/))。

实际上，本题也是 $0-1$ 背包问题，

- 目标总和为 $n$ -> 背包总容量是 $n$；
- 用次幂的和组成 $n$ -> 次幂 $2^x,3^x\dots$ 是物品的重量；
- 整数互不相同 -> 每个物品只能选 $0/1$ 次。

最直接想到的 **思路**：每个物品仅有 *选* 或 *不选* 两种可能 —— 递归。

**定义** $dfs(i,r)$ 表示从前往后处理到第 $i$ 个物品时，剩余背包容量是 $r$，能得到的合法方案总数。

第 $i$ 个物品的重量是 $i^x$，下一个物品的重量就是 $(i+1)^x$。转移过程、递归边界等都相对容易，这里不再阐述。

**注意**：背包的上限就是 $n$，物品的重量不可能超过 $n$，所以在预处理所有物品时，提前进行剪枝，不要让重量大于 $n$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        # 添加 1~n 的所有 x 次幂，作为物品备选
        powers = []
        i = 1
        while True:
            p = pow(i, x)
            if p > n:
                break
            powers.append(p)
            i += 1
        m = len(powers)

        @cache
        def dfs(idx, remain):
            if remain == 0:  # 当前是一个可行方案
                return 1
            if remain < 0 or idx == m:  # 不可行
                return 0
            # 不选
            res = dfs(idx + 1, remain)
            # 选
            if remain >= powers[idx]:
                res += dfs(idx + 1, remain - powers[idx])
            return res % MOD

        return dfs(0, n)
```

```java
// java
class Solution {
    static final int MOD = 1_000_000_007;
    private List<Integer> powers;
    private int m;
    private Integer[][] memo;

    public int numberOfWays(int n, int x) {
        // 添加 1~n 的所有 x 次幂，作为物品备选
        powers = new ArrayList<>();
        int i = 1;
        while (true) {
            long p = (long) Math.pow(i, x);
            if (p > n) break;
            powers.add((int) p);
            i++;
        }
        m = powers.size();
        memo = new Integer[m + 1][n + 1];
        return dfs(0, n);
    }

    private int dfs(int idx, int remain) {
        if (remain == 0) { // 当前是一个可行方案
            return 1;
        }
        if (remain < 0 || idx == m) { // 不可行
            return 0;
        }
        if (memo[idx][remain] != null) {
            return memo[idx][remain];
        }

        // 不选当前次幂
        int res = dfs(idx + 1, remain);

        // 选当前次幂
        if (remain >= powers.get(idx)) {
            res = (res + dfs(idx + 1, remain - powers.get(idx))) % MOD;
        }

        return memo[idx][remain] = res % MOD;
    }
}
```

最大底数满足 $i^x\leq n$，将物品总数记作 $m$，则有 $m\leq \left\lfloor n^{1/x} \right\rfloor$。

记忆化后，每个状态只会计算一次。时间复杂度 = 状态个数 $\times$ 单个状态的计算时间。参数一共两个，状态个数等于 $O(m\times n)$，单个状态的计算时间为 $O(1)$，所以总时间复杂度为 $O(m\times n)$。

- 时间复杂度： $O(m\times n)$，其中 $m\leq \left\lfloor n^{1/x} \right\rfloor$
- 空间复杂度： $O(m\times n)$，保存多少状态，就需要多少空间

---

### $DP$

将递归 $1:1$ 转化为递推。

**定义** $dp[i][s]$ 表示用前 $i$ 个不同的 $x$ 次幂（从 $1^x$ 到 $i^x$），凑成和为 $s$ 的方案数。

**边界**： $dp[0][0]=1$ 表示不选任何数，总和为 $0$ 有 $1$ 种方案。

转移过程、递推方向等这里不再阐述。代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        # 预计算所有 <= n 的 x 次幂
        powers = []
        i = 1
        while True:
            p = pow(i, x)
            if p > n:
                break
            powers.append(p)
            i += 1
        m = len(powers)

        # dp[i][s] = 前 i 个次幂构成和 s 的方案数
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 1  # 初始化

        for i in range(1, m + 1):
            for s in range(n + 1):
                # 不选第 i 个次幂
                dp[i][s] = dp[i-1][s]
                # 选第 i 个次幂
                if s >= powers[i-1]:
                    dp[i][s] = (dp[i][s] + dp[i-1][s - powers[i-1]]) % MOD

        return dp[m][n]
```

```java
// java
class Solution {
    static final int MOD = 1_000_000_007;

    public int numberOfWays(int n, int x) {
        // 预计算所有 <= n 的 x 次幂
        List<Integer> powers = new ArrayList<>();
        int base = 1;
        while (true) {
            long p = (long) Math.pow(base, x); // 计算 base^x
            if (p > n) break;
            powers.add((int) p);
            base++;
        }
        int m = powers.size();

        // dp[i][s] = 前 i 个次幂构成和 s 的方案数
        int[][] dp = new int[m + 1][n + 1];
        dp[0][0] = 1; // 初始化：用 0 个数凑出 0，有 1 种方案

        for (int i = 1; i <= m; i++) {
            for (int sum = 0; sum <= n; sum++) {
                // 不选第 i 个次幂
                dp[i][sum] = dp[i - 1][sum];
                // 选第 i 个次幂
                int val = powers.get(i - 1);
                if (sum >= val) {
                    dp[i][sum] = (dp[i][sum] + dp[i - 1][sum - val]) % MOD;
                }
            }
        }

        return dp[m][n];
    }
}
```

- 时间复杂度： $O(m\times n)$，同理
- 空间复杂度： $O(m\times n)$，表示数组 $dp$ 的大小

---

### 空间优化

可以发现，计算状态 $dp[i]$ 时，只会用到 $dp[i-1]$ 的值，不会用到比 $i-1$ 更早的状态。所以能采用 **滚动数组**，优化掉第一维。

回想一下，为什么 $0-1$ 背包问题优化后是倒序枚举？为了避免 **数据污染**。

这里不再赘述细节，详情可以见上面给出的链接。代码如下，已附加注释：

```Python
# python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        # 计算所有 <= n 的 x 次幂
        powers = []
        i = 1
        while True:
            p = pow(i, x)
            if p > n:
                break
            powers.append(p)
            i += 1

        # dp[s] 表示当前已处理的次幂可凑出和 s 的方案数
        dp = [0] * (n + 1)
        dp[0] = 1

        # 遍历每一个次幂
        for p in powers:
            for s in range(n, p - 1, -1):  # 倒序更新
                dp[s] = (dp[s] + dp[s - p]) % MOD

        return dp[n]
```

```java
// java
class Solution {
    static final int MOD = 1_000_000_007;

    public int numberOfWays(int n, int x) {
        // 预计算所有 <= n 的 x 次幂
        List<Integer> powers = new ArrayList<>();
        int base = 1;
        while (true) {
            long p = (long) Math.pow(base, x); // base^x
            if (p > n) break;
            powers.add((int) p);
            base++;
        }

        // dp[s] 表示当前已处理的次幂可凑出和 s 的方案数
        int[] dp = new int[n + 1];
        dp[0] = 1; // 和为 0 的方案数为 1

        // 遍历每一个次幂（0/1 背包）
        for (int value : powers) {
            // 倒序更新，确保每个次幂只能用一次
            for (int sum = n; sum >= value; sum--) {
                dp[sum] = (dp[sum] + dp[sum - value]) % MOD;
            }
        }

        return dp[n];
    }
}
```

- 时间复杂度： $O(m\times n)$
- 空间复杂度： $O(n)$，数组 $dp$ 的空间变小

---

### 预处理

输入相同的 $n$，输出永远相同，这说明 $dp$ 中的数据是 “死的”。

将计算 $dp$ 的部分提到 **静态** 代码块中，提前进行计算。力扣平台是多次调用 $number$ 方法跑所有样例，所以预处理中的内容只会计算一次。

代码如下，已附加注释：

```Python
# python
MAX_N = 300
MAX_X = 5
MOD = 10**9 + 7

# dp[x][s] 表示使用 (x+1) 次幂，凑成 s 的方案数
dp = [[1] + [0] * MAX_N for _ in range(MAX_X)]

# 预计算所有情况
for power in range(MAX_X):  # 指数
    for base in count(1):   # 底数
        value = base ** (power + 1)
        if value > MAX_N:   # 剪枝
            break
        # 倒序更新
        for total in range(MAX_N, value - 1, -1):
            dp[power][total] += dp[power][total - value]

class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        return dp[x - 1][n] % MOD
```

```java
// java
class Solution {
    static final int MAX_N = 300;
    static final int MAX_X = 5;
    static final int MOD = 1_000_000_007;

    // dp[x][s] 表示使用 (x+1) 次幂，凑成 s 的方案数
    static int[][] dp = new int[MAX_X][MAX_N + 1];

    // 静态代码块：类加载时执行一次预计算
    static {
        // 初始化：和为 0 的方案数为 1
        for (int i = 0; i < MAX_X; i++) {
            dp[i][0] = 1;
        }

        // 预计算所有情况
        for (int power = 0; power < MAX_X; power++) { // 指数
            for (int base = 1; ; base++) {            // 底数
                long value = (long) Math.pow(base, power + 1);
                if (value > MAX_N) break;             // 剪枝

                // 倒序更新（0/1 背包）
                for (int total = MAX_N; total >= value; total--) {
                    dp[power][total] += dp[power][(int)(total - value)];
                }
            }
        }
    }

    public int numberOfWays(int n, int x) {
        return dp[x - 1][n] % MOD;
    }
}
```

- 时间复杂度： $O(1)$，预处理部分的时间与空间被均摊
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/solutions/3750553/0-1bei-bao-ji-yi-hua-er-wei-dp-yi-wei-dp-vtdo/)
