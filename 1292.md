[Problem: 1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/)

### 二维前缀和

如何快速计算任意矩形区域的元素和？二维前缀和原理/推导，可以看这篇 [图解](https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/2993541/tu-jie-er-wei-qian-zhui-he-tui-dao-ji-su-61oc/)。

构建一个二维前缀和数组 $prefix$，其中 $prefix[i][j]$ 表示从矩阵左上角 $(0, 0)$ 到位置 $(i-1, j-1)$ 的矩形区域内所有元素的和。

**逆序枚举边长**：正方形的最大可能边长为 $min(m, n)$，从这个最大值开始，递减枚举边长 $k$。

对于每一个边长 $k$，遍历矩阵中所有可能的正方形区域。一旦发现 **任意一个** 正方形的元素和 $\le threshold$，直接返回当前的 $k$。因为我们是从大到小找的，找到的第一个符合条件的 $k$ 一定是最大的。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m, n = len(mat), len(mat[0])
        # prefix[i][j] 表示 mat 中从 (0,0) 到 (i-1, j-1) 的矩形元素和
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 上方 + 左方 - 左上重叠 + 当前元素
                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + mat[i-1][j-1]
        
        # 从最大可能的边长开始向下枚举
        for k in range(min(m, n), 0, -1):
            found = False
            # 枚举右下角坐标 (i, j)
            for i in range(k, m + 1):
                for j in range(k, n + 1):
                    # 计算边长为 k 的正方形区域和
                    cur_sum = prefix[i][j] - prefix[i-k][j] - prefix[i][j-k] + prefix[i-k][j-k]
                    
                    if cur_sum <= threshold:
                        found = True
                        break  # 在当前 k 下找到了，跳出内层循环
                
                if found:
                    break  # 跳出外层循环
            
            # 这就是最大值
            if found:
                return k
                
        # 如果循环结束都没找到
        return 0
```

```Java
// java
class Solution {
    public int maxSideLength(int[][] mat, int threshold) {
        int m = mat.length, n = mat[0].length;
        // prefix[i][j] 表示 mat 中从 (0,0) 到 (i-1, j-1) 的矩形元素和
        int[][] prefix = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 上方 + 左方 - 左上重叠 + 当前元素
                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }

        // 从最大可能的边长开始向下枚举
        for (int k = Math.min(m, n); k > 0; k--) {
            boolean found = false;
            // 枚举右下角坐标 (i, j)
            for (int i = k; i <= m; i++) {
                for (int j = k; j <= n; j++) {
                    // 计算边长为 k 的正方形区域和
                    int curSum = prefix[i][j] - prefix[i - k][j] - prefix[i][j - k] + prefix[i - k][j - k];

                    if (curSum <= threshold) {
                        found = true;
                        break; // 在当前 k 下找到了，跳出内层循环
                    }
                }
                if (found) {
                    break; // 跳出外层循环
                }
            }

            // 这就是最大值
            if (found) {
                return k;
            }
        }

        // 如果循环结束都没找到
        return 0;
    }
}
```

- 时间复杂度： $O(mn\times min(m, n))$，其中 $m,n$ 分别是矩阵 $mat$ 的行数和列数。预处理时间为 $O(mn)$，而枚举的 $k$ 最大为 $min(m, n)$
- 空间复杂度： $O(mn)$，表示前缀和数组 $prefix$ 的大小

---

### 优化

不需要每次重新检查所有点。我们在遍历矩阵 $(i, j)$ 时，尝试以该点为 **右下角**，能否构成一个边长为 $ans + 1$ 的正方形。

- 如果找到了一个合法的边长 $ans+1$ 的正方形，就把结果 $ans$ 加 $1$
- 如果找不到，继续遍历下一个点
- 因为 $ans$ 只增不减，所以总共只需要遍历一次矩阵

这里的 $ans$ 代表：“截止目前，我们在遍历过程中已经找到的、确定的最大合法边长”。

本质：**贪心** 思想以及矩阵元素非负带来的 **单调性**。

我们可以通过一个 “俄罗斯套娃” 的逻辑来理解。因为大正方形包含小正方形，假设矩阵中存在一个最大的合法正方形，其右下角坐标为 $(R, C)$，边长为 $K$。

由于矩阵元素非负，如果一个大的正方形和 $\le$ 阈值，那么它内部包含的 **左上角子正方形** 的和肯定也 $\le$ 阈值。

我们可以画一条这个大正方形的 **主对角线**，沿着对角线倒推：

1. 右下角 $(R, C)$：存在一个边长为 $K$ 的合法正方形。
2. 往左上退一步 $(R-1, C-1)$：在这个位置，必然存在一个边长为 $K-1$ 的合法正方形，它是大正方形的一部分。
3. 再退一步 $(R-2, C-2)$：在这个位置，必然存在一个边长为 $K-2$ 的合法正方形。
4. $\dots$
5. 一直退到 $(R-K+1, C-K+1)$：在这个位置，必然存在一个边长为 $1$ 的合法正方形。

**执行过程就像爬楼梯**：只要存在一个边长为 $K$ 的解，那么在遍历到它的右下角之前，我们一定已经在之前的步骤中，通过它内部层层嵌套的子正方形，把 $ans$ 一步步升级到 $K-1$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m, n = len(mat), len(mat[0])
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + mat[i-1][j-1]
        
        ans = 0
        # 枚举正方形的右下角
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 检查边长为 ans + 1 的正方形是否存在
                cur_len = ans + 1
                if i >= cur_len and j >= cur_len:
                    cur_sum = prefix[i][j] - prefix[i-cur_len][j] - prefix[i][j-cur_len] + prefix[i-cur_len][j-cur_len]
                    # 存在，尝试寻找更大的
                    if cur_sum <= threshold:
                        ans += 1
                        
        return ans
```

```Java
// java
class Solution {
    public int maxSideLength(int[][] mat, int threshold) {
        int m = mat.length, n = mat[0].length;
        int[][] prefix = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }

        int ans = 0;
        // 枚举正方形的右下角
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 检查边长为 ans + 1 的正方形是否存在
                int curLen = ans + 1;
                if (i >= curLen && j >= curLen) {
                    int curSum = prefix[i][j] - prefix[i - curLen][j] - prefix[i][j - curLen] + prefix[i - curLen][j - curLen];
                    // 存在，尝试寻找更大的
                    if (curSum <= threshold) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度： $O(mn)$
- 空间复杂度： $O(mn)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solutions/3883947/er-wei-qian-zhui-he-bao-li-mei-ju-you-hu-5xb4/)
