[Problem: 3350. 检测相邻递增子数组 II](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/)

### 方法：二分 & DP & 优化

如果你没做过前一题 [3349](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/description/)，建议先去做一遍，题解为 [传送门](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/solutions/3805836/wu-jie-mo-ni-shuang-zhi-zhen-dp-yi-ci-bi-z6yc/)。本题只是在此基础上，将判断 $k$ 变为了寻找 $k$，以及数据范围的增大。

注意，两个子数组必须 **相邻**，而且是分别严格递增。

**暴力思路**：枚举 $k$，然后分别枚举第一/二个子数组的起点，然后检查。复杂度是 $O(n^3)$，题目限制 $n\leq 2\times 10^5$，很明显超时。

因此，想到一个简单的优化：将 “从小到大” 枚举 $k$ 变为 “二分寻找”。

检查 $check$ 部分使用暴力/双指针，能写出下面的代码：

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        # 检查是否存在两个相邻的长度为 k 的严格递增子数组
        def check(k):
            if 2 * k > n:
                return False

            # is_increasing[i] 表示 nums[i:i+k] 是否为严格递增子数组
            is_increasing = [False] * (n - k + 1)
            for i in range(n - k + 1):
                # 判断从 i 开始的 k 长度子数组是否严格递增
                is_valid = True
                for j in range(i + 1, i + k):
                    if nums[j] <= nums[j - 1]:
                        is_valid = False
                        break
                if is_valid:
                    is_increasing[i] = True

            # 枚举两个相邻的长度为 k 的子数组
            for i in range(n - 2 * k + 1):
                # 检查 nums[i:i+k] 和 nums[i+k:i+2*k] 是否都为严格递增
                if is_increasing[i] and is_increasing[i + k]:
                    return True

            return False

        # 二分查找 k 的最大值
        ans = 0
        low = 1
        high = n // 2  # k 的最大可能值为 n/2

        while low <= high:
            mid = (low + high) // 2
            if mid == 0:  # k=0 总是可能的
                low = mid + 1
                continue
            
            if check(mid):
                # 如果对于 mid 可行，说明可能存在更大的 k
                ans = mid  # 记录当前可行的最大 k
                low = mid + 1
            else:
                # 如果对于 mid 不可行，需要缩小 k 的范围
                high = mid - 1
                
        return ans
```

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        # 检查是否存在两个相邻的长度为 k 的严格递增子数组
        def check(k):
            if 2 * k > n:
                return False

            # 遍历所有可能的、两个相邻子数组的起始位置 i
            for i in range(n - 2 * k + 1):
                j = i + k  # 第二个子数组的起始位置
                flag = True # 标记当前这对子数组是否满足条件

                if k > 1:
                    cnt = 1
                    m = i
                    # 同时检查两个子数组是否都是严格递增的
                    while cnt < k:
                        if (nums[m] >= nums[m + 1] or 
                            nums[j] >= nums[j + 1]):
                            flag = False
                            break
                        m += 1
                        j += 1
                        cnt += 1
                
                # 找到
                if flag:
                    return True
            
            # 仍未找到
            return False

        # 二分查找 k 的最大值
        ans = 0
        low = 1
        high = n // 2  # k 的最大可能值为 n/2

        while low <= high:
            mid = (low + high) // 2
            if mid == 0:  # k=0 总是可能的
                low = mid + 1
                continue
            
            if check(mid):
                # 如果对于 mid 可行，说明可能存在更大的 k
                ans = mid  # 记录当前可行的最大 k
                low = mid + 1
            else:
                # 如果对于 mid 不可行，需要缩小 k 的范围
                high = mid - 1
                
        return ans
```

时间复杂度是 $O(n^2logn)$，也就是 $O(10^{15})$ 范畴。因此还是会超时，暴力做法会卡在 $1089/1111$ 样例，双指针做法卡在 $1102/1111$ 样例。

---

### $DP$

如果使用昨天 **连续递增计数** 的思路，也即 $dp[i]$ 表示以 $nums[i]$ 结尾的连续递增子数组的长度，则可以将 $check$ 检查变为 $O(n)$。

具体来说，如果当前段 $count\geq k$，说明这一段 $[i-k+1,i]$ 可以作为后一个递增的子数组，所以检查 $[i-2k+1,i-k]$ 前一段能否作为相邻的递增子数组。

**流程**：依旧使用二分，检查部分使用 $DP$ 思路，判断相邻两段关系。

二分使用最容易理解的 **闭区间** 写法，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        # 检查是否存在两个相邻的长度为 k 的严格递增子数组
        def check(k):
            if 2 * k > n:
                return False

            # 记录每个位置是否可以作为长度为k的递增子数组的结尾
            is_increased = [False] * (n + 1)
            count = 0  # 当前连续递增的长度

            for index in range(n):
                # 如果当前元素不大于前一个元素，重置连续递增计数
                if index > 0 and nums[index] <= nums[index - 1]:
                    count = 0
                
                count += 1
                
                # 当连续递增的长度达到 k 时
                if count >= k:
                    # 检查是否存在另一个不重叠的递增子数组
                    if is_increased[index - k + 1]:
                        return True
                    
                    # 标记当前位置可以作为长度为k的递增子数组的结尾
                    is_increased[index + 1] = True

            # 没有找到
            return False

        # 二分查找 k 的最大值
        ans = 0
        low = 1
        high = n // 2  # k 的最大可能值为 n/2

        while low <= high:
            mid = (low + high) // 2
            if mid == 0:  # k=0 总是可能的
                low = mid + 1
                continue
            
            if check(mid):
                # 如果对于 mid 可行，说明可能存在更大的 k
                ans = mid  # 记录当前可行的最大 k
                low = mid + 1
            else:
                # 如果对于 mid 不可行，需要缩小 k 的范围
                high = mid - 1
                
        return ans
```

```Java
// java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int ans = 0;
        int low = 1;
        int high = n / 2; // k 的最大可能值为 n/2

        // 二分查找 k 的最大值
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (mid == 0) { // k=0 总是可能的
                low = mid + 1;
                continue;
            }

            if (check(nums, mid)) {
                // 如果对于 mid 可行，说明可能存在更大的 k
                ans = mid; // 记录当前可行的最大 k
                low = mid + 1;
            } else {
                // 如果对于 mid 不可行，需要缩小 k 的范围
                high = mid - 1;
            }
        }

        return ans;
    }

    // 检查是否存在两个相邻的长度为 k 的严格递增子数组
    private boolean check(List<Integer> nums, int k) {
        int n = nums.size();
        if (2 * k > n) {
            return false;
        }

        // 记录每个位置是否可以作为长度为k的递增子数组的结尾
        boolean[] isIncreased = new boolean[n + 1];
        int count = 0; // 当前连续递增的长度

        for (int index = 0; index < n; index++) {
            // 如果当前元素不大于前一个元素，重置连续递增计数
            if (index > 0 && nums.get(index) <= nums.get(index - 1)) {
                count = 0;
            }

            count++;

            // 当连续递增的长度达到 k 时
            if (count >= k) {
                // 检查是否存在另一个不重叠的递增子数组
                if (isIncreased[index - k + 1]) {
                    return true;
                }

                // 标记当前位置可以作为长度为k的递增子数组的结尾
                isIncreased[index + 1] = true;
            }
        }

        // 没有找到
        return false;
    }
}
```

- 时间复杂度： $O(n\times logn)$，二分的次数为 $O(logn)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 前后缀

可以将 **动态规划** 的逻辑进一步加强。

定义 $dpPre[i]$ 表示以 $nums[i]$ **结尾** 的递增子数组的长度，以及 $dpSuf[i]$ 表示以 $nums[i]$ **开始** 的递增子数组的长度。

递推完 $DP$ 后，枚举两个相邻子数组的 **分割点** $i$。第一个子数组的最大长度是 $dpPre[i]$，第二个子数组的最大长度是 $dpSuf[i+1]$。而 $k$ 必须满足两者，所以取 **较小值**。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        # 正向 DP: 计算以 nums[i] 结尾的递增子数组长度
        dp_pre = [0] * n
        dp_pre[0] = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                dp_pre[i] = dp_pre[i - 1] + 1
            else:
                dp_pre[i] = 1

        # 反向 DP: 计算从 nums[i] 开始的递增子数组长度
        dp_suf = [0] * n
        dp_suf[n - 1] = 1
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp_suf[i] = dp_suf[i + 1] + 1
            else:
                dp_suf[i] = 1
        
        # 遍历所有可能的分割点，寻找 k 的最大值
        ans = 0
        # 分割点在 i 和 i+1 之间
        for i in range(n - 1):
            # 第一个子数组的最大长度是 dp_pre[i]
            # 第二个子数组的最大长度是 dp_suf[i+1]
            # k 必须同时满足两者，所以取其较小值
            cur_k = min(dp_pre[i], dp_suf[i+1])
            if cur_k > ans:
                ans = cur_k
                
        return ans
```

```Java
// java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        // 正向 DP: 计算以 nums[i] 结尾的递增子数组长度
        int[] dp_pre = new int[n];
        dp_pre[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp_pre[i] = dp_pre[i - 1] + 1;
            } else {
                dp_pre[i] = 1;
            }
        }

        // 反向 DP: 计算从 nums[i] 开始的递增子数组长度
        int[] dp_suf = new int[n];
        dp_suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                dp_suf[i] = dp_suf[i + 1] + 1;
            } else {
                dp_suf[i] = 1;
            }
        }
        
        // 遍历所有可能的分割点，寻找 k 的最大值
        int ans = 0;
        // 分割点在 i 和 i+1 之间
        for (int i = 0; i < n - 1; i++) {
            // 第一个子数组的最大长度是 dp_pre[i]
            // 第二个子数组的最大长度是 dp_suf[i+1]
            // k 必须同时满足两者，所以取其较小值
            int cur_k = Math.min(dp_pre[i], dp_suf[i + 1]);
            if (cur_k > ans) {
                ans = cur_k;
            }
        }
                
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，三次线性遍历
- 空间复杂度： $O(n)$，表示数组 $dp$ 的空间

---

### 分段

**换个思路**：只保留严格递增段。从前往后遍历，一旦不再递增，就在此处断开。那么，整个数组就被划分成为很多段，段内都是递增！

因为，两个相邻的递增数组（目标），

- 要么位于同一个 “递增段”，长度 $k$ 就是段长 $/2$；
- 要么就是不同段，那么 $k$ 是 “相邻段” 的长度较小值。

具体来说，定义 $segment$ 存储每一段递增的长度。使用一个 $for$ 循环填充 $segment$ 列表，然后再次遍历它，分两种情况寻找答案。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        # 将数组信息压缩为一维的“递增段长度”列表
        segment = []
        cur_len = 1
        for i in range(n - 1):
            if nums[i] < nums[i + 1]:
                # 递增段延续，长度加一
                cur_len += 1
            else:
                # 递增段中断，记录下刚结束的段的长度
                segment.append(cur_len)
                # 新的段从当前元素开始，长度重置为 1
                cur_len = 1
        
        # 记录最后一个递增段的长度
        segment.append(cur_len)
        
        ans = 0
        # 两个子数组完全位于同一个长的递增段内部
        # 对于一个长度为 L 的段，k 的最大值是 L // 2
        for length in segment:
            ans = max(ans, length // 2)
        
        # 两个子数组跨越两个相邻的递增段
        # k 的大小取决于两个相邻段中较短的那个
        for i in range(len(segment) - 1):
            ans = max(ans, min(segment[i], segment[i + 1]))
        
        return ans
```

```Java
// java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        // 将数组信息压缩为一维的“递增段长度”列表
        List<Integer> segment = new ArrayList<>();
        int cur_len = 1;
        for (int i = 0; i < n - 1; i++) {
            if (nums.get(i) < nums.get(i + 1)) {
                // 递增段延续，长度加一
                cur_len++;
            } else {
                // 递增段中断，记录下刚结束的段的长度
                segment.add(cur_len);
                // 新的段从当前元素开始，长度重置为 1
                cur_len = 1;
            }
        }
        
        // 记录最后一个递增段的长度
        segment.add(cur_len);
        
        int ans = 0;
        // 两个子数组完全位于同一个长的递增段内部
        // 对于一个长度为 L 的段，k 的最大值是 L / 2
        for (int length : segment) {
            ans = Math.max(ans, length / 2);
        }
        
        // 两个子数组跨越两个相邻的递增段
        // k 的大小取决于两个相邻段中较短的那个
        for (int i = 0; i < segment.size() - 1; i++) {
            ans = Math.max(ans, Math.min(segment.get(i), segment.get(i + 1)));
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 一次遍历

将 “统计 $segment$” 与 “计算答案” 的两个过程合二为一。

**流程**：如果出现 “断点”，则分两种情况计算答案。否则，就累加长度。切记，最后遍历完成后，一定要对最后一个段进行计算，毕竟它没参与。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        prev = 0  # 前一个递增段的长度
        cur = 1   # 当前递增段的长度

        # 从第二个元素开始遍历
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                # 如果当前元素大于前一个，说明当前递增段在延续
                cur += 1
            else:
                # 递增段在 nums[i-1] 处结束
                
                # 情况 1: 两个子数组可能完全位于刚结束的这个段内部
                ans = max(ans, cur // 2)
                
                # 情况 2: 两个子数组跨越了前一个段和刚结束的这个段
                # 第一个子数组是前一段的后缀，第二个是当前段的前缀
                if prev > 0:
                    ans = max(ans, min(prev, cur))
                
                # 更新状态：刚结束的段成为“前一个段”
                prev = cur
                # 开启了一个新的递增段，长度重置为 1
                cur = 1
        
        # 必须对最后一个递增段进行结算，因为它没有遇到“中断点”
        # 同理两种情况
        ans = max(ans, cur // 2)
        if prev > 0:
            ans = max(ans, min(prev, cur))
            
        return ans
```

```Java
// java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int ans = 0;
        int prev = 0;  // 前一个递增段的长度
        int cur = 1;   // 当前递增段的长度

        // 从第二个元素开始遍历
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                // 如果当前元素大于前一个，说明当前递增段在延续
                cur++;
            } else {
                // 递增段在 nums[i-1] 处结束
                
                // 情况 1: 两个子数组可能完全位于刚结束的这个段内部
                ans = Math.max(ans, cur / 2);
                
                // 情况 2: 两个子数组跨越了前一个段和刚结束的这个段
                // 第一个子数组是前一段的后缀，第二个是当前段的前缀
                if (prev > 0) {
                    ans = Math.max(ans, Math.min(prev, cur));
                }
                
                // 更新状态：刚结束的段成为“前一个段”
                prev = cur;
                // 开启了一个新的递增段，长度重置为 1
                cur = 1;
            }
        }
        
        // 必须对最后一个递增段进行结算，因为它没有遇到“中断点”
        // 同理两种情况
        ans = Math.max(ans, cur / 2);
        if (prev > 0) {
            ans = Math.max(ans, Math.min(prev, cur));
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/solutions/3806896/wu-jie-bao-li-er-fen-qian-hou-zhui-dp-fe-vukw/)
