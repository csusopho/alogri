[Problem: 1733. 需要教语言的最少人数](https://leetcode.cn/problems/minimum-number-of-people-to-teach/description/)

### 方法：贪心 & 优化

注意：

- 首先，我们只能给所有人教 **一门** 语言，不能多种语言！
- 其次，如果两个人是好友，且他们会同一门语言，就不需要教！

因此，可以将好友划分为 “能交流”、“沟通障碍” 这两大类。很明显，我们只需要给这些 “沟通障碍” 的所有人教同一门语言即可。

**贪心**：找出 “沟通障碍” 的用户集合，统计 **覆盖最多** 用户的语言，然后教剩下的人。

通俗的来说，就是先找出有困难的用户，然后枚举每种语言，统计这门语言已经会的人数，用的人最多，那么需要教的人最少。

> 类比一下，大部分人都学过英语，那么只要教剩余的人英语，最快时间让他们都能沟通。

如何判断两好友能交流？看看他们学会的 $language$ 是否有交集。

- 如果是暴力双 $for$，很浪费时间；
- 如果都转为 $set$ 集合，再枚举判断，那就是 $O(len1+len2)$；
- 转为集合后，使用库函数判断，那就是 $O(min(len1,len2))$。

如何计算每种语言有多少人不会？直接判断该语言是否在该用户的 $language$ 中。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        # 转换为集合形式，便于判断交集
        langs = [set(l) for l in languages]

        # Step 1: 找出不能沟通的用户
        problem = set()
        for u, v in friendships:
            u -= 1
            v -= 1
            if langs[u].intersection(langs[v]):
                continue  # 他们有交集，可以沟通
            problem.add(u)
            problem.add(v)

        if not problem:
            return 0  # 所有人都能沟通

        # Step 2: 遍历每种语言，计算最少需要教的人数
        ans = float("inf")
        for lang in range(1, n + 1):
            # 看哪些人不会这门语言
            need_teach = 0
            for user in problem:
                if lang not in langs[user]:
                    need_teach += 1
            if need_teach < ans:
                ans = need_teach

        return ans
```

```Java
// java
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        // 转换为集合形式，便于判断交集
        List<Set<Integer>> langs = new ArrayList<>();
        for (int i = 0; i < languages.length; i++) {
            Set<Integer> set = new HashSet<>();
            for (int lang : languages[i]) {
                set.add(lang);
            }
            langs.add(set);
        }

        // Step 1: 找出不能沟通的用户
        Set<Integer> problem = new HashSet<>();
        for (int[] pair : friendships) {
            int u = pair[0] - 1;
            int v = pair[1] - 1;

            // 判断是否有交集
            boolean canCommunicate = false;
            for (int lang : langs.get(u)) {
                if (langs.get(v).contains(lang)) {
                    canCommunicate = true;
                    break;
                }
            }

            if (!canCommunicate) {
                problem.add(u);
                problem.add(v);
            }
        }

        if (problem.isEmpty()) {
            return 0; // 所有人都能沟通
        }

        // Step 2: 遍历每种语言，计算最少需要教的人数
        int ans = Integer.MAX_VALUE;
        for (int lang = 1; lang <= n; lang++) {
            int needTeach = 0;
            for (int user : problem) {
                if (!langs.get(user).contains(lang)) {
                    needTeach++;
                }
            }
            if (needTeach < ans) {
                ans = needTeach;
            }
        }

        return ans;
    }
}
```

假设用户数为 $m$，语言总数为 $n$，好友对数为 $f$，每个用户掌握的语言平均数量为 $k$，这个通常很小。

- 时间复杂度： $O((m+f)\times k + n\times m)$，后者的枚举最花费时间
- 空间复杂度： $O(m\times k)$，表示集合 $langs$ 的大小

---

### 优化

查看了一下通过速度最快的代码，他们优化的是第二个步骤 “计算最少人数”。

不再是枚举语言，然后计算有几个人不会；而是枚举用户，计算他们 **每种语言** 的分别掌握人数。也就是 **转化思路**：

最少需要教的人数 = 总人数 - 最大掌握人数。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        # 每个用户掌握的语言集合
        user_langs = [frozenset(langs) for langs in languages]
        
        # 记录所有“沟通不通”的用户
        teach = set()
        for u, v in friendships:
            u_idx, v_idx = u - 1, v - 1
            # 如果两人语言集合没有交集，说明不能沟通
            if user_langs[u_idx].isdisjoint(user_langs[v_idx]):
                teach.update((u_idx, v_idx))
        
        # 如果所有好友都能沟通，不用教
        if not teach:
            return 0
        
        total = len(teach)       # 有问题的用户总数
        counts = [0] * (n + 1)   # 每种语言能覆盖多少用户
        max_count = 0            # 当前覆盖人数最大值
        
        # 遍历需要教学的用户，统计他们会的语言
        for user in teach:
            for lang in user_langs[user]:
                counts[lang] += 1
                # 更新最大覆盖人数
                if counts[lang] > max_count:
                    max_count = counts[lang]
                    # 如果某语言覆盖了全部用户，可以直接返回 0
                    if max_count == total:
                        return 0
        
        # 需要教学的人数 = 总人数 - 最优语言覆盖的人数
        return total - max_count
```

```Java
// java
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        // 每个用户掌握的语言集合
        List<Set<Integer>> userLangs = new ArrayList<>();
        for (int i = 0; i < languages.length; i++) {
            Set<Integer> set = new HashSet<>();
            for (int lang : languages[i]) {
                set.add(lang);
            }
            userLangs.add(set);
        }

        // 记录所有“沟通不通”的用户
        Set<Integer> teach = new HashSet<>();
        for (int[] pair : friendships) {
            int u = pair[0] - 1;
            int v = pair[1] - 1;

            // 如果两人语言集合没有交集，说明不能沟通
            boolean disjoint = true;
            for (int lang : userLangs.get(u)) {
                if (userLangs.get(v).contains(lang)) {
                    disjoint = false;
                    break;
                }
            }

            if (disjoint) {
                teach.add(u);
                teach.add(v);
            }
        }

        // 如果所有好友都能沟通，不用教
        if (teach.isEmpty()) {
            return 0;
        }

        int total = teach.size();          // 有问题的用户总数
        int[] counts = new int[n + 1];     // 每种语言能覆盖多少用户
        int maxCount = 0;                  // 当前覆盖人数最大值

        // 遍历需要教学的用户，统计他们会的语言
        for (int user : teach) {
            for (int lang : userLangs.get(user)) {
                counts[lang]++;
                // 更新最大覆盖人数
                if (counts[lang] > maxCount) {
                    maxCount = counts[lang];
                    // 如果某语言覆盖了全部用户，可以直接返回 0
                    if (maxCount == total) {
                        return 0;
                    }
                }
            }
        }

        // 需要教学的人数 = 总人数 - 最优语言覆盖的人数
        return total - maxCount;
    }
}
```

- 时间复杂度： $O(f\times k + n\times f)$
- 空间复杂度： $O(m\times k)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-number-of-people-to-teach/solutions/3777616/tan-xin-jie-du-ti-yi-setpan-duan-jiao-ji-flqo/)
