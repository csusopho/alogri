[Problem: 1390. 四因数](https://leetcode.cn/problems/four-divisors/description/)

### 方法：枚举 & 数学

一个数字 $x$ 有多少因子？暴力想法就是枚举 $[1,x-1]$，判断每个因子是否整除 $x$。这种情况下，时间复杂度为 $O(n\times U)$，会超时。

数字 $x$ 分解为两因子相乘，一定是一大一小（平方数除外），比如 $2\times 4=8$。如果 $2$ 是数字 $8$ 的因子，则 $4$ 也一定是因子。一次性判断两个因子！

这个大小怎么界定的？以 $\sqrt{x}$ 为边界。左侧因子是小因子，右侧因子为大因子。所以，枚举的范围可以缩小为 $[1,\sqrt{x}]$。

**特别注意**：平方数比如 $9=3\times 3$，它有两个相同的因子，这只能算作一个因数！

代码如下，已附加注释：

```Python
# python
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        ans = 0

        for num in nums:
            res = 0  # 存储当前数字的因子和
            count = 0  # 存储当前数字的因子个数

            # 遍历从 1 到 sqrt(num) 的所有可能的因子
            for j in range(1, int(math.sqrt(num)) + 1):
                if num % j == 0:  # j 是 num 的因子
                    other = num // j  # 计算对应的另一个因子
                    if other != j:  # 如果两个因子不同
                        count += 2
                        res += other + j
                    else:  # 如果两个因子相同（即 j 是平方根）
                        count += 1
                        res += j

            # 如果因子个数为 4，将因子和累加到结果中
            if count == 4:
                ans += res

        return ans
```

```Java
// java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int ans = 0;

        for (int num : nums) {
            int res = 0;  // 存储当前数字的因子和
            int count = 0;  // 存储当前数字的因子个数

            // 遍历从 1 到 sqrt(num) 的所有可能的因子
            for (int j = 1; j * j <= num; j++) {
                if (num % j == 0) {  // j 是 num 的因子
                    int other = num / j;  // 计算对应的另一个因子
                    if (other != j) {  // 如果两个因子不同
                        count += 2;
                        res += other + j;
                    } else {  // 如果两个因子相同（即 j 是平方根）
                        count += 1;
                        res += j;
                    }
                }
            }

            // 如果因子个数为 4，将因子和累加到结果中
            if (count == 4) {
                ans += res;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logU)$，其中 $n$ 是数组 $nums$ 长度，而 $U$ 是数字大小
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 埃氏筛

一个正整数 $x$ 恰好有 $4$ 个因数，只有两种情况：

- $x$ 是两个不同素数的乘积 $x = p \times q$。此时因数为 $1, p, q, pq$，因数和为 $(1+p)(1+q)$
- $x$ 是某个素数的立方 $x = p^3$。此时因数为 $1, p, p^2, p^3$，因数和为 $1+p+p^2+p^3$

看到 **素数** 这两个字，想到用 “埃氏筛” 或者 “欧拉筛” 进行快速计算。具体的原理/模板，请看这篇 [题解](https://leetcode.cn/problems/find-the-count-of-numbers-which-are-not-special/solutions/2996915/shu-xue-shu-xue-zheng-ming-qian-zhui-he-mfevi/)。

**流程**：简单粗暴地遍历每个数 $i$，把它填入所有 $i$ 的倍数的因数列表中。

这个逻辑就好像发牌：

- 手拿数字卡片 $2$，给 $2, 4, 6, 8\dots$ 的盒子里各扔一张 $2$
- 手拿数字卡片 $3$，给 $3, 6, 9, 12\dots$ 的盒子里各扔一张 $3$
- $\dots$

最后每个盒子里装的就是它所有的因数。

代码如下，已附加注释：

```Python
# python
# 埃氏筛，填充每个数的因数列表
MAX_N = 100001
# 每个数默认有一个因数 1
divisors = [[1] for _ in range(MAX_N)]

# 枚举可能的因子 i
for i in range(2, MAX_N):
    # 遍历所有 i 的倍数
    for j in range(i, MAX_N, i):
        divisors[j].append(i)

class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        ans = 0
        for num in nums:
            # 查表
            if len(divisors[num]) == 4:
                ans += sum(divisors[num])
        return ans
```

```Java
// java
class Solution {
    // 埃氏筛，填充每个数的因数列表
    static final int MAX_N = 100001;
    // 每个数默认有一个因数 1
    static List<Integer>[] divisors = new ArrayList[MAX_N];

    static {
        for (int i = 0; i < MAX_N; i++) {
            divisors[i] = new ArrayList<>();
            divisors[i].add(1);
        }

        // 枚举可能的因子 i
        for (int i = 2; i < MAX_N; i++) {
            // 遍历所有 i 的倍数
            for (int j = i; j < MAX_N; j += i) {
                divisors[j].add(i);
            }
        }
    }

    public int sumFourDivisors(int[] nums) {
        int ans = 0;
        for (int num : nums) {
            // 查表
            if (divisors[num].size() == 4) {
                int sum = 0;
                for (int d : divisors[num]) {
                    sum += d;
                }
                ans += sum;
            }
        }
        return ans;
    }
}
```

预处理的 $O(Ulog(logU))$ 时间被多个测试样例均摊，时间与空间可以视作 $O(1)$。

- 时间复杂度： $O(n)$，线性查表
- 空间复杂度： $O(1)$

---

### 欧拉筛

利用欧拉筛预处理出 $spf$ **最小质因数** 数组。对于任意数字 $x$，只需要取出它的最小质因子 $p = spf[x]$，就能将 $x$ 拆解为 $x = p \times q$。

一个数 $x$ 想要有 $4$ 个因数，剩余部分 $q = x/p$ 必须满足以下两种情况之一：

- $q$ 是一个 **新的质数**，即 $spf[q] == q$ 且 $p \neq q$。此时 $x = p \times q$，因数和为 $(1+p)(1+q)$
- $q$ 是 $p$ 的 **平方**，即 $q == p^2$。此时 $x = p^3$，因数和为 $1 + p + p^2 + p^3$

欧拉筛的处理时间与空间为 $O(U)$，被所有样例均摊。实测运行速度不如上面的方法，是因为主循环进行了计算。

代码如下，已附加注释：

```Python
# python
# 欧拉筛
N = 100001
# 计算每个数的最小质因数
spf = list(range(N))
primes = []

for i in range(2, N):
    if spf[i] == i:   # i 是质数
        primes.append(i)
    for p in primes:  # 遍历已有素数
        val = i * p   # 先计算
        if val >= N:
            break
        # 标记 val 的最小质因数是 p
        spf[val] = p
        # p 是 i 的最小质因数，停止标记
        if i % p == 0:
            break

class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        ans = 0
        for x in nums:
            p = spf[x]
            # x 是质数，只有 2 个因数，跳过
            if p == x:
                continue
            # 剩余部分
            q = x // p
            
            # 情况 1: x = p * q
            if spf[q] == q and p != q:
                ans += (1 + p) * (1 + q)
            # 情况 2: x = p^3
            # 等比求和：1 + p + p^2 + p^3
            elif q == p * p:
                ans += 1 + p + q + x
        
        return ans
```

```Java
// java
class Solution {
    // 欧拉筛
    static final int N = 100001;
    // 计算每个数的最小质因数
    static int[] spf = new int[N];
    static List<Integer> primes = new ArrayList<>();

    static {
        for (int i = 0; i < N; i++) spf[i] = i;

        for (int i = 2; i < N; i++) {
            if (spf[i] == i) {   // i 是质数
                primes.add(i);
            }
            for (int p : primes) {  // 遍历已有素数
                long val = (long) i * p;   // 先计算
                if (val >= N) {
                    break;
                }
                // 标记 val 的最小质因数是 p
                spf[(int)val] = p;
                // p 是 i 的最小质因数，停止标记
                if (i % p == 0) {
                    break;
                }
            }
        }
    }

    public int sumFourDivisors(int[] nums) {
        int ans = 0;
        for (int x : nums) {
            int p = spf[x];
            // x 是质数，只有 2 个因数，跳过
            if (p == x) {
                continue;
            }
            // 剩余部分
            int q = x / p;
            
            // 情况 1: x = p * q
            if (spf[q] == q && p != q) {
                ans += (1 + p) * (1 + q);
            }
            // 情况 2: x = p^3
            // 等比求和：1 + p + p^2 + p^3
            else if (q == p * p) {
                ans += 1 + p + q + x;
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/four-divisors/solutions/3872249/san-jie-gen-hao-mei-ju-ai-shi-shai-ou-la-eqyg/)
