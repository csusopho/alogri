[Problem: 1578. 使绳子变成彩色的最短时间](https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/description/)

### 方法：贪心 & 优化

**连续** 气球不能相同颜色，每个气球移除需要时间 $needTime[i]$，求最少移除总时间。

因此，得到一个自然的 **贪心** 思路：将连续相同颜色的气球划为一组，组内最大值才能保留，其他气球都需要移除。

**做法**：每个气球都与前一个字符比较，判断连续相同组，然后组内累加。**优化点**：无需使用额外变量，直接原地修改。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        ans = 0

        # 从第二个字符开始遍历
        for i in range(1, len(colors)):
            # 颜色相同，同一组
            if colors[i] == colors[i - 1]:
                # 如果前一个字符的成本更高
                if neededTime[i - 1] > neededTime[i]:
                    # 删除当前字符，并更新最大值
                    ans += neededTime[i]
                    neededTime[i] = neededTime[i - 1]
                else:
                    # 否则删除前一个字符，累加时间
                    ans += neededTime[i - 1]
        
        return ans
```

```Java
// java
class Solution {
    public int minCost(String colors, int[] neededTime) {
        int ans = 0;

        // 从第二个字符开始遍历
        for (int i = 1; i < colors.length(); i++) {
            // 颜色相同，同一组
            if (colors.charAt(i) == colors.charAt(i - 1)) {
                // 如果前一个字符的成本更高
                if (neededTime[i - 1] > neededTime[i]) {
                    // 删除当前字符，并更新最大值
                    ans += neededTime[i];
                    neededTime[i] = neededTime[i - 1];
                } else {
                    // 否则删除前一个字符，累加时间
                    ans += neededTime[i - 1];
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为串 $colors$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 优化

上面的代码，有些简洁，且是原地更新，不太符合企业规范。如果我们将 “同/不同组” 的处理 **分开** 进行，并使用变量进行标注，代码更易懂且速度更快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        # 当前组颜色
        res = ''
        # 同组的最大时间
        mx = 0
        ans = 0
        
        for x, t in zip(colors, neededTime):
            # 同一组中
            if x == res:
                if t < mx:
                    ans += t
                else:
                    # 更新最大时间
                    ans += mx
                    mx = t
            # 换组
            else:
                # 更新颜色
                res = x
                # 重置
                mx = t
                
        return ans
```

```Java
// java
class Solution {
    public int minCost(String colors, int[] neededTime) {
        // 当前组颜色
        char res = ' ';
        // 同组的最大时间
        int mx = 0;
        int ans = 0;
        
        for (int i = 0; i < colors.length(); i++) {
            char x = colors.charAt(i);
            int t = neededTime[i];
            
            // 同一组中
            if (x == res) {
                if (t < mx) {
                    ans += t;
                } else {
                    // 更新最大时间
                    ans += mx;
                    mx = t;
                }
            // 换组
            } else {
                // 更新颜色
                res = x;
                // 重置
                mx = t;
            }
        }
                
        return ans;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 另类解

我们可以 **换种思路**：累加每一组的最大值，然后用总和减去最大。

为了处理边界，可以在字符串以及数组 **末尾** 分别添加 “空字符” 以及 “0”。

> $ps$：这种解法的 $Python$ 代码速度会比上面更快，虽然都是超过 $100\%$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        # 添加空格，确保最后一组也能处理
        colors += ' '
        neededTime += [0]
        
        # 同组最长的移除时间
        mx = 0
        # “需要保留”的时间总和
        cnt = 0
        # 上一个气球的颜色
        prev = ''
        
        for x, y in zip(colors, neededTime):
            # 同一组中
            if x == prev:
                if y > mx:
                    mx = y
            # 换组
            else:
                prev = x
                # 累加最大值
                cnt += mx
                # 重置
                mx = y
        
        return sum(neededTime) - cnt
```

```Java
// java
class Solution {
    public int minCost(String colors, int[] neededTime) {
        // 添加空格，确保最后一组也能处理
        String extendedColors = colors + " ";
        int[] extendedTime = Arrays.copyOf(neededTime, neededTime.length + 1);
        extendedTime[neededTime.length] = 0;

        // 同组最长的移除时间
        int mx = 0;
        // “需要保留”的时间总和
        int cnt = 0;
        // 上一个气球的颜色
        char prev = ' ';
        
        for (int i = 0; i < extendedColors.length(); i++) {
            char x = extendedColors.charAt(i);
            int y = extendedTime[i];
            
            // 同一组中
            if (x == prev) {
                if (y > mx) {
                    mx = y;
                }
            // 换组
            } else {
                prev = x;
                // 累加最大值
                cnt += mx;
                // 重置
                mx = y;
            }
        }
        
        int totalSum = 0;
        for (int time : extendedTime) {
            totalSum += time;
        }

        return totalSum - cnt;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$，而 $Java$ 为 $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/solutions/3822044/san-jie-tan-xin-yuan-di-xiu-gai-you-hua-0x29f/)
