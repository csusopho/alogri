[Problem: 778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/description/)

### 方法：Dijkstra & Kruskal

~~最大难点在于读懂题意。~~

时间为 $t$ 时，水位是 $t$。如果格子高度为 $3$，则时间为 $1$ 时格子上没水！时间为 $6$ 时，总高度才是 $6$。

将本题抽象为 **图搜索** 问题：起点是 $(0,0)$，终点是 $(n-1,n-1)$。如果当前格子比邻居格子高，则移动无成本；否则，成本是两者的差值。

注意，这种说法还必须补充一点：起点有成本 $grid[0][0]$。因为没有水则无法游泳，必须先让脚下有水。比如样例 $[[3,2],[0,1]]$ 的答案为 $3$，必须先消耗 $3$ 才能出发。或者说，本题不能跳水，两个方格水位一致时，才能平滑游泳。

那么，本题也可以理解为 **路径上的最大值**。因为起点的成本是 $grid[0][0]-0$，如果我们累加路径上的各种差值，也即 `(起-0)+(x-起)+...+(最-x)`，得出的就是 “最大值”。

后续全部按照 “最大值” 的角度来理解。如果想按照 “相邻差值” 的方法建图，那就是 [1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/description/)，两个题目近乎相同，对应题解正在制作。本题的其他解法，全部放在评论区，欢迎留言。

为什么本题不是 **动规**？之前的题目是只能向右下角移动，所以状态转移是从左边或上面来的；但是这里的移动是 $4$ 个方向，也就是说能 `S` 形移动，导致转移方程写不出来。

---

### 朴素 $Dijkstra$

这里的 “路径长度” 不是各边权重之和，而是路径上遇到的最大节点权重。

网格中寻找路径？从起点到终点的单源最短路？因此，我们想到使用 $Dijkstra$。朴素版本以及堆优化版本的原理及模版，请查看这篇 [题解](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/solutions/2848394/po-su-dijkstradui-you-hua-mo-ban-zhao-lu-ve92/)。

**核心**：每次需要找下一个节点时，它会 **遍历所有** 未被访问过的节点，通过线性扫描的方式找出那个 “距离” 最小的节点，时间复杂度为 $O(V)$。

定义一个 $dist$ 数组，记录从起点 $(0,0)$ 到达每个点 $(i, j)$ 所需的最小时间（即路径最小最大海拔）。所有值初始化为无穷大。

同时，创建一个 $visited$ 数组，表示一个节点是否已经被访问，防止无限循环。

**流程**：

- 总共需要从图中选出 $n\times n$ 个节点，所以循环 $n\times n$ 次。
- 在每一次循环中：
  - 寻找下一个节点：遍历整个 $dist$ 数组，找到一个 “未被访问过” 且 $dist[i][j]$ 值最小的节点 $(r, c)$。
  - 标记访问：将这个找到的节点标记为已访问，$visited[r][c] = True$。
  - 更新邻居：遍历 $(r, c)$ 的四个邻居 $(nr, nc)$。对于每个未被访问过的邻居，计算到达它的新时间（取 $max$）。如果 $newTime$ 小于 $dist[nr][nc]$ 中记录的旧时间，说明我们找到了一条更 “省时” 的路径，更新 $dist[nr][nc]$ 为 $newTime$。

当终点 $(n-1, n-1)$ 被选为当前 “距离” 最小的节点时，它的 $dist$ 值就已经确定为最终解，可以直接返回。或者，等所有循环结束。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        # 到达每个单元格的最小“最大高度”
        dist = [[float('inf')] * n for _ in range(n)]
        # 节点是否已被选为最短路径的一部分
        visited = [[False] * n for _ in range(n)]
        # 四个方向
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        # 初始化起点
        dist[0][0] = grid[0][0]
        
        # 总共有 n*n 个节点
        for _ in range(n * n):
            # 线性扫描，找到未被访问且值最小的节点，作为下一个访问！
            min_dist = float('inf')
            r, c = -1, -1
            
            for i in range(n):
                for j in range(n):
                    if not visited[i][j] and dist[i][j] < min_dist:
                        min_dist = dist[i][j]
                        r, c = i, j

            # 已找到终点
            if r == -1:
                break
            
            # 标记找到的节点为已访问
            visited[r][c] = True
            
            # 这个最近的节点就是终点
            if r == n - 1 and c == n - 1:
                return dist[r][c]
            
            # 更新邻居节点的距离
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                
                # 检查新坐标是否在网格内且未被访问
                if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]:
                    # 计算到达邻居节点的新时间
                    new_time = max(dist[r][c], grid[nr][nc])
                    
                    # 如果找到了一个更优的路径，则更新
                    if new_time < dist[nr][nc]:
                        dist[nr][nc] = new_time
                        
        return dist[n-1][n-1]
```

```Java
// java
class Solution {
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        // 到达每个单元格的最小“最大高度”
        int[][] dist = new int[n][n];
        for (int[] row : dist) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        // 节点是否已被选为最短路径的一部分
        boolean[][] visited = new boolean[n][n];
        // 四个方向
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // 初始化起点
        dist[0][0] = grid[0][0];

        // 总共有 n*n 个节点
        for (int i = 0; i < n * n; i++) {
            // 线性扫描，找到未被访问且值最小的节点，作为下一个访问！
            int minDis = Integer.MAX_VALUE;
            int r = -1, c = -1;

            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (!visited[j][k] && dist[j][k] < minDis) {
                        minDis = dist[j][k];
                        r = j;
                        c = k;
                    }
                }
            }

            // 已找到终点
            if (r == -1) {
                break;
            }

            // 标记找到的节点为已访问
            visited[r][c] = true;

            // 这个最近的节点就是终点
            if (r == n - 1 && c == n - 1) {
                return dist[r][c];
            }

            // 更新邻居节点的距离
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // 检查新坐标是否在网格内且未被访问
                if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc]) {
                    // 计算到达邻居节点的新时间
                    int newTime = Math.max(dist[r][c], grid[nr][nc]);

                    // 如果找到了一个更优的路径，则更新
                    if (newTime < dist[nr][nc]) {
                        dist[nr][nc] = newTime;
                    }
                }
            }
        }

        return dist[n - 1][n - 1];
    }
}
```

- 时间复杂度： $O(n^4)$，其中 $n$ 为矩阵 $grid$ 的行数，勉强通过
- 空间复杂度： $O(n^2)$，表示数组 $dist,visited$ 的大小，性能 $100\%$

---

### 堆优化 $Dijkstra$

每次暴力地双 $for$ 寻找最近节点，非常浪费时间。自然地，我们联想到 **最小堆** 优化。

堆中存储的是一个三元组 `(time, r, c)`，表示 “用时 $time$ 到达了坐标 $(r, c)$”。优先队列根据 $time$ **从小到大** 进行排序，确保堆顶是 “等待时间最短” 的节点。

如果 $(r, c)$ 就是我们的终点 $(n-1, n-1)$，那么 $time$ 就是最终答案。因为我们总是从耗时最小的路径进行扩展，所以第一次到达终点时的时间一定是最优的。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        # 到达每个单元格的最小“最大高度”
        dist = [[float('inf')] * n for _ in range(n)]
        dist[0][0] = grid[0][0]
        # 最小堆，存储 (当前路径最大高度, 行, 列)
        min_heap = [(grid[0][0], 0, 0)]
        # 四个方向
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        while min_heap:
            # 最大高度最小的节点
            time, r, c = heapq.heappop(min_heap)
            # 已经到达终点
            if r == n - 1 and c == n - 1:
                return time
            
            # 遍历四个方向
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                
                # 检查新坐标是否在网格内
                if 0 <= nr < n and 0 <= nc < n:
                    # 计算到达邻居节点的新时间
                    new_time = max(time, grid[nr][nc])
                    
                    # 如果找到了一个更优的路径
                    if new_time < dist[nr][nc]:
                        dist[nr][nc] = new_time
                        heapq.heappush(min_heap, (new_time, nr, nc))

        # 理论上不会到达这里，因为总能找到路径       
        return -1
```

```Java
// java
class Solution {
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        // 到达每个单元格的最小“最大高度”
        int[][] dist = new int[n][n];
        for (int[] row : dist) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        dist[0][0] = grid[0][0];

        // 最小堆，存储 {当前路径最大高度, 行, 列}，按“最大高度”升序排列
        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        minHeap.offer(new int[]{grid[0][0], 0, 0});

        // 四个方向
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        while (!minHeap.isEmpty()) {
            // 最大高度最小的节点
            int[] current = minHeap.poll();
            int time = current[0];
            int r = current[1];
            int c = current[2];

            // 已经到达终点
            if (r == n - 1 && c == n - 1) {
                return time;
            }
            
            // 如果当前取出的节点的time比已记录的到达该节点的最小time还要大，
            // 说明已经有更优的路径到达过该节点了，直接跳过
            // 这是对已访问节点的优化，避免不必要的计算
            if (time > dist[r][c]) {
                continue;
            }

            // 遍历四个方向
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // 检查新坐标是否在网格内
                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    // 计算到达邻居节点的新时间
                    int newTime = Math.max(time, grid[nr][nc]);

                    // 如果找到了一个更优的路径
                    if (newTime < dist[nr][nc]) {
                        dist[nr][nc] = newTime;
                        minHeap.offer(new int[]{newTime, nr, nc});
                    }
                }
            }
        }
        
        // 理论上不会到达这里，因为总能找到路径
        return -1;
    }
}
```

- 时间复杂度： $O(n^2\times logn)$，每个节点出入堆一次
- 空间复杂度： $O(n^2)$

---

### 并查集

想象一下，水位从 $t=0$ 开始慢慢上涨。我们不再以 “路径” 为中心，而是以 “时间”（水位高度）为中心。

- 当水位为 $t$ 时，所有海拔高度 $\leq t$ 的平台都被水淹没了；
- 这些被淹没的平台，如果彼此相邻，就意味着它们在水下是 **连通** 的，我们就可以在它们之间自由游泳。

如此一来，问题的核心就变成了：**最早在哪个时刻 $t$，起点 $(0, 0)$ 和终点 $(n-1, n-1)$ 属于同一个连通分量？**

这就对应 **并查集**。具体的原理以及模版，可以看这篇题解，[传送门](https://leetcode.cn/problems/redundant-connection/solutions/2966966/bing-cha-ji-bao-li-mei-ju-zhao-huan-you-k08ct/)。

并查集的思路与 $Dijkstra$ 完全不同。 $Dijkstra$ 是从起点开始，一步步向外探索路径；而并查集则是 **从全局的视角**，将整个问题看作是随着水位上升，各个格子逐渐连接成片的过程。

**流程**：

- **预处理**：由于水位是逐渐上升的，我们应该按照平台的海拔高度，从低到高来处理它们。因为海拔低的平台会先被淹没并形成连通区域。为此，我们创建一个列表，存储所有的 `(海拔, 行, 列)` 信息，并按海拔 **从小到大** 排序。
- **初始化**：创建一个 $parent$ 数组，其中包含 $n^2$ 个元素，每个元素代表一个格子，初始时它们各自属于不同的集合。
- **遍历**：按排序后的顺序，依次遍历每个平台 $(height, r, c)$。
- **处理**：当前格子是 $(r, c)$，相邻格子记作 $(nr, nc)$。如果一个相邻格子的海拔 $\leq$ 当前格子的海拔，我们就将 $(r, c)$ 和 $(nr, nc)$ 在并查集中进行合并。
- **检查连通性**：在每次合并操作后，我们都检查一下起点 $(0, 0)$ 和终点 $(n-1, n-1)$ 是否在同一个集合中。
- **结束**：一旦起点和终点连通了，那么处理当前格子时所对应的海拔 $height$，就是我们能找到的最小答案。因为我们是按海拔从小到大处理的。

边值排序、逐渐添加、构建最小生成树。这不就是 $Kruskal$？本题只是稍微进行了变形，不再是连通所有节点，而是连通起点与终点。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        # parent[i] 表示节点 i 的父节点
        parent = list(range(n * n))
        # rank[i] 用于按秩合并优化，记录树的高度
        rank = [1] * (n * n)

        # 查找节点 i 的根节点，使用路径压缩
        def find(i):
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]

        # 合并节点 i 和 j 所在的集合，使用按秩合并
        def union(i, j):
            ri = find(i)
            rj = find(j)
            if ri != rj:
                # 按秩合并：将秩小的树合并到秩大的树上
                if rank[ri] > rank[rj]:
                    parent[rj] = ri
                elif rank[ri] < rank[rj]:
                    parent[ri] = rj
                else:
                    parent[rj] = ri
                    rank[ri] += 1
        
        # 将二维坐标 (r, c) 转换为一维索引
        def to_1d(r, c):
            return r * n + c

        # 创建包含 (海拔, 行, 列) 的列表
        cells = []
        for r in range(n):
            for c in range(n):
                cells.append((grid[r][c], r, c))
        
        # 按海拔从小到大排序
        cells.sort()

        start_node = to_1d(0, 0)
        end_node = to_1d(n - 1, n - 1)
        
        # 从小到大遍历
        for height, r, c in cells:
            node_1d = to_1d(r, c)

            # 四个方向的邻居
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                # 检查邻居是否在网格内，并且其海拔低于或等于当前格子
                if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] <= height:
                    neighbor_1d = to_1d(nr, nc)
                    union(node_1d, neighbor_1d)
            
            # 检查起点和终点是否连通
            if find(start_node) == find(end_node):
                return height
        
        # 理论上不会执行到这里
        return -1
```

```Java
// java
class Solution {
    // parent[i] 表示节点 i 的父节点
    private int[] parent;
    // rank[i] 用于按秩合并优化，记录树的高度
    private int[] rank;
    private int n;

    // 查找节点 i 的根节点，使用路径压缩
    private int find(int i) {
        if (parent[i] != i) {
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    // 合并节点 i 和 j 所在的集合，使用按秩合并
    private void union(int i, int j) {
        int rootI = find(i);
        int rootJ = find(j);
        if (rootI != rootJ) {
            // 按秩合并：将秩小的树合并到秩大的树上
            if (rank[rootI] > rank[rootJ]) {
                parent[rootJ] = rootI;
            } else if (rank[rootI] < rank[rootJ]) {
                parent[rootI] = rootJ;
            } else {
                parent[rootJ] = rootI;
                rank[rootI]++;
            }
        }
    }

    // 将二维坐标 (r, c) 转换为一维索引
    private int to1D(int r, int c) {
        return r * n + c;
    }

    public int swimInWater(int[][] grid) {
        this.n = grid.length;
        int size = n * n;
        this.parent = new int[size];
        this.rank = new int[size];

        for (int i = 0; i < size; i++) {
            parent[i] = i;
            rank[i] = 1;
        }

        // 创建包含 (海拔, 行, 列) 的列表
        List<int[]> cells = new ArrayList<>();
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                cells.add(new int[]{grid[r][c], r, c});
            }
        }

        // 按海拔从小到大排序
        cells.sort(Comparator.comparingInt(a -> a[0]));

        int startNode = to1D(0, 0);
        int endNode = to1D(n - 1, n - 1);
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // 从小到大遍历
        for (int[] cell : cells) {
            int height = cell[0];
            int r = cell[1];
            int c = cell[2];
            int node1D = to1D(r, c);

            // 四个方向的邻居
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];
                // 检查邻居是否在网格内，并且其海拔低于或等于当前格子
                if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] <= height) {
                    int neighbor1D = to1D(nr, nc);
                    union(node1D, neighbor1D);
                }
            }
            
            // 检查起点和终点是否连通
            if (find(startNode) == find(endNode)) {
                return height;
            }
        }

        // 理论上不会执行到这里
        return -1;
    }
}
```

- 时间复杂度： $O(n^2\times logn)$，调库快排；使用了路径压缩和按秩合并优化的并查集，单次操作的平均时间复杂度接近 $O(α(n^2))$，其中 $α$ 是反阿克曼函数，其增长极其缓慢，对于所有实际问题都可以看作是一个极小的常数
- 空间复杂度： $O(n^2)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/swim-in-rising-water/solutions/3799193/san-jie-zui-duan-lu-or-lian-tong-xing-po-3lax/)
