[Problem: 2749. 得到整数零需要执行的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/description/)

### 方法：数学

题意比较清晰，这里不再赘述，如果我们直接暴力模拟，能写出下面的代码：

```Python
# python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        # 队列元素: (当前值, 已经操作的步数)
        q = deque([(num1, 0)])
        visited = set([num1])

        while q:
            cur, steps = q.popleft()
            if cur == 0:  # 找到答案
                return steps
            # 枚举 i
            for i in range(31):
                nxt = cur - (2**i + num2)
                if nxt >= 0 and nxt not in visited:  # 只考虑非负
                    visited.add(nxt)
                    q.append((nxt, steps + 1))
        return -1
```

记忆化后，时间复杂度为 $O(num1)$，会超时，卡在 $212/542$ 样例。

---

本质上，这一题是 **数学题**，要从二进制的角度看待。

经过 $k$ 次操作后，如果最终能变成 $0$，等式两边进行移项，得到：

$$
num1 - k \cdot num2 = \sum_{j=1}^k 2^{i_j}
$$

等式右侧是 $k$ 个 $2^i$ 次幂的和！

换句话说，**问题转化** 为：从 $num1$ 中不停减掉 $num2$，然后看剩余的数是否等于 $k$ 个 $2$ 的幂之和。

$2$ 的次幂相加，有什么特点？它的规则是 $01+01=10$。因为二进制中只含 $0/1$，所以在 $k$ 个 $2^i$ 相加后，二进制中 $1$ 的个数一定不超过 $k$！

同时，最小的 $2^i$ 是 $2^0 = 1$。  将等式左侧记为 $remain$，如果要用恰好 $k$ 项来表示 $remain$，那么这 $k$ 项的最小可能和为：

$$
\underbrace{1 + 1 + \cdots + 1}_{k \text{ 次}} = k
$$

因此，剩余项 $remain$ 必须满足两个条件：

- $remain \geq k$
- $remain.bitCount() \leq k$

由于 $01+01$ 的机制存在，只要满足上述条件，则 $reamin$ 必定能由 $k$ 个 $2^i$ 次幂构成。

从小到大枚举操作次数，代码如下，已附加注释：

```Python
# python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(1, 61):  # 最多60次操作
            remain = num1 - k * num2
            if remain < 0:
                continue
            # 必须能由 k 个 2^i 构成
            # 条件1: 二进制 1 的个数 <= k
            # 条件2: remain >= k (每次至少贡献 1)
            if bin(remain).count("1") <= k and remain >= k:
                return k
        return -1
```

```Java
// java
class Solution {
    public int makeTheIntegerZero(int num1, int num2) {
        // 枚举操作次数 k 从 1 到 60
        for (int k = 1; k <= 60; k++) {
            int remain = num1 - k * num2;
            if (remain < 0) {
                continue; // remain 小于0，无法凑出解
            }
            // 必须能由 k 个 2^i 构成
            // 条件1: 二进制 1 的个数 <= k
            // 条件2: remain >= k (每次至少贡献 1)
            if (Integer.bitCount(remain) <= k && remain >= k) {
                return k;
            }
        }
        return -1;
    }
}
```

- 时间复杂度： $O(1)$，位运算的计算时间为 $O(1)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 剪枝

如果 $remain$ 小于 $0$，则一定说明 $num2>0$，才导致减为负数，所以后续只会一直为负，直接返回 $-1$ 或者 $break$ 表示不可行！代码如下：

```Python
# python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(1, 61):  # 最多60次操作
            remain = num1 - k * num2
            if remain < 0:
                return -1
            # 必须能由 k 个 2^i 构成
            if remain.bit_count() <= k and remain >= k:
                return k
        return -1
```

```Java
// java
class Solution {
    public int makeTheIntegerZero(int num1, int num2) {
        for (int k = 1; k <= 60; k++) {  // 最多60次操作
            int remain = num1 - k * num2;
            if (remain < 0) {
                break;
            }
            // 必须能由 k 个 2^i 构成
            if (Integer.bitCount(remain) <= k && remain >= k) {
                return k;
            }
        }
        return -1;
    }
}
```

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/solutions/3772826/shu-xue-wen-ti-zhuan-hua-bao-li-ci-mi-zh-t1rx/)
