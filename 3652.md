[Problem: 3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)

### 方法：滑窗

所有买入/卖出没有限制，无需考虑卖出前是否买入。修改的是连续的长度为 $k$ 的子数组，或者不进行修改。总利润是所有 $s\times p$ 的累加和。

修改的子数组必须 **连续**，提示我们使用 **滑动窗口** 来遍历所有可能的修改区间。

原始利润是，不进行任何修改时的初始 $s\times p$ 总和。本题是定长为 $k$ 的窗口，

- 前半段长度 $k/2$：策略强制变为 $0$。
- 后半段长度 $k/2$：策略强制变为 $1$。

因此，我们需要计算修改后，相对于原始利润的 **变化量** $delta$。其中，变化量 = 新收益 - 旧收益。对于窗口内的某一天 $i$：

- 若在 **前半段**：新策略是 $0$。变化量 = $0 - \text{original}[i]$。
- 若在 **后半段**：新策略是 $1$。变化量 = $\text{prices}[i] - \text{original}[i]$。

其中，上面的 $original[i]=s[i]\times p[i]$ 表示第 $i$ 天的原始利润。

如果暴力遍历每个窗口，需要 $O(n\times k)$ 的时间，太慢了。滑窗的本质就是让一个数从一端进来，让其他数从另一端退出。这样的过程使得暴力双 $for$ 枚举变为了一次遍历，从而降低时间至 $O(n)$。具体的原理/实现，可以看这篇 [题解](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solutions/2901292/yi-ti-shuang-jie-shuang-zhi-zhen-ha-xi-e-cods/)。

具体来说，前一个窗口为 $[i,j]$，后一个窗口是 $[i+1,j+1]$。滑动到新位置后，

1. 移出左侧索引 $i$：它原本在窗口前半段（强制 $0$），现在移出窗口，恢复原始策略。它对 $delta$ 的贡献是 $0-original[i]$。
2. 中间 $i + k/2$ 元素 **变性**：它原本在窗口后半段（强制 $1$），现在滑到了窗口前半段（强制 $0$）。它对 $delta$ 的贡献是 $ (0 - \text{orig}) - (\text{price} - \text{orig}) = -\text{price} $。
3. 移入右侧索引 $i + k$：它新加入窗口后半段（强制 $1$）。它对 $delta$ 的贡献是 $price[i+k]-original[i+k]$。

每次滑动后，新窗口比旧窗口变动三个元素，新的 $delta$ 就是修改后结果 - 原始利润。因此，所有 $delta$ 取最大，就是原利润上的最大增益。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        n = len(prices)
        # 原始每一天的收益：prices[i] * strategy[i]
        orig_profits = [p * s for p, s in zip(prices, strategy)]
        total = sum(orig_profits)

        # 初始化窗口
        half_k = k // 2
        delta = 0
        # 前半段变为 0
        for i in range(half_k):
            delta += (0 - orig_profits[i])
        # 后半段变为 1
        for i in range(half_k, k):
            delta += (prices[i] - orig_profits[i])
        # 记录最大增量
        mx = max(0, delta)

        # 开始滑动
        for i in range(1, n - k + 1):
            remove_idx = i - 1        # 旧移出元素
            mid_idx = i + half_k - 1  # 从后半段滑入前半段的元素
            add_idx = i + k - 1       # 新加入元素

            # 左侧
            delta -= (0 - orig_profits[remove_idx])
            # 中间元素转换
            delta -= prices[mid_idx]
            # 右侧
            delta += (prices[add_idx] - orig_profits[add_idx])
            # 更新
            mx = max(mx, delta)

        return total + mx
```

```Java
// java
class Solution {
    public long maxProfit(int[] prices, int[] strategy, int k) {
        int n = prices.length;
        // 原始每一天的收益：prices[i] * strategy[i]
        long[] origProfits = new long[n];
        long total = 0;
        for (int i = 0; i < n; i++) {
            origProfits[i] = (long) prices[i] * strategy[i];
            total += origProfits[i];
        }

        // 初始化窗口
        int halfK = k / 2;
        long delta = 0;
        // 前半段变为 0
        for (int i = 0; i < halfK; i++) {
            delta += (0 - origProfits[i]);
        }
        // 后半段变为 1
        for (int i = halfK; i < k; i++) {
            delta += (prices[i] - origProfits[i]);
        }
        // 记录最大增量
        long mx = Math.max(0, delta);

        // 开始滑动
        for (int i = 1; i <= n - k; i++) {
            int removeIdx = i - 1;        // 旧移出元素
            int midIdx = i + halfK - 1;   // 从后半段滑入前半段的元素
            int addIdx = i + k - 1;       // 新加入元素

            // 左侧
            delta -= (0 - origProfits[removeIdx]);
            // 中间元素转换
            delta -= prices[midIdx];
            // 右侧
            delta += (prices[addIdx] - origProfits[addIdx]);
            // 更新
            mx = Math.max(mx, delta);
        }

        return total + mx;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是数组 $prices$ 的长度
- 空间复杂度： $O(n)$，表示数组 $original$ 的大小

---

### 优化

创建 $original$ 数组计算每天的初始收益，是一个辅助作用。实际作用不大，直接将它去除。那么，总收益 $total$ 可以分化到每一天累加，每次需要 $original$ 的时候用 $s\times p$ 现场算。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        n = len(prices)
        half_k = k // 2
        
        total = 0   # 不修改的总利润
        delta = 0   # 利润变化量
        
        # 初始化窗口
        # 前半段
        for i in range(half_k):
            p, s = prices[i], strategy[i]
            total += s * p
            delta -= s * p
        # 后半段
        for i in range(half_k, k):
            p, s = prices[i], strategy[i]
            total += s * p
            delta += (1 - s) * p
        
        # 最大增益
        mx = delta
        for i in range(k, n):
            p, s = prices[i], strategy[i]
            # 累加原始利润
            total += s * p
            
            mid_idx = i - half_k
            left_idx = i - k
            # 新进入窗口右侧
            right_gain = (1 - s) * p
            # 移出窗口左侧
            left_loss = strategy[left_idx] * prices[left_idx]
            # 从后半段滑到前半段
            mid_loss = prices[mid_idx]
            # 变化量
            delta += right_gain + left_loss - mid_loss
            
            if delta > mx:
                mx = delta
        
        return total + max(mx, 0)
```

```Java
// java
class Solution {
    public long maxProfit(int[] prices, int[] strategy, int k) {
        int n = prices.length;
        int halfK = k / 2;
        
        long total = 0;   // 不修改的总利润
        long delta = 0;   // 利润变化量
        
        // 初始化窗口
        // 前半段
        for (int i = 0; i < halfK; i++) {
            long p = prices[i];
            int s = strategy[i];
            total += s * p;
            delta -= s * p;
        }
        // 后半段
        for (int i = halfK; i < k; i++) {
            long p = prices[i];
            int s = strategy[i];
            total += s * p;
            delta += (1 - s) * p;
        }
        
        // 最大增益
        long mx = delta;
        for (int i = k; i < n; i++) {
            long p = prices[i];
            int s = strategy[i];
            // 累加原始利润
            total += s * p;
            
            int midIdx = i - halfK;
            int leftIdx = i - k;
            // 新进入窗口右侧
            long rightGain = (1 - s) * p;
            // 移出窗口左侧
            long leftLoss = (long) strategy[leftIdx] * prices[leftIdx];
            // 从后半段滑到前半段
            long midLoss = prices[midIdx];
            // 变化量
            delta += rightGain + leftLoss - midLoss;
            
            if (delta > mx) {
                mx = delta;
            }
        }
        
        return total + Math.max(mx, 0);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/solutions/3859831/shuang-jie-ding-chang-hua-dong-chuang-ko-lc95/)
