[Problem: 2048. 下一个更大的数值平衡数](https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/)

### 方法：暴力 & 回溯 & 打表

题意比较清晰，“平衡数” 是指拆分每一位后，数字的值 = 出现次数。

**暴力**：从 $n+1$ 开始从小往大枚举，直到找出第一个符合的 “平衡数”。

代码如下，已附加注释：

```Python
# python
class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        # 哈希枚举
        res = n + 1  # 答案
        
        while True:
            # 数组哈希，存储每个数字对应的出现次数
            cnt = [0] * 10
            
            x = res
            while x != 0:  # 统计
                last_digit = x % 10
                cnt[last_digit] += 1
                x //= 10
            
            flag = True  # 标志位
            for i in range(10):
                # 出现的次数必须等于它本身的值
                if cnt[i] != 0 and cnt[i] != i:
                    flag = False
                    break
            
            if flag:  # 当前数字满足要求
                break
            res += 1  # 继续寻找
            
        return res
```

```Java
// java
class Solution {
    public int nextBeautifulNumber(int n) {
        // 哈希枚举
        int res = n + 1;  // 答案
        int cnt[] = new int[10];  // 数组哈希，存储每个数字对应的出现次数
        while(true) {
            Arrays.fill(cnt, 0);  // 清空
            int x = res;
            while(x != 0) {  // 统计
                cnt[x % 10]++;
                x /= 10;
            }
            boolean flag = true;  // 标志位
            for(int i = 0; i < 10; i++) {
                if(cnt[i] != 0 && cnt[i] != i) {  // 不满足要求，提前退出
                    flag = false;
                    break;
                }
            }
            if(flag)  // 当前数字满足要求
                break;
            res++;  // 继续寻找
        }
        return res;
    }
}
```

由于本题限制 $n\leq 10^6$，如果我们枚举出所有 “平衡数”，最大的也只是 $O(10^7)$ 量级。一个数字 $x$ 有 $log_{10}x$ 个数位，因此判断时间为 $lgx\leq 20$。

- 时间复杂度： $O(G\times lgn)$，其中 $n$ 是提供下限，而 $G=res-n$ 表示差距
- 空间复杂度： $O(Z)$，其中 $Z=10$ 表示数组 $cnt$ 的长度

注意，上面的代码使用的 **数组形式** 哈希，而不是普通哈希 $Map$。经测试，普通哈希表，相比于数组形式，平均运行时间长 $3$ 倍以上。

---

### 回溯

上面是递推形式，有没有递归形式？有的xd。

这里，我们可以使用两次回溯，从 $0$ 开始搜索全部的 “平衡数”，然后从中挑选出 $>n$ 的最小答案。虽然比较麻烦，就当作温习 $DFS$ 的写法了。

**第一层回溯：寻找数字的组合**。

- 首先确定构成数值平衡数的数字有 **哪些**。例如，数字 $1333$ 是由 $1$ 和 $3$ 构成的。
- 这一步的目标是找出所有可能的数字集合（如 $\{1, 3\}$ 或 $\{2\}$），其中，集合中所有数字 $d$ 的总和（即 $1+3=4$）必须等于最终生成数字的长度。
- 最大平衡数是七位数，所以我们只需要搜索长度不超过 $7$ 的数字组合。

**第二层回溯：生成数字的全排列**。

- 当找到一个有效的数字组合后（例如 $\{1, 3\}$），我们就得到了构成平衡数的具体“原料”：一个 $1$ 和三个 $3$。
- 接下来，我们需要用这些 “原料” 生成所有可能的数字排列，例如 $1333$, $3133$, $3313$, $3331$。
- 在生成每一种排列后，我们将其转换为整数，并检查它是否大于给定的 $n$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        self.ans = float('inf')
        # 平衡数长度不会超过7
        self.max_len = 7

        # 寻找构成平衡数的数字组合
        # 从 start_digit 开始选择数字
        # combination = [1, 2] 意味着需要 1个'1' 和 2个'2'
        def find_combinations(start_digit, combination):
            # 基于此组合生成全排列
            if combination:
                counter = Counter()
                for d in combination:
                    counter[str(d)] = d
                
                # 总长度
                total_len = sum(combination)
                # 进入第二层回溯，生成全排列
                generate_permutations("", counter, total_len)
        
            # 继续寻找新的组合
            for d in range(start_digit, 10):
                # 如果当前组合的长度加上新数字d，超过了最大长度限制，则停止
                if sum(combination) + d > self.max_len:
                    break
                
                # 选择数字 d
                combination.append(d)
                # 向下递归
                find_combinations(d + 1, combination)
                # 撤销选择
                combination.pop()

        # 根据给定的原料，生成所有数字排列
        # 正在构建的串，剩余可用数字，目标总长度
        def generate_permutations(path, counter, total_len):
            # 已生成
            if len(path) == total_len:
                num = int(path)
                # 如果这个数字大于n，尝试更新
                if num > n:
                    self.ans = min(self.ans, num)
                    return
            
            # 遍历所有可用的数字
            for d_str, count in counter.items():
                if count > 0:
                    # 使用一个数字d_str
                    counter[d_str] -= 1
                    # 向下递归
                    generate_permutations(path + d_str, counter, total_len)
                    # 撤销选择
                    counter[d_str] += 1

        # 从数字1开始，启动第一层回溯
        find_combinations(1, [])
        return self.ans
```

```Java
// java
class Solution {
    private int ans;
    // 平衡数长度不会超过7
    private final int MAX_LEN = 7;

    public int nextBeautifulNumber(int n) {
        this.ans = Integer.MAX_VALUE;
        // 从数字1开始，启动第一层回溯，初始长度为0
        findCombinations(1, new ArrayList<>(), 0, n);
        return this.ans;
    }

    // 第一层回溯：寻找构成平衡数的数字组合
    // 从 start_digit 开始选择数字
    // combination = [1, 2] 意味着需要 1个'1' 和 2个'2'
    // currentLen 是当前组合的总长度
    private void findCombinations(int startDigit, List<Integer> combination, int currentLen, int n) {
        // 基于此组合生成全排列
        if (!combination.isEmpty()) {
            Map<Integer, Integer> counter = new HashMap<>();
            for (int d : combination) {
                counter.put(d, d);
            }
            // 进入第二层回溯，生成全排列
            generatePermutations(new StringBuilder(), counter, currentLen, n);
        }

        // 继续寻找新的组合
        for (int d = startDigit; d < 10; d++) {
            // 如果当前组合的长度加上新数字d，超过了最大长度限制，则停止
            if (currentLen + d > this.MAX_LEN) {
                break;
            }

            // 选择数字 d
            combination.add(d);
            // 向下递归
            findCombinations(d + 1, combination, currentLen + d, n);
            // 撤销选择
            combination.remove(combination.size() - 1);
        }
    }

    // 第二层回溯：根据给定的原料，生成所有数字排列
    // 正在构建的串，剩余可用数字，目标总长度
    private void generatePermutations(StringBuilder path, Map<Integer, Integer> counter, int totalLen, int n) {
        // 已生成
        if (path.length() == totalLen) {
            long num = Long.parseLong(path.toString());
            // 如果这个数字大于n，尝试更新
            if (num > n) {
                this.ans = (int) Math.min(this.ans, num);
            }
            return;
        }

        // 遍历所有可用的数字
        for (int d : new ArrayList<>(counter.keySet())) {
            // 如果数字 d 还有剩余可用
            if (counter.get(d) > 0) {
                // 使用一个数字 d
                path.append(d);
                counter.put(d, counter.get(d) - 1);
                // 向下递归
                generatePermutations(path, counter, totalLen, n);
                // 撤销选择
                counter.put(d, counter.get(d) + 1);
                path.deleteCharAt(path.length() - 1);
            }
        }
    }
}
```

在 “寻找组合” $findCombinations$ 的方法中，枚举的是 $d$ ~ $10$，而组合的长度 $\leq 7$，所以可能的组合数量非常少，可以看作一个固定的常数。

在 “生成排列” $generatePermutations$ 的方法中，对于给定组合，由多项式系数公式可知，排列总数为 $L! / (d_1! * d_2! * ...)$，而生成每个长度为 $L$ 的排列需要 $O(L)$ 的时间。

- 时间复杂度： $O(U)$，其中 $U$ 是 $O(10^7)$ 量级表示枚举上限，实际远远比这小
- 空间复杂度： $O(1)$，递归深度不会超过 $7$，中间哈希/列表的大小也受限于它

---

### 预处理

实际上，不管 $n$ 的大小是多少，上述流程都保持不变。

因此，我们完全可以 **提前生成** 所有的 “平衡数”，然后遍历结果列表 $NUMBERS$，找出第一个 $>n$ 的答案。

**做法**：将计算 $dfs$ 的部分提到 **静态** 代码块中，提前计算 $NUMBERS$。力扣平台是多次调用 $nextBeautiful$ 方法跑所有样例，所以预处理中的内容只会计算一次。

代码如下，已附加注释：

```Python
# python
# 所有找到的数值平衡数
BEAUTIFUL_NUMBERS = []
# 平衡数长度不会超过7
MAX_LEN = 7

# 根据数字原料，生成所有排列
def generate_permutations(path, counter, total_len):
    # 当一个完整的数字排列生成后，将其添加到列表中
    if len(path) == total_len:
        BEAUTIFUL_NUMBERS.append(int(path))
        return
    
    # 遍历所有可用的数字
    for d_str, count in counter.items():
        if count > 0:
            counter[d_str] -= 1  # 选择
            generate_permutations(path + d_str, counter, total_len)
            counter[d_str] += 1 # 回溯

# 寻找所有可能的数字组合
def find_combinations(start_digit, combination):
    # 用它来生成全排列
    if combination:
        counter = Counter()
        for d in combination:
            counter[str(d)] = d
        # 总长度
        total_len = sum(combination)
        # 进入第二层回溯，生成全排列
        generate_permutations("", counter, total_len)
    
    # 继续寻找新的组合
    for d in range(start_digit, 10):
        if sum(combination) + d > MAX_LEN:
            break
        combination.append(d)  # 选择
        find_combinations(d + 1, combination)
        combination.pop() # 回溯

# 填充 BEAUTIFUL_NUMBERS 列表
find_combinations(1, [])
# 排序，方便从低到高搜索
BEAUTIFUL_NUMBERS.sort()


class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        # 线性搜索
        for beautiful_num in BEAUTIFUL_NUMBERS:
            if beautiful_num > n:
                return beautiful_num
```

```Java
// java
class Solution {
    // 所有找到的数值平衡数
    private static final List<Integer> BEAUTIFUL_NUMBERS = new ArrayList<>();
    // 平衡数长度不会超过7
    private static final int MAX_LEN = 7;

    // 这段代码只会在类加载时执行一次
    static {
        // 填充 BEAUTIFUL_NUMBERS 列表
        findCombinations(1, new ArrayList<>(), 0);
        // 排序，方便从低到高搜索
        Collections.sort(BEAUTIFUL_NUMBERS);
    }

    // 寻找所有可能的数字组合
    private static void findCombinations(int startDigit, List<Integer> combination, int currentLen) {
        // 用它来生成全排列
        if (!combination.isEmpty()) {
            Map<Integer, Integer> counter = new HashMap<>();
            for (int d : combination) {
                counter.put(d, d);
            }
            // 进入第二层回溯，生成全排列
            generatePermutations(new StringBuilder(), counter, currentLen);
        }

        // 继续寻找新的组合
        for (int d = startDigit; d < 10; d++) {
            // 如果总长度会超过 MAX_LEN，则停止
            if (currentLen + d > MAX_LEN) {
                break;
            }
            combination.add(d); // 选择
            findCombinations(d + 1, combination, currentLen + d);
            combination.remove(combination.size() - 1); // 回溯
        }
    }

    // 根据数字原料，生成所有排列
    private static void generatePermutations(StringBuilder path, Map<Integer, Integer> counter, int totalLen) {
        // 当一个完整的数字排列生成后，将其添加到列表中
        if (path.length() == totalLen) {
            BEAUTIFUL_NUMBERS.add(Integer.parseInt(path.toString()));
            return;
        }

        // 遍历所有可用的数字
        for (int d : new ArrayList<>(counter.keySet())) {
            if (counter.get(d) > 0) {
                path.append(d);  // 选择
                counter.put(d, counter.get(d) - 1);

                generatePermutations(path, counter, totalLen);

                counter.put(d, counter.get(d) + 1); // 回溯
                path.deleteCharAt(path.length() - 1);
            }
        }
    }

    public int nextBeautifulNumber(int n) {
        // 线性搜索
        for (int beautifulNum : BEAUTIFUL_NUMBERS) {
            if (beautifulNum > n) {
                return beautifulNum;
            }
        }
        // 理论上不会到达这里
        return -1; 
    }
}
```

- 时间复杂度： $O(1)$，预处理内容会被均摊
- 空间复杂度： $O(1)$

---

### 打表

~~既然如此，咱也不装了。~~

上面用代码介绍了 “平衡数” 的生成过程，所以我们可以利用这个结果，直接打表，定义长度为 $110$ 的列表 $BALANCE$，其中存储所有计算出的 “平衡数”。

注意，线性从小到大遍历 $BALANCE$，速度有点过慢。它已经 **升序**，所以使用 **二分** 查找，快速定位 $>n$ 的第一个数字。

代码如下，已附加注释：

```Python
# python
BALANCE = (
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
    14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
    33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
    122333, 123233, 123323, 123332, 132233, 132323, 132332,
    133223, 133232, 133322, 155555, 212333, 213233, 213323,
    213332, 221333, 223133, 223313, 223331, 224444, 231233,
    231323, 231332, 232133, 232313, 232331, 233123, 233132,
    233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322,
    321233, 321323, 321332, 322133, 322313, 322331, 323123,
    323132, 323213, 323231, 323312, 323321, 331223, 331232,
    331322, 332123, 332132, 332213, 332231, 332312, 332321,
    333122, 333212, 333221, 422444, 424244, 424424, 424442,
    442244, 442424, 442442, 444224, 444242, 444422, 515555,
    551555, 555155, 555515, 555551, 666666, 1224444
)

class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        index = bisect_right(BALANCE, n)
        return BALANCE[index]
```

```Java
// java
class Solution {
    // 打表+二分
    private static final int[] balance = new int[] {
        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
        14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
        33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
        122333, 123233, 123323, 123332, 132233, 132323, 132332,
        133223, 133232, 133322, 155555, 212333, 213233, 213323,
        213332, 221333, 223133, 223313, 223331, 224444, 231233,
        231323, 231332, 232133, 232313, 232331, 233123, 233132,
        233213, 233231, 233312, 233321, 242444, 244244, 244424,
        244442, 312233, 312323, 312332, 313223, 313232, 313322,
        321233, 321323, 321332, 322133, 322313, 322331, 323123,
        323132, 323213, 323231, 323312, 323321, 331223, 331232,
        331322, 332123, 332132, 332213, 332231, 332312, 332321,
        333122, 333212, 333221, 422444, 424244, 424424, 424442,
        442244, 442424, 442442, 444224, 444242, 444422, 515555,
        551555, 555155, 555515, 555551, 666666, 1224444
    };

    public int nextBeautifulNumber(int n) {
        int i = Arrays.binarySearch(balance, n + 1);
        if (i < 0) {
            i = -i - 1;
        }
        return balance[i];
    }
}
```

- 时间复杂度： $O(1)$，列表的总长度才 $O(10^2)$ 量级
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/next-greater-numerically-balanced-number/solutions/3814555/si-jie-bao-li-ha-xi-hui-su-tui-dao-yu-ch-fjcv/)
