[Problem: 3100. 换水问题 II](https://leetcode.cn/problems/water-bottles-ii/description/)

### 方法：模拟 & 数学

前置题目：[1518](https://leetcode.cn/problems/water-bottles/description/)，本题在此基础上，增加了设定： **兑换一次后，门槛+1**。

喝水流程：

- 喝掉有水的瓶子，得到空瓶；
- 每次能得到的新水瓶 = 空瓶数 / 门槛，兑换完成后，门槛 $+1$。

交替循环上述过程，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        # 初始时，喝掉所有满水瓶
        drunk = numBottles
        empty = numBottles

        # 当拥有的空瓶子足够交换时，持续进行
        while empty >= numExchange:
            # 换 1 个满瓶
            empty -= numExchange
            # 交换后，所需瓶数+1
            numExchange += 1
            # 喝掉新换来的满瓶
            drunk += 1
            # 新喝掉的瓶子也变成了空瓶
            empty += 1

        return drunk
```

```Java
// java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        // 初始时，喝掉所有满水瓶
        int drunk = numBottles;
        int empty = numBottles;

        // 当拥有的空瓶子足够交换时，持续进行
        while (empty >= numExchange) {
            // 换 1 个满瓶
            empty -= numExchange;
            // 交换后，所需瓶数+1
            numExchange++;
            // 喝掉新换来的满瓶
            drunk++;
            // 新喝掉的瓶子也变成了空瓶
            empty++;
        }

        return drunk;
    }
}
```

- 时间复杂度： $O(log_E{B})$，其中 $B,E$ 分别为两变量的缩写
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 数学

**总供给**：一开始有 `numBottles` 个空瓶。每成功交换一次，我们就会喝掉换来的水，从而 “产生” 一个新的空瓶。所以，如果我们进行了 $k$ 次交换，我们总共可以用于交换的空瓶资源是 `numBottles + k`。

**总消耗**：为了进行 $k$ 次交换，我们需要支付的成本是递增的。

- 第 $1$ 次交换消耗 `numExchange` 个空瓶。
- 第 $2$ 次交换消耗 `numExchange + 1` 个空瓶。
- ...
- 第 $k$ 次交换消耗 `numExchange + k - 1` 个空瓶。

总消耗就是这个等差数列的和：

$$
Sum = numExchange + (numExchange + 1) + ... + (numExchange + k - 1)
$$

使用等差数列求和公式 `(首项 + 末项) * 项数 / 2`，总消耗为：

$$
TotalCost = (2\times numExchange + k - 1)\times k / 2
$$

只要我们的 **总供给** 大于或等于 **总消耗**，交换过程就可以持续下去。因此，我们要求解满足以下不等式的最大整数 $k$，它满足：

$$
numBottles + k >= (2\times numExchange + k - 1)\times k / 2
$$

将所有项移到一边，整理成标准形式 `ax^2 + bx + c <= 0`，则有

$$
k^2 + (2\times numExchange - 3)k - 2\times numBottles <= 0
$$

如何求解这个关于 $k$ 的一元二次不等式？使用一元二次方程求根公式 `x = [-b ± sqrt(b^2 - 4ac)] / 2a`，在上述公式中：

- $a = 1$
- $b = 2\times numExchange - 3$
- $c = -2\times numBottles$

将上述字母带入，可得

$$
k = [3 - 2\times numExchange ± sqrt((2\times numExchange - 3)^2 + 8\times numBottles)] / 2
$$

由于 $k$ 必须是正数，我们只取正根，则

$$
k = [3 - 2\times numExchange + sqrt((2\times numExchange - 3)^2 + 8\times numBottles)] / 2
$$

不等式的解是介于两个根之间的，由于我们寻找的是最大整数 $k$，所以 $k = floor(k)$，即对求得的正根向下取整。

**注意**：上式有个小 $bug$，无法正确通过样例 $881$。因为空瓶子并不能全部被 “消耗” 掉！最后，无论如何也凑不够 `numExchange` 个空瓶时，手上必然会剩下至少 `1` 个空瓶，所以我们实际可用于循环兑换的资本是 `numBottles - 1`。

也即，对应的 $c$ 要修改为 $-2\times (numBottles-1)$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        # 定义一元二次方程的系数，a = 1
        b = 2 * numExchange - 3
        c = -2 * (numBottles - 1)

        # 计算判别式 (b^2 - 4ac)
        discri = b**2 - 4 * 1 * c

        # 使用求根公式计算正根 k
        # k = (-b + sqrt(discri)) / 2a
        k_root = (-b + math.sqrt(discri)) / 2
        
        # k 是最大可能的交换次数，必须是整数，所以向下取整
        k = int(k_root)

        # 最终结果是初始瓶数加上总的交换次数
        return numBottles + k
```

```Java
// java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        // 定义一元二次方程的系数，a = 1
        double b = 2.0 * numExchange - 3;
        double c = -2.0 * (numBottles - 1);

        // 计算判别式 (b^2 - 4ac)
        double discriminant = b * b - 4 * 1 * c;

        // 使用求根公式计算正根 k
        // k = (-b + sqrt(discriminant)) / 2a
        double kRoot = (-b + Math.sqrt(discriminant)) / 2.0;
        
        // k 是最大可能的交换次数，必须是整数，所以向下取整
        int k = (int) kRoot;

        // 最终结果是初始瓶数加上总的交换次数
        return numBottles + k;
    }
}
```

- 时间复杂度： $O(1)$，数学计算
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/water-bottles-ii/solutions/3797175/shuang-jie-mo-ni-shu-xue-xiang-xi-tui-da-44ft/)
