[Problem: 2785. 将字符串中的元音字母排序](https://leetcode.cn/problems/sort-vowels-in-a-string/description/)

### 方法：排序 & 位运算 & 计数

题意：辅音 **留在原地**，而元音必须 **升序** 排列。

因此，我们容易想到：记录串 $s$ 中的所有元音，将它们升序排列后，一一放回这些元音的 “原本” 的位置。

> 类比一下，就是从坑中拔出萝卜，排好队，然后再放回坑中。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sortVowels(self, s: str) -> str:
        vowels = "aeiouAEIOU"
    
        # 提取所有元音字母并按 ASCII 值排序
        s_vowels = sorted([char for char in s if char in vowels])
        
        res = list(s)  # 将字符串转换为列表以便修改
        vowel_idx = 0
        
        # 遍历原始字符串，将排序后的元音字母放回原位
        for i in range(len(s)):
            if s[i] in vowels:
                res[i] = s_vowels[vowel_idx]
                vowel_idx += 1
                
        return "".join(res)
```

```Java
// java
class Solution {
    public String sortVowels(String s) {
        String vowels = "aeiouAEIOU";

        // 提取所有元音字母并按 ASCII 值排序
        List<Character> s_vowels = new ArrayList<>();
        for (char c : s.toCharArray()) {
            if (vowels.indexOf(c) != -1) {  // 是元音
                s_vowels.add(c);
            }
        }
        Collections.sort(s_vowels); // 排序

        char[] res = s.toCharArray(); // 将字符串转换为字符数组以便修改
        int vowel_idx = 0;

        // 遍历原始字符串，将排序后的元音字母放回原位
        for (int i = 0; i < res.length; i++) {
            if (vowels.indexOf(res[i]) != -1) {
                res[i] = s_vowels.get(vowel_idx);
                vowel_idx++;
            }
        }

        return new String(res);
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 为串 $s$ 的长度
- 空间复杂度： $O(n)$，表示中间列表 $sVowels$ 的大小，忽略排序的 $O(logn)$ 栈开销

---

### 位运算

如何判断一个字母是元音？可以从 $ASCII$ 码的角度来理解！

元音字母的 $ASCII$ 低 $5$ 位，其二进制表示的特定位为 $1$：

- 对于小写/大写 `'a'/'A'`，低 $5$ 位是 $1(0b00001)$
- 对于小写/大写 `'e'/'E'`，低 $5$ 位是 $5(0b00101)$
- 对于小写/大写 `'i'/'I'`，低 $5$ 位是 $9(0b01001)$
- 对于小写/大写 `'o'/'O'`，低 $5$ 位是 $15(0b01111)$
- 对于小写/大写 `'u'/'U'`，低 $5$ 位是 $21(0b10101)$

因此，我们可以这样设置位掩码：

- $1 << 1 (a/A) = 2$
- $1 << 5 (e/E) = 32$
- $1 << 9 (i/I) = 512$
- $1 << 15 (o/O) = 32768$
- $1 << 21 (u/U) = 2097152$
- $Sum = 2+32+512+32768+2097152=2130466$

数字 $2130466$ 的二进制是 `0010 0000 1000 0010 0010 0010`。我们可以清楚地看到，确实只有第 $1, 5, 9, 15, 21$ 位是 $1$。

这样一来，通过移位运算 `>>` 和与运算 `&` 结合，就能轻松判断该位是否为 $1$，从而判断当前字母是否为元音。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sortVowels(self, s: str) -> str:
        VOWEL_MASK = 2130466 # 0b10000011000001000001000010

        def isVowel(c):
            # ord(c) & 31 获取ASCII值的低5位
            # VOWEL_MASK >> (ord(c) & 31) 将对应位置的位移到最右边
            # & 1 检查最右边的位是否为1
            return (VOWEL_MASK >> (ord(c) & 31) & 1) > 0
        

        vowels_list = []
        # 将字符串转换为列表，方便修改
        s_list = list(s) 

        for char_s in s_list:
            if isVowel(char_s):
                vowels_list.append(char_s)
        
        # 对提取出的元音字母进行排序
        vowels_list.sort()

        idx = 0 # 用于追踪 sorted_vowels 中的索引
        for i in range(len(s_list)):
            if isVowel(s_list[i]):
                s_list[i] = vowels_list[idx]
                idx += 1
        
        # 将列表重新连接成字符串
        return "".join(s_list)
```

```Java
// java
class Solution {
    private static final int VOWEL_MASK = 2130466;

    private boolean isVowel(char c) {
        // (c & 31) 获取 ASCII 值的低5位，这可以有效地将大写和小写元音映射到 VOWEL_MASK 中的相同位置
        // (VOWEL_MASK >> (c & 31)) 将对应位置的位移到最右边
        // & 1 检查最右边的位是否为1，如果是1则表示该字符是元音
        return ((VOWEL_MASK >> (c & 31)) & 1) > 0;
    }

    public String sortVowels(String s) {
        List<Character> vowelsList = new ArrayList<>();
        // 将字符串转换为字符数组，方便修改
        char[] s_arr = s.toCharArray();

        // 遍历字符数组，提取所有元音字母
        for (char char_s : s_arr) {
            if (isVowel(char_s)) {
                vowelsList.add(char_s);
            }
        }

        // 对提取出的元音字母进行排序
        Collections.sort(vowelsList);

        int vowelIdx = 0; // 用于追踪 sorted_vowels 中的索引
        // 遍历原始字符数组，将排序后的元音字母放回原位
        for (int i = 0; i < s_arr.length; i++) {
            if (isVowel(s_arr[i])) {
                s_arr[i] = vowelsList.get(vowelIdx);
                vowelIdx++;
            }
        }

        // 将字符数组重新连接成字符串
        return new String(s_arr);
    }
}
```

- 时间复杂度： $O(n\times logn)$，同理
- 空间复杂度： $O(n)$

---

### 计数

看了一下通过速度最快的代码，使用的是计数排序，而不是快排。

本质上，就是按照字母表中的先后顺序，统计字母个数，然后从小到大放回。

代码如下，已附加注释：

```Python
# python
class Solution:
    def sortVowels(self, s: str) -> str:
        # 定义所有元音字母的ASCII码集合，用于快速查找
        VOWELS = {65, 69, 73, 79, 85, 97, 101, 105, 111, 117}  
        
        # 将输入字符串编码为ASCII字节序列
        s_bytes = s.encode('ascii')
        
        # 统计每个ASCII字符出现的次数
        count = [0] * 128
        # 记录字符串中元音字母的原始位置索引
        pos = []
        
        # 遍历字节序列，统计元音并记录其位置
        for i, char in enumerate(s_bytes):
            if char in VOWELS:
                count[char] += 1
                pos.append(i)
        
        # 创建一个可变的字节数组
        res = bytearray(s_bytes)
        
        idx = 0
        # 按照ASCII顺序（排序后）遍历元音字母的ASCII值
        sorted_vowel = [65, 69, 73, 79, 85, 97, 101, 105, 111, 117]
        for ascii_val in sorted_vowel:
            # 根据统计的数量，将当前ASCII值的元音填充回其原始位置
            for _ in range(count[ascii_val]):
                res[pos[idx]] = ascii_val
                idx += 1
        
        # 将修改后的字节数组解码回字符串
        return res.decode('ascii')
```

```Java
// java
class Solution {
    public String sortVowels(String s) {
        // 定义所有元音字母的ASCII码集合，用于快速查找
        Set<Integer> VOWELS = new HashSet<>(Arrays.asList(65, 69, 73, 79, 85, 97, 101, 105, 111, 117));

        // 将输入字符串转换为字符数组，方便操作
        char[] sChars = s.toCharArray();

        // 统计每个ASCII字符出现的次数
        int[] count = new int[128];
        // 记录字符串中元音字母的原始位置索引
        List<Integer> pos = new ArrayList<>();

        // 遍历字符数组，统计元音并记录其位置
        for (int i = 0; i < sChars.length; i++) {
            int charAscii = sChars[i]; // 获取字符的ASCII值
            if (VOWELS.contains(charAscii)) {
                count[charAscii]++;
                pos.add(i);
            }
        }

        // 创建一个可变的字符数组，用于存放结果
        char[] resChars = Arrays.copyOf(sChars, sChars.length);

        int idx = 0;
        // 按照ASCII顺序（排序后）遍历元音字母的ASCII值
        for (int ascii_val = 0; ascii_val < 128; ascii_val++) {
            if (VOWELS.contains(ascii_val)) { // 只处理元音
                // 根据统计的数量，将当前ASCII值的元音填充回其原始位置
                for (int i = 0; i < count[ascii_val]; i++) {
                    resChars[pos.get(idx)] = (char) ascii_val;
                    idx++;
                }
            }
        }

        // 将修改后的字符数组转换回字符串
        return new String(resChars);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/sort-vowels-in-a-string/solutions/3778533/pai-xu-diao-ku-wei-yun-suan-pan-duan-ji-sngy5/)
