[Problem: 3013. 将数组分成最小总代价的子数组 II](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/description/)

### 对顶堆

题意：将数组分成 $k$ 个子数组，并最小化这些子数组第一个元素的累加和。

- 第一个子数组必然从 $nums[0]$ 开始，所以 $nums[0]$ 是固定成本。
- 需要在剩下的元素 $nums[1]...nums[n-1]$ 中，**选择 $k-1$ 个切分点**，作为子数组的起始位置。
- 设这 $k-1$ 个切分点的下标为 $i_1, i_2, \dots, i_{k-1}$，题目约束 $i_{k-1} - i_1 \le \text{dist}$。
- 这意味着，我们选出的这 $k-1$ 个下标中，**最大下标与最小下标的差值** 不能超过 $dist$。
- 目标变为：最小化 $nums[0] + nums[i_1] + nums[i_2] + ... + nums[i_{k-1}]$。

由于 $i_{k-1}$ 和 $i_1$ 的距离限制，这本质上是一个 **滑动窗口** 问题。

从前往后枚举 $i_1$，首先固定第二个子数组的起始下标。对于固定的 $i_1$，其余的 $k-2$ 个切分点 $i_2, \dots, i_{k-1}$ 必须落在区间 $(i_1, i_1 + \text{dist}]$ 内。

为了使总代价最小，我们需要在这个区间 $nums[i_1 + 1 ... i_1 + dist]$ 中选出 $k-2$ 个 **最小的元素**。因此，**问题转化为**：在一个变长，最大为 $dist$ 的滑动窗口中，动态维护最小的 $k-2$ 个元素的和。

如何选择数据结构，能够添加/删除元素，查询 $k$ 个最小元素和？使用 **对顶堆**。

- Selected Heap：大顶堆，维护窗口内当前最小的 $k-2$ 个元素。
- Candidates Heap：小顶堆，维护窗口内其余的元素。

> 为什么大顶堆维护最小元素？老生常谈的问题。堆中都是小元素，堆顶最大。如果其他元素比堆顶元素小，说明堆顶元素可以删除，其他更小的元素就能进入。

堆中不好直接删除元素？**懒删除**，使用一个哈希表标记应该删除的元素。

---

新加入元素应该放进哪个堆？换句话说，如何判断它是否为最小的 $k-2$ 个元素之一？如果 $selected$ 未满，或者它比 $selected$ 堆顶元素更小，则加入 $selected$ 堆。反之，放入另一个堆。

如何将移出窗口的元素从堆中删除？首先判断它处于哪个堆中，同理上述逻辑。然后，标记该元素无效，并更新堆大小/总和等变量。

切记，上述两种操作后，都需要平衡堆，让 $select$ 中恰好有 $k-2$ 个元素。如果多了，就弹出堆顶，压入 $candidate$ 中；如果少了，就从 $candidate$ 中弹出并压入。

平衡完成后，最好清理两个堆中堆顶的无效元素，防止堆过大速度慢。

---

**初始** 窗口为 $nums[2] ... nums[dist+1]$。将这些元素加入堆，并计算最小的 $k-2$ 个数之和。

在滑动时，将的新位置 $i+1$ 看作 $i_1$，也即第二个子数组起点，

- 移除 $nums[i+1]$。它之前是候选池中的元素，而现在被划分到第二个子数组中，所以不能再算作那 $k-2$ 个最小元素之一，必须从堆中移除。
- 添加 $nums[i + 1 + dist]$。窗口右边界扩展，纳入新元素进入候选池。

每次滑动后，计算新窗口中的 $k-2$ 最小的总元素和，更新答案。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        n = len(nums)
        # 从窗口中选出 k-2 个最小元素
        target = k - 2
        
        # select_heap 是大顶堆，维护最小的 target 个数
        select_heap = []
        # cand_heap 是小顶堆，维护剩余的数
        cand_heap = []
        
        # select中的有效元素和
        total_valid = 0
        
        # 两个堆中当前的有效元素数量
        cnt_L = 0
        cnt_R = 0
        
        # 延迟删除记录
        to_remove = Counter()
        
        # 将元素加入堆
        def add(val):
            nonlocal total_valid, cnt_L, cnt_R
            # 如果 select_heap 未满，或者 val 比 select_heap 中最大的小
            # 则加入 select_heap，否则加入 cand_heap
            if not select_heap or val < -select_heap[0]:
                heapq.heappush(select_heap, -val)
                total_valid += val
                cnt_L += 1
            else:
                heapq.heappush(cand_heap, val)
                cnt_R += 1
            balance()

        # 标记删除
        def remove(val):
            nonlocal total_valid, cnt_L, cnt_R
            to_remove[val] += 1
            
            # 如果 val 比 select_heap 的最大值还要小或相等，那它肯定在 select_heap 里
            if select_heap and val <= -select_heap[0]:
                cnt_L -= 1
                total_valid -= val
            else:
                cnt_R -= 1
            balance()
            
        # 清理堆顶的废元素
        def prune():
            while select_heap and to_remove[-select_heap[0]] > 0:
                to_remove[-select_heap[0]] -= 1
                heapq.heappop(select_heap)
            while cand_heap and to_remove[cand_heap[0]] > 0:
                to_remove[cand_heap[0]] -= 1
                heapq.heappop(cand_heap)

        # 平衡两个堆的大小，使 select_heap 恰好有 target 个有效元素
        def balance():
            nonlocal total_valid, cnt_L, cnt_R
            prune()
            
            # 如果 select_heap 不够，从 cand_heap 拿
            while cnt_L < target and cand_heap:
                val = heapq.heappop(cand_heap)
                if to_remove[val] > 0:
                    to_remove[val] -= 1
                    continue
                else:
                    heapq.heappush(select_heap, -val)
                    total_valid += val
                    cnt_L += 1
                    cnt_R -= 1
                    prune()  # 每次移动后清理一下
            
            # 如果 select_heap 太多，移去 cand_heap
            while cnt_L > target and select_heap:
                val = -heapq.heappop(select_heap)
                if to_remove[val] > 0:
                    to_remove[val] -= 1
                    continue
                else:
                    heapq.heappush(cand_heap, val)
                    total_valid -= val
                    cnt_L -= 1
                    cnt_R += 1
                    prune()  # 同理清理

        # 初始化窗口
        # i_1 初始为 1，候选窗口范围 nums[2 ... dist+1]
        window_end = min(n, dist + 2)
        for i in range(2, window_end):
            add(nums[i])

        ans = nums[0] + nums[1] + total_valid
        # 开始滑动，当前 i_1 变为 i+1
        for i in range(1, n - 1):
            # 移除 nums[i+1]
            if i + 1 < n:
                remove(nums[i+1])
            else:
                break  # 无法构成更靠后的组合
            
            # 添加 nums[i + 1 + dist]
            if i + 1 + dist < n:
                add(nums[i + 1 + dist])
            
            # 如果有效元素不足 k-2 个，说明剩下的数组长度不够分
            if cnt_L + cnt_R < target:
                break
            
            cur_cost = nums[0] + nums[i+1] + total_valid
            if cur_cost < ans:
                ans = cur_cost
        
        return ans
```

```Java
// java
class Solution {
    // 延迟删除记录
    private Map<Integer, Integer> toRemove;
    // selectHeap 是大顶堆，维护最小的 target 个数
    private PriorityQueue<Integer> selectHeap;
    // candHeap 是小顶堆，维护剩余的数
    private PriorityQueue<Integer> candHeap;
    
    // select中的有效元素和
    private long totalValid;
    // 两个堆中当前的有效元素数量
    private int cntL;
    private int cntR;
    private int target;

    public long minimumCost(int[] nums, int k, int dist) {
        int n = nums.length;
        // 从窗口中选出 k-2 个最小元素
        target = k - 2;
        
        selectHeap = new PriorityQueue<>(Collections.reverseOrder());
        candHeap = new PriorityQueue<>();
        toRemove = new HashMap<>();
        totalValid = 0;
        cntL = 0;
        cntR = 0;

        // 初始化窗口
        // i_1 初始为 1，候选窗口范围 nums[2 ... dist+1]
        int windowEnd = Math.min(n, dist + 2);
        for (int i = 2; i < windowEnd; i++) {
            add(nums[i]);
        }

        long ans = (long) nums[0] + nums[1] + totalValid;
        
        // 开始滑动，当前 i_1 变为 i+1
        for (int i = 1; i < n - 1; i++) {
            // 移除 nums[i+1]
            if (i + 1 < n) {
                remove(nums[i + 1]);
            } else {
                break; // 无法构成更靠后的组合
            }

            // 添加 nums[i + 1 + dist]
            if (i + 1 + dist < n) {
                add(nums[i + 1 + dist]);
            }

            // 如果有效元素不足 k-2 个，说明剩下的数组长度不够分
            if (cntL + cntR < target) {
                break;
            }

            long curCost = (long) nums[0] + nums[i + 1] + totalValid;
            if (curCost < ans) {
                ans = curCost;
            }
        }
        
        return ans;
    }

    // 将元素加入堆
    private void add(int val) {
        // 如果 selectHeap 未满，或者 val 比 selectHeap 中最大的小
        // 则加入 selectHeap，否则加入 candHeap
        if (selectHeap.isEmpty() || val < selectHeap.peek()) {
            selectHeap.offer(val);
            totalValid += val;
            cntL++;
        } else {
            candHeap.offer(val);
            cntR++;
        }
        balance();
    }

    // 标记删除
    private void remove(int val) {
        toRemove.put(val, toRemove.getOrDefault(val, 0) + 1);

        // 如果 val 比 selectHeap 的最大值还要小或相等，那它肯定在 selectHeap 里
        if (!selectHeap.isEmpty() && val <= selectHeap.peek()) {
            cntL--;
            totalValid -= val;
        } else {
            cntR--;
        }
        balance();
    }

    // 清理堆顶的废元素
    private void prune() {
        while (!selectHeap.isEmpty() && toRemove.getOrDefault(selectHeap.peek(), 0) > 0) {
            int val = selectHeap.poll();
            toRemove.put(val, toRemove.get(val) - 1);
        }
        while (!candHeap.isEmpty() && toRemove.getOrDefault(candHeap.peek(), 0) > 0) {
            int val = candHeap.poll();
            toRemove.put(val, toRemove.get(val) - 1);
        }
    }

    // 平衡两个堆的大小，使 selectHeap 恰好有 target 个有效元素
    private void balance() {
        prune();

        // 如果 selectHeap 不够，从 candHeap 拿
        while (cntL < target && !candHeap.isEmpty()) {
            int val = candHeap.poll();
            if (toRemove.getOrDefault(val, 0) > 0) {
                toRemove.put(val, toRemove.get(val) - 1);
                continue;
            } else {
                selectHeap.offer(val);
                totalValid += val;
                cntL++;
                cntR--;
                prune(); // 每次移动后清理一下
            }
        }

        // 如果 selectHeap 太多，移去 candHeap
        while (cntL > target && !selectHeap.isEmpty()) {
            int val = selectHeap.poll();
            if (toRemove.getOrDefault(val, 0) > 0) {
                toRemove.put(val, toRemove.get(val) - 1);
                continue;
            } else {
                candHeap.offer(val);
                totalValid -= val;
                cntL--;
                cntR++;
                prune(); // 同理清理
            }
        }
    }
}
```

- 时间复杂度： $O(n\times logD)$，其中 $n$ 是数组 $nums$ 的长度，堆的大小最多为 $D=dist$，每个元素最多出入堆一次
- 空间复杂度： $O(n)$，表示哈希表 $remove$ 的大小

---

### 优化

上述做法有些复杂，特别是标记删除+清理等操作，都快变成堆的底层代码了。下面是我参考运行速度较快的代码，使用 **有序列表** 替换堆，从而无需考虑复杂操作。

将 “出入堆” 以及 “对顶堆平衡” 的操作放入主循环中，从而缩短代码。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        # 除了 nums[0] 以外，再选出 k-1 个数
        target = k - 1
        base_cost = nums[0]
        
        # 初始窗口
        init_window = nums[1 : dist + 2]
        
        # 维护窗口内最小的 target 个数
        selected = SortedList(init_window)
        # 维护窗口内剩余的数
        candidates = SortedList()
        
        # 当前 selected 中所有元素的和
        cur_sum = sum(init_window)
        
        # 平衡，将 selected 中多余的较大元素移动到 candidates
        while len(selected) > target:
            max_val = selected.pop()
            cur_sum -= max_val
            candidates.add(max_val)
        
        ans = base_cost + cur_sum
        # i 指向即将进入窗口的新元素下标
        for i in range(dist + 2, len(nums)):
            # 移除
            removed_val = nums[i - dist - 1]
            
            # 判断要移除的元素是在 selected 中还是 candidates 中
            if removed_val in selected:
                selected.remove(removed_val)
                cur_sum -= removed_val
            else:
                candidates.remove(removed_val)
            
            # 进入
            added_val = nums[i]
            
            # 新元素比 selected 中最大的还小，说明它属于 selected
            if len(selected) > 0 and added_val < selected[-1]:
                selected.add(added_val)
                cur_sum += added_val
            else:
                candidates.add(added_val)
            
            # 维护 selected 的大小为 target
            if len(selected) < target:
                # 缺元素：从 candidates 中拿最小的补进来
                min_candidate = candidates.pop(0)
                selected.add(min_candidate)
                cur_sum += min_candidate
            elif len(selected) > target:
                # 多元素：把 selected 中最大的踢到 candidates
                max_selected = selected.pop()
                cur_sum -= max_selected
                candidates.add(max_selected)
            
            ans = min(ans, base_cost + cur_sum)
        
        return ans
```

```Java
// java
class Solution {
    TreeMap<Integer, Integer> selected;
    TreeMap<Integer, Integer> candidates;
    // selected 中当前的元素总数
    int selectedSize;

    public long minimumCost(int[] nums, int k, int dist) {
        // 除了 nums[0] 以外，再选出 k-1 个数
        int target = k - 1;
        long baseCost = nums[0];
        
        selected = new TreeMap<>();
        candidates = new TreeMap<>();
        selectedSize = 0;
        
        long curSum = 0;

        // 初始窗口: nums[1 : dist + 2]
        int windowEnd = Math.min(nums.length, dist + 2);
        for (int i = 1; i < windowEnd; i++) {
            add(selected, nums[i]);
            selectedSize++;
            curSum += nums[i];
        }

        // 平衡，将 selected 中多余的较大元素移动到 candidates
        while (selectedSize > target) {
            int maxVal = selected.lastKey();
            remove(selected, maxVal);
            selectedSize--;
            curSum -= maxVal;
            add(candidates, maxVal);
        }

        long ans = baseCost + curSum;

        // i 指向即将进入窗口的新元素下标
        for (int i = dist + 2; i < nums.length; i++) {
            // 移除
            int removedVal = nums[i - dist - 1];

            // 判断要移除的元素是在 selected 中还是 candidates 中
            // 优先检查 selected
            if (selected.containsKey(removedVal)) {
                remove(selected, removedVal);
                selectedSize--;
                curSum -= removedVal;
            } else {
                remove(candidates, removedVal);
            }

            // 进入
            int addedVal = nums[i];

            // 新元素比 selected 中最大的还小，说明它属于 selected
            if (selectedSize > 0 && addedVal < selected.lastKey()) {
                add(selected, addedVal);
                selectedSize++;
                curSum += addedVal;
            } else {
                add(candidates, addedVal);
            }

            // 维护 selected 的大小为 target
            if (selectedSize < target) {
                // 缺元素：从 candidates 中拿最小的补进来
                int minCandidate = candidates.firstKey();
                remove(candidates, minCandidate);
                add(selected, minCandidate);
                selectedSize++;
                curSum += minCandidate;
            } else if (selectedSize > target) {
                // 多元素：把 selected 中最大的踢到 candidates
                int maxSelected = selected.lastKey();
                remove(selected, maxSelected);
                selectedSize--;
                curSum -= maxSelected;
                add(candidates, maxSelected);
            }

            ans = Math.min(ans, baseCost + curSum);
        }

        return ans;
    }

    // 向 TreeMap 中添加元素
    private void add(TreeMap<Integer, Integer> map, int val) {
        map.put(val, map.getOrDefault(val, 0) + 1);
    }

    // 从 TreeMap 中移除元素
    private void remove(TreeMap<Integer, Integer> map, int val) {
        int count = map.get(val);
        if (count == 1) {
            map.remove(val);
        } else {
            map.put(val, count - 1);
        }
    }
}
```

- 时间复杂度： $O(nlogD)$，同理
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/solutions/3894346/hua-chuang-jie-du-ti-yi-topkwen-ti-dui-d-rb5i/)
