[Problem: 3217. 从链表中移除在数组中存在的节点](https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/description/)

### 方法：双/单指针

题意比较清晰，注意几点就行：

1. 链表中的头节点也可能被删除，最好使用哨兵；
2. 题目保证删完之后，链表中至少会剩下一个节点；
3. 不能暴力地让每个节点都遍历 $nums$ 数组，会超时；
4. 不要真的去 $delete$ 删除，释放内存，题干表述不准确。

**模拟**：使用双指针，指针 $prev$ 指向需要保留的最后一个节点，指针 $cur$ 指向正在处理的节点。以及一个虚拟头结点 $dummy$，作为哨兵，作为 $head$ 的前一个节点。

链表题总是混淆指针？动手在纸上画一画，这里的 $cur$ 指针类似老虎，它将捕获到的猎物（保留节点）交给指针 $prev$ 进行存储。

- 如果节点需要删除，则 $cur$ 指针会忽略它；
- 反之，则将该节点交给 $prev$，并同步后移。

代码如下，已附加注释：

```Python
# python
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        # 创建集合
        nums_set = set(nums)
        # 哨兵节点，它指向原始头节点
        dummy = ListNode(0)
        dummy.next = head

        # prev 指针指向要保留的最后一个节点
        # curr 指针用于遍历链表
        prev = dummy
        curr = head

        while curr:
            if curr.val in nums_set:
                # 移除
                prev.next = curr.next
            else:
                # 保留
                prev = curr
            # 更新
            curr = curr.next

        # 真实头节点
        return dummy.next
```

```Java
// java
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        // 创建集合
        Set<Integer> nums_set = new HashSet<>();
        for (int num : nums) {
            nums_set.add(num);
        }
        
        // 哨兵节点，它指向原始头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // prev 指针指向要保留的最后一个节点
        // curr 指针用于遍历链表
        ListNode prev = dummy;
        ListNode curr = head;

        while (curr != null) {
            if (nums_set.contains(curr.val)) {
                // 移除
                prev.next = curr.next;
            } else {
                // 保留
                prev = curr;
            }
            // 更新
            curr = curr.next;
        }

        // 真实头节点
        return dummy.next;
    }
}
```

- 时间复杂度： $O(n+m)$，其中 $n,m$ 分别为数组 $nums$，链表 $head$ 的长度
- 空间复杂度： $O(n)$，表示哈希 $Set$ 的大小

---

### 单指针

实际上，并不需要两个指针 $prev,cur$ 同步工作，使用一个指针也行，只不过稍微难理解一点，记住整体保留/跳过的逻辑即可。

代码如下，已附加注释：

```Python
# python
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        st = set(nums)
        # 哨兵节点
        dummy = ListNode(next=head)
        # 指向需要被保留的最后一个节点
        cur = dummy
        
        while cur.next:
            if cur.next.val in st:
                # 如果存在，则跳过下一个节点
                cur.next = cur.next.next
            else:
                # 如果不存在，说明下一个节点应该被保留
                cur = cur.next
        
        # 修改后链表的头节点
        return dummy.next
```

```Java
// java
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        Set<Integer> st = new HashSet<>();
        for (int num : nums) {
            st.add(num);
        }
        
        // 哨兵节点
        ListNode dummy = new ListNode(0, head);
        // 指向需要被保留的最后一个节点
        ListNode cur = dummy;
        
        while (cur.next != null) {
            if (st.contains(cur.next.val)) {
                // 如果存在，则跳过下一个节点
                cur.next = cur.next.next;
            } else {
                // 如果不存在，说明下一个节点应该被保留
                cur = cur.next;
            }
        }
        
        // 修改后链表的头节点
        return dummy.next;
    }
}
```

- 时间复杂度： $O(n+m)$
- 空间复杂度： $O(n)$

---

### 另类解

不用哨兵行不行？当然可以！

我们从第二个节点开始处理，将 $head$ 当作哨兵。最后返回时，再单独处理这个 $head$ 即可。

注意，这个逻辑能通过，是因为题目保证最后一定会至少剩下一个节点。不过，这种写法不推荐，因为不如上面的解法清晰。

代码如下，已附加注释：

```Python
# python
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        st = set(nums)
        
        # 处理 head 后的所有节点
        curr = head
        while curr and curr.next:
            # 检查下一个节点的值是否在集合中
            if curr.next.val in st:
                # 删除下一个节点
                curr.next = curr.next.next
            else:
                # 保留
                curr = curr.next
        
        # 单独处理头节点
        if head.val in st:
            return head.next
        else:
            return head
```

```Java
// java
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        Set<Integer> st = new HashSet<>();
        for (int num : nums) {
            st.add(num);
        }
        
        // 处理 head 后的所有节点
        ListNode curr = head;
        while (curr != null && curr.next != null) {
            // 检查下一个节点的值是否在集合中
            if (st.contains(curr.next.val)) {
                // 删除下一个节点
                curr.next = curr.next.next;
            } else {
                // 保留
                curr = curr.next;
            }
        }
        
        // 单独处理头节点
        if (st.contains(head.val)) {
            return head.next;
        } else {
            return head;
        }
    }
}
```

- 时间复杂度： $O(n+m)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/solutions/3820731/san-jie-shuang-zhi-zhen-dan-zhi-zhen-bu-zdz7z/)
