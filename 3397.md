[Problem: 3397. 执行操作后不同元素的最大数量](https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/)

### 方法：贪心 & 优化

注意，加的是 $[-k, k]$ 范围内的整数。也即，对于数字 $x$，可以把它变成 $[x-k, x+k]$ 这个区间内的 **任意一个** 整数。

最终结果是让不同的数字尽可能多，因此，我们应该让每个元素经过变换后，尽可能地不与其他元素 “撞车”。

**贪心**：假设我们是从小到大生成不同数字，上一个生成的数字是 $x$，则当前数字最好就是 $x+1$，从而让后续元素有更大的范围可选！

**核心**：对数组排序，让最小的元素变为最小，即 $nums[0]-k$，后面的元素依次增大。以一种有序的方式处理元素，从而做出局部最优决策。

- 使用一个变量 $last$，记录上一个生成的不同元素的值；以及一个计数器 $count$，用于记录不同元素的数量。
- 对于每个元素 $num$，它能够变换的范围是 $[num - k, num + k]$。
- 此时，需要为 $num$ 选择一个新值 $newVal$，这个值需要满足两个条件：
  - $newVal$ 必须大于 $last$，保证是新的不同元素
  - $newVal$ 必须在 $[num - k, num + k]$ 范围内
- 为了给后续元素留下最大的选择空间，我们应该选择满足条件的、最小的 $newVal$，即最小可能的新值为 $max(last + 1, num - k)$。
- 检查它是否在 $num$ 的可变换范围内，即 $newVal <= num + k$。
- 如果满足条件，说明我们成功地为当前元素 $num$ 找到了一个新的、不与之前元素重复的值。此时，我们将 $count+1$ ，并更新 $last$ 为 $newVal$。
- 如果不满足条件，说明 $num$ 无论如何变换，都无法得到一个比 $last$ 更大的新值，因此我们无法为它生成一个新的不同元素，只能跳过 $num$。

遍历结束后， $count$ 的值就是可能拥有的不同元素的最大数量。

每一次选择都是 **当前** 最优，从而为后续元素创造了最优的条件，最终得到 **全局** 最优。

题目指定 $nums[i],k\leq 10^9$，所以使用 $int$ 不会溢出。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        # 上一个生成的不同元素的值
        last = float('-inf')
        ans = 0

        for num in nums:
            # 为当前 num 找到一个大于 last 的新值
            # 至少要比 last 大 1，并且不能小于 num - k
            target_val = max(last + 1, num - k)
            
            # 检查是否在可变换范围内 [num - k, num + k]
            if target_val <= num + k:
                # 如果可以，说明我们成功生成了一个新的不同元素
                ans += 1
                # 更新 last 为新生成的值
                last = target_val
            
        return ans
```

```Java
// java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        Arrays.sort(nums);
        
        // 上一个生成的不同元素的值
        // 初始化为一个极小值，以确保第一个元素总能被处理
        int last = Integer.MIN_VALUE;
        int ans = 0;

        for (int num : nums) {
            // 为当前 num 找到一个大于 last 的新值
            // 至少要比 last 大 1，并且不能小于 num - k
            int targetVal = Math.max(last + 1, num - k);
            
            // 检查是否在可变换范围内 [num - k, num + k]
            if (targetVal <= num + k) {
                // 如果可以，说明我们成功生成了一个新的不同元素
                ans++;
                // 更新 last 为新生成的值
                last = targetVal;
            }
        }
            
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度，瓶颈在于快排
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

---

### 优化

我们可以采用 “减法” 的思路：先假设所有元素都可以变为不同的值，

- 如果某个元素无法变成一个，比之前元素所选值更大的新值时，就将 $ans-1$；
- 否则，就可以选择新值，只需要更新 $last$。

相比于之前的方法，这里减少了 $targetVal$ 的计算，速度相对更快。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = len(nums)
        # 记录上一个元素被分配的新值
        last = -inf
        
        for num in nums:
            # 可以毫无冲突地为它选择一个新值
            if num - k > last:
                # 选择最小的可能值 num - k
                last = num - k
            
            # 仍然大于上一个分配的值，这说明存在一个可选的新值
            elif num + k > last:
                # 我们必须选择一个比 last 大的值
                last += 1
            
            # 所有可选值 [num - k, num + k] 都已经被“占用”
            else:
                ans -= 1
                
        return ans
```

```Java
// java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        Arrays.sort(nums);
        // 假设所有元素都可以变成不同的值
        int ans = nums.length;
        
        // 记录上一个元素被分配的新值
        // 初始化为一个极小值，以确保第一个元素总能被处理
        int last = Integer.MIN_VALUE;
        
        for (int num : nums) {
            // 当前元素可选择的最小值(num - k)已经大于上一个分配的值
            if (num - k > last) {
                // 可以毫无冲突地为它选择一个新值
                last = num - k;
            
            // num - k <= last，但其可选范围的上限(num + k) 仍然大于上一个分配的值
            } else if (num + k > last) {
                // 我们必须选择一个比 last 大的值，最小的选择就是 last + 1
                last++;

            // 所有可选值 [num - k, num + k] 都已经被“占用”
            } else {
                // 无法为它分配一个新的、更大的唯一值
                ans--;
            }
        }
                
        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，同理
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/solutions/3809284/tan-xin-pai-xu-jian-fa-you-hua-cong-ju-b-y2i7/)
