[Problem: 2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/description/)

### 方法：后缀 & LogTrick

题意：对于每一个起点 $i$，需要找到一个从 $i$ 开始的最短子数组 $[i, j]$，使得这个子数组的 **按位或** $OR$ 值等于从位置 $i$ 到末尾 $n-1$ 的最大 $OR$ 值。

参与 $OR$ 运算的数字越多，结果只会不变或增大。以 $i$ 开头的最大或值，就是从 $nums[i]$ 一直按位或到 $nums[n-1]$。

**暴力**：双 $for$ 枚举所有子数组，先计算每个 $i$ 开头的最大或值 $mx$，然后从前往后找出最近的 $j$ 使得子数组的或值等于最大值 $mx$。

这种方法的时间复杂度为 $O(n^2)$，而题目限制 $n\le 10^5$，所以会超时。

---

### 后缀

注意到，随着子数组长度的增大，或值的结果会 **不变** 或者递增。也就是说，一个或值能对应多个 $j$。既然枚举下标超时，那枚举或值不就行了！

左边界为 $i$ 时，如果右边界 $j\dots k$，都对应同一个或值，只记录第一次出现的 $j$，它才对应最短长度。同时，根据集合的角度可知，集合 $[i+1,j]\in[i,j]$，因此我们选择 **倒序枚举**，有几个好处：

1. 向子数组 $[j],[j,j+1]\dots [j,n)$ 中，都添加一个 $nums[j-1]$，就能快速得到 $[j-1],[j-1,j]\dots [j-1,n)$ 这个新的子数组，利用先前结果
2. 子数组 $[j,n)$ 的最大或值 $mx$，或上 $nums[j-1]$，就得到 $[j-1,n)$ 的最大或值

**关键点**：使用列表 $list$ 存储子数组 $[i,n-1]$ 中的 `(或值，最近下标)`。

如此一来，第一个 $for$ 循环枚举 $i$，而第二个 $for$ 循环就是枚举 $list$ 中的或值，不再是枚举 $j$，优化了暴力做法！

**流程**：预处理得到 $suffix$ 数组，其中 $suffix[i]$ 表示后缀的最大或值；两重 $for$ 枚举，更新 $list$ 或值列表，并在其中找出最大或值对应的最近位置。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        suffix_or = [0] * n

        # 预处理 suffix_or[i]
        suffix_or[-1] = nums[-1]
        for i in range(n - 2, -1, -1):
            suffix_or[i] = suffix_or[i + 1] | nums[i]

        # 从右往左得到 OR 值状态集合
        or_list = []  # 每个元素是 (or_val, end_index)

        for i in range(n - 1, -1, -1):
            # 包含自身 nums[i]
            new_or_list = [(nums[i], i)]
            # 基于上一轮的所有 OR 状态更新当前的 OR 列表
            for val, end_idx in or_list:
                new_val = val | nums[i]
                # 只保留不同 OR 值，也就是第一个右端点
                if new_or_list[-1][0] != new_val:
                    new_or_list.append((new_val, end_idx))
            
            or_list = new_or_list  # 滚动更新

            # 找到 suffix_or[i] 对应的最早位置
            for val, j in or_list:
                if val == suffix_or[i]:
                    ans[i] = j - i + 1
                    break

        return ans
```

```Java
// java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        int[] suffixOr = new int[n];

        // 预处理 suffixOr[i]，表示从 i 到末尾的 OR 值
        suffixOr[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffixOr[i] = suffixOr[i + 1] | nums[i];
        }

        // 从右往左得到 OR 值状态集合
        // 每个元素是一个 (or_val, end_index) 的 pair
        List<int[]> orList = new ArrayList<>();

        for (int i = n - 1; i >= 0; i--) {
            // 包含自身 nums[i]
            List<int[]> newOrList = new ArrayList<>();
            newOrList.add(new int[]{nums[i], i});

            // 基于上一轮的所有 OR 状态更新当前的 OR 列表
            for (int[] pair : orList) {
                int val = pair[0], endIdx = pair[1];
                int newVal = val | nums[i];
                // 只保留不同 OR 值，也就是第一个右端点
                if (newVal != newOrList.get(newOrList.size() - 1)[0]) {
                    newOrList.add(new int[]{newVal, endIdx});
                }
            }

            // 滚动更新
            orList = newOrList;

            // 找到 suffixOr[i] 对应的最早位置
            for (int[] pair : orList) {
                int val = pair[0], j = pair[1];
                if (val == suffixOr[i]) {
                    ans[i] = j - i + 1;
                    break;
                }
            }
        }

        return ans;
    }
}
```

题目给定 $nums[i]\leq 10^9$，而 $2^{29}-1<10^9<2^{30}-1$，所以或值最多 $30$ 位。将 $nums$ 数组中的最大值记作 $M$，则有 $logM<30$。

- 时间复杂度： $O(n\times logM)$，其中 $n$ 是数组 $nums$ 的长度，而 $M$ 表示 $nums$ 中的最大值
- 空间复杂度： $O(n+logM)$，表示数组 $suffix$ 以及列表 $list$ 的长度

---

### 优化

第一重 $for$ 枚举也是倒序，所以能将 “预处理后缀最值” 与该过程合二为一。用一个变量 $suffix$ 代替整个数组，表示 $[i,n)$ 中的最大或值。

并且，没必要使用列表，换成哈希 $Map$ 存储 `(或值，最近右端点)` 的结构。直接从 $Map$ 中取数，比从 $List$ 取，寻找 $maxOr$ 的下标速度更快。

> $ps$：下面的代码，实际运行速度比上面还慢一点， $233333$

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        # 后缀的最大 OR 值
        max_or = 0
        # (某个 OR 值，能延伸到的最近右端点)
        or_pos = dict()

        for i in range(n - 1, -1, -1):
            new_or_pos = dict()
            # nums[i] 自身构成一个子数组
            new_or_pos[nums[i]] = i

            # 将当前元素与之前所有可能的 OR 值合并
            for val, j in or_pos.items():
                new_val = val | nums[i]
                # 若新 OR 值未出现过，记录其能达到的最远右端点
                if new_val not in new_or_pos:
                    new_or_pos[new_val] = j

            or_pos = new_or_pos  # 滚动更新
            max_or |= nums[i]    # 更新最大 OR 值
            ans[i] = or_pos[max_or] - i + 1

        return ans
```

```Java
// java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];

        // 后缀的最大 OR 值
        int maxOr = 0;

        // 某个 OR 值能延伸到的最近右端点：Map<OR值, 最右端点>
        Map<Integer, Integer> orPos = new HashMap<>();

        for (int i = n - 1; i >= 0; i--) {
            Map<Integer, Integer> newOrPos = new HashMap<>();

            // nums[i] 自身构成一个子数组
            newOrPos.put(nums[i], i);

            // 将当前元素与之前所有可能的 OR 值合并
            for (Map.Entry<Integer, Integer> entry : orPos.entrySet()) {
                int val = entry.getKey();
                int j = entry.getValue();
                int newVal = val | nums[i];

                // 若新 OR 值未出现过，记录其能达到的最远右端点
                if (!newOrPos.containsKey(newVal)) {
                    newOrPos.put(newVal, j);
                }
            }

            // 滚动更新
            orPos = newOrPos;

            // 更新最大 OR 值
            maxOr |= nums[i];

            // 计算结果：当前 i 到能达到 maxOr 的最远位置
            ans[i] = orPos.get(maxOr) - i + 1;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logM)$，同理
- 空间复杂度： $O(logM)$，表示哈希 $Map$ 的大小

---

### $LogTrick$

什么叫做 $LogTrick$？简单来说，就是通过对数运算 $logarithm$ 将乘法变为加法，简化数学推导，优化问题的过程。

本质就是二进制，具体原理可以看灵神写的 [博客](https://zhuanlan.zhihu.com/p/1933215367158830792)，或者我的这篇 [题解](https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/solutions/3049652/hua-chuang-bao-li-mo-ni-wei-yun-suan-hua-x00v/)。

**原理**：将子数组的 “或” 值保存在 *原地* 左端点处。

**做法**：外层循环右指针，从 $i = 0$ 开始，从左到右遍历 $nums$。内层循环左指针，从 $j = i - 1$ 开始，*从右到左* 遍历 $nums$，更新 $nums[j] = nums[j] \mid nums[i]$。

- $i = 1$ 时，把 $nums[0]$ 到 $nums[1]$ 的 $OR$ 记录在 $nums[0]$ 中
- $i = 2$ 时，把 $nums[1]$ 到 $nums[2]$ 的 $OR$ 记录在 $nums[1]$ 中，$nums[0]$ 到 $nums[2]$ 的 $OR$ 记录在 $nums[0]$ 中
- $i = 3$ 时，把 $nums[2]$ 到 $nums[3]$ 的 $OR$ 记录在 $nums[2]$ 中；$nums[1]$ 到 $nums[3]$ 的 $OR$ 记录在 $nums[1]$ 中；$nums[0]$ 到 $nums[3]$ 的 $OR$ 记录在 $nums[0]$ 中。
- 依此类推 $\dots$

如此一来，子数组 $[j:i]$ 的 $OR$ 值保留在 $nums[j]$ 处，只需要判断这一个值就能判断一个子数组。**本质** 就是一边计算“或”，一边修改原数组，与之前唯一区间就是原地/异地。

> $ps$：如果不理解，可以看看最开始的暴力，这里只是换成了倒序+原地修改。

“或值” 只会不变或增大，所以增加一个 **剪枝** 操作：一旦或值达到最大，就停止 $OR$ 运算。总的来看，每个数字至多可以增大 $logM$ 次，这意味着第二个 $for$ 的寻找次数不超过 $logM$。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        ans = [0] * len(nums)

        for i, x in enumerate(nums):
            ans[i] = 1  # 长度至少为 1
            for j in range(i - 1, -1, -1):  # 倒序枚举
                if (nums[j] | x) == nums[j]:  # nums[j] 及其左边元素无法增大
                    break
                # nums[j] 增大，现在 nums[j] = 原数组 nums[j] 到 nums[i] 的或值
                nums[j] |= x  
                # nums[j] 最后一次增大时的子数组长度就是答案
                ans[j] = i - j + 1
        
        return ans
```

```Java
// java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];

        // 枚举每个位置作为右端点
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            ans[i] = 1;  // 长度至少为 1

            // 从 i 向左倒序枚举
            for (int j = i - 1; j >= 0; j--) {
                // nums[j] 及其左边元素无法再增加 OR 值
                if ((nums[j] | x) == nums[j]) {
                    break;
                }
                // nums[j] 增大，现在 nums[j] = 原数组 nums[j] 到 nums[i] 的 OR 值
                nums[j] |= x;

                // nums[j] 最后一次增大时，对应的子数组长度就是答案
                ans[j] = i - j + 1;
            }
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logM)$
- 空间复杂度： $O(1)$，仅使用常数个额外变量，返回值 $ans$ 一般不计入复杂度

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/3736484/san-jie-dao-xu-hou-zhui-zui-zhi-you-hua-fx5ny/)
