[Problem: 2561. 重排水果](https://leetcode.cn/problems/rearranging-fruits/description/)

### 方法：贪心

交换两个篮子中的水果，操作次数不限。

最直接的想法：篮子 $1$ 多个 $a$，篮子 $2$ 多个 $b$，直接交换它俩不就行了？这种情况下，交换的成本为 $min(a,b)$。但是，还有一种情况：

```Java
          交换前        交换一次        交换两次
篮子1   [1,28,28]      [56,28,28]      [56,1,28]
篮子2   [1,56,56]       [1,1,56]       [1,28,56]
成本      null          min(1,56)      min(1,28)
```

选择直接交换 $28$ 和 $56$，成本为 $28$；通过 $1$ 的两次中转，成本为 $1\times 2$。

**思路**：遍历两数组，统计出差异，也就是需要交换的水果；要么直接交换，要么经过「全局最小」的两次中转。

**关键问题**：一大堆水果中，选择哪些水果一一配对？

如果只有两个水果 $(a,b)$，那就是它俩匹配；进阶一点，如果有 $4$ 个水果，它们的大小关系为： $a_i\leq a_k, b_l\leq b_j$，最佳方案就是 $(a_i, b_l)$ 和 $(a_k, b_j)$。

为什么不是 $a_i$ 和 $b_j$ 配对呢？也即，我们需要证明：

$$
\min(a_i, b_j) + \min(a_k, b_l) \ge \min(a_i, b_l) + \min(a_k, b_j)
$$

它们之间有不同的大小关系，我们按不同情况证明此不等式。

- 情况一： $a_i \le b_j$，$a_k \le b_l$

原方案代价为 $\min(a_i, b_j) + \min(a_k, b_l) = a_i + a_k$；交换后代价为 $\min(a_i, b_l) + \min(a_k, b_j) \ge a_i + a_k$。因此不等式成立。

- 情况二： $a_i > b_j$，$a_k > b_l$

原方案代价为 $\min(a_i, b_j) + \min(a_k, b_l) = b_j + b_l$；交换后代价为 $\min(a_i, b_l) + \min(a_k, b_j) \le b_l + b_j$。因此不等式依然成立。

- 情况三：$a_i \le b_j$，$a_k > b_l$

原方案代价为 $\min(a_i, b_j) + \min(a_k, b_l) = a_i + b_l$；交换后代价为 $\min(a_i, b_l) + \min(a_k, b_j) \le a_i + b_j$。注意到 $b_j \le b_l$，因此 $a_i + b_j \le a_i + b_l$，不等式成立。

- 情况四： $a_i > b_j$，$a_k \le b_l$，不满足前提条件，不可能出现。

**贪心**：因此，我们想到将数组 $a$ 升序，即 $a_1 \le a_2 \le \cdots \le a_k$；而数组 $b$ 降序，即 $b_1 \ge b_2 \ge \cdots \ge b_k$，让它俩一一配对。

**反证**：如果当前某个配对方案不是 “升序-降序”，那么它一定存在上述的非贪心配对 $(a_i,b_j)$，我们就可以交换两个配对，使得总代价不增或减小。

**总结**：找出两个篮子中分别需要换出去（多出）的水果 $swap$，以及全局最小价格；然后，使用贪心策略，对 $swap$ 进行排序，并考虑两种交换方式之一，计算总价格。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        counter1 = Counter(basket1)
        counter2 = Counter(basket2)
        
        total_cnt = counter1 + counter2
        for fruit, total_count in total_cnt.items():
            if total_count % 2 != 0:
                return -1  # 有奇数，无法相等

        # 记录每个水果需要换出的数量
        swap1 = []
        swap2 = []
        for fruit in total_cnt:
            diff = counter1[fruit] - counter2[fruit]
            if diff > 0:
                swap1.extend([fruit] * (diff // 2))
            elif diff < 0:
                swap2.extend([fruit] * (-diff // 2))

        # 最小成本水果，用于中转交换
        global_min = min(basket1 + basket2)
        
        # 一个升序一个降序，两者配对
        swap1.sort()
        swap2.sort(reverse=True)

        cost = 0
        for a, b in zip(swap1, swap2):
            cost += min(2 * global_min, min(a, b))  # 直接交换 or 中转

        return cost
```

```Java
// java
class Solution {
    public long minCost(int[] basket1, int[] basket2) {
        Map<Integer, Integer> counter1 = new HashMap<>();
        Map<Integer, Integer> counter2 = new HashMap<>();

        // 统计 basket1 中每个水果的数量
        for (int fruit : basket1) {
            counter1.put(fruit, counter1.getOrDefault(fruit, 0) + 1);
        }

        // 统计 basket2 中每个水果的数量
        for (int fruit : basket2) {
            counter2.put(fruit, counter2.getOrDefault(fruit, 0) + 1);
        }

        // 合并两个篮子的水果总数量
        Map<Integer, Integer> totalCnt = new HashMap<>();
        for (int fruit : counter1.keySet()) {
            totalCnt.put(fruit, counter1.get(fruit));
        }
        for (int fruit : counter2.keySet()) {
            totalCnt.put(fruit, totalCnt.getOrDefault(fruit, 0) + counter2.get(fruit));
        }

        // 检查每个水果是否总数为偶数
        for (int count : totalCnt.values()) {
            if (count % 2 != 0) {
                return -1;  // 有奇数，无法相等
            }
        }

        // 记录每个水果需要换出的数量
        List<Integer> swap1 = new ArrayList<>();
        List<Integer> swap2 = new ArrayList<>();

        for (int fruit : totalCnt.keySet()) {
            int diff = counter1.getOrDefault(fruit, 0) - counter2.getOrDefault(fruit, 0);
            if (diff > 0) {
                for (int i = 0; i < diff / 2; i++) {
                    swap1.add(fruit);
                }
            } else if (diff < 0) {
                for (int i = 0; i < -diff / 2; i++) {
                    swap2.add(fruit);
                }
            }
        }

        // 最小成本水果，用于中转交换
        int globalMin = Integer.MAX_VALUE;
        for (int fruit : basket1) {
            globalMin = Math.min(globalMin, fruit);
        }
        for (int fruit : basket2) {
            globalMin = Math.min(globalMin, fruit);
        }

        // 一个升序一个降序，两者配对
        Collections.sort(swap1);
        swap2.sort(Collections.reverseOrder());

        long cost = 0;
        for (int i = 0; i < swap1.size(); i++) {
            int a = swap1.get(i);
            int b = swap2.get(i);
            // 直接交换 or 中转
            cost += Math.min(2L * globalMin, Math.min(a, b));
        }

        return cost;
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 为数组 $basket1$ 的长度，性能瓶颈在排序
- 空间复杂度： $O(n)$，表示哈希表 $count$ 以及列表 $swap$ 的大小

---

### 优化

无需使用两个 $swap$ 列表，将它们合二为一，左右两半就是对称的。如此一来，“预处理” 以及 “计算” 部分的代码量就能大大减小。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        # 统计每种水果的净数量变化
        total_cnt = defaultdict(int)
        for fruit1, fruit2 in zip(basket1, basket2):
            total_cnt[fruit1] += 1
            total_cnt[fruit2] -= 1

        # 记录每个水果需要换出的数量
        swap_list = []
        for fruit, diff in total_cnt.items():
            if diff % 2 != 0:
                return -1  # 有奇数，无法相等
            # 绝对值/2
            swap_list.extend([fruit] * (abs(diff) // 2))

        # 升序
        swap_list.sort()
        # 所有水果中的最小值
        global_min = min(total_cnt)

        # 只需交换前一半，后一半是另一边对称的
        half_len = len(swap_list) // 2
        ans = 0
        for i in range(half_len):
            cur_cost = swap_list[i]
            # 直接交换 or 中转
            ans += min(cur_cost, 2 * global_min)

        return ans
```

```Java
// java
class Solution {
    public long minCost(int[] basket1, int[] basket2) {
        // 统计每种水果的净数量变化
        Map<Integer, Integer> totalCnt = new HashMap<>();
        for (int i = 0; i < basket1.length; i++) {
            int fruit1 = basket1[i];
            int fruit2 = basket2[i];
            totalCnt.put(fruit1, totalCnt.getOrDefault(fruit1, 0) + 1);
            totalCnt.put(fruit2, totalCnt.getOrDefault(fruit2, 0) - 1);
        }

        // 记录每个水果需要换出的数量
        List<Integer> swapList = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : totalCnt.entrySet()) {
            int fruit = entry.getKey();
            int diff = entry.getValue();
            if (diff % 2 != 0) {
                return -1;  // 有奇数，无法相等
            }
            for (int i = 0; i < Math.abs(diff) / 2; i++) {
                swapList.add(fruit);
            }
        }

        // 升序
        Collections.sort(swapList);

        // 所有水果中的最小值
        int globalMin = Integer.MAX_VALUE;
        for (int key : totalCnt.keySet()) {
            globalMin = Math.min(globalMin, key);
        }

        // 只需交换前一半，后一半是另一边对称的
        int halfLen = swapList.size() / 2;
        long ans = 0;
        for (int i = 0; i < halfLen; i++) {
            int curCost = swapList.get(i);
            // 直接交换 or 中转
            ans += Math.min(curCost, 2L * globalMin);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n\times logn)$，同理
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/rearranging-fruits/solutions/3740316/tan-xin-liang-chong-jiao-huan-fang-shi-s-30nt/)
