[Problem: 3075. 幸福值最大化的选择方案](https://leetcode.cn/problems/maximize-happiness-of-selected-children/description/)

### 方法：贪心+排序

总共选 $k$ 个孩子，**没选中** 的所有值会减小 $1$，**已经选过** 的值不变！

**最优策略**：为了让选择的值最大，每一轮都选择当前剩下的孩子中幸福值最大的那个。

为什么这种贪心思路正确？

- 每个孩子被选中时，其贡献是 `max(0, 初始值 - 已经过去的轮数)`。
- 不管选哪 $k$ 个孩子，他们最终被减去的 “总轮数” 是固定的（分别是减 $0$，减 $1$，减 $2$ ... 减 $k-1$）。
- 为了让总和最大，显然应该让 “被减数”，即初始幸福值尽可能大。如果用一个较小的值 **替换** 掉前 $k$ 大中的某个值，总和只会减少或不变。

为什么一定要按 **“从大到小”** 的顺序选？

- 如果值都很大，大家减完 $1$ 都还是正数，顺序不影响；
- 反之，因为小的会减为 $0$，晚点选它没损失；但大的如果晚点选，就会被白白减去 $1$。

本质上，由于存在 $max(0, ...)$ 这个 “截断” 机制，越小的值越容易触发 “保底 $0$”。为了保护总和，我们应该 **优先榨取大值的剩余价值**，让那些迟早要变成 $0$ 的小值去承担减量。

直观类比：想象你有 $k$ 个正在融化的冰淇淋（大小不一），它们每分钟都融化掉等量的体积（直到化光）。

- 如果你想吃到最多的冰淇淋，你肯定先吃最大的那个。
- 因为当你吃最大的时候，小的也在融化。如果先吃小的，等吃完小的，大的已经化掉一大部分了；由于大冰淇淋体积大，先吃它能保住最多的总量。

如果我们按照 **选择排序**，也就是暴力的思路，一共 $k$ 轮，每轮从剩余未处理的元素中找到最大值，并交换到数组的前部。

时间复杂度是 $O(n\times k)$，实测会超时，卡在 $671/674$ 样例。

因此，我们使用 **快速排序**，将数组从大到小排序，这样只需要顺序遍历。同时进行 **剪枝**，如果当前数字变为 $0$，那后面更小的数字也一定变为 $0$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort(reverse=True)
        res = 0
        for i in range(k):
            if happiness[i] <= i:
                break
            res += happiness[i] - i
        return res
```

```Java
// java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        Arrays.sort(happiness);
        int n = happiness.length;
        long res = 0;
        for (int i = 0; i < k; i++) {
            // 升序排序，所以最大的数字在后面
            if (happiness[n - 1 - i] <= i) {
                break;
            }
            res += (long) happiness[n - 1 - i] - i;
        }
        return res;
    }
}
```

我们可以稍微调换顺序，并在数字变为 $0$ 时直接 $return$ 而不是 $break$，速度更快。经实测，下面 $Python$ 代码耗时 $99ms$，超过 $100\%$。

```Python
# python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort(reverse=True)
        res = 0
        for i in range(k):
            contribution = happiness[i] - i
            if contribution > 0:
                res += contribution
            else:
                return res
        return res
```

```Java
// java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        Arrays.sort(happiness);
        int n = happiness.length;
        long res = 0;
        for (int i = 0; i < k; i++) {
            int contribution = happiness[n - 1 - i] - i;
            if (contribution > 0) {
                res += contribution;
            } else {
                return res;
            }
        }
        return res;
    }
}
```

- 时间复杂度： $O(nlogn)$，其中 $n$ 为数组 $happiness$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量，忽略排序的 $O(logn)$ 栈开销

---

### 最大堆

如果不想排序，也可以使用 **堆** 这种结构自行调整先后顺序。

速度不如快排，代码如下，已附加注释：

```Python
# python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        mx_heap = [-h for h in happiness]
        heapq.heapify(mx_heap)
        res = 0

        for i in range(k):
            # 取出当前最大值
            val = -heapq.heappop(mx_heap)
            # 减去减少量
            contribution = val - i
            if contribution > 0:
                res += contribution
            else:
                break
        
        return res
```

```Java
// java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        PriorityQueue<Integer> mx_heap = new PriorityQueue<>(Collections.reverseOrder());
        for (int h : happiness) {
            mx_heap.offer(h);
        }
        long res = 0;

        for (int i = 0; i < k; i++) {
            // 取出当前最大值
            int val = mx_heap.poll();
            // 减去减少量
            int contribution = val - i;
            if (contribution > 0) {
                res += contribution;
            } else {
                break;
            }
        }
        
        return res;
    }
}
```

- 时间复杂度： $O((n+k)\times logn)$，压入/弹出/调整时间均为 $O(logn)$ 级别
- 空间复杂度： $O(n)$，表示堆 $mxHeap$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximize-happiness-of-selected-children/solutions/3865329/shuang-jie-bao-li-tan-xin-pai-xu-dui-jie-w8l5/)
