[Problem: 1877. 数组中最大数对和的最小值](https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/description/)

### 贪心

~~最大难点：读懂题意。~~

我们可以把这道题想象成 **组队拔河**。

初始有一堆数字，有的很大（大力士），有的很小（力气小）。需要把它们两两配对，目标是：让所有队伍中 “最强的那一队” 尽量不要太强，也就是让最大值尽可能小。

在这个目标下，我们该怎么分组？比如 $[1,2,98,100]$。

- 如果让两个最大的数在一起 **强强联合**：把 $98$ 和 $100$ 分在一组，和是 $198$。这简直太强了，导致 “最大数对和” 直接飙升。为了不让最大值这么大，必须拆散这两个大数。
- 或者让两个最小的数在一起 **弱弱联合**：把 $1$ 和 $2$ 分在一组，剩下的 $98$ 和 $100$ 就被迫分在一组了，结果还是出现了 “强强联合”的情况，导致最大值很大。

因此，为了让最大值尽可能低，我们需要 **“平均”**。用最小的数去 “拖累” 最大的数，用第二小的数去 “拖累” 第二大的数...... 以此类推。

**总结**：把数组从小到大排好序。拿最小的数和最大的数配对，拿第二小的数和第二大的数配对，一直配到中间。算出每一对的和，最大值，就是我们要的答案。

---

为什么排序后“首尾配对”是正确的？

假设数组里只有 $4$ 个数，从小到大排好序是 $A, B, C, D$。把它们分成两组，一共有三种分法：

- 方案 $1$：最小配最小，最大配最大

也即 $(A+B)$ 和 $(C+D)$。显然 $C+D$ 是最大的，这是最差的方案。

- 方案 $2$：交叉配对

也即 $(A+C)$ 和 $(B+D)$。因为 $B > A$ 且 $D > C$，所以 $B+D$ 肯定比 $A+C$ 大。最大值是 $B+D$。

- 方案 3：我们的策略

也即 $(A+D)$ 和 $(B+C)$，最大值是 $\max(A+D, B+C)$。因为 $A < B$，所以 $A+D < B+D$；因为 $C < D$，所以 $B+C < B+D$。这两个结果都比方案 $2$ 的值更小。

**推广到 N 个数：** 这就好比田忌赛马的反向操作。

最大的数 $D$，就像是一个极高的柱子。为了降低整体高度，我们必须给这个最高的柱子垫一个最薄的底座。如果我们给最大的数 $D$ 垫了任何一个比 $A$ 大的数（比如 $B$），那么 $D+B$ 的高度一定会超过 $D+A$。

虽然 $D+A$ 可能会变小，导致其他的组合（比如 $C+B$）变大，但根据数学上的 “重排不等式” 或 “交换论证法”，这种让最大值和最小值结合的方式，能够最有效地将数值平均化，从而压低最大值。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        # 升序
        nums.sort()
        n = len(nums)
        max_sum = 0
        
        # 双指针思想
        for i in range(n // 2):
            # 用“当前最小”配“当前最大”
            cur_sum = nums[i] + nums[n - 1 - i]
            
            # 所有配对和中，保留最大的那个
            if cur_sum > max_sum:
                max_sum = cur_sum
        
        return max_sum
```

```Java
// java
class Solution {
    public int minPairSum(int[] nums) {
        // 升序
        Arrays.sort(nums);
        int n = nums.length;
        int maxSum = 0;
        
        // 双指针思想
        for (int i = 0; i < n / 2; i++) {
            // 用“当前最小”配“当前最大”
            int curSum = nums[i] + nums[n - 1 - i];
            
            // 所有配对和中，保留最大的那个
            if (curSum > maxSum) {
                maxSum = curSum;
            }
        }
        
        return maxSum;
    }
}
```

- 时间复杂度： $O(n\times logn)$，快速排序
- 空间复杂度： $O(1)$，忽略排序的 $O(logn)$ 栈开销

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/solutions/3887858/tan-xin-pai-xu-hou-shou-wei-pei-dui-lei-f9ta7/)
