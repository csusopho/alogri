[Problem: 1975. 最大方阵和](https://leetcode.cn/problems/maximum-matrix-sum/description/)

### 方法：贪心

选择相邻的两个元素，同时乘以 $-1$ 变号。发现这种操作的本质！

**负号的“移动”**。假设我们有三个相邻的元素 $A, B, C$。

- 初始状态： $[-A, B, C]$
- 操作 $(A, B)$：变成 $[A, -B, C]$
- 再操作 $(B, C)$：变成 $[A, B, -C]$

**结论**：通过连续的操作，我们可以将一个负号从矩阵中的任意位置，移动到任意其他位置（因为矩阵是连通的）。

**负号的“抵消”**。假设矩阵中任意位置有两个负数。

- 利用 “移动” 的特性，我们可以将这两个负号移动到相邻的位置。
- 此时对这两个相邻的负数执行一次操作，它们都会变成正数。

**结论**：任意两个负号可以互相抵消，最终都变为正数。

基于上述两个发现，得出以下逻辑：

- 如果矩阵中有 **偶数个** 负数，可以将它们两两配对，通过移动和操作全部消除。最终所有元素都可以变成非负数。
- 如果矩阵中有 **奇数个** 负数，无论怎么操作，只能两两消除，最终必然会 **剩下一个负号** 无法消除。

因此，为了 “最大化方阵元素的和”：

- 假如原始矩阵有偶数个负数，可以把所有数字都变成正数。则最大和 = 所有元素的绝对值之和。
- 原始矩阵有奇数个负数，必须保留一个负号。**贪心地** 把这个 “无法消除的负号” 移动到 **绝对值最小** 的那个元素上。则最大和 = 所有元素的绝对值之和 - $2\times$ (最小绝对值)。

为什么要减 $2$ 倍？因为在累积 “所有绝对值之和” 时，把这个数当作正数加了一次。操作后它变为负数，所以要减去这一份（变回 $0$），再减去一份（变成负数）。

如果矩阵中有 $0$，且负数个数为奇数。将负号移动到 $0$ 上，减 $0$ 依然是 $0$。这等价于 $0$ 的绝对值是最小的，减去 $2 \times 0$ 不影响结果。所以上述逻辑对 **含零的情况** 完全通用。

统计绝对值之和，寻找最小绝对值，统计负数个数，都整合在一个 $for$ 循环中。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        total_sum = 0
        neg_count = 0
        # 最小绝对值
        min_abs_val = float('inf')
        
        for row in matrix:
            for x in row:
                # 累加绝对值
                val = abs(x)
                total_sum += val
                
                # 维护最小绝对值
                if val < min_abs_val:
                    min_abs_val = val
                
                # 统计负数个数
                if x < 0:
                    neg_count += 1
        
        # 判断负数的个数
        if neg_count % 2 == 0:
            # 偶数，负号都能消除
            return total_sum
        else:
            # 奇数，必须保留一个负号
            return total_sum - 2 * min_abs_val
```

```Java
// java
class Solution {
    public long maxMatrixSum(int[][] matrix) {
        long total_sum = 0;
        int neg_count = 0;
        // 最小绝对值
        int min_abs_val = Integer.MAX_VALUE;
        
        for (int[] row : matrix) {
            for (int x : row) {
                // 累加绝对值
                int val = Math.abs(x);
                total_sum += val;
                
                // 维护最小绝对值
                if (val < min_abs_val) {
                    min_abs_val = val;
                }
                
                // 统计负数个数
                if (x < 0) {
                    neg_count++;
                }
            }
        }
        
        // 判断负数的个数
        if (neg_count % 2 == 0) {
            // 偶数，负号都能消除
            return total_sum;
        } else {
            // 奇数，必须保留一个负号
            return total_sum - 2L * min_abs_val;
        }
    }
}
```

- 时间复杂度： $O(n^2)$，其中 $n$ 是方阵 $matrix$ 的边长
- 空间复杂度： $O(1)$，仅使用常数个额外变量

如果将 $minVal$ 初始化为 $10^5$，并且返回答案时结构优化为如下形式：

```Python
# 奇数个负数时，减去 2 倍的最小绝对值
if neg_count % 2 != 0:
    total_sum -= 2 * min_abs_val

return total_sum
```

那么，整体 $Python$ 运行时间会缩小 $4ms$，变为速度最快的一批，超过 $97\%$。

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-matrix-sum/solutions/3873047/tan-xin-kan-tou-ben-zhi-fu-shu-de-yi-don-rsgp/)
