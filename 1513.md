[Problem: 1513. 仅含 1 的子串数](https://leetcode.cn/problems/number-of-substrings-with-only-1s/description/)

### 方法：模拟 & 数学

字符串 $111$ 有几个子串？**暴力** 的做法：从前往后遍历，每个字符都作为子串的终点，然后累加计数。

比如，以第一个 $1$ 结尾的子串共有 $1$ 个，以第二个 $1$ 结尾的子串共有 $1,11$ 两个，以第三个 $1$ 结尾的子串共有 $1,11,111$ 三个。

总结上述 **流程**：统计连续 $1$ 的个数 $cnt$，如果当前字符是 $1$，就意味着新增了 $cnt+1$ 个以当前 $1$ 结尾的子串数，增加到答案；反之，说明连续 $1$ 中断。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSub(self, s: str) -> int:
        MOD = 10**9 + 7
        res = 0
        cnt = 0  # 当前连续'1'的个数
        
        for char in s:
            if char == '1':
                # 新增 cnt + 1 个以当前 '1' 结尾的子串
                cnt += 1
                res += cnt
            else:
                # 计数器归零
                cnt = 0
            # 在每一步累加后都取模
            res %= MOD
            
        return res
```

```Java
// java
class Solution {
    public int numSub(String s) {
        final int MOD = 1_000_000_007;
        long res = 0;
        int cnt = 0; // 当前连续'1'的个数

        for (char character : s.toCharArray()) {
            if (character == '1') {
                // 新增 cnt + 1 个以当前 '1' 结尾的子串
                cnt++;
                res += cnt;
            } else {
                // 计数器归零
                cnt = 0;
            }
            // 在每一步累加后都取模
            res %= MOD;
        }

        return (int) res;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 是字符串 $s$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 数学

上面的做法是拆分到 **每一步统计**，而实际上我们可以放在 **一起统计**。也即，先统计这一连续块的长度，然后再进行数学计算。

本质上来看，就是将 $0+1+2+\dots+t-1$ 的累加过程换成一步 $t\times(t-1)/2$。特别提醒，最后一块可能以 $1$ 结尾，记得处理最后一段。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSub(self, s: str) -> int:
        MOD = 10**9 + 7
        res = 0
        cnt = 0
        
        for char in s:
            if char == '1':
                # 连续计数
                cnt += 1
            else:
                # 结算上一段连续的 '1'
                res += cnt * (cnt + 1) // 2
                # 累加后取模
                res %= MOD
                # 重置计数器
                cnt = 0
        
        # 处理以 '1' 结尾的最后一段
        if cnt > 0:
            res += cnt * (cnt + 1) // 2
            res %= MOD
            
        return res
```

```Java
// java
class Solution {
    public int numSub(String s) {
        final int MOD = 1_000_000_007;
        long res = 0;
        long cnt = 0;  // 记得使用 long

        for (char character : s.toCharArray()) {
            if (character == '1') {
                // 连续计数
                cnt++;
            } else {
                // 结算上一段连续的 '1'
                res += cnt * (cnt + 1) / 2;
                // 累加后取模
                res %= MOD;
                // 重置计数器
                cnt = 0;
            }
        }

        // 处理以 '1' 结尾的最后一段
        if (cnt > 0) {
            res += cnt * (cnt + 1) / 2;
            res %= MOD;
        }

        return (int) res;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

经本人实测，如果将连续 $1$ 的计数放入哈希，然后再遍历哈希计算，运行时间与这段代码一致，并没有提升。

---

### 优化

手动遍历串，统计每块 $1$ 的个数，意味着每个 $s[i]$ 都会经历 “判断+计算”，速度较慢。

调库，使用 $split$ 根据 $0$ 将串 $s$ **切分**，那么切分的每一段都只含有 $1$，我们只需要处理每段就行，避免对每个字符的判断！

代码如下，实测速度最快，能超过 $98\%$：

```Python
# python
class Solution:
    def numSub(self, s: str) -> int:
        ones = s.split('0')
        res = 0
        for sub in ones:
            res += len(sub) * (len(sub) + 1) / 2
        return int(res % (10**9 + 7))
```

```Java
// java
class Solution {
    public int numSub(String s) {
        String[] ones = s.split("0");
        long res = 0;
        final int MOD = 1_000_000_007;

        for (String sub : ones) {
            // 记得使用 long
            long n = sub.length();
            res += n * (n + 1) / 2;
            // 更好的做法是在循环内部取模
            res %= MOD; 
        }
        
        return (int) res;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/number-of-substrings-with-only-1s/solutions/3832920/shu-xue-bao-li-mo-ni-shu-xue-yi-ci-bian-c61ix/)
