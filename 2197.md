[Problem: 2197. 替换数组中的非互质数](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/)

### 方法：栈

什么是 $LCM$ 和 $GCD$？

- **GCD (Greatest Common Divisor)**：最大公约数，是指两个或多个整数共有约数中最大的一个。
- **LCM (Least Common Multiple)**：最小公倍数，是指两个或多个整数公有的倍数中，除 $0$ 以外最小的一个正整数。

$LCM$ 和 $GCD$ 满足：两个正整数的乘积等于它们的最小公倍数和最大公约数的乘积。

对于任意两个正整数 `a` 和 `b`，它们的关系可以用以下公式表示：

$$lcm(a, b) \times gcd(a, b) = a \times b$$

以数字 $12$ 和 $18$ 为例：

1）求最大公约数 $GCD$：

- $12$ 的约数有： $1, 2, 3, 4, 6, 12$
- $18$ 的约数有： $1, 2, 3, 6, 9, 18$
- 因此，它们的最大公约数是 $6$

2）求最小公倍数 $LCM$：

- $12$ 的倍数有： $12, 24, 36, 48,\dots$
- $18$ 的倍数有： $18, 36, 54,\dots$
- 因此，它们的最小公倍数是 $36$

3）验证关系：

- `lcm(12, 18) * gcd(12, 18) = 36 * 6 = 216`
- `12 * 18 = 216`

两者结果相同，验证了上述公式。（具体数学证明，可以上网查阅）

我们也可以通过 `质因数分解` 来理解这个关系：

- 将 $12$ 和 $18$ 分解质因数： $12 = 2^2 * 3^1,18 = 2^1 * 3^2$；
- **$GCD$ 的计算**：取两者共有的质因数，并选择较低的指数：`gcd(12, 18) = 2¹ * 3¹ = 6`；
- **$LCM$ 的计算**：取两者所有的质因数，并选择较高的指数：`lcm(12, 18) = 2² * 3² = 4 * 9 = 36`。

从这个角度看，`a * b` 的质因数分解包含了每个质因数的指数之和，而 `lcm * gcd` 的质因数分解也恰好是每个质因数的（较高指数 + 较低指数），因此两者是相等的。

如何编写代码计算 $GCD$？

- 辗转相减法/更相减损术：

```Java
// 递推版
int gcd(int a, int b) {
    while (a != b) {
        if (a > b) {
            a -= b;
        } else {
            b -= a;
        }
    }
    return a;
}
```

```Java
// 递归版
int gcd(int a, int b) {
    return a == b ? a : a > b ? gcd(a - b, b) : gcd(a, b - a);
}
```

- 辗转相除法/欧几里得算法：

```Java
// 递推版
int gcd(int a, int b) {
    while (b != 0) {  // 只要b不等于0，就继续迭代
        int tmp = b;
        b = a % b;
        a = tmp;
    }
    return a;
}
```

```Java
// 递归版
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

- 素因子分解法：

```Java
// 递推版
int gcd(int a, int b) {
    int yz = 1; // 定义变量 yz，初始值为 1
    for (int i = 2; i <= b; i++) { // 从 2 到 b 枚举可能的因子
        if (a % i == 0 && b % i == 0) { // 如果 i 是 a 和 b 的公因子
            a /= i; // 将 a 除以 i，去除公因子
            b /= i; // 将 b 除以 i，去除公因子
            yz *= i; // 将 i 乘入 yz，记录公因子
            i--; // i 需要再次枚举，所以减一
        }
    }
    return yz; // 返回最大公因数
}
```

只要计算出 $GCD$，然后利用上面的数学公式，就可快速得出 $LCM$。

---

**题意**：如果 $x,y$ 两数的 $GCD>1$，就说明是 “非互质数”。将两数删除，替换为 $LCM$。

**最大难点**：假设 $a,b,c$ 三数相邻，到底优先计算 $a,b$ 还是 $c,d$？题目已经指出，**任意顺序** 替换，可以得到相同的结果。到底该如何证明？

**本质原因**： $LCM$ 具有交换律。想象一下，数组中的数字因为 “非互质” 关系而相互连接。那么，`a,b,c` 就形成了一个 “连通分量”。在这个 “区块” 内的任何操作，都不会影响到 “区块” 外的数字。无论是任意处理顺序，只要是处理一个连续的非互质区块，最终的结果都是这个区块内所有数字的最小公倍数。

> 如果想看数学证明，请评论区留言，我看到后就附加。

因此，本题只需要直接模拟，一旦相邻两数 “非互质” 就立刻删除+替换。如何不断地合并相邻数字？使用 **栈**。

- 栈顶 —— 前一个数字；
- 新加入 —— 当前数字。

这种思维使得我们避免索引问题，从而正确处理相邻（前后）的关系。

代码如下，已附加注释：

```Python
# python
class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        # 计算最大公约数 GCD
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        # 计算最小公倍数 LCM
        def lcm(a, b):
            # 使用整数除法
            return a * b // gcd(a, b)

        res = []  # 栈
        
        for num in nums:
            # 将当前数字加入
            res.append(num)
            
            # 检查新加入的数字是否与它前面的数字非互质
            while len(res) >= 2:
                x = res[-2]  # 前一个元素
                y = res[-1]  # 新加入的元素
                
                common_divisor = gcd(x, y)
                
                # 互质，则停止合并
                if common_divisor == 1:
                    break
                # 如果非互质，则将这两个数弹出
                last = res.pop()
                prev = res.pop()
                
                # 计算它们的LCM
                new_val = lcm(prev, last)
                res.append(new_val)

        return res
```

```Java
// java
class Solution {
    public List<Integer> replaceNonCoprimes(int[] nums) {
        // LinkedList 在尾部的添加/删除操作上效率更高
        LinkedList<Integer> res = new LinkedList<>(); // 栈
        
        for (int num : nums) {
            // 将当前数字加入
            res.add(num);
            
            // 检查新加入的数字是否与它前面的数字非互质
            while (res.size() >= 2) {
                int y = res.getLast();      // 新加入的元素
                int x = res.get(res.size() - 2); // 前一个元素
                
                long commonDivisor = gcd(x, y);
                
                // 互质，则停止合并
                if (commonDivisor == 1) {
                    break;
                }
                
                // 如果非互质，则将这两个数弹出
                res.removeLast(); // 弹出 y
                res.removeLast(); // 弹出 x
                
                // 计算它们的LCM，并将新值加回栈中
                int newVal = (int)lcm(x, y);
                res.add(newVal);
            }
        }

        return res;
    }

    // 计算最大公约数 GCD
    private long gcd(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // 计算最小公倍数 LCM
    private long lcm(long a, long b) {
        if (a == 0 || b == 0) {
            return 0;
        }
        // 使用公式: lcm(a, b) = (a * b) / gcd(a, b)
        return a * b / gcd(a, b);
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为数组 $nums$ 的长度，数学计算/压入/弹出的时间为 $O(1)$
- 空间复杂度： $O(1)$，返回值 $res$ 一般不计入复杂度

---

### 简化

`Math.gcd()` 这个函数是在 `Java 8` 中才被添加到 `java.lang.Math` 类库，而力扣编辑器是 `Java 7`，所以无法直接调库，只能使用 `java.math.BigInteger.gcd()`。但是这样代码也比较长，所以不再展示。

对 $Python$ 代码进行整合，从而大幅度简化，得出如下代码：

```Python
# python
class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        res = []
        for x in nums:
            # 只要非互质，且GCD>1就弹出
            while res and gcd(x, res[-1]) > 1:
                x = lcm(x, res.pop())
            # 计算结果加入栈
            res.append(x)
        return res
```

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/solutions/3783419/shu-xue-san-chong-gcdmo-ban-zhan-mo-ni-j-ffav/)
