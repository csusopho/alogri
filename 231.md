[Problem: 231. 2 的幂](https://leetcode.cn/problems/power-of-two/description/)

### 方法：位运算 & 数学

什么是 $2$ 的幂？比如 $2,4,\dots$，它们的二进制的形式为 $10,100,\dots$。也即，该数字在二进制的组成中，仅仅只有一个 $1$，其余全是 $0$。

**注意**：所有 $2^x$ 一定大于 $0$，小于等于 $0$ 的数字肯定不符合要求。

题目不允许循环/递归，但是为了防止小白不太清楚，这里仅作展示，代码如下：

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 2 == 0:
            n = n // 2
        return n == 1
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) {
            return false;
        }
        while (n % 2 == 0) {
            n = n / 2;
        }
        return n == 1;
    }
}
```

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1:
            return True
        if n == 0 or n % 2 != 0:
            return False 
        return self.isPowerOfTwo(n // 2)
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n == 1) {
            return true;
        }
        if (n == 0 || n % 2 != 0) {
            return false;
        }
        return isPowerOfTwo(n / 2);
    }
}
```

如果我们选择调库，而非手写，则有：

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and bin(n).count('1') == 1
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && Integer.bitCount(n) == 1;
    }
}
```

根据计算机的精度问题，可以直接暴力将数字 **取对数**，判断结果是整数还是小数：

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and log(n, 2) == int(log(n, 2))
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && Math.log(n) / Math.log(2) == (int)(Math.log(n) / Math.log(2));
    }
}
```

- 时间复杂度： $O(logn)$，其中 $n$ 为题目给定数字，位运算
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 位运算

$2^x$ 是 $10000$ 的形式，如果将它减去 $1$，则会变为 $01111$ 的形式。与 $AND$ 运算规则是：有 $0$ 则 $0$，全 $1$ 为 $1$。所以两者相与后，答案会变为 $0$。

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & (n - 1) == 0
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```

在计算机里，整数是用 **二进制补码** 表示的：

- 正数的补码 = 原码
- 负数的补码 = 原码按位取反 + 1

例如 $n=8$，正数和原码相同，原码就是 `00001000`，补码就是 `00001000`。

计算 $-n$ 时， $n$ 按位取反得到 `11110111`，加 $1$ 变为 `11111000`。可以返现，仅仅只是前面增加了很多 $1$。

`n & -n` 则会保留 $n$ 的最低位的 $1$，其他位全部变成 $0$。比如上面 $n=8$ 时，结果为 `00001000`，这个值是 $8$。换成 $n=12$，则

```Java
    n     = 00001100
   -n     = 11110100
    &     ----------
            00000100   ← 只剩最低位的 1
```

这个值是 $8$，与原数 $12$ 不相同，说明不是 $2$ 的幂。代码如下：

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & -n == n
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & -n) == n;
    }
}
```

- 时间复杂度： $O(1)$，数学运算
- 空间复杂度： $O(1)$

---

### 数学

题目限制 $n\le 2^{31}-1$，所以最大的数字为 $2^{30}$。已知 $4$ 能整除 $8$，所以根据这种数学关系，能整出一种花活，代码如下：

```Python
# python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (1 << 30) % n == 0
```

```Java
// java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (1 << 30) % n == 0;
    }
}
```

- 时间复杂度： $O(1)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/power-of-two/solutions/3747419/qi-jie-mo-ni-di-gui-diao-ku-wei-yun-suan-rotf/)
