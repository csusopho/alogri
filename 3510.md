[Problem: 3510. 移除最小数对使数组有序 II](https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-ii/description/)

### 双有序集合

前一题是 $3507$，本题再使用暴力则会超时。

暴力速度慢的本质：一次遍历查找最小相邻和，删除元素会移动后续所有元素。

在删除合并过程中，数组 $nums$ 的物理空间其实没变，变的是 **“哪些索引还是有效的”**。

- 初始时，有效索引集合是 $\{0, 1, 2, 3, 4, \dots\}$
- 如果合并了索引 $2$ 和 $3$，有效集合变成 $\{0, 1, 2, 4, \dots\}$
- 在这个集合中， $2$ 的下一个数是 $4$

原本在 $nums$ 中的“相邻”，现在变成了 **“在有序集合中位置相邻”。**

因此，维护一个 **有序集合** $valid$，它存储有效的索引。同时再维护一个 **有序集合** $candidates$，它存储有效的相邻元素和。

将 $valid$ 初始为 $[0, 1, 2, ..., n-1]$，表示当前的拓扑结构。以及 $candidates$ 存储 $(sum, index)$，表示当前的决策空间，注意 $index$ 是 $nums$ 中左边元素的索引。

还可以维护一个变量 $cnt$ 表示逆序的相邻元素对的个数，如果为 $0$ 说明已递增。

每一次合并操作，都可以拆解为 **“定位 $\rightarrow$ 断开 $\rightarrow$ 重连”** 三步骤。

---

**第一步，定位**。

首先询问候选管理员：当前谁的和最小？集合升序，所以 $candidates[0]$ 给出 $(minSum, u)$。

然后询问拓扑管理员： $u$ 的左右护法是谁？为了方便，在 $valid$ 中二分查找 $u$ 的位置 $rank$。则左邻居 $L$ = $valid[rank - 1]$，右邻居 $V$ = $valid[rank + 1]$，右右邻居 $R$ = $valid[rank + 2]$。

千万别混淆，上面的 $u$ 是 $nums$ 中索引，而 $rank$ 表示它在 $valid$ 中索引。

**第二步，断开旧连接**。

在物理合并发生前，必须先清除旧关系对 “环境” 的影响。

清除逆序贡献：

- 判断 $(L, u)$ 是否逆序？是则 $cnt - 1$
- 判断 $(u, V)$ 是否逆序？是则 $cnt - 1$
- 判断 $(V, R)$ 是否逆序？是则 $cnt - 1$

清除候选资格：

- 从 $candidates$ 中直接移除 $(nums[L]+nums[u], L)$
- 从 $candidates$ 中直接移除 $(nums[V]+nums[R], V)$

**第三步，物理合并与重连**。

将 $(u,v)$ 物理合并，也即 $nums[u] += nums[v]$。

接着删除拓扑，从 $valid$ 中移除 $V$，让 $u$ 在拓扑序列中的直接后继变成了 $R$。

建立新连接：

- 计算新逆序贡献：检查 $(L, u)$ 和 $(u, R)$，更新 $cnt$
- 注册新候选人：将新的相邻和 $nums[L]+nums[u]$ 和 $nums[u]+nums[R]$ 加入 $candidates$

流程结束后，检查 $cnt$。一旦归零，返回总操作次数 $ops$。

---

理清逻辑，这个方法相对容易理解。**数值** 归 $nums$ 管，**位置** 归 $valid$ 管，**优先级** 归 $candidates$ 管。各司其职。

代码如下，已附加注释：

```Python
# python
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        n = len(nums)
        ops = 0
        # 维护当前有效的索引
        valid = SortedList(range(n))
        # 维护 (相邻和, 左侧索引)
        candidates = SortedList()
        for i in range(n - 1):
            candidates.add((nums[i] + nums[i+1], i))
            
        # 统计初始逆序对数量
        descent_cnt = 0
        for i in range(n - 1):
            if nums[i] > nums[i+1]:
                descent_cnt += 1
        
        # 已经非递减
        if descent_cnt == 0:
            return 0
        
        while descent_cnt > 0:
            if not candidates:
                break

            # 取出和最小的一对 (sum, i)
            cur_sum, u = candidates.pop(0) 
            
            # 在 valid 中找到 u 的位置
            # 我们要合并 u 和 v，变成 u
            rank = valid.index(u)
            # v 是 u 的右邻居
            v = valid[rank + 1]
            
            l_idx = valid[rank - 1] if rank > 0 else -1
            r_idx = valid[rank + 2] if rank + 2 < len(valid) else -1

            # 1. 移除逆序数计数
            # 左边关系 (l_idx, u)
            if l_idx != -1:
                if nums[l_idx] > nums[u]:
                    descent_cnt -= 1
            
            # 中间关系 (u, v)
            if nums[u] > nums[v]:
                descent_cnt -= 1
                
            # 右边关系 (v, r_idx)
            if r_idx != -1:
                if nums[v] > nums[r_idx]:
                    descent_cnt -= 1
                    
            # 2. 从 candidates 中移除受影响的“和”
            # 移除左边对: (l_idx, u)
            if l_idx != -1:
                candidates.remove((nums[l_idx] + nums[u], l_idx))
                
            # 移除右边对 (v, r_idx)
            if r_idx != -1:
                candidates.remove((nums[v] + nums[r_idx], v))
                
            # 3. 执行合并
            nums[u] += nums[v]
            # 从拓扑结构中移除 v
            valid.pop(rank + 1)
            ops += 1

            # 4. 更新逆序数
            if l_idx != -1:
                if nums[l_idx] > nums[u]:
                    descent_cnt += 1 
            if r_idx != -1:
                if nums[u] > nums[r_idx]:
                    descent_cnt += 1
            
            # 将新的和加入 candidates
            if l_idx != -1:
                candidates.add((nums[l_idx] + nums[u], l_idx))
            if r_idx != -1:
                candidates.add((nums[u] + nums[r_idx], u))
             
        return ops
```

```Java
// java
class Solution {
    public int minimumPairRemoval(int[] numsInput) {
        int n = numsInput.length;
        // 使用 long 数组防止求和溢出
        long[] nums = new long[n];
        for (int i = 0; i < n; i++) {
            nums[i] = numsInput[i];
        }
        
        int ops = 0;
        
        // 维护当前有效的索引
        TreeSet<Integer> valid = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            valid.add(i);
        }
        
        // 维护 (相邻和, 左侧索引)
        // 优先按 sum 排序，sum 相同按 index 排序
        TreeSet<long[]> candidates = new TreeSet<>((a, b) -> {
            int cmp = Long.compare(a[0], b[0]);
            if (cmp != 0) return cmp;
            return Long.compare(a[1], b[1]);
        });
        
        for (int i = 0; i < n - 1; i++) {
            candidates.add(new long[]{nums[i] + nums[i+1], i});
        }
            
        // 统计初始逆序对数量
        int descent_cnt = 0;
        for (int i = 0; i < n - 1; i++) {
            if (nums[i] > nums[i+1]) {
                descent_cnt++;
            }
        }
        
        // 已经非递减
        if (descent_cnt == 0) {
            return 0;
        }
        
        while (descent_cnt > 0) {
            if (candidates.isEmpty()) {
                break;
            }

            // 取出和最小的一对 (sum, i)
            long[] cur = candidates.pollFirst(); 
            int u = (int) cur[1];
            
            // 在 valid 中找到 u 的位置
            // 我们要合并 u 和 v，变成 u
            // v 是 u 的右邻居
            Integer v = valid.higher(u);
            
            // 获取 l_idx (u 的左邻居) 和 r_idx (v 的右邻居)
            Integer l_idx = valid.lower(u);
            Integer r_idx = (v != null) ? valid.higher(v) : null;

            // 1. 移除逆序数计数
            // 左边关系 (l_idx, u)
            if (l_idx != null) {
                if (nums[l_idx] > nums[u]) {
                    descent_cnt--;
                }
            }
            
            // 中间关系 (u, v)
            if (v != null && nums[u] > nums[v]) {
                descent_cnt--;
            }
                
            // 右边关系 (v, r_idx)
            if (v != null && r_idx != null) {
                if (nums[v] > nums[r_idx]) {
                    descent_cnt--;
                }
            }
                    
            // 2. 从 candidates 中移除受影响的“和”
            // 移除左边对: (l_idx, u)
            if (l_idx != null) {
                candidates.remove(new long[]{nums[l_idx] + nums[u], l_idx});
            }
                
            // 移除右边对 (v, r_idx)
            if (v != null && r_idx != null) {
                candidates.remove(new long[]{nums[v] + nums[r_idx], v});
            }
                
            // 3. 执行合并
            if (v != null) {
                nums[u] += nums[v];
                // 从拓扑结构中移除 v
                valid.remove(v);
                ops++;
            }

            // 4. 更新逆序数
            if (l_idx != null) {
                if (nums[l_idx] > nums[u]) {
                    descent_cnt++; 
                }
            }
            if (r_idx != null) {
                if (nums[u] > nums[r_idx]) {
                    descent_cnt++;
                }
            }
            
            // 将新的和加入 candidates
            if (l_idx != null) {
                candidates.add(new long[]{nums[l_idx] + nums[u], l_idx});
            }
            if (r_idx != null) {
                candidates.add(new long[]{nums[u] + nums[r_idx], u});
            }
        }
             
        return ops;
    }
}
```

- 时间复杂度： $O(n\times logn)$，有序集合中查找/删除，维护有序性为 $O(log)$ 时间
- 空间复杂度： $O(n)$，表示两个有序集合的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-ii/solutions/3887172/shuang-you-xu-ji-he-fen-bu-tui-dao-jie-s-ppri/)
