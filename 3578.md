[Problem: 3578. 统计极差最大为 K 的分割方式数](https://leetcode.cn/problems/count-partitions-with-max-min-difference-at-most-k/description/)

### 方法：DP+最小堆/单调队列

题意比较清晰，想象一下，假如我们想计算 $nums[0...10]$ 的分割方法数。

- 切了最后一刀，把数组分成了 $nums[0...5]$ 和 $nums[6...10]$。
- 如果已知 $nums[0...5]$ 有 $S$ 种分割方法，那么对于这种特定的 “最后一刀”，总方法数就是 $S \times 1$。
- 这意味着，解决 **长数组** 的问题，可以归结为解决前面 **较短数组** 的问题。父->子，符合 $DP$ 的核心思想。

**无后效性**：一旦我们把前 $i$ 个数字分割好了，算出有 $S$ 种方法。后面处理第 $i+1$ 个数字时，不需要知道前面具体是怎么分的，只需要知道前面一共分了 $S$ 种即可。前面的决策不会影响后面 “如何计算”，只会影响 “数据基础”。

**定义** $dp[i]$ 表示计算 $nums[0...i]$ 的分割方案数，记为 $dp[i]$。

假设最后一段的结束位置是 $i$。那么它的开始位置 $j$ 可以是 $i$，可以是 $i-1$，可以是 $i-2\dots$，直到某个位置 $left$，再往左就不满足 “最大-最小” 的差值 $\le k$。

**枚举所有可能的 “最后一段”：**

- 最后一段是 $[i]$。肯定满足 $max-min <= k$，这种切法就是合法的。前面部分是 $nums[0...i-1]$，所以方案数为 $dp[i-1]$。
- 最后一段是 $[i-1, i]$。如果这段合法，剩下的前面部分是 $nums[0...i-2]$，方案数为 $dp[i-2]$。
- ... 以此类推。

最后一段长度为 $1$ 的切法，**绝不可能** 同时是长度为 $2$ 的切法。这些情况是 **互斥** 的，根据 **加法原理**：总方案数 = 情况A的方案数 + 情况B的方案数 + ...

> 不好理解？其实就是切一刀 = 一种方案，不同切分方式独立，切分的左右两段互不干扰。

用数学方式表达，得出 **状态转移方程**：

$$
dp[i] = dp[i-1] + dp[i-2] + ... + dp[left]
$$

也就是说 $dp[i] = sum(dp[j])$，累加所有合法的 “前继状态”。

初始化 $dp[0]=1$ 表示空数组，方案数为 $1$。

其他细节不再阐述，使用倒序遍历寻找 $j$ 即可。代码如下，已附加注释：

```Python
# python
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        n = len(nums)
        MOD = 10**9 + 7
        # dp[i] 表示数组 [0,i-1] 元素的合法分割方案总数
        dp = [0] * (n + 1)
        # 初始化
        dp[0] = 1

        for i in range(1, n + 1):
            # 动态维护当前子段的最值
            cur_max = -float('inf')
            cur_min = float('inf')
            
            # 枚举“最后一段”的开始位置 j
            for j in range(i - 1, -1, -1):
                val = nums[j]
                
                # 更新
                if val > cur_max: cur_max = val
                if val < cur_min: cur_min = val
                
                # 检查 [j, i-1] 是否合法
                if cur_max - cur_min <= k:
                    # 可以在 j 处切一刀
                    dp[i] = (dp[i] + dp[j]) % MOD
                else:
                    # 剪枝优化
                    break
                    
        return dp[n]
```

时间复杂度为 $O(n^2)$，题目限制 $n\leq 5\times 10^4$，所以会超时，卡在 $869/878$ 样例。

---

### 堆

我们计算的是 $\sum dp[j]$，随着 $j$ 向左移动，子段 $nums[j...i-1]$ 变长，最大值可能变大，最小值可能变小，差值只会增大或不变。

将 $[left,i]$ 视为一个窗口，随着右边界 $i$ 的增加，差值增大或不变，为了符合题目要求，则 $left$ 也只能向右移动，具有 **单调性**，所以能使用滑动窗口。

如何在窗口中快速获取最小/大值？使用 **堆/优先队列**。

这样只能弹出堆顶元素，无法直接移除堆中间元素，怎么办？使用 **延迟删除** 策略。

- 堆中存储元组 `(数值, 下标)`。
- 当堆顶元素的下标小于当前窗口左边界 $left$ 时，说明这个堆顶已经失效（滑出窗口），此时才将其弹出。
- 反之，下标在窗口内，即使堆内部有失效元素，也不影响我们获取当前窗口的最值。

计算区间 $[left, i-1]$ 的和，每次都遍历求解吗？使用 **前缀和** 进行优化，具体原理可以看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。

注意 $prefix[i]$ 表示的是 $dp$ 数组在 $[0,i-1]$ 内的区间和，也即 $\sum_{k=0}^{i-1} dp[k]$。

**算法流程**，从前往后遍历：

- 将当前元素 $nums[i-1]$ 加入两个堆中；
- 如果最小/大堆的堆顶元素在窗口外，则移除；
- 获取窗口最值，判断差值是否满足条件，不满足则右移 $left$。
- 利用前缀和计算 $dp[i] = prefix[i] - prefix[left]$，并更新 $presum[i+1]$。

答案是最后一次计算出的 $dp[n]$，或者说 $prefix[n+1] - prefix[n]$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        n = len(nums)
        MOD = 10**9 + 7
        # prefix[i] 表示 sum(dp[0]...dp[i-1])
        prefix = [0] * (n + 2)
        prefix[1] = 1  # 初始化

        # min_heap 存储窗口内的 (val, index)，最小堆
        # max_heap 存储窗口内的 (-val, index)，最大堆
        min_heap = []
        max_heap = []
        left = 0
        
        for i in range(1, n + 1):
            num = nums[i-1]
            idx = i - 1
            
            # 入堆
            heapq.heappush(min_heap, (num, idx))
            heapq.heappush(max_heap, (-num, idx))
            
            while True:
                # 清理堆顶
                while min_heap and min_heap[0][1] < left:
                    heapq.heappop(min_heap)
                while max_heap and max_heap[0][1] < left:
                    heapq.heappop(max_heap)
                
                # 获取当前窗口最值
                curr_min = min_heap[0][0]
                curr_max = -max_heap[0][0]
                
                # 检查是否满足条件，停止收缩
                if curr_max - curr_min <= k:
                    break
                
                # 不满足条件，继续尝试
                left += 1
            
            # 有效的上一个分割点 j 的范围是 [left, i-1]
            cur_plan = (prefix[i] - prefix[left]) % MOD
            # 更新前缀和
            prefix[i+1] = (prefix[i] + cur_plan) % MOD
        
        # 结果是 dp[n]，即最后一次计算出的 cur_plan
        return (prefix[n+1] - prefix[n]) % MOD
```

```Java
// java
class Solution {
    public int countPartitions(int[] nums, int k) {
        int n = nums.length;
        int MOD = 1_000_000_007;
        // prefix[i] 表示 sum(dp[0]...dp[i-1])
        long[] prefix = new long[n + 2];
        prefix[1] = 1;  // 初始化

        // min_heap 存储窗口内的 (val, index)，最小堆
        // max_heap 存储窗口内的 (-val, index)，最大堆
        PriorityQueue<int[]> min_heap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        PriorityQueue<int[]> max_heap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        int left = 0;
        
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            int idx = i - 1;
            
            // 入堆
            min_heap.offer(new int[]{num, idx});
            max_heap.offer(new int[]{-num, idx});
            
            while (true) {
                // 清理堆顶
                while (!min_heap.isEmpty() && min_heap.peek()[1] < left) {
                    min_heap.poll();
                }
                while (!max_heap.isEmpty() && max_heap.peek()[1] < left) {
                    max_heap.poll();
                }
                
                // 获取当前窗口最值
                int curr_min = min_heap.peek()[0];
                int curr_max = -max_heap.peek()[0];
                
                // 检查是否满足条件，停止收缩
                if (curr_max - curr_min <= k) {
                    break;
                }
                
                // 不满足条件，继续尝试
                left++;
            }
            
            // 有效的上一个分割点 j 的范围是 [left, i-1]
            // 取模处理负数需要 +MOD
            long cur_plan = (prefix[i] - prefix[left] + MOD) % MOD;
            // 更新前缀和
            prefix[i + 1] = (prefix[i] + cur_plan) % MOD;
        }
        
        // 结果是 dp[n]，即最后一次计算出的 cur_plan
        return (int) ((prefix[n + 1] - prefix[n] + MOD) % MOD);
    }
}
```

- 时间复杂度： $O(n\times logn)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(n)$，表示堆 $heap$ 以及数组 $prefix$ 的大小

---

### 单调队列

我们可以手动维护 **两个双端队列**，分别存储最大/小值的下标。

其中，最大值队列从左到右 **递减**。如果当前元素值比队尾更大，说明应该去除队尾，让 $i$ 加入队尾；同样地，最小值队列从左到右 **递增**。

这样做有什么好处？两个队列的末尾分别是最大/小值，那么两者相减，就能判断窗口是否符合要求，且从左到右的下标是递增的，直接从队首弹出下标即可。

整体逻辑不变，代码如下，已附加注释：

```Python
# python
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        n = len(nums)
        MOD = 10**9 + 7
        # prefix[i] 表示 sum(dp[0]...dp[i-1])
        prefix = [0] * (n + 2)
        prefix[1] = 1  # 初始化

        # max_q 维护窗口内的最大值下标，递减
        # min_q 维护窗口内的最小值下标，递增
        max_q = deque()
        min_q = deque()
        left = 0
        
        for i in range(1, n + 1):
            num = nums[i-1]
            
            # 维护最大值队列
            while max_q and nums[max_q[-1]] <= num:
                max_q.pop()
            max_q.append(i-1)
            
            # 维护最小值队列
            while min_q and nums[min_q[-1]] >= num:
                min_q.pop()
            min_q.append(i-1)
            
            # 收缩左边界 left
            while nums[max_q[0]] - nums[min_q[0]] > k:
                left += 1
                # 如果队首的下标已经滑出窗口左侧，则移除
                if max_q[0] < left:
                    max_q.popleft()
                if min_q[0] < left:
                    min_q.popleft()
            
            # 有效的上一个分割点 j 的范围是 [left, i-1]
            cur_plan = (prefix[i] - prefix[left]) % MOD
            # 更新前缀和
            prefix[i+1] = (prefix[i] + cur_plan) % MOD
            
        # 结果是 dp[n]，即最后一次计算出的 cur_plan
        return (prefix[n+1] - prefix[n]) % MOD
```

```Java
// java
class Solution {
    public int countPartitions(int[] nums, int k) {
        int n = nums.length;
        int MOD = 1_000_000_007;
        // prefix[i] 表示 sum(dp[0]...dp[i-1])
        long[] prefix = new long[n + 2];
        prefix[1] = 1;  // 初始化

        // max_q 维护窗口内的最大值下标，递减
        // min_q 维护窗口内的最小值下标，递增
        Deque<Integer> max_q = new ArrayDeque<>();
        Deque<Integer> min_q = new ArrayDeque<>();
        int left = 0;
        
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            
            // 维护最大值队列
            while (!max_q.isEmpty() && nums[max_q.peekLast()] <= num) {
                max_q.pollLast();
            }
            max_q.offerLast(i - 1);
            
            // 维护最小值队列
            while (!min_q.isEmpty() && nums[min_q.peekLast()] >= num) {
                min_q.pollLast();
            }
            min_q.offerLast(i - 1);
            
            // 收缩左边界 left
            while (nums[max_q.peekFirst()] - nums[min_q.peekFirst()] > k) {
                left++;
                // 如果队首的下标已经滑出窗口左侧，则移除
                if (max_q.peekFirst() < left) {
                    max_q.pollFirst();
                }
                if (min_q.peekFirst() < left) {
                    min_q.pollFirst();
                }
            }
            
            // 有效的上一个分割点 j 的范围是 [left, i-1]
            // 取模处理负数需要 +MOD
            long cur_plan = (prefix[i] - prefix[left] + MOD) % MOD;
            // 更新前缀和
            prefix[i + 1] = (prefix[i] + cur_plan) % MOD;
        }
            
        // 结果是 dp[n]，即最后一次计算出的 cur_plan
        return (int) ((prefix[n + 1] - prefix[n] + MOD) % MOD);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-partitions-with-max-min-difference-at-most-k/solutions/3850254/shuang-jie-tui-dao-si-lu-you-lai-dphua-c-6sv1/)
