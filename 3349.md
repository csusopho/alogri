[Problem: 3349. 检测相邻递增子数组 I](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/description/)

### 方法：模拟 & 双指针 & DP

注意，两个子数组必须 **相邻**，而且是分别严格递增。

**简单思路**：枚举第一个子数组的起点 $i$，第二个子数组的起点就是 $i+k$，然后检查这两个子数组是否递增。

代码如下，已附加注释：

```Python
# python
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)

        # 判断从 start 开始的 k 长度子数组是否严格递增
        def is_increasing(start):
            for j in range(start + 1, start + k):
                if nums[j] <= nums[j - 1]:
                    return False
            return True

        # 枚举两个相邻的长度为k的子数组
        for i in range(n - 2 * k + 1):
            if is_increasing(i) and is_increasing(i + k):
                return True

        return False
```

```Java
// java
class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();

        // 枚举两个相邻的长度为k的子数组
        for (int i = 0; i <= n - 2 * k; i++) {
            if (isIncreasing(nums, i, k) && isIncreasing(nums, i + k, k)) {
                return true;
            }
        }

        return false;
    }

    // 判断从 start 开始的 k 长度子数组是否严格递增
    private boolean isIncreasing(List<Integer> nums, int start, int k) {
        // 从子数组的第二个元素开始检查
        for (int j = start + 1; j < start + k; j++) {
            if (nums.get(j) <= nums.get(j - 1)) {
                return false;
            }
        }
        return true;
    }
}
```

- 时间复杂度： $O(n\times k)$，其中 $n$ 是数组 $nums$ 的长度
- 空间复杂度： $O(1)$，仅使用常数个额外变量

---

### 双指针

可以将上面的过程看作双线操作，一个指针检查 $[i,i+k)$ 的子数组，另外一个指针检查 $[i+k,i+2k)$ 的子数组。

因此，我们将上面的过程变形为递推形式，使用两个指针，**同时进行** 检查。一旦某个指针发现非递增，另外一个指针也没必要进行！

代码如下，已附加注释（速度最快）：

```Python
# python
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n):
            j = i + k
            flag = True
            cnt = 1
            m = i
            # 检查两个子数组是否都是严格递增的
            while cnt < k:
                # 检查索引是否越界或者是否不满足严格递增条件
                if (m + 1 >= n or j + 1 >= n or 
                    nums[m] >= nums[m + 1] or 
                    nums[j] >= nums[j + 1]):
                    flag = False
                    break
                m += 1
                j += 1
                cnt += 1
            # 如果找到满足条件的子数组，立即返回True
            if flag and cnt == k:
                return True
        # 遍历完所有可能后仍未找到，返回False
        return False
```

```Java
// java
class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();

        // 外部循环遍历第一个子数组的所有可能起始点
        for (int i = 0; i < n; i++) {
            // j 是第二个相邻子数组的起始点
            int j = i + k;
            
            boolean flag = true;
            int cnt = 1;
            int m = i;

            // 检查两个子数组是否都是严格递增的
            while (cnt < k) {
                // 检查索引是否越界或者是否不满足严格递增条件
                if (m + 1 >= n || j + 1 >= n ||
                    nums.get(m) >= nums.get(m + 1) ||
                    nums.get(j) >= nums.get(j + 1)) {
                    flag = false;
                    break;
                }
                m++;
                j++;
                cnt++;
            }
            
            // 如果找到满足条件的子数组，立即返回True
            if (flag && cnt == k) {
                return true;
            }
        }
        
        // 遍历完所有可能后仍未找到，返回False
        return false;
    }
}
```

- 时间复杂度： $O(n\times k)$
- 空间复杂度： $O(1)$

---

### $DP$

可以用 **动态规划** 的逻辑来理解本题，拓宽一下思维。

**定义** $dp[i]$ 表示以 $nums[i]$ 结尾的连续递增子数组的长度。

- 如果 $nums[i]>nums[i-1]$，说明严格递增，则 $dp[i]=dp[i-1]+1$；
- 否则，说明不再递增，需要将 $dp[i]$ 置 $1$，表示仅含当前元素。

递推完 $DP$ 后，就要增加一次 $for$ 循环，检查相邻数组的长度是否符合要求。

其他细节不再阐述，代码如下，已附加注释：

```Python
# python
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        # dp[i] 表示以 nums[i] 结尾的连续递增子数组的长度
        dp = [0] * n
        dp[0] = 1
        
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1
            else:
                dp[i] = 1

        # 遍历寻找满足条件的相邻点
        for i in range(2 * k - 1, n):
            # 检查以 i-k 结尾的第一个子数组长度是否满足
            len_first = dp[i - k]
            # 检查以 i 结尾的第二个子数组长度是否满足
            len_second = dp[i]
            
            if len_first >= k and len_second >= k:
                return True
                
        return False
```

```Java
// java
class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();

        // dp[i] 表示以 nums[i] 结尾的连续递增子数组的长度
        int[] dp = new int[n];
        dp[0] = 1;

        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp[i] = dp[i - 1] + 1;
            } else {
                dp[i] = 1;
            }
        }

        // 遍历寻找满足条件的相邻点
        // 循环的起始点是 2*k - 1，这是第一个可能满足条件的 i 的值
        for (int i = 2 * k - 1; i < n; i++) {
            // 检查以 i-k 结尾的第一个子数组长度是否满足
            int len_first = dp[i - k];
            // 检查以 i 结尾的第二个子数组长度是否满足
            int len_second = dp[i];

            if (len_first >= k && len_second >= k) {
                return true;
            }
        }

        return false;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$，表示数组 $dp$ 的空间

---

### 一次遍历

可以将 $dp$ 数组变为 $bool$ 类型，稍微减少一点空间。同时，使用上面 **连续递增计数** 的思路，将两次遍历简化为一次遍历。

具体来说，如果当前 $count\geq k$，说明这一段 $[i-k+1,i]$ 可以作为后一个递增的子数组，所以检查 $[i-2k+1,i-k]$ 前一段能否作为相邻的递增子数组。

而是否为长度 $k$ 的递增，则保存在 $dp$ 数组中，与上面的逻辑相同。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        is_increased = [False] * (n + 1)  # 记录每个位置是否可以作为长度为k的递增子数组的结尾
        count = 0  # 当前连续递增的长度
        
        for index in range(n):
            # 如果当前元素不大于前一个元素，重置连续递增计数
            if index >= 1 and nums[index - 1] >= nums[index]:
                count = 0
            
            count += 1  # 增加当前连续递增长度
            
            # 如果当前连续递增长度达到k
            if count >= k:
                # 检查是否存在另一个不重叠的递增子数组
                if is_increased[index - k + 1]:
                    return True
                # 标记当前位置可以作为长度为k的递增子数组的结尾
                is_increased[index + 1] = True
        
        return False
```

```Java
// java
class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();

        // isIncreased[i] 记录索引 i-1 是否可以作为长度为k的递增子数组的结尾
        boolean[] isIncreased = new boolean[n + 1];
        int count = 0; // 当前连续递增的长度

        for (int index = 0; index < n; index++) {
            // 如果当前元素不大于前一个元素，说明递增序列中断
            if (index >= 1 && nums.get(index - 1) >= nums.get(index)) {
                count = 0;
            }

            count += 1; // 增加当前连续递增长度

            // 如果当前连续递增长度达到或超过 k
            if (count >= k) {
                // 检查是否存在另一个紧邻的、不重叠的递增子数组。
                if (isIncreased[index - k + 1]) {
                    return true;
                }
                
                // 标记当前位置可以作为长度为k的递增子数组的结尾
                isIncreased[index + 1] = true;
            }
        }

        return false;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 优化

本质上，我们只关心 “这一段” 与 “相邻前一段” 是否同时递增，而不关心 “更早的段”。

因此，采用空间优化，**滚动更新**，只保留两个变量 $prev$ 和 $cur$，分别代表前一段、当前段的连续递增长度。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        if n < 2 * k:
            return False

        prev_len = 1  # 上一段连续递增长度
        curr_len = 1  # 当前连续递增长度

        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                curr_len += 1  # 递增中
            else:
                prev_len = curr_len  # 记录上一段长度
                curr_len = 1         # 重置当前长度

            # 条件1: 当前递增长度 >= 2k → 一整段可分为两段相邻子数组
            # 条件2: 当前段 >= k 且 上一段 >= k → 两段相邻递增子数组
            if curr_len >= 2 * k or (curr_len >= k and prev_len >= k):
                return True

        return False
```

```Java
// java
class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();

        if (n < 2 * k) {
            return false;
        }

        int prev_len = 0;  // 上一段连续递增长度, 初始化为0更严谨
        int curr_len = 1;  // 当前连续递增长度

        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                curr_len++;  // 递增中
            } else {
                prev_len = curr_len;  // 记录上一段长度
                curr_len = 1;         // 重置当前长度
            }

            // 条件1: 当前递增长度 >= 2k → 一整段可分为两段相邻子数组
            // 条件2: 当前段 >= k 且 上一段 >= k → 两段相邻递增子数组
            if (curr_len >= 2 * k || (curr_len >= k && prev_len >= k)) {
                return true;
            }
        }

        return false;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/solutions/3805836/wu-jie-mo-ni-shuang-zhi-zhen-dp-yi-ci-bi-z6yc/)
