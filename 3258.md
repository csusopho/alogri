[Problem: 3258. 统计满足 K 约束的子字符串数量 I](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/description/)

### 方法：滑动窗口

题意：字符串由 $0$ 和 $1$ 组成，只要其中的 $0$ 或 $1$ 的数量小于等于 $k$，就表示该串满足约束，求字符串 $s$ 有几个符合要求的子串。

注意，这里是 $0$ 或 $1$ 任意一个不超过 $k$ 即可！

**暴力**：双 $for$ 循环，第一个 $for$ 枚举左端点，第二个 $for$ 枚举右端点。判断每个子串，累计总和。

假设字符串 $s$ 的长度为 $n$，暴力做法的时间为 $O(n^2)$，不会超时。感兴趣的小伙伴自行尝试，这里不再介绍。

### 滑窗

如果子串越长，数字 $0$ 和 $1$ 的数目越多，则越有可能超过 $k$ 的容纳范围，具有 **单调性**。这种单调性很适合使用双指针，时间是一次遍历的 $O(n)$。

双指针的一贯套路就是枚举一个指针，求出符合的另一个指针。不然两个指针都在变化，很容易思路混乱，导致重复情况。

双指针构造一个滑动窗口，核心思路就是在 **固定** 右指针的情况下，找到左指针的位置，使得这个窗口内 $0$ 或 $1$ 的个数小于等于 $k$。假如目前的右边界是 $r$，对应的最小左边界是 $l$，那么这个窗口内的子串长度为 $r-l+1$。

从左往右 **枚举** 右指针，得到不同情况下的左边界，得到此种情况下的最长子串。不同的右边界，得到的子串就一定不同。

### 哈希计数

在双指针移动的过程中，必须使用 **哈希** 去记录这个窗口内两种数字的个数。如果不使用哈希，每次统计当前窗口的元素时，都要去遍历两指针内的元素，太麻烦，而且没有利用滑窗的优势。

在向右移动右指针的时候，相当于将新元素移入到窗口内，只是增加了一个元素！那么，使用哈希统计时，只需要增加一个记录，不用再去遍历计数。

同理，在寻找左边界的时候，相当于将元素移出窗口，就是减少元素！那么，只需要减少一个记录，就能得到当前窗口的计数。

滑窗的本质就是让一个数从一端进来，让其他数从另一端退出。每次的滑窗统计被优化至 $O(1)$，也就是 $O(n^2)\rightarrow O(n)$ 的 **本质**。

### 优化

假设当前窗口的双指针分别指向 $l,r$ 位置，也即滑窗长度为 $r-l+1$。如果这个窗口 $[l,r]$ 符合要求，就说明 $[l+1,r],\dots,[r,r]$ 都符合要求。

也就是说，当子串的右边界为 $r$ 时，不符合的左边界都被移出窗口，**符合要求** 的串一共有 $r-l+1$ 个，都是有效贡献，直接累加到答案中！

注意，虽然是一次遍历右边界，但是每个右边界的所有左边界都被考虑到。也即，不会缺漏情况。

本题只统计 $0$ 和 $1$ 的数量，并且，串中 **只有** $0$ 和 $1$。假设 $0$ 的数量为 $zero$，那么 $1$ 的数量为 $r-l+1-zero$，无需多用一个变量去记录 $1$。

实现上面的推导过程，代码如下，已附加详细注释：

```Python
# python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        # 滑动窗口
        n = len(s)
        ans = 0  # 计数
        zero = 0
        left = 0  # 左指针

        for right in range(n):  # right 为右指针
            if s[right] == '0':  # 移入右边界
                zero += 1
            # 说明0和1的数量超出限制，移动左指针
            while zero > k and right - left + 1 - zero > k:
                if s[left] == '0':
                    zero -= 1
                left += 1
            # 窗口长度即为子字符串个数
            ans += right - left + 1

        return ans
```

```Java
// java
class Solution {
    public int countKConstraintSubstrings(String s, int k) {
        int n = s.length();
        int ans = 0;  // 计数
        int zero = 0;
        int left = 0;  // 左指针

        for (int right = 0; right < n; right++) {  // right 为右指针
            if (s.charAt(right) == '0') {  // 移入右边界
                zero++;
            }
            // 如果 0 和 1 的数量超出限制，移动左指针
            while (zero > k && right - left + 1 - zero > k) {
                if (s.charAt(left) == '0') {
                    zero--;
                }
                left++;
            }
            // 窗口长度即为符合条件的子字符串个数
            ans += right - left + 1;
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为字符串 $s$ 的长度，两个指针作为决定循环进行的关键因素，都是最多一次遍历串
- 空间复杂度： $O(1)$，仅用常数个额外变量

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/solutions/2985751/hua-dong-chuang-kou-yuan-li-tui-dao-xian-jj95/)
