[Problem: 1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/description/)

### 方法：Dijkstra & Kruskal & 二分

用通俗的话来说，就是尽量让路径平缓，起伏落差越小越好。

将本题抽象为 **图搜索** 问题：起点是 $(0,0)$，终点是 $(m-1,n-1)$。体力值 = 一条路径上，相邻格子之间 “差值” 的最大值。

为什么本题不是 **动规**？之前的题目是只能向右下角移动，所以状态转移是从左边或上面来的；但是这里的移动是 $4$ 个方向，也就是说能 `S` 形移动，导致转移方程写不出来。

题目 [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/description/) 与本题近乎相同，只是 “差最大” 与 “网格值最大” 的区别而已，对应题解为 [传送门](https://leetcode.cn/problems/swim-in-rising-water/solutions/3799193/san-jie-zui-duan-lu-or-lian-tong-xing-po-3lax/)。

---

### 朴素 $Dijkstra$

这里的 “路径长度” 不是各边权重之和，而是路径上遇到的最大节点差。

网格中寻找路径？从起点到终点的单源最短路？因此，我们想到使用 $Dijkstra$。朴素版本以及堆优化版本的原理及模版，请查看这篇 [题解](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/solutions/2848394/po-su-dijkstradui-you-hua-mo-ban-zhao-lu-ve92/)。

**核心**：每次需要找下一个节点时，它会 **遍历所有** 未被访问过的节点，通过线性扫描的方式找出那个 “距离” 最小的节点，时间复杂度为 $O(V)$。

定义一个 $dist$ 数组，记录从起点 $(0,0)$ 到达每个点 $(i, j)$ 的最小体力消耗，初始化为无穷大。同时，创建一个 $visited$ 数组，表示一个节点是否已经被访问，防止无限循环。

**流程**：

- 总共需要从图中选出 $m\times n$ 个节点，所以循环 $m\times n$ 次。
- 在每一次循环中：
  - 寻找下一个节点：遍历整个 $dist$ 数组，找到一个 “未被访问过” 且 $dist[i][j]$ 值最小的节点 $(r, c)$。
  - 标记访问：将这个找到的节点标记为已访问，$visited[r][c] = True$。
  - 更新邻居：遍历 $(r, c)$ 的四个邻居 $(nr, nc)$。对于每个邻居，计算差值 $diff$。如果 $diff$ 小于 $dist[nr][nc]$ 中记录的值，说明我们找到了一条更 “省力” 的路径，更新 $dist[nr][nc]$ 为 $diff$。

当终点 $(m-1, n-1)$ 被选为当前 “距离” 最小的节点时，它的 $dist$ 值就已经确定为最终解，可以直接返回。或者，等所有循环结束。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        # 到达每个格子的最小体力消耗
        dist = [[float('inf')] * n for _ in range(m)]
        # 初始化起点
        dist[0][0] = 0
        # 标记节点是否已被选为最短路径的一部分
        visited = [[False] * n for _ in range(m)]
        # 四个方向
        DIRS = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        # 总共有 m * n 个节点，每次确定一个节点的最短路径
        for _ in range(m * n):
            # 线性扫描，找到未被访问且值最小的节点，作为下一个访问！
            min_dist = float('inf')
            x, y = -1, -1
            
            for r in range(m):
                for c in range(n):
                    if not visited[r][c] and dist[r][c] < min_dist:
                        min_dist = dist[r][c]
                        x, y = r, c
            
            # 没有找到可选节点，说明找完
            if x == -1:
                break
                
            # 将找到的节点标记为已访问
            visited[x][y] = True

            # 已经到达终点
            if x == m - 1 and y == n - 1:
                return dist[x][y]
            
            # 更新该节点的邻居的距离(松弛操作)
            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                
                # 检查邻居是否在边界内
                if 0 <= nx < m and 0 <= ny < n:
                    # 当前节点 (x,y) 到达邻居 (nx,ny) 的差值
                    new_dist = max(dist[x][y], abs(heights[nx][ny] - heights[x][y]))
                    
                    # 如果找到了更优的路径，则更新
                    if new_dist < dist[nx][ny]:
                        dist[nx][ny] = new_dist
              
        return dist[m - 1][n - 1]
```

时间复杂度为 $O(m^2\times n^2)$，题目限制 $m,n\leq 100$。所以超时，卡在 $33/76$ 样例。

---

### 堆优化 $Dijkstra$

每次暴力地双 $for$ 寻找最近节点，非常浪费时间。自然地，我们联想到 **最小堆** 优化。

堆中存储的是一个三元组 `(effort, r, c)`，表示 “耗费 $effort$ 到达了坐标 $(r, c)$”。优先队列根据 $effort$ **从小到大** 进行排序，确保堆顶是 “耗费最小” 的节点。

如果 $(r, c)$ 就是我们的终点 $(m-1, n-1)$，那么 $effort$ 就是最终答案。因为我们总是从耗时最小的路径进行扩展，所以第一次到达终点时的时间一定是最优的。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumEffortPath(self, heights: list[list[int]]) -> int:
        m = len(heights)
        n = len(heights[0])

        # 距离数组：存储从起点到达 (r, c) 的最小体力消耗
        dist = [[math.inf] * n for _ in range(m)]
        dist[0][0] = 0  # 起点消耗为 0

        # 优先队列（最小堆），按路径消耗从小到大排序
        # 数组结构: (currentPathEffort, row, col)
        pq = [(0, 0, 0)]

        # 方向数组：右、下、左、上
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while pq:
            # 取出当前消耗最小的节点
            curr_dist, r, c = heapq.heappop(pq)

            # 标准 Dijkstra 优化：如果当前取出的路径比已记录的更差，跳过
            if curr_dist > dist[r][c]:
                continue
            
            # 如果已到达终点，可以提前返回
            if r == m - 1 and c == n - 1:
                return curr_dist

            # 遍历相邻节点
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc

                # 越界检查
                if not (0 <= nr < m and 0 <= nc < n):
                    continue

                # 计算两点间的高度差
                diff = abs(heights[r][c] - heights[nr][nc])
                # 从起点到邻居节点的路径消耗，是当前路径消耗和新边消耗的最大值
                new_dist = max(curr_dist, diff)

                # 如果发现了更优路径，更新并加入队列
                if dist[nr][nc] > new_dist:
                    dist[nr][nc] = new_dist
                    heapq.heappush(pq, (new_dist, nr, nc))
        
        # 实际上走不到这里
        return dist[m - 1][n - 1]
```

```Java
// java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;

        // 距离数组：存储从起点到达 (r, c) 的最小体力消耗
        int[][] dist = new int[m][n];
        for (int[] row : dist) {
            Arrays.fill(row, Integer.MAX_VALUE); // 初始化为无穷大
        }
        dist[0][0] = 0; // 起点消耗为 0

        // 优先队列，按路径消耗从小到大排序
        // 数组结构: {row, col, currentPathEffort}
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, 0});

        // 方向数组：右、下、左、上
        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.isEmpty()) {
            // 取出当前消耗最小的节点
            int[] curr = pq.poll();
            int r = curr[0], c = curr[1];
            int currDist = curr[2];

            // 标准 Dijkstra 优化：如果当前取出的路径比已记录的更差，跳过
            if (currDist > dist[r][c]) {
                continue;
            }
            
            // 如果已到达终点，可以提前返回（可选优化）
            if (r == m - 1 && c == n - 1) {
                return currDist;
            }

            // 遍历相邻节点
            for (int[] dir : dirs) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // 越界检查
                if (nr < 0 || nr >= m || nc < 0 || nc >= n) {
                    continue;
                }

                // 计算两点间的高度差
                int diff = Math.abs(heights[r][c] - heights[nr][nc]);
                // 更新
                int newDist = Math.max(currDist, diff);

                // 如果发现了更优路径，更新并加入队列
                if (dist[nr][nc] > newDist) {
                    dist[nr][nc] = newDist;
                    pq.offer(new int[]{nr, nc, newDist});
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
}
```

- 时间复杂度： $O(mn\times log(mn))$，其中 $m,n$ 是矩阵 $heights$ 的行数和列数，每个节点出入堆一次
- 空间复杂度： $O(m\times n)$，表示数组 $dist$ 以及堆 $pq$ 的大小

---

### 并查集

假设最终的体力消耗为 $x$，那么消耗为 $x-1$ 则不能连通起点与终点。将这个过程想象为，体力值从 $x=0$ 开始慢慢上涨，直至能连通起点与终点。

如此一来，问题的核心就变成了：**体力 $x$ 逐渐增大到何时，起点 $(0, 0)$ 和终点 $(m-1, n-1)$ 属于同一个连通分量？**

这就对应 **并查集**。具体的原理以及模版，可以看这篇题解，[传送门](https://leetcode.cn/problems/redundant-connection/solutions/2966966/bing-cha-ji-bao-li-mei-ju-zhao-huan-you-k08ct/)。

并查集的思路与 $Dijkstra$ 完全不同。 $Dijkstra$ 是从起点开始，一步步向外探索路径；而并查集则是 **从全局的视角**，将整个问题看作是随着体力的上升，各个格子逐渐连接成片的过程。

**流程**：

- **预处理**：由于体力是逐渐上升的，我们应该按照格子的高度差，从低到高来处理。因为 “起伏小” 的格子耗费的体力小，容易形成连通区域。为此，我们创建一个列表 $edges$，存储 `(点A, 点B, 差值)`，并按差值 **从小到大** 排序。
- **初始化**：创建一个 $parent$ 数组，其中包含 $m\times n$ 个元素，每个元素代表一个格子，初始时它们各自属于不同的集合。

非常重要的一步：**建图**。图中所有的边，都需要记录在 $edges$ 中。一共四个方向，不能让 $a,b$ 连接后出现 $b,a$ 连接的重复情况，因此只添加向右和向下的边。

- **处理**：顺序遍历已经排序的 $edges$，将这条边的两个节点 $a,b$ 进行连接。其中的差值 $x$，它表示当前的体力消耗。
- **检查连通性**：在每次合并操作后，我们都检查一下起点 $(0, 0)$ 和终点 $(m-1, n-1)$ 是否在同一个集合中。
- **结束**：一旦起点和终点连通了，那么当前边对应的 $x$，就是我们能找到的最小答案。因为我们是按差值从小到大处理的。

边值排序、逐渐添加、构建最小生成树。这不就是 $Kruskal$？本题只是稍微进行了变形，不再是连通所有节点，而是连通起点与终点。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumEffortPath(self, heights: list[list[int]]) -> int:
        m = len(heights)
        n = len(heights[0])
        # 初始化并查集
        parent = list(range(m * n))
        
        # 并查集 (Union-Find) 模板
        def find(x):
            # 查找 x 的根节点，并进行路径压缩
            # 递归查找根节点，并将沿途节点的父节点直接指向根节点
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(a, b):
            # 合并 a 和 b 所在的集合
            # 将 a 的根节点的父节点指向 b 的根节点
            parent[find(a)] = find(b)

        def query(a, b) -> bool:
            # 查询 a 和 b 是否属于同一个集合（即是否连通）
            return find(a) == find(b)
        
        def get_index(x, y):
            # 将二维坐标 (x, y) 转换为一维索引
            return x * n + y
        

        # 预处理出所有的边
        # edge 存的是 [a, b, w]，代表从节点 a 到节点 b 的代价为 w
        edges = []
        for i in range(m):
            for j in range(n):
                idx = get_index(i, j)
                # 只需考虑向右和向下的边，即可覆盖图中所有的边，避免重复
                # 添加向下的边
                if i + 1 < m:
                    a = idx
                    b = get_index(i + 1, j)
                    w = abs(heights[i][j] - heights[i + 1][j])
                    edges.append([a, b, w])
                # 添加向右的边
                if j + 1 < n:
                    a = idx
                    b = get_index(i, j + 1)
                    w = abs(heights[i][j] - heights[i][j + 1])
                    edges.append([a, b, w])

        # 根据边的权重 w（高度差）进行升序排序
        edges.sort(key=lambda x: x[2])

        # 从权重最小的边开始遍历，尝试将边加入到图中（合并两个节点）
        start = get_index(0, 0)
        end = get_index(m - 1, n - 1)
        for a, b, w in edges:
            # 合并这条边连接的两个节点
            union(a, b)
            # 检查起点和终点是否已经连通
            if query(start, end):
                # 如果连通，说明已经找到了一条路径
                # 已排序，第一次遇到，说明就是最小的“最大值”
                return w

        return 0
```

```Java
// java
class Solution {
    // 并查集 (Union-Find) 模版
    int N = 10005; 
    // parent[i] 存储节点 i 的父节点
    int[] parent = new int[N];
    int m, n;

    // 合并 a 和 b 所在的集合
    void union(int a, int b) {
        // 将 a 的根节点的父节点指向 b 的根节点
        parent[find(a)] = parent[find(b)];
    }

    // 查询 a 和 b 是否属于同一个集合（即是否连通）
    boolean query(int a, int b) {
        return find(a) == find(b);
    }

    // 查找 x 的根节点，并进行路径压缩
    int find(int x) {
        if (parent[x] != x) {
            // 递归查找根节点，并将沿途节点的父节点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 将二维坐标 (x, y) 转换为一维索引
    int getIndex(int x, int y) {
        return x * n + y;
    }

    public int minimumEffortPath(int[][] heights) {
        m = heights.length;
        n = heights[0].length;

        // 初始化并查集
        for (int i = 0; i < m * n; i++) {
            parent[i] = i;
        }

        // 预处理出所有的边
        // edge 存的是 [a, b, w]，代表从节点 a 到节点 b 的代价为 w
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int idx = getIndex(i, j);
                // 只需考虑向右和向下的边，即可覆盖图中所有的边，避免重复
                // 添加向下的边
                if (i + 1 < m) {
                    int a = idx;
                    int b = getIndex(i + 1, j);
                    int w = Math.abs(heights[i][j] - heights[i + 1][j]);
                    edges.add(new int[]{a, b, w});
                }
                // 添加向右的边
                if (j + 1 < n) {
                    int a = idx;
                    int b = getIndex(i, j + 1);
                    int w = Math.abs(heights[i][j] - heights[i][j + 1]);
                    edges.add(new int[]{a, b, w});
                }
            }
        }

        // 根据边的权重 w（高度差）进行升序排序
        Collections.sort(edges, (a, b) -> a[2] - b[2]);

        // 从权重最小的边开始遍历，尝试将边加入到图中（合并两个节点）
        int start = getIndex(0, 0);
        int end = getIndex(m - 1, n - 1);
        for (int[] edge : edges) {
            int a = edge[0], b = edge[1], w = edge[2];
            // 合并这条边连接的两个节点
            union(a, b);
            // 检查起点和终点是否已经连通
            if (query(start, end)) {
                // 如果连通，说明已经找到了一条路径
                // 已排序，第一次遇到，说明就是最小的“最大值”
                return w;
            }
        }

        return 0; 
    }
}
```

- 时间复杂度： $O(mn\times log(mn))$，调库快排；使用了路径压缩优化的并查集，单次操作的平均时间复杂度接近 $O(α(mn))$，其中 $α$ 是反阿克曼函数，其增长极其缓慢，对于所有实际问题都可以看作是一个极小的常数
- 空间复杂度： $O(mn)$

---

### 二分

可以假设最少消耗为 $x$，然后检查，能否用这个值从起点走到终点。在网格中搜索路径，那就是老生常谈，使用 $DFS$ 或 $BFS$。

为什么这种思路正确？因为消耗越大，越有可能走完，具有 **单调性**，所以能使用二分。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        # 方向数组，上、下、左、右
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        m = len(heights)
        n = len(heights[0])

        # 检查在最大允许消耗为 effort 的条件下
        # 是否存在一条从 (x, y) 到达终点 (m-1, n-1) 的有效路径
        def dfs(x, y, effort, visited):
            # 已经到达终点
            if x == m - 1 and y == n - 1:
                return True
            
            # 标记当前单元格为已访问，防止在路径中重复访问（成环）
            visited[x][y] = True
            
            # 遍历四个相邻方向
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                
                # 检查下一个位置是否越界或已被访问
                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                    # 计算移动到下一个单元格的体力消耗
                    cost = abs(heights[nx][ny] - heights[x][y])
                    
                    # 如果消耗在允许的 effort 范围内
                    if cost <= effort:
                        # 从相邻格子出发能到达终点，则说明当前路径可行
                        if dfs(nx, ny, effort, visited):
                            return True
            
            # 无法到达终点
            return False
        
        
        # 左边界为0，右边界为10^6，可以换成网格中最大值
        l, r = 0, 1000000
        
        while l < r:
            # 当前猜测的 "最大允许体力消耗"
            mid = l + (r - l) // 2
            
            # 检查在此消耗下，能否从起点到达终点
            # 每次检查都需要一个全新的 visited 数组
            visited = [[False] * n for _ in range(m)]
            if dfs(0, 0, mid, visited):
                # mid 是一个可行解，意味着可能还有更小的解，所以缩小右边界
                r = mid
            else:
                # mid 不可行，说明需要更大的消耗，所以增大左边界
                l = mid + 1
        
        return l
```

```Java
// java
class Solution {
    private int m;
    private int n;
    // 方向数组，上、下、左、右
    private int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int minimumEffortPath(int[][] heights) {
        m = heights.length;
        n = heights[0].length;
        
        // 左边界为0，右边界为10^6，可以换成网格中最大值
        int l = 0, r = 1000000;
        
        while(l < r) {
            // 当前猜测的 "最大允许体力消耗"
            int mid = l + (r - l) / 2;
            
            // 检查能否从起点到终点
            // 全新的 visited 数组
            if(dfs(0, 0, mid, heights, new boolean[m][n])) {
                // mid 是一个可行解，尝试寻找更小的答案
                r = mid;
            } else {
                // 否则，说明需要更大的消耗
                l = mid + 1;
            }
        }
        
        return l;
    }

    // 最大允许消耗为 effort，是否存在一条从 (x, y) 到达终点 (m-1, n-1) 的有效路径
    private boolean dfs(int x, int y, int effort, int[][] heights, boolean[][] visited) {
        // 已经到达终点
        if(x == m - 1 && y == n - 1) {
            return true;
        }
        
        // 标记当前单元格为已访问，防止在路径中重复访问（成环）
        visited[x][y] = true;
        
        // 遍历四个相邻方向
        for(int[] d : dirs) {
            int nx = x + d[0];
            int ny = y + d[1];
            
            // 检查下一个位置是否越界或已被访问
            if(0 <= nx && nx < m && 0 <= ny && ny < n && !visited[nx][ny]) {
                // 体力消耗
                int cost = Math.abs(heights[nx][ny] - heights[x][y]);
                
                // 在范围内
                if(cost <= effort) {
                    // 从相邻格子出发能到达终点，则说明当前路径可行
                    if(dfs(nx, ny, effort, heights, visited)) {
                        return true;
                    }
                }
            }
        }
        
        // 无法到达终点
        return false;
    }
}
```

- 时间复杂度： $O(mn\times logM)$，其中 $M$ 是网格中的最大值
- 空间复杂度： $O(mn)$

---

### $BFS$

同理，网格搜索的部分，可以使用 $BFS$ 进行替换。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m = len(heights)
        n = len(heights[0])
        # 方向数组，上、下、左、右
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        # 左边界为0，右边界为10^6，可以换成网格中最大值
        left, right = 0, 1000000
        ans = 0
        
        while left <= right:
            # 当前猜测的 "最大允许体力消耗"
            mid = left + (right - left) // 2
            
            # BFS 部分：检查在最大消耗为 mid 的条件下，起点和终点是否连通
            queue = collections.deque([(0, 0)])  # 从起点 (0, 0) 开始
            
            # 记录节点是否已被访问，防止重复遍历
            # 使用一维列表模拟二维，索引为 x * n + y
            visited = [False] * (m * n)
            visited[0] = True
            
            while queue:
                x, y = queue.popleft()

                # 遍历四个方向
                for dx, dy in dirs:
                    nx, ny = x + dx, y + dy

                    # 判断邻居节点是否：在界内、未被访问、并且移动消耗 <= mid
                    if (0 <= nx < m and 0 <= ny < n and 
                        not visited[nx * n + ny] and
                        abs(heights[x][y] - heights[nx][ny]) <= mid):
                        
                        queue.append((nx, ny))
                        visited[nx * n + ny] = True
            # --- BFS 结束 ---

            # 检查终点是否可达
            if visited[m * n - 1]:
                # 如果终点可达，mid 是一个可行解，保存它，并尝试寻找更小的答案
                ans = mid
                right = mid - 1
            else:
                # 否则，说明需要更大的消耗
                left = mid + 1
        
        # 返回最后一次成功连通起点和终点时记录的 mid 值
        return ans
```

```Java
// java
class Solution {
    private int m;
    private int n;
    // 方向数组，上、下、左、右
    private int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int minimumEffortPath(int[][] heights) {
        m = heights.length;
        n = heights[0].length;
        
        // 左边界为0，右边界为10^6，可以换成网格中最大值
        int left = 0, right = 1000000;
        int ans = 0;
        
        while(left <= right) {
            // 当前猜测的 "最大允许体力消耗"
            int mid = left + (right - left) / 2;
            
            // BFS 部分：检查在最大消耗为 mid 的条件下，起点和终点是否连通
            Queue<int[]> queue = new LinkedList<int[]>();
            queue.offer(new int[]{0, 0});  // 从起点 (0, 0) 开始
            
            // 记录节点是否已被访问，防止重复遍历
            boolean[] visited = new boolean[m * n];
            visited[0] = true;
            
            while (!queue.isEmpty()) {
                int[] cell = queue.poll();
                int x = cell[0], y = cell[1];

                // 遍历四个方向
                for (int i = 0; i < 4; ++i) {
                    int nx = x + dirs[i][0];
                    int ny = y + dirs[i][1];

                    // 判断邻居节点是否：在界内、未被访问、并且移动消耗 <= mid
                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx * n + ny] 
                        && Math.abs(heights[x][y] - heights[nx][ny]) <= mid) {
                        
                        queue.offer(new int[]{nx, ny});
                        visited[nx * n + ny] = true;
                    }
                }
            }
            // --- BFS 结束 ---

            // 检查终点
            if (visited[m * n - 1]) {
                // 如果终点可达，mid 是一个可行解，尝试寻找更小的答案
                ans = mid;
                right = mid - 1;
            } else {
                // 否则，说明需要更大的消耗
                left = mid + 1;
            }
        }
        
        // 最后一次成功连通起点和终点时记录的 mid 值
        return ans;
    }
}
```

- 时间复杂度： $O(mn\times logM)$，同理
- 空间复杂度： $O(mn)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/path-with-minimum-effort/solutions/3799718/wu-jie-bu-shi-dong-gui-po-su-dui-you-hua-x5cc/)
