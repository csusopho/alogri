[Problem: 2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/description/)

### 方法：哈希 & 堆

题意比较清晰： $change$ 处理下标位置的值，而 $find$ 是用值寻找下标。

因此，一种直接联想到的 **思路**：构建 “下标-值” 以及 “值-下标” 两个哈希，这样就能一一对应这两个函数。也即 `(下标，数字)` 和 `(数字，下标列表)`。

如何在列表中寻找 **最小值**？

- 暴力做法：直接遍历，但是会超时；
- 一般做法：替换为有序的数据结构，比较方便；
- 巧妙做法：手动维护，使它有序，稍微麻烦。

这里介绍后两种做法。

如何手动让列表升序？换句话说，新插入的数字应该放在什么位置？要删除的数字处于哪个位置？有序列表中寻找元素 —— 联想到 **二分查找**。

二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~

这里为了方便大家理解，使用 **左闭右开** 的写法，而不是直接调库。

代码如下，已附加详细注释：

```Python
# python
class NumberContainers:
    def __init__(self):
        # key: 数字, value: 索引列表，手动维护升序
        self.num_idxs = defaultdict(list)
        # key: 索引, value: 数字
        self.idx_num = dict()

    def change(self, index: int, number: int) -> None:
        if index in self.idx_num:
            # 如果该索引已有数字，先移除旧的关联
            old_num = self.idx_num[index]
            # 从旧数字的索引列表中移除该索引（保持有序）
            idx_list = self.num_idxs[old_num]
            # 二分查找来定位要删除的索引
            left, right = 0, len(idx_list)
            pos = -1
            while left < right:
                mid = (left + right) // 2
                if idx_list[mid] < index:
                    left = mid + 1
                else:
                    right = mid
            pos = left
            # 确认找到了该索引并移除它
            if pos < len(idx_list) and idx_list[pos] == index:
                idx_list.pop(pos)
                if not idx_list:  # 如果列表为空，删除该数字的条目
                    del self.num_idxs[old_num]
        
        # 更新或添加新的关联
        self.idx_num[index] = number
        # 将索引添加到新数字的有序列表中
        idx_list = self.num_idxs[number]
        # 二分查找来定位要插入的索引
        left, right = 0, len(idx_list)
        while left < right:
            mid = (left + right) // 2
            if idx_list[mid] < index:
                left = mid + 1
            else:
                right = mid
        idx_list.insert(left, index)

    def find(self, number: int) -> int:
        if number in self.num_idxs and self.num_idxs[number]:
            return self.num_idxs[number][0]  # 返回最小的索引
        return -1
```

```Java
// java
class NumberContainers {
    // key: 数字, value: 索引列表，手动维护升序
    private Map<Integer, List<Integer>> numIdxs;
    // key: 索引, value: 数字
    private Map<Integer, Integer> idxNum;

    public NumberContainers() {
        numIdxs = new HashMap<>();
        idxNum = new HashMap<>();
    }
    
    public void change(int index, int number) {
        if (this.idxNum.containsKey(index)) {
            // 如果该索引已有数字，先移除旧的关联
            int oldNum = this.idxNum.get(index);
            
            // 如果新旧数字相同，则无需任何操作
            if (oldNum == number) {
                return;
            }

            // 从旧数字的索引列表中移除该索引（保持有序）
            List<Integer> idxList = this.numIdxs.get(oldNum);
            
            // 二分查找来定位要删除的索引
            int left = 0, right = idxList.size();
            while (left < right) {
                // 无符号右移，防止整数溢出
                int mid = (left + right) >>> 1;
                if (idxList.get(mid) < index) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            int pos = left;

            // 确认找到了该索引并移除它
            if (pos < idxList.size() && idxList.get(pos).equals(index)) {
                idxList.remove(pos);
                if (idxList.isEmpty()) { // 如果列表为空，删除该数字的条目
                    this.numIdxs.remove(oldNum);
                }
            }
        }
        
        // 更新或添加新的关联
        this.idxNum.put(index, number);
        
        // 将索引添加到新数字的有序列表中
        List<Integer> idxList = this.numIdxs.computeIfAbsent(number, k -> new ArrayList<>());

        // 二分查找来定位要插入的索引
        int left = 0, right = idxList.size();
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (idxList.get(mid) < index) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        idxList.add(left, index);
    }
    
    public int find(int number) {
        if (this.numIdxs.containsKey(number) && !this.numIdxs.get(number).isEmpty()) {
            return this.numIdxs.get(number).get(0);  // 返回最小的索引
        }
        return -1;
    }
}
```

- 时间复杂度：
  - 函数 $change$ 为 $O(k)$，其中 $k$ 为列表的平均长度，二分查找时间为 $O(logk)$，插入后维护的时间为 $O(k)$
  - 函数 $find$ 为 $O(1)$
- 空间复杂度： $O(n)$，其中 $n$ 是 $change$ 的总调用次数，表示两个哈希的大小

---

### 堆

前面介绍过，可以使用有序的数据结构（队列/堆）进行维护，从而快速寻找最小值。

不过，本题有个 **麻烦点**：函数 $change$ 会修改下标处的值，会导致之前已经放在堆中的数据变为无效（错误）！

因此，我们使用 **懒删除** 的策略：调用 $find$ 函数时，根据哈希 $Map$ 中的正确值，检查这个堆顶数据，从而判断是否有效，若无效直接删除，否则就作为正确答案。

**做法**：依旧使用一个哈希维护 “索引-数字”，且每个数字都对应一个堆，堆中存放索引，从而维护 “数字-索引” 的结构。

代码如下，已附加详细注释：

```Python
# python
class NumberContainers:
    def __init__(self):
        #索引-数字,记录最新的对应关系
        self.index_map = {}
        # 存储 数字->[索引堆] 的映射
        # 每个堆是个最小堆，堆中存放索引
        self.num_heaps = defaultdict(list)
        

    def change(self, index: int, number: int) -> None:
        # 记录
        self.index_map[index] = number
        # 压入对应堆
        heapq.heappush(self.num_heaps[number], index)
        

    def find(self, number: int) -> int:
        # 不存在，或堆已清空
        if number not in self.num_heaps:
            return -1

        min_heap = self.num_heaps[number]

        # 懒删除：清理堆顶的无效下标
        # 循环直到堆为空或者堆顶的下标是有效的
        while min_heap:
            min_index = min_heap[0]
            # 检查
            if self.index_map.get(min_index) == number:
                # 找到了有效的最小下标
                return min_index
            else:
                # 下标已经被更新，是过时数据，从堆中弹出
                heapq.heappop(min_heap)

        # 走到这，说明该数字的所有下标都已过时，堆变空了
        return -1
```

```Java
// java
class NumberContainers {
    // 索引-数字,记录最新的对应关系
    private Map<Integer, Integer> indexMap;
    // 存储 数字->[索引堆] 的映射
    // 每个堆是个最小堆，堆中存放索引
    private Map<Integer, PriorityQueue<Integer>> numHeaps;

    public NumberContainers() {
        this.indexMap = new HashMap<>();
        this.numHeaps = new HashMap<>();
    }
    
    public void change(int index, int number) {
        // 记录
        this.indexMap.put(index, number);
        // 压入对应堆
        // 键不存在，则为其创建一个新的堆
        this.numHeaps.computeIfAbsent(number, k -> new PriorityQueue<>()).add(index);
    }
    
    public int find(int number) {
        // 不存在，或堆已清空
        if (!this.numHeaps.containsKey(number) || this.numHeaps.get(number).isEmpty()) {
            return -1;
        }

        PriorityQueue<Integer> minHeap = this.numHeaps.get(number);

        // 懒删除：清理堆顶的无效下标
        // 循环直到堆为空或者堆顶的下标是有效的
        while (!minHeap.isEmpty()) {
            // 获取堆顶元素
            int minIndex = minHeap.peek();
            
            // 检查
            if (Integer.valueOf(number).equals(this.indexMap.get(minIndex))) {
                // 找到了有效的最小下标
                return minIndex;
            } else {
                // 下标已经被更新，是过时数据，从堆中弹出
                minHeap.poll();
            }
        }

        // 走到这，说明该数字的所有下标都已过时，堆变空了
        return -1;
    }
}
```

- 时间复杂度：
  - 函数 $change$ 为 $O(logk)$，其中 $k$ 为堆的平均大小，堆的调整为 $log$ 时间
  - 函数 $find$ 均摊后为 $O(logk)$，每个元素最多弹出一次
- 空间复杂度： $O(n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/design-a-number-container-system/solutions/3784509/shuang-jie-liang-ha-xi-shou-dong-er-fen-rd0p8/)
