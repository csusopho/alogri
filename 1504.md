[Problem: 1504. 统计全 1 子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/description/)

### 方法：前缀和 & DP

本题是 **任意** 子矩阵，前置题目为 [1277](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/)，后者必须是正方形，题解为 [传送门](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solutions/3758286/si-jie-bao-li-er-wei-qian-zhui-he-dp-yua-6n8q/)。本题要求更宽泛，所以难度更大。

我们知道，一个矩形 “处于对角线” 的两个点确定后，这个矩形就是唯一确定。后续所有说明，都按照 “左上角” 和 “右下角” 这两个顶点展开。

**暴力** 想法：枚举这两个顶点，找出所有矩形，判断该子矩形是否全为 $1$。

枚举任意一个顶点，需要花费 $O(m\times n)$ 时间，然后枚举子矩阵内所有点。因此总时间为 $O(m^3\times n^3)$，题目限定 $m,n\leq 150$，复杂度为 $O(10^8)$，肯定超时。

---

对子矩阵形内的所有点进行扫描，重复多次，非常浪费时间。该区域的面积是 $l\times d$，如果全为 $1$，那么累加和也一定是 $l\times d$！求子区域的总和 —— **前缀和**。

二维前缀和的具体原理、推导，可以看这篇 [图解](https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/2993541/tu-jie-er-wei-qian-zhui-he-tui-dao-ji-su-61oc/)。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        # 构建二维前缀和数组
        pre = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + mat[i-1][j-1]
        
        ans = 0
        # 遍历所有可能的左上角和右下角
        for i in range(m):
            for j in range(n):
                for k in range(i, m):
                    for l in range(j, n):
                        # 计算子矩形的面积
                        area = (k - i + 1) * (l - j + 1)
                        # 实际和
                        total = pre[k+1][l+1] - pre[i][l+1] - pre[k+1][j] + pre[i][j]
                        if total == area:
                            ans += 1
        return ans
```

时间复杂度为 $O(m^2\times n^2)$，遗憾超时，卡在 $67/73$ 样例。多次测试，发现 $Python$ 代码一定超时，而 $Java$ 代码一般不超时，这里不再展示。

---

### $DP$

寻找 **规律**：一个大矩形，它一定是多个更小的矩形扩展出来的。

**逐列、从右向左** 地演示拼接这个过程：

```Java
    大矩形       当前矩形      向左移动     向左移动
   1  1  1       x  x  1      x  1  1      1  1  1
   1  1  1       x  x  1      x  1  1      1  1  1
   1  1  1       x  x  1      x  1  1      1  1  1
```

一旦遇到 $0$ 这种 “障碍物”，就会导致全 $1$ 大矩形的高度变小：

```Java
    大矩形       当前矩形      向左移动     向左移动
   0  0  1       x  x  1      x  x  x      x  x  x
   0  1  1       x  x  1      x  1  1      x  x  x
   1  1  1       x  x  1      x  1  1      1  1  1
```

一个宽度为 $1$，高度为 $3$ 的矩形，能包含几个子矩形？三个。

**固定** “右下角” 顶点不变，必须包含它，则宽度为 $2$，高度为 $2$ 的矩形，有：

```Java
    大矩形      子矩形    子矩形     子矩形    子矩形
     1  1       x  x      x  1      x  x      1  1
     1  1       x  1      x  1      1  1      1  1
```

也即，宽度为 $d$ 高度为 $h$ 的矩形，一共包含 $d\times h$ 个子矩形！

如果 $(i-1,j)$ 格子向上全 $1$ 的高度为 $3$，则当前 $(i,j)$ 格子向上全 $1$ 高度是 $4$！不用重新检查整列，而是 **用之前的结果递推新的结果** —— $DP$。

**定义** $dp[i][j]$ 表示从 $(i,j)$ 向上连续 $1$ 的个数。

> $ps$：其实这里命名为 $height$ 更合适，为了格式才写作 $dp$。

**状态转移**：当前列向上连续 $1$ 的高度，取决于上一个 $(i-1,j)$ 格子，有

$$
dp[i][j] =
\begin{cases}
dp[i-1][j] + 1 & \text{if } mat[i][j]=1 \\
0 & \text{otherwise}
\end{cases}
$$

递推方向、边界、初始化等不再阐述，详情见代码。将该过程 **预处理**，推导完成后借助 $dp$ 数组以及数学运算，得出答案。

**本质**：枚举右下角顶点，左上角不再枚举，而是通过高度快速得出这一列有几个顶点能作为左上角。

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        # dp[i][j] 表示从当前格子(i,j)向上连续1的个数
        dp = [[0] * n for _ in range(m)]
        ans = 0
        
        # 预处理高度数组
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 1:
                    dp[i][j] = 1 if i == 0 else dp[i-1][j] + 1
        
        # 对每一行进行处理
        for i in range(m):
            for j in range(n):
                if dp[i][j] == 0:
                    continue
                
                min_height = dp[i][j]
                # 向左遍历，计算以(i,j)为右下角的所有矩形
                for k in range(j, -1, -1):
                    if dp[i][k] == 0:
                        break
                    min_height = min(min_height, dp[i][k])
                    ans += min_height
        
        return ans
```

```Java
// java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        // dp[i][j] 表示从当前格子(i,j)向上连续1的个数
        int[][] dp = new int[m][n];
        int ans = 0;
        
        // 预处理高度数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    dp[i][j] = (i == 0) ? 1 : dp[i-1][j] + 1;
                }
            }
        }
        
        // 对每一行进行处理
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dp[i][j] == 0) {
                    continue;
                }
                
                int minHeight = dp[i][j];
                // 向左遍历，计算以(i,j)为右下角的所有矩形
                for (int k = j; k >= 0; k--) {
                    if (dp[i][k] == 0) {
                        break;
                    }
                    minHeight = Math.min(minHeight, dp[i][k]);
                    ans += minHeight;
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n^2)$，其中 $m,n$ 分别为 $mat$ 的行数和列数
- 空间复杂度： $O(m\times n)$，表示数组 $dp$ 的大小

---

### 原地修改

一般来说，“ $DP$ 递推” 过程是与 “答案计算” 过程是合二为一，上面为了逻辑的清晰，才将它们拆分，实际可以放在一起。

我们是按照 $i,j$ 递增的顺序填写 $DP$ 表。一旦使用过 $mat[i][j]$ 后，再也不会第二次使用。因此，我们可以将 $mat$ 当作 $dp$，原地进行修改！

代码如下，已附加注释：

```Python
# python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0

        # 第一行：高度就是元素值本身
        # 从第二行开始，原地更新高度信息
        for i in range(m):
            for j in range(n):
                if i > 0 and mat[i][j] == 1:
                    mat[i][j] = mat[i-1][j] + 1  # 更新为高度值
                
                if mat[i][j] > 0:  # 当前高度大于0
                    min_height = mat[i][j]
                    # 向左遍历，计算以(i,j)为右下角的所有矩形
                    for k in range(j, -1, -1):
                        if mat[i][k] == 0:
                            break
                        min_height = min(min_height, mat[i][k])
                        ans += min_height
        
        return ans
```

```Java
// java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int ans = 0;

        // 第一行：高度就是元素值本身
        // 从第二行开始，原地更新高度信息
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0 && mat[i][j] == 1) {
                    mat[i][j] = mat[i-1][j] + 1;  // 更新为高度值
                }
                
                if (mat[i][j] > 0) {  // 当前高度大于0
                    int minHeight = mat[i][j];
                    // 向左遍历，计算以(i,j)为右下角的所有矩形
                    for (int k = j; k >= 0; k--) {
                        if (mat[i][k] == 0) {
                            break;
                        }
                        minHeight = Math.min(minHeight, mat[i][k]);
                        ans += minHeight;
                    }
                }
            }
        }
        
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n^2)$
- 空间复杂度： $O(1)$

---

### 单调栈

如果我们将 $1$ 视作墙，而 $0$ 视作空气，则本题可以看作 [84.最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)。

因此，想到使用 **单调栈**。目的是通过栈快速找到左侧更矮的墙，也就是被 $0$ 导致高度变小，从而加速上述矩形面积的计算，不再是一列一列向左遍历。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        # 存储当前行每列的"柱状图高度"
        heights = [0] * n
        ans = 0
    
        for i in range(m):
            # 更新直方图高度
            for j in range(n):
                if mat[i][j] == 0:
                    heights[j] = 0
                else:
                    heights[j] += 1
            
            # 计算这一行的矩形数
            # 递增栈，存列索引，快速找到左边第一个比当前高度小的位置
            stack = []
            # count[x] 表示当前行第 x 列为右下角的所有全 1 子矩形的数量
            count = [0] * n
            
            for j in range(n):
                # 维护单调递增栈：弹出所有高度 >= 当前高度的元素
                while stack and heights[stack[-1]] >= heights[j]:
                    stack.pop()
                
                if stack:
                    # 栈不为空：左边有更小的柱子
                    prev = stack[-1]  # 左边第一个比当前矮的柱子位置
                    count[j] = count[prev] + heights[j] * (j - prev)
                else:
                    # 栈为空：当前是最小的柱子
                    count[j] = heights[j] * (j + 1)
                
                stack.append(j)
                ans += count[j]
    
        return ans
```

```Java
// java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        // 存储当前行每列的"柱状图高度"
        int[] heights = new int[n];
        int ans = 0;
    
        for (int i = 0; i < m; i++) {
            // 更新直方图高度
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 0) {
                    heights[j] = 0;
                } else {
                    heights[j] += 1;
                }
            }
            
            // 计算这一行的矩形数
            // 递增栈，存列索引，快速找到左边第一个比当前高度小的位置
            Stack<Integer> stack = new Stack<>();
            // count[x] 表示当前行第 x 列为右下角的所有全 1 子矩形的数量
            int[] count = new int[n];
            
            for (int j = 0; j < n; j++) {
                // 维护单调递增栈：弹出所有高度 >= 当前高度的元素
                while (!stack.isEmpty() && heights[stack.peek()] >= heights[j]) {
                    stack.pop();
                }
                
                if (!stack.isEmpty()) {
                    // 栈不为空：左边有更小的柱子
                    int prev = stack.peek();  // 左边第一个比当前矮的柱子位置
                    count[j] = count[prev] + heights[j] * (j - prev);
                } else {
                    // 栈为空：当前是最小的柱子
                    count[j] = heights[j] * (j + 1);
                }
                
                stack.push(j);
                ans += count[j];
            }
        }
    
        return ans;
    }
}
```

- 时间复杂度： $O(m\times n)$，每个列索引最多被压入和弹出栈一次
- 空间复杂度： $O(n)$，表示栈 $stack$ 的大小

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/count-submatrices-with-all-ones/solutions/3759473/yi-bu-bu-tui-dao-qian-zhui-he-dp-yuan-di-y6fs/)
