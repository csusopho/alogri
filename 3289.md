[Problem: 3289. 数字小镇中的捣蛋鬼](https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/description/)

### 方法：哈希 & 原地 & 位运算

不重复的数字是 $[0,n-1]$，重复两个数字，所以数组 $nums$ 的长度为 $n+1$。

如何找出这两个重复数字？最简单的想法：**哈希模拟**。

- 一次遍历，记录所有数字以及对应出现次数，第二次遍历哈希。
- 只要数字 $x$ 已经记录过，说明这个数字重复；反之，就记录到哈希中。

经实测，第一种方法速度更快。第二种方法中，即使哈希 $Map$ 换成数组形式，代码的速度几乎没怎么加快。

使用朴素的第一种方法，代码如下：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        cnt = Counter(nums)
        ans = []
        for key in cnt:
            if cnt[key] == 2:
                ans.append(key)
        return ans
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        Map<Integer, Integer> counts = new HashMap<>();
        
        // 填充哈希
        for (int num : nums) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }
        
        int idx = 0;
        int[] result = new int[2];
        
        // 遍历哈希表
        for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
            if (entry.getValue() == 2) {
                result[idx++] = entry.getKey();
            }
        }
        
        return result;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(n)$

---

### 数学

设多出的两个数分别为 $x$ 和 $y$。

因为数组中一定有 $[0,n-1]$ 固定出现，直接算一遍数组 **总和** $S1$，以及数组的 **平方和** $S2$，然后可以列出等式：

$$
x+y+\dots=S1\\
x^2+y^2+\dots=S2
$$

省略号中的内容，根据等差数列求和公式快速计算。再利用求根公式，解出唯一解 $x,y$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums) - 2  # 理论上不重复时的数组长度
    
        # 计算和的差 (S1 = a + b)
        actual_sum = sum(nums)
        # 理论总和 (0 + ... + n-1) 的公式为 (n-1)*n / 2
        expected_sum = (n - 1) * n // 2
        s1 = actual_sum - expected_sum
        
        # 计算平方和的差 (S2 = a*a + b*b)
        actual_sq_sum = sum(num * num for num in nums)
        # 理论平方和 (0^2 + ... + (n-1)^2) 的公式为 (n-1)*n*(2n-1) / 6
        expected_sq_sum = (n - 1) * n * (2 * n - 1) // 6
        s2 = actual_sq_sum - expected_sq_sum

        # 解方程组
        # s_diff = a - b
        # (a-b)^2 = 2*(a^2+b^2) - (a+b)^2 = 2*s2 - s1*s1
        s_diff = int(math.sqrt(2 * s2 - s1 * s1))
        
        # 最终求解 a 和 b
        # 2a = s1 + s_diff
        # 2b = s1 - s_diff
        dup1 = (s1 + s_diff) // 2
        dup2 = (s1 - s_diff) // 2
        
        return [dup1, dup2]
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length - 2; // 理论上不重复时的数组长度

        // 计算和的差 (S1 = a + b)
        int actualSum = 0;
        for (int num : nums) {
            actualSum += num;
        }
        // 理论总和 (0 + ... + n-1) 的公式为 (n-1)*n / 2
        int expectedSum = (n - 1) * n / 2;
        int s1 = actualSum - expectedSum;
        
        // 计算平方和的差 (S2 = a*a + b*b)
        int actualSqSum = 0;
        for (int num : nums) {
            actualSqSum += num * num;
        }
        // 理论平方和 (0^2 + ... + (n-1)^2) 的公式为 (n-1)*n*(2n-1) / 6
        int expectedSqSum = (n - 1) * n * (2 * n - 1) / 6;
        int s2 = actualSqSum - expectedSqSum;

        // 解方程组
        // s_diff = a - b
        // (a-b)^2 = 2*(a^2+b^2) - (a+b)^2 = 2*s2 - s1*s1
        int sDiffSq = 2 * s2 - s1 * s1;
        int sDiff = (int) Math.sqrt(sDiffSq);
        
        // 最终求解 a 和 b
        // 2a = s1 + s_diff
        // 2b = s1 - s_diff
        int dup1 = ((s1 + sDiff) / 2);
        int dup2 = ((s1 - sDiff) / 2);
        
        return new int[]{dup1, dup2};
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 原地

如果元素不重复，那么只有 $[0,n-1]$ 的独特数字。假设从前往后升序排列，则数组的下标 **等于** 对应元素值，也即 $i = nums[i]$。

那么，我们可以按照这个 “排序” 的思路，每个数字 $nums[i]$ 就应该放在 $i$ 位置！

此时，由于存在重复数字，那么会导致两个相同的数字放在同一个位置。我们怎么知道这个位置是 **第二次** 放置数字呢？

第一种方法，就是目标位置放置 $-x$。一旦 $x$ 第二次出现，它还会放在 $x$ 的位置，此时发现已经被负数占据，那么就说明重复！

那数字 $0$ 重复怎么办？**解决办法**：数字 $0$ 的位置放置 $-n$。数组中的数字都小于 $n$，所以只要 $0$ 位置出现 $-n$，一定是 $0$ 重复。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        ans = []
        n = len(nums)
        
        # 从前往后遍历，不是遍历值！
        for i in range(n):
            # 当前位置的原始数字
            num = nums[i]
            
            # 如果 num 是我们用来标记 0 的特殊值，将其转换回 0
            if num == -n:
                index = 0
            else:
                index = abs(num)
            
            # 目标索引处的值是负数，说明之前已经被遇到过
            if nums[index] < 0:
                ans.append(index)
                if len(ans) == 2:
                    break
            
            # 目标索引处的值是 0
            elif nums[index] == 0:
                # 将其标记为一个不可能出现的负数值
                nums[index] = -n
            
            # 正常标记，将其变为负数
            else:
                nums[index] *= -1

        return ans
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int[] res = new int[2];
        int resIdx = 0;
        int n = nums.length;
        
        // 从前往后遍历，不是遍历值！
        for (int i = 0; i < n; i++) {
            // 当前位置的原始数字
            int num = nums[i];
            
            int index;
            // 如果 num 是我们用来标记 0 的特殊值，将其转换回 0
            if (num == -n) {
                index = 0;
            } else {
                index = Math.abs(num);
            }
            
            // 目标索引处的值是负数，说明之前已经被遇到过
            if (nums[index] < 0) {
                res[resIdx++] = index;
                if (resIdx == 2) {
                    break; // 找到两个就可以提前退出
                }
            }
            // 目标索引处的值是 0
            else if (nums[index] == 0) {
                // 将其标记为一个不可能出现的负数值
                nums[index] = -n;
            }
            // 正常标记，将其变为负数
            else {
                nums[index] *= -1;
            }
        }

        return res;
    }
}
```

---

第二种方法，**提前** 将所有数字都 $+1$。

这样一来，数组中就不存在 $0$。我们就可以无风险地使用 “负数标记” 法。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        ans = []
    
        # 将所有数字加 1
        for i in range(len(nums)):
            nums[i] += 1
        
        # “负号标记法”
        for i in range(len(nums)):
            index = abs(nums[i])
            # 值对应的真实下标
            target_index = index - 1
            
            # 负数，说明之前已经被遇到过
            if nums[target_index] < 0:
                ans.append(index - 1)
            else:
                # 正数，将其标记为负数
                nums[target_index] *= -1
        
        return ans
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int[] res = new int[2];
        int resIdx = 0;

        // 将所有数字加 1
        for (int i = 0; i < nums.length; i++) {
            nums[i]++;
        }
        
        // “负号标记法”
        for (int i = 0; i < nums.length; i++) {
            int value = Math.abs(nums[i]);
            // 值对应的真实下标
            int targetIndex = value - 1;
            
            // 负数，说明之前已经被遇到过
            if (nums[targetIndex] < 0) {
                res[resIdx++] = value - 1;
            } else {
                // 如果是正数，将其标记为负数
                nums[targetIndex] *= -1;
            }
        }
        
        return res;
    }
}
```

---

第三种方法，设定基数 $base$。不再是将数字标记为负数，而是 **加上** $base$。

这样一来，只需要判断值与 $base$ 的大小关系，就能判断值是否重复出现。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = []
        # 基数设定为，不重复数组的长度
        base = n - 2
        
        for i in range(n):
            # 取出数字，并用取模运算恢复其原始值
            original_num = nums[i] % base
            
            # 检查该原始数字对应的“槽位”是否已被标记
            if nums[original_num] >= base:
                # 已经被加过一次了
                ans.append(original_num)
            else:
                # 第一次遇到
                nums[original_num] += base
        
        return ans
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length;
        int[] res = new int[2];
        int resIdx = 0;

        // 基数设定为，不重复数组的长度
        int base = n - 2;
        
        for (int i = 0; i < n; i++) {
            // 取出数字，并用取模运算恢复其原始值。
            int originalNum = nums[i] % base;
            
            // 检查该原始数字对应的“槽位”是否已被标记
            if (nums[originalNum] >= base) {
                // 已经被加过一次了
                res[resIdx++] = originalNum;
            } else {
                // 第一次遇到
                nums[originalNum] += base;
            }
        }
        
        return res;
    }
}
```

---

第四种方法，使用最传统的 **循环归位** 方法。

将每个数字 $x$ 放到它 “应该” 在的位置，即索引 $x$ 上。这样一来，前面的 $[0,n-1]$ 都会放置完成，而没有被正确归位的数字就是我们要找的重复数。

- 如果 $nums[i]$ 和 $nums[nums[i]]$ 不相等，说明我们可以安全地将 $nums[i]$ 换到 $nums[nums[i]]$ 这个位置去，从而让一个数字更接近它的目标位置。
- 如果 $nums[i]$ 和 $nums[nums[i]]$ 相等，这意味着 $nums[i]$ 这个值（我们称之为 $val$）在 $i$ 和 $val$ 这两个位置上的值都是 $val$。这说明 $val$ 已经重复了，因此 $while$ 循环终止，我们移动到下一个 $i$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)

        for i in range(n):
            # 不匹配时，持续交换
            while nums[i] != nums[nums[i]]:
                # 希望交换的目标索引
                j = nums[i]
                # 将 nums[i] 送到它“应该”在的位置 j
                nums[i], nums[j] = nums[j], nums[i]
        
        # 已经排序完成，前面是 [0, 1, ..., n-1]，后面是多出来的数
        return nums[-2:]
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            // 不匹配时，持续交换
            while (nums[i] != nums[nums[i]]) {
                // 希望交换的目标索引
                int j = nums[i];
                // 执行交换，将 nums[i] 送到它“应该”在的位置 j
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        
        // 已经排序完成，前面是 [0, 1, ..., n-1]，后面是多出来的数
        return Arrays.copyOfRange(nums, n - 2, n);
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

---

### 分组异或

异或 ^ 运算的性质：`a ^ a = 0`，且 `a ^ 0 = a`。

**第一步、消除成对数字。**

数组中包含 $[0,n-1]$ 的独特数字，以及两个重复数字 $x,y$。将 $nums$ 中所有数字进行异或，再异或上 $[0,n-1]$ 中所有数字。

此时，只有 $x,y$ 出现奇数次，独特数字出现偶数次。则上述运算的结果，就是两个重复数字的异或 `x ^ y`，将它记作 $g$。

**第二步、分组。**

因为 $x$ 和 $y$ 不等，所以 $g$ 至少有一位是 $1$。通过位运算的知识可知， $g$ 中最右边那个 $1$，可以通过 `g & -g` 得到，这个位就是 $x$ 和 $y$ 的一个不同之处。

**第三步、再次异或。**

根据这个 “不同位”，我们可以将 $nums$ 中所有数字分成两组：一组是在这个位上为 $0$ 的，另一组为 $1$ 的。

- $x$ 和 $y$ 会被分到不同的组里。
- 同样地，利用 “第一步” 中的技巧，将每个组中的所有数字，都异或上 $nums$ 列表和 $[0,n-1]$ 列表；
- 对于任何 $0$ 到 $n-1$ 中只出现一次的数字，它会同时出现在两个列表中，因此在各自组内进行异或运算时相互抵消。
- 因此，第一组所有数字的异或总和就是 $x$，第二组的总和就是 $y$。

代码如下，已附加注释：

```Python
# python
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums) - 2
        
        # 所有元素异或
        xor_sum = 0
        for num in nums:
            xor_sum ^= num
        
        # 遍历 0 到 n-1 的理论列表，得到 x ^ y
        for i in range(n):
            xor_sum ^= i
            
        # 找出 x 和 y 不同的位置
        diff_bit = xor_sum & -xor_sum
        
        # 根据这个不同的位将所有数字分组
        dup1, dup2 = 0, 0
        
        # 分组异或，遍历 nums 数组
        for num in nums:
            if num & diff_bit:
                dup1 ^= num
            else:
                dup2 ^= num
        
        # 遍历 0 到 n-1 的理论列表
        for i in range(n):
            if i & diff_bit:
                dup1 ^= i
            else:
                dup2 ^= i
        
        return [dup1, dup2]
```

```Java
// java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length - 2;

        int xorSum = 0;
        // 与 nums 所有元素异或
        for (int num : nums) {
            xorSum ^= num;
        }
        
        // 与 0 到 n-1 的理论列表所有元素异或，得到 x ^ y
        for (int i = 0; i < n; i++) {
            xorSum ^= i;
        }
        
        // 找出 x 和 y 不同的位置
        int diffBit = xorSum & -xorSum;
        
        // 根据这个不同的位将所有数字分组
        int dup1 = 0;
        int dup2 = 0;
        
        // 对数组 nums 进行分组异或
        for (int num : nums) {
            if ((num & diffBit) != 0) {
                dup1 ^= num;
            } else {
                dup2 ^= num;
            }
        }
        
        // 遍历 0 到 n-1 的理论列表进行分组异或
        for (int i = 0; i < n; i++) {
            if ((i & diffBit) != 0) {
                dup1 ^= i;
            } else {
                dup2 ^= i;
            }
        }
        
        return new int[]{dup1, dup2};
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(1)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/solutions/3820301/wei-yun-suan-liu-chong-o1jie-fa-shu-xue-begur/)
