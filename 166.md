[Problem: 166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/description/)

### 方法：模拟

题意很清晰，这里不再赘述。

为什么本题不是直接用 $numerator$ 除以 $denominator$，然后判断小数部分的循环结果呢？因为除法具有 **精度问题**，精度需要足够高，才能容纳非循环部分和至少两个循环周期。如此一来，小数部分必须足够长，求解非常浪费时间。

> $ps$：如果想尝试，可以看看代码能否通过 `1/333` 这个样例，别问我怎么知道的。

小学教的竖式除法，我们是怎么做的？

- 第一步：计算整数部分
  - `1` 除以 `6`，商是 `0`，余数是 `1`
  - 目前结果: `"0."`
  - **当前余数: `1`**

- 第二步：计算小数第一位
  - 我们将余数 `1` 乘以 `10`，得到 `10`（这相当于在手动除法中，在余数后面 "补一个 $0$"）
  - 用 `10` 除以 `6`，商是 `1`，余数是 `4`
  - 目前结果: `"0.1"`
  - **当前余数: `4`**

- 第三步：计算小数第二位
  - 我们将余数 `4` 乘以 `10`，得到 `40`
  - 用 `40` 除以 `6`，商是 `6`，余数是 `4`
  - 目前结果: `"0.16"`
  - **当前余数: `4`**

- 第四步：发现循环
  - **停！** 我们注意到，现在的余数 `4` 在 **第三步** 开始前也出现过
  - 接下来我们要做什么？我们会将这个余数 `4` 乘以 `10` 得到 `40`，然后用 `40` 去除以 `6`
  - 这和第三步的操作 **一模一样**！所以我们必然会再次得到商 `6` 和余数 `4`

- 无限循环
  - 因为我们又回到了余数为 `4` 的状态，所以下一步、下下一步、以及之后的所有步骤，都会不断地重复 “余数`4` -> 乘以 `10` -> 变为 `40` -> 除以`6` -> 商 `6`，余数 `4`”这个过程
  - 因此，数字 `6` 将会无限重复下去

也就是说：**当一个余数再次出现时，就意味着小数部分开始循环了。**

因此，我们想到使用一个 **哈希Map** 存储出现过的余数。哈希的键是余数，值是什么？该余数的 **对应下标**。假设余数 $6$ 第一次出现在小数第 $2$ 位，然后在小数第 $5$ 位再次出现，说明循环节就是 $(2,5)$。节前加 `(`，节后加 `)`。

**注意**：需要判断分子是否为 $0$，以及 $-2,147,483,648$ 导致的 $int$ 溢出问题，还有结果的正负，并提前计算整数部分。

主体部分还是上面介绍的 $\times 10$ 取余，记录余数的过程。

代码如下，已附加注释：

```Python
# python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        # 如果分子为 0，直接返回 "0"
        if numerator == 0:
            return "0"

        # 判断结果是否为负数
        is_negative = (numerator < 0) ^ (denominator < 0)
        # 取绝对值，方便计算
        numerator, denominator = abs(numerator), abs(denominator)
        # 计算整数部分和余数
        integer_part, remainder = divmod(numerator, denominator)
        result = []
        # 如果是负数，添加负号
        if is_negative:
            result.append("-")
        # 添加整数部分
        result.append(str(integer_part))

        # 如果余数为 0，说明没有小数部分，直接返回结果
        if remainder == 0:
            return "".join(result)

        # 添加小数点
        result.append(".")
        # 用字典记录余数出现的位置，用于检测循环小数
        remainder_positions = {}
        # 处理小数部分
        while remainder > 0:
            # 如果余数已经出现过，说明开始循环
            if remainder in remainder_positions:
                # 在循环开始的位置插入 "("
                result.insert(remainder_positions[remainder], "(")
                # 在末尾添加 ")"
                result.append(")")
                break
            # 记录当前余数的位置
            remainder_positions[remainder] = len(result)
            # 计算下一位小数
            integer_part, remainder = divmod(remainder * 10, denominator)
            # 将当前位添加到结果中
            result.append(str(integer_part))

        # 将结果列表转换为字符串并返回
        return "".join(result)
```

```Java
// java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        // 如果分子为 0，直接返回 "0"
        if (numerator == 0) {
            return "0";
        }

        StringBuilder result = new StringBuilder();
        
        // 判断结果是否为负数。使用异或 (^) 检查分子和分母的符号是否不同
        if ((numerator < 0) ^ (denominator < 0)) {
            result.append("-");
        }

        // 取绝对值，方便计算
        // 使用 long 类型以防止 Integer.MIN_VALUE 溢出
        long num = Math.abs((long) numerator);
        long den = Math.abs((long) denominator);

        // 计算整数部分
        result.append(num / den);
        long remainder = num % den;

        // 如果余数为 0，说明没有小数部分，直接返回结果
        if (remainder == 0) {
            return result.toString();
        }

        // 添加小数点
        result.append(".");

        // Key: 余数, Value: 该余数在字符串中开始出现的位置索引
        Map<Long, Integer> remainderPositions = new HashMap<>();
        
        // 处理小数部分
        while (remainder != 0) {
            // 如果余数已经出现过，说明开始循环
            if (remainderPositions.containsKey(remainder)) {
                // 在循环开始的位置插入 "("
                result.insert(remainderPositions.get(remainder), "(");
                // 在末尾添加 ")"
                result.append(")");
                break;
            }
            
            // 记录当前余数的位置 (即当前结果字符串的长度)
            remainderPositions.put(remainder, result.length());
            
            // 将余数乘以 10 以计算下一位小数
            remainder *= 10;
            // 计算下一位小数
            result.append(remainder / den);
            // 更新余数
            remainder %= den;
        }

        // 将结果 StringBuilder 转换为字符串并返回
        return result.toString();
    }
}
```

将分母 $denominator$ 的绝对值记为 $D$。在长除法中，每一位的余数都来自于 `* 10 % D`。因此，可能的非零余数最多有 $D-1$ 个。根据抽屉原理， $while$ 循环最多执行 $D$ 次，就会出现重复的余数或余数变为 $0$。

- 时间复杂度： $O(D)$，其中 $D=denominator$ 这个除数
- 空间复杂度： $O(D)$，表示哈希表 $positions$ 以及列表 $res$ 的长度

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/fraction-to-recurring-decimal/solutions/3790794/mo-ni-shu-shi-chu-fa-ha-xi-jie-shi-wei-s-kyc1/)
