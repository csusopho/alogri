[Problem: 3541. 找到频率最高的元音和辅音](https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/description/)

### 方法：哈希 & 位运算

一句话，答案 = 最高元音出现次数 + 最高辅音出现次数。

使用 **两个哈希** 分别统计元/辅音的出现次数，代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFreqSum(self, s: str) -> int:
        vowels = "aeiou"
        vo_cnt = {}  # 元音计数
        co_cnt = {}  # 辅音计数

        # 统计频率
        for char in s:
            if char in vowels:
                vo_cnt[char] = vo_cnt.get(char, 0) + 1
            else:
                co_cnt[char] = co_cnt.get(char, 0) + 1

        # 找出最高元音
        mx_vo_freq = 0
        if vo_cnt:
            mx_vo_freq = max(vo_cnt.values())

        # 找出最高辅音
        mx_co_freq = 0
        if co_cnt:
            mx_co_freq = max(co_cnt.values())

        return mx_vo_freq + mx_co_freq
```

```Java
// java
class Solution {
    public int maxFreqSum(String s) {
        // 使用 Set 存储元音，方便快速查找
        Set<Character> vowels = Set.of('a', 'e', 'i', 'o', 'u');
        
        Map<Character, Integer> vowelCounts = new HashMap<>();  // 元音计数
        Map<Character, Integer> consonantCounts = new HashMap<>();  // 辅音计数

        // 统计频率
        for (char c : s.toCharArray()) {
            if (vowels.contains(c)) {
                vowelCounts.put(c, vowelCounts.getOrDefault(c, 0) + 1);
            } else {
                consonantCounts.put(c, consonantCounts.getOrDefault(c, 0) + 1);
            }
        }

        // 找出最高元音
        int maxVowelFreq = 0;
        if (!vowelCounts.isEmpty()) {
            // 调库，直接找出 values 中的最大值
            maxVowelFreq = Collections.max(vowelCounts.values());
        }

        // 找出最高辅音
        int maxConsonantFreq = 0;
        if (!consonantCounts.isEmpty()) {
            maxConsonantFreq = Collections.max(consonantCounts.values());
        }

        return maxVowelFreq + maxConsonantFreq;
    }
}
```

也可以使用单哈希，速度更快，代码如下：

```Python
# python
class Solution:
    def maxFreqSum(self, s: str) -> int:
        # 一次性统计字符串中所有字符的出现频率
        cnts = Counter(s)

        mx_vo_freq = 0
        mx_co_freq = 0

        # 遍历唯一的字符及其频率
        for char, count in cnts.items():
            # 判断字符是否为元音
            if char in 'aeiou':
                mx_vo_freq = max(mx_vo_freq, count)
            else:
                mx_co_freq = max(mx_co_freq, count)
        
        return mx_vo_freq + mx_co_freq
```

```Java
// java
class Solution {
    public int maxFreqSum(String s) {
        // 使用 Set 存储元音
        Set<Character> vowels = Set.of('a', 'e', 'i', 'o', 'u');
        
        // 一次性统计字符串中所有字符的出现频率
        Map<Character, Integer> counts = new HashMap<>();
        for (char c : s.toCharArray()) {
            counts.put(c, counts.getOrDefault(c, 0) + 1);
        }

        int maxVowelFreq = 0;
        int maxConsonantFreq = 0;

        // 遍历唯一的字符及其频率
        for (Map.Entry<Character, Integer> entry : counts.entrySet()) {
            char character = entry.getKey();
            int count = entry.getValue();

            // 判断字符是否为元音
            if (vowels.contains(character)) {
                // 更新元音的最高频率
                maxVowelFreq = Math.max(maxVowelFreq, count);
            } else {
                // 更新辅音的最高频率
                maxConsonantFreq = Math.max(maxConsonantFreq, count);
            }
        }
        
        return maxVowelFreq + maxConsonantFreq;
    }
}
```

- 时间复杂度： $O(n)$，其中 $n$ 为串 $s$ 的长度
- 空间复杂度： $O(|\Sigma|)$，其中 $|\Sigma|=26$ 表示字符集大小

---

### 一次遍历

可以一边更新哈希，一边统计最大出现次数，将两个过程合二为一。同时，使用哈希数组替代传统 $Map$，速度更快。

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFreqSum(self, s: str) -> int:
        vowels = "aeiou"
        # 使用长度为 26 的数组来代替字典
        freq_map = [0] * 26
        
        mx_vo_freq = 0
        mx_co_freq = 0

        for char in s:
            # 计算字符在数组中的索引
            index = ord(char) - ord('a')
            freq_map[index] += 1
            current_freq = freq_map[index]

            # 判断是元音还是辅音，并更新对应的最大频率
            if char in vowels:
                if current_freq > mx_vo_freq:
                    mx_vo_freq = current_freq
            else:
                if current_freq > mx_co_freq:
                    mx_co_freq = current_freq

        return mx_vo_freq + mx_co_freq
```

```Java
// java
class Solution {
    public int maxFreqSum(String s) {
        // 使用 Set 存储元音
        Set<Character> vowels = Set.of('a', 'e', 'i', 'o', 'u');
        
        // 使用长度为 26 的数组来代替 HashMap
        int[] freqMap = new int[26];
        
        int maxVowelFreq = 0;
        int maxConsonantFreq = 0;

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 计算字符在数组中的索引
            int index = c - 'a';
            freqMap[index]++;
            int currentFreq = freqMap[index];

            // 判断是元音还是辅音，并更新对应的最大频率
            if (vowels.contains(c)) {
                maxVowelFreq = Math.max(maxVowelFreq, currentFreq);
            } else {
                maxConsonantFreq = Math.max(maxConsonantFreq, currentFreq);
            }
        }

        return maxVowelFreq + maxConsonantFreq;
    }
}
```

- 时间复杂度： $O(n)$，同理
- 空间复杂度： $O(|\Sigma|)$

---

### 位运算

我们可以将 $26$ 个小写字母分别映射到一个整数的 $26$ 个位上。`'a'` 对应第 $0$ 位，`'b'` 对应第 $1$ 位，以此类推，`'z'` 对应第 $25$ 位。

创建一个整数，其中只有对应元音字母的位被设置为 $1$，即

- `'a'` -> `1 << 0`  (第 $0$ 位)
- `'e'` -> `1 << 4`  (第 $4$ 位)
- `'i'` -> `1 << 8`  (第 $8$ 位)
- `'o'` -> `1 << 14` (第 $14$ 位)
- `'u'` -> `1 << 20` (第 $20$ 位)

将这些值通过按位或 `|` 运算结合起来，就得到了我们的元音掩码。

$$
VOWELMASK = (1 << 0) | (1 << 4) | (1 << 8) | (1 << 14) | (1 << 20)
$$

对于任何一个字符，我们计算出它对应的位掩码。例如，对于 `'c'` 就是 `1 << 2`。然后将这个字符的掩码与 `VOWEL_MASK` 进行按位与 `&` 运算。

- 如果结果为 $1$，说明该字符对应的位在元音掩码中是 $1$，因此它是一个元音
- 如果结果为 $0$，说明它是一个辅音

代码如下，已附加注释：

```Python
# python
class Solution:
    def maxFreqSum(self, s: str) -> int:
        VOWEL_MASK = 1065233
        # 使用长度为 26 的数组来代替字典
        freq_map = [0] * 26
        
        mx_vo_freq = 0
        mx_co_freq = 0

        for char in s:
            # 计算字符在数组中的索引
            index = ord(char) - ord('a')
            freq_map[index] += 1
            current_freq = freq_map[index]

            if (1 << index) & VOWEL_MASK:  # 元音
                if current_freq > mx_vo_freq:
                    mx_vo_freq = current_freq
            else:  # 辅音
                if current_freq > mx_co_freq:
                    mx_co_freq = current_freq

        return mx_vo_freq + mx_co_freq
```

```Java
// java
class Solution {
    private static final int VOWEL_MASK = 1065233;

    public int maxFreqSum(String s) {
        // 使用长度为 26 的数组来代替 HashMap
        int[] freqMap = new int[26];
        
        int maxVowelFreq = 0;
        int maxConsonantFreq = 0;

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 计算字符在数组中的索引
            int index = c - 'a';
            
            freqMap[index]++;
            int currentFreq = freqMap[index];

            // 使用位运算检查当前字符是否为元音
            if (((1 << index) & VOWEL_MASK) != 0) { // 元音
                if (currentFreq > maxVowelFreq) {
                    maxVowelFreq = currentFreq;
                }
            } else { // 辅音
                if (currentFreq > maxConsonantFreq) {
                    maxConsonantFreq = currentFreq;
                }
            }
        }

        return maxVowelFreq + maxConsonantFreq;
    }
}
```

- 时间复杂度： $O(n)$
- 空间复杂度： $O(|\Sigma|)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/solutions/3780400/si-jie-shuang-dan-ha-xi-yi-ci-bian-li-we-4l5a/)
