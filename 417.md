[Problem: 417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/description/)

### 方法：DFS & BFS

题意：每个方格的顶部有雨水，值代表高度，雨水从高往低流。如果一个方格上的雨水既能流到左/上边界，又能流达右/下边界，则它就是目标。

网格中寻找路径？第一想法就是 **暴力**。让每个方格都作为起点，找出它能到达的所有位置，判断其中是否含有需要的几个边界。

**定义** $dfs(i,j)$ 表示从 $(i,j)$ 位置开始流动，判断能否到达目标边界。

**转移过程**：对于当前 $(i,j)$ 位置来说，它可以到达四个方向的邻居，只要有一个到达边界，则它也能到达，用方程表示为：

$$
dfs(i, j) = dfs(i-1, j)\lor dfs(i+1, j)\lor dfs(i, j-1)\lor dfs(i, j+1)
$$

注意，上述方程默认四个方向不越界，且都是从高往低流。如果任意条件不满足，则去除对应的某个状态。

**递归边界**：上边界是 $i=0$，左边界是 $j=0$，下边界是 $i=m-1$，右边界是 $j=n-1$。上/左边界对应太平洋，下/右边界对应大西洋。

每个方格进行递归时，都使用一个哈希 $Set$ 进行 **记忆化**，记录已经走过的方格，从而避免同一个位置的重复搜索，导致无限循环。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        res = []

        # 遍历每一个单元格
        for r in range(m):
            for c in range(n):
                # 对每个单元格进行两次DFS，分别检查是否能到达两个大洋
                can_reach_pacific = self.dfs(r, c, set(), heights, "pacific")
                can_reach_atlantic = self.dfs(r, c, set(), heights, "atlantic")

                if can_reach_pacific and can_reach_atlantic:
                    res.append([r, c])
        
        return res

    # 检查从 (r, c) 是否可以流到指定的大洋
    def dfs(self, r, c, visited, heights, ocean):
        # 已经搜索过
        if (r, c) in visited:
            return False

        # 检查是否已经到达目标大洋的边界
        if ocean == "pacific":
            if r == 0 or c == 0:
                return True
        elif ocean == "atlantic":
            if r == len(heights) - 1 or c == len(heights[0]) - 1:
                return True
        
        visited.add((r, c))

        # 向四个方向探索
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc

            # 检查新坐标是否在边界内
            if 0 <= nr < len(heights) and 0 <= nc < len(heights[0]):
                # 检查是否可以流向下一个单元格
                if heights[nr][nc] <= heights[r][c]:
                    if self.dfs(nr, nc, visited, heights, ocean):
                        return True
        
        # 所有方向都无法到达
        return False
```

```Java
// java
class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;
        List<List<Integer>> res = new ArrayList<>();

        // 遍历每一个单元格
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                // 对每个单元格进行两次DFS，分别检查是否能到达两个大洋
                // 注意：为每次DFS调用创建一个新的visited集合
                boolean can_reach_pacific = dfs(r, c, new HashSet<>(), heights, "pacific");
                boolean can_reach_atlantic = dfs(r, c, new HashSet<>(), heights, "atlantic");

                if (can_reach_pacific && can_reach_atlantic) {
                    res.add(Arrays.asList(r, c));
                }
            }
        }
        
        return res;
    }

    // 检查从 (r, c) 是否可以流到指定的大洋
    private boolean dfs(int r, int c, Set<List<Integer>> visited, int[][] heights, String ocean) {
        // 将坐标转换为List，以便在Set中正确地进行比较
        List<Integer> pos = Arrays.asList(r, c);

        // 已经搜索过
        if (visited.contains(pos)) {
            return false;
        }

        // 检查是否已经到达目标大洋的边界
        if ("pacific".equals(ocean)) {
            if (r == 0 || c == 0) {
                return true;
            }
        } else if ("atlantic".equals(ocean)) {
            if (r == heights.length - 1 || c == heights[0].length - 1) {
                return true;
            }
        }
        
        visited.add(pos);

        // 向四个方向探索
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        
        for (int[] dir : directions) {
            int nr = r + dir[0];
            int nc = c + dir[1];

            // 检查新坐标是否在边界内
            if (nr >= 0 && nr < heights.length && nc >= 0 && nc < heights[0].length) {
                // 检查是否可以流向下一个单元格
                if (heights[nr][nc] <= heights[r][c]) {
                    if (dfs(nr, nc, visited, heights, ocean)) {
                        return true;
                    }
                }
            }
        }
        
        // 所有方向都无法到达
        return false;
    }
}
```

- 时间复杂度： $O(m^2\times n^2)$，其中 $m,n$ 是数组 $heights$ 的行数和列数，每个方格搜索时都会遍历整个网格
- 空间复杂度： $O(m\times n)$，保存多少状态，就需要多少空间

---

### 正难则反

可以发现，每个方格都会搜索一遍矩形，非常浪费时间。究其本质，是没有利用每次搜索的结果！

比如，在示例 $1$ 中，我们已知值为 $6$ 的方格能到达左边界和下边界，那么比它更大的相邻 $7$ 方格也一定能到达！

所以，该如何利用这一特点？**反向思考**：让水从低往高流。只有 **一片** 水域 “太平洋”，看它最多能拓展到哪，而不是受困于 **多个** 方格。

**做法**：让边界处的元素元素进行 $DFS$，向内扩展探索。

注意，这里的哈希 $Set$ 本质上与之前的哈希 $Set$ 不同！下面的 $visited$ 是被一片水域共享，也即两条边界上的方格都使用一个哈希！而之前的 $visited$ 是一个方格单独享有！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        
        # 分别记录从太平洋和大西洋出发，可遍历到的单元格
        pacific = [[False for _ in range(n)] for _ in range(m)]
        atlantic = [[False for _ in range(n)] for _ in range(m)]

        # 从(r,c)出发，反向寻找所有地势更高或相等的单元格
        def dfs(r, c, visited):
            # 标记当前单元格为可到达
            visited[r][c] = True
            
            # 向四个方向探索
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                
                # 检查新坐标是否越界
                if not (0 <= nr < m and 0 <= nc < n):
                    continue
                # 如果新单元格已经访问过，则跳过
                if visited[nr][nc]:
                    continue
                # 从低向高判断
                if heights[nr][nc] >= heights[r][c]:
                    dfs(nr, nc, visited)

        # 从太平洋边界（顶部和左侧）开始DFS
        for r in range(m):
            dfs(r, 0, pacific)
        for c in range(n):
            dfs(0, c, pacific)

        # 从大西洋边界（底部和右侧）开始DFS
        for r in range(m):
            dfs(r, n - 1, atlantic)
        for c in range(n):
            dfs(m - 1, c, atlantic)
        
        # 找出同时可以到达两个大洋的单元格
        res = []
        for r in range(m):
            for c in range(n):
                if pacific[r][c] and atlantic[r][c]:
                    res.append([r, c])
        
        return res
```

```Java
// java
class Solution {
    private int m;
    private int n;
    private int[][] heights;
    
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        this.heights = heights;
        this.m = heights.length;
        this.n = heights[0].length;
        
        // 分别记录从太平洋和大西洋出发，可遍历到的单元格
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];

        // 从太平洋边界（顶部和左侧）开始DFS
        for (int r = 0; r < m; r++) {
            dfs(r, 0, pacific);
        }
        for (int c = 0; c < n; c++) {
            dfs(0, c, pacific);
        }

        // 从大西洋边界（底部和右侧）开始DFS
        for (int r = 0; r < m; r++) {
            dfs(r, n - 1, atlantic);
        }
        for (int c = 0; c < n; c++) {
            dfs(m - 1, c, atlantic);
        }
        
        // 找出同时可以到达两个大洋的单元格
        List<List<Integer>> res = new ArrayList<>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (pacific[r][c] && atlantic[r][c]) {
                    res.add(Arrays.asList(r, c));
                }
            }
        }
        
        return res;
    }

    // 从(r,c)出发，反向寻找所有地势更高或相等的单元格
    private void dfs(int r, int c, boolean[][] visited) {
        // 标记当前单元格为可到达
        visited[r][c] = true;
        
        // 向四个方向探索
        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        for (int[] dir : directions) {
            int nr = r + dir[0];
            int nc = c + dir[1];
            
            // 检查新坐标是否越界
            if (nr < 0 || nr >= m || nc < 0 || nc >= n) {
                continue;
            }
            // 如果新单元格已经访问过，则跳过
            if (visited[nr][nc]) {
                continue;
            }
            // 从低向高判断
            if (heights[nr][nc] >= heights[r][c]) {
                dfs(nr, nc, visited);
            }
        }
    }
}
```

- 时间复杂度： $O(m\times n)$，每个网格最多被搜索两次
- 空间复杂度： $O(m\times n)$

---

### $BFS$

我们可以将 $DFS$ 深搜转化为 $BFS$ 广搜，逻辑同理，都是从边界向内扩展。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        
        # 两个队列，分别用于两个大洋的BFS
        pacific_queue = deque()
        atlantic_queue = deque()
        
        # 分别记录从太平洋和大西洋出发，可遍历到的单元格
        pacific_reachable = [[False for _ in range(n)] for _ in range(m)]
        atlantic_reachable = [[False for _ in range(n)] for _ in range(m)]

        # 加入所有与海洋相邻的单元格
        for r in range(m):
            # 左边界（太平洋）
            pacific_queue.append((r, 0))
            pacific_reachable[r][0] = True
            # 右边界（大西洋）
            atlantic_queue.append((r, n - 1))
            atlantic_reachable[r][n - 1] = True
            
        for c in range(n):
            # 上边界（太平洋）
            pacific_queue.append((0, c))
            pacific_reachable[0][c] = True
            # 下边界（大西洋）
            atlantic_queue.append((m - 1, c))
            atlantic_reachable[m - 1][c] = True

        # 定义BFS辅助函数
        def bfs(queue, reachable):
            while queue:
                r, c = queue.popleft()
                
                # 探索四个方向的邻居
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    
                    # 检查新坐标是否越界
                    if not (0 <= nr < m and 0 <= nc < n):
                        continue
                    # 如果新单元格已经访问过，则跳过
                    if reachable[nr][nc]:
                        continue
                    # 从低向高判断
                    if heights[nr][nc] >= heights[r][c]:
                        reachable[nr][nc] = True
                        queue.append((nr, nc))

        # 分别对两个大洋执行BFS
        bfs(pacific_queue, pacific_reachable)
        bfs(atlantic_queue, atlantic_reachable)

        # 找出同时可以到达两个大洋的单元格
        res = []
        for r in range(m):
            for c in range(n):
                if pacific_reachable[r][c] and atlantic_reachable[r][c]:
                    res.append([r, c])
        
        return res
```

```Java
// java
class Solution {
    private int m;
    private int n;
    private int[][] heights;
    
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        this.heights = heights;
        this.m = heights.length;
        this.n = heights[0].length;
        
        // 两个队列，分别用于两个大洋的BFS
        Queue<int[]> pacificQueue = new LinkedList<>();
        Queue<int[]> atlanticQueue = new LinkedList<>();
        
        // 分别记录从太平洋和大西洋出发，可遍历到的单元格
        boolean[][] pacificReachable = new boolean[m][n];
        boolean[][] atlanticReachable = new boolean[m][n];

        // 加入所有与海洋相邻的单元格
        for (int r = 0; r < m; r++) {
            // 左边界（太平洋）
            pacificQueue.offer(new int[]{r, 0});
            pacificReachable[r][0] = true;
            // 右边界（大西洋）
            atlanticQueue.offer(new int[]{r, n - 1});
            atlanticReachable[r][n - 1] = true;
        }
            
        for (int c = 0; c < n; c++) {
            // 上边界（太平洋）
            pacificQueue.offer(new int[]{0, c});
            pacificReachable[0][c] = true;
            // 下边界（大西洋）
            atlanticQueue.offer(new int[]{m - 1, c});
            atlanticReachable[m - 1][c] = true;
        }

        // 分别对两个大洋执行BFS
        bfs(pacificQueue, pacificReachable);
        bfs(atlanticQueue, atlanticReachable);

        // 找出同时可以到达两个大洋的单元格
        List<List<Integer>> res = new ArrayList<>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (pacificReachable[r][c] && atlanticReachable[r][c]) {
                    res.add(Arrays.asList(r, c));
                }
            }
        }
        
        return res;
    }

    // 定义BFS辅助函数
    private void bfs(Queue<int[]> queue, boolean[][] reachable) {
        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int r = cell[0];
            int c = cell[1];
            
            // 探索四个方向的邻居
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];
                
                // 检查新坐标是否越界
                if (nr < 0 || nr >= m || nc < 0 || nc >= n) {
                    continue;
                }
                // 如果新单元格已经访问过，则跳过
                if (reachable[nr][nc]) {
                    continue;
                }
                // 从低向高判断
                if (heights[nr][nc] >= heights[r][c]) {
                    reachable[nr][nc] = true;
                    queue.offer(new int[]{nr, nc});
                }
            }
        }
    }
}
```

- 时间复杂度： $O(m\times n)$，同理
- 空间复杂度： $O(m\times n)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/pacific-atlantic-water-flow/solutions/3798572/san-jie-bao-li-dfs-zheng-nan-ze-fan-shui-ggpc/)
