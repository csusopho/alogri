[Problem: 3346. 执行操作后元素的最高频率 I](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/)

### 方法：二分 & 双指针 & 前缀和

为了方便表述，将 $numOperations$ 简记为 $op$。

本题可以理解为 **至多** 操作 $op$ 次，毕竟 $+0$ 相当于没有操作。题意比较清晰，就是将某些数字，全都变为一个数字 $x$。求 $x$ 的最大出现次数。

注意，变形后的 $x$ 不一定属于 $nums$！比如样例 $583$，数组 $nums=[88,53]$，而 $k=27$，最后变成的数字是 $88-27=61$，且 $53+8=61$，所以答案是 $2$。

小数字往大变形，大数字往小变形，最后的变形结果 $x$ 肯定 $\leq max(nums)$。

**暴力** 想法：枚举 $x$，然后判断在 $op$ 的条件下，数组 $nums$ 中有多少数字能变为它。也即，寻找 $nums$ 中有多少数在 $[x-k,x+k]$ 的范围内。

查找数字？很容易联想到 **二分**，而前提是 “有序”，因此对数组 $nums$ **升序** 排列。

记得使用一个 **哈希 $Map$**，其中 $cnts[x]=m$ 表示数组中的 $x$ 重复了 $m$ 次。

假设数组中 $> x+k$ 的数字有 $l$ 个，且 $\geq x-k$ 的数字有 $r$ 个，则在 $[x-k,x+k]$ 范围内的数字一共有 $r-l$ 个。

- 假设 $op$ 无限大，能将范围内所有数字都变形为 $x$，则最终次数为 $r-l$；
- 反之，若 $op$ 不够大，不能全部转为 $x$，则至多转化 $op$ 个数字，加上 $x$ 自身无需变形，则最终次数为 $op+cnts[x]$。

因此，最终结果就是上述两者取 **较小值** $min$。

如果不好理解，就拆分为三步，先计算可以用来转化的数量 $r-l-cnts[x]$，再将它与 $op$ 对比取较小者，最后加上 $cnts[x]$ 得到总次数。

二分不会写？记住循环不变量，始终明确左边界的值与右边界的值是否符合要求，从而正确缩小区间。 ~~实在不会写就调库吧。~~ 下面使用最容易理解的 **闭区间** 二分。

切记，不能将枚举上界定为题目给定的 $nums[i]$ 上界 $10^5$，因为会超时！卡在 $139/635$ 样例，将它变为数组中的最大值 $mx$，才勉强通过！

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        # 查找第一个 >= target 的元素索引
        def search(arr, target):
            left, right = 0, len(arr) - 1
            idx = len(arr)
            while left <= right:
                mid = left + (right - left) // 2
                if arr[mid] >= target:
                    idx = mid
                    right = mid - 1
                else:
                    left = mid + 1
            return idx

        nums.sort()
        ans = 1

        # 数组哈希
        MX = nums[-1]
        counts = [0] * (MX + 1)
        for num in nums:
            counts[num] += 1
        
        # 每一个整数，都是潜在的目标值
        for target in range(MX + 1):
            # 一次操作
            lower = target - k
            upper = target + k

            # 找到第一个大于等于 lower 的数的索引
            start_idx = search(nums, lower)
            # 找到第一个大于 upper 的数的索引
            end_idx = search(nums, upper + 1)

            # 原始数量
            initial_freq = counts[target]
            
            # 落在区间内的元素总数
            total = end_idx - start_idx
            # 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            convert = total - initial_freq
            # 最多只能使用 numOperations 次操作
            op_use = min(numOperations, convert)
            
            # 可以达到的总频率 = 初始频率 + 新转换过来的数量
            total_freq = initial_freq + op_use
            ans = max(ans, total_freq)
            
        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 预先排序，这是二分查找的前提
        Arrays.sort(nums);
        int ans = 1;

        // 数组哈希
        // 获取数组中的最大值，用于确定频率数组的大小
        int MX = nums[nums.length - 1];
        int[] counts = new int[MX + 1];
        for (int num : nums) {
            counts[num]++;
        }
        
        // 每一个整数，都是潜在的目标值
        for (int target = 0; target <= MX; target++) {
            // 一次操作的范围
            long lower = target - k;
            long upper = target + k;

            // 找到第一个大于等于 lower 的数的索引
            int start_idx = search(nums, lower);
            // 找到第一个大于 upper 的数的索引
            int end_idx = search(nums, upper + 1);

            // 原始数量：目标值在原数组中已经出现的次数
            int initial_freq = counts[target];
            
            // 落在区间 [lower, upper] 内的元素总数
            int total = end_idx - start_idx;
            // 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            int convert = total - initial_freq;
            // 最多只能使用 numOperations 次操作
            int op_use = Math.min(numOperations, convert);
            
            // 可以达到的总频率 = 初始频率 + 新转换过来的数量
            int total_freq = initial_freq + op_use;
            // 更新全局最大频率
            ans = Math.max(ans, total_freq);
        }
            
        return ans;
    }

    // 查找第一个 >= target 的元素索引
    private int search(int[] arr, long target) {
        int left = 0, right = arr.length - 1;
        int idx = arr.length;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= target) {
                // 找到了一个大于等于 target 的数，尝试往左边找更小的
                idx = mid;
                right = mid - 1;
            } else {
                // 当前数小于 target，需要往右边找
                left = mid + 1;
            }
        }
        return idx;
    }
}
```

- 时间复杂度： $O((n+M)\times logn)$，其中 $n$ 是数组 $nums$ 的长度，而 $M$ 是数组中的最大值，对 $nums$ 进行排序以及二分，二分的总次数为 $M+1$
- 空间复杂度： $O(M)$，忽略排序的 $O(logn)$ 的栈开销

---

### 简化

如果你觉得比较复杂，那就使用上面说的 $min(r-l, op+cnts[x])$，将代码进行简化。

同理二分上界，变化后的 $x$ 一定是 $\geq min(nums)$，因为变为这个最小值，一定比变成 $0$ 的范围要求更小，答案次数更大。

应用这两点优化，代码如下：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        cnt = Counter(nums)
        
        for x in range(nums[0], nums[-1] + 1):
            l = bisect_left(nums, x - k)
            r = bisect_right(nums, x + k)
            ans = max(ans, min(r - l, numOperations + cnt[x]))
        
        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        Arrays.sort(nums);
        // 使用 HashMap 统计
        Map<Integer, Integer> counts = new HashMap<>();
        for (int num : nums) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }
        
        int ans = 0;
        int minVal = nums[0];
        int maxVal = nums[nums.length - 1];

        // 遍历所有可能的“目标值”
        for (int x = minVal; x <= maxVal; x++) {
            int l = search(nums, x - k);
            int r = search(nums, x + k + 1);

            int currentMaxFreq = Math.min(r - l, numOperations + counts.getOrDefault(x, 0));
            ans = Math.max(ans, currentMaxFreq);
        }
        
        return ans;
    }

    // 查找第一个 >= target 的元素索引
    private int search(int[] arr, long target) {
        int left = 0, right = arr.length - 1;
        int idx = arr.length;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= target) {
                idx = mid;
                right = mid - 1;
            } else {
                // 当前数小于 target，需要往右边找
                left = mid + 1;
            }
        }
        return idx;
    }
}
```

- 时间复杂度： $O((n+M)\times logn)$，同理
- 空间复杂度： $O(n)$，表示哈希 $Map$ 的大小

---

### 双指针

这题的 **本质**，就是用一个 $[x-k,x+k]$ 范围的 “精灵球”，在 $nums$ 这片大陆上，尽可能抓住最多数量的 “宠物”。

将其抽象为一个 **滑窗**，初始时能覆盖 $[l,r]$ 范围内的元素。滑窗的总长度为 $2k$，从下标 $0$ 开始覆盖，不断递增 $x$，看看每次能覆盖几个下标。

也即，在枚举 $x$ 的过程中，左右指针都是不断向右移动，确保 $nums[i]$ 在范围内。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        counter = Counter(nums)
        nums.sort()
        
        # 初始化
        left = 0
        right = 0
        ans = 0
        
        # 枚举潜在的目标值
        for target in range(nums[0], nums[-1] + 1):
            # 无法转换成 target 的数从窗口左侧移出
            while nums[left] < target - k:
                left += 1
            
            # 可以转换成 target 的数都包含进窗口右侧
            while right < len(nums) and nums[right] <= target + k:
                right += 1
            
            # 元素总数
            total = right - left
            # 初始频率
            initial_freq = counter.get(target, 0)
            
            # 可以用来转换的数量
            convert = total - initial_freq
            # 实际能转换的数量
            op_use = min(numOperations, convert)
            
            # 初始频率 + 新转换过来的数量
            total_freq = initial_freq + op_use
            ans = max(ans, total_freq)

        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 别忘了排序！
        Arrays.sort(nums);
        // 使用 HashMap 统计
        Map<Integer, Integer> counter = new HashMap<>();
        for (int num : nums) {
            counter.put(num, counter.getOrDefault(num, 0) + 1);
        }

        // 初始化
        int left = 0;
        int right = 0;
        int ans = 0;
        
        int minVal = nums[0];
        int maxVal = nums[nums.length - 1];

        // 枚举潜在的目标值
        for (int target = minVal; target <= maxVal; target++) {
            // 无法转换成 target 的数从窗口左侧移出
            while (nums[left] < target - k) {
                left++;
            }
            
            // 可以转换成 target 的数都包含进窗口右侧
            while (right < nums.length && nums[right] <= target + k) {
                right++;
            }
            
            
            // 元素总数
            int total = right - left;
            // 初始频率
            int initial_freq = counter.getOrDefault(target, 0);

            // 可以用来转换的数量
            int convert = total - initial_freq;
            // 实际能转换的数量
            int op_use = Math.min(numOperations, convert);
            
            // 初始频率 + 新转换过来的数量
            int total_freq = initial_freq + op_use;
            ans = Math.max(ans, total_freq);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(nlogn+M)$，两个指针最多各自移动一趟 $nums$ 数组
- 空间复杂度： $O(n)$，表示哈希 $Map$ 的大小

---

### 前缀和

能否不排序？排序的目的是，找到 `x+-k` 范围内的元素总数。

如果不想排序，可以考虑 **前缀和**。具体原理及做法，可以看看这篇 [题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2842529/pai-xu-qian-zhui-he-er-fen-fei-chang-qin-biux/)。具体来说，定义数组 $prefix$，其中 $prefix[x]$ 表示数值在 $[0,x]$ 范围内的元素个数。

总体的逻辑不变，还是枚举变形后的 $x$，只不过换成 “前缀和” 来寻找答案次数。

代码如下，已附加详细注释：

```Python
# python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        mx = max(nums)
        # 数组哈希
        cnts = [0] * (mx + 1)
        for num in nums:
            cnts[num] += 1

        # 前缀和
        prefix = [0] * (mx + 1)
        prefix[0] = cnts[0]
        for i in range(1, mx + 1):
            prefix[i] = prefix[i - 1] + cnts[i]
        
        ans = 0
        # 每一个整数，都是潜在的目标值
        for target in range(mx + 1):
            # 这些元素不需要操作
            initial_freq = cnts[target]

            # 可以转化的范围
            lower = max(0, target - k)
            upper = min(mx, target + k)

            # 使用前缀和数组计算区间内总数
            if lower == 0:
                total = prefix[upper]
            else:
                total = prefix[upper] - prefix[lower - 1]

            # 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            convert = total - initial_freq
            # 实际能转换的数量
            op_use = min(convert, numOperations)

            # 可以达到的总频率 = 初始频率 + 新转换过来的数量
            total_freq = initial_freq + op_use
            ans = max(ans, total_freq)

        return ans
```

```Java
// java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 找到数组中的最大值
        int mx = 0;
        for (int num : nums) {
            if (num > mx) {
                mx = num;
            }
        }
        
        // 数组哈希
        int[] cnts = new int[mx + 1];
        for (int num : nums) {
            cnts[num]++;
        }

        // 前缀和 prefix[i] 存储从 0 到 i 的所有数字的累计出现次数
        int[] prefix = new int[mx + 1];
        prefix[0] = cnts[0];
        for (int i = 1; i <= mx; i++) {
            prefix[i] = prefix[i - 1] + cnts[i];
        }
        
        int ans = 0;
        // 每一个整数，都是潜在的目标值
        for (int target = 0; target <= mx; target++) {
            // 这些元素不需要操作

            int initial_freq = cnts[target];
            // 可以转化的范围
            int lower = Math.max(0, target - k);
            int upper = Math.min(mx, target + k);

            // 使用前缀和计算区间内总数
            int total;
            if (lower == 0) {
                total = prefix[upper];
            } else {
                total = prefix[upper] - prefix[lower - 1];
            }

            // 可以用来转换的数量 = 区间总数 - 目标值本身的数量
            int convert = total - initial_freq;
            // 实际能转换的数量
            int op_use = Math.min(convert, numOperations);

            // 可以达到的总频率 = 初始频率 + 新转换过来的数量
            int total_freq = initial_freq + op_use;
            ans = Math.max(ans, total_freq);
        }

        return ans;
    }
}
```

- 时间复杂度： $O(n+M)$
- 空间复杂度： $O(M)$

如果本篇题解你觉得写得不错，欢迎点个赞让更多人看见~

> 题解已发布力扣平台 [我的题解](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/solutions/3811913/si-jie-bao-li-mei-ju-er-fen-bian-jie-you-45sh/)
